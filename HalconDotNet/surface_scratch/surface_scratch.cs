//
// File generated by HDevelop for HALCON/.NET (C#) Version 17.12
//

using HalconDotNet;
public partial class HDevelopExport
{
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
    public HDevelopExport()
    {
        // Default settings used in HDevelop 
        HOperatorSet.SetSystem("width", 512);
        HOperatorSet.SetSystem("height", 512);
        if (HalconAPI.isWindows)
            HOperatorSet.SetSystem("use_window_thread", "true");
        action();
    }
#endif

    // Procedures 
    // External procedures 
    // Chapter: Develop
    // Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
    public void dev_open_window_fit_image(HObject ho_Image, HTuple hv_Row, HTuple hv_Column,
        HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
    {




        // Local iconic variables 

        // Local control variables 

        HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
        HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
        HTuple hv_ResizeFactor = null, hv_ImageWidth = null, hv_ImageHeight = null;
        HTuple hv_TempWidth = null, hv_TempHeight = null, hv_WindowWidth = null;
        HTuple hv_WindowHeight = null;
        // Initialize local and output iconic variables 
        //This procedure opens a new graphics window and adjusts the size
        //such that it fits into the limits specified by WidthLimit
        //and HeightLimit, but also maintains the correct image aspect ratio.
        //
        //If it is impossible to match the minimum and maximum extent requirements
        //at the same time (f.e. if the image is very long but narrow),
        //the maximum value gets a higher priority,
        //
        //Parse input tuple WidthLimit
        if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
            new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
        {
            hv_MinWidth = 500;
            hv_MaxWidth = 800;
        }
        else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
            1))) != 0)
        {
            hv_MinWidth = 0;
            hv_MaxWidth = hv_WidthLimit.Clone();
        }
        else
        {
            hv_MinWidth = hv_WidthLimit.TupleSelect(0);
            hv_MaxWidth = hv_WidthLimit.TupleSelect(1);
        }
        //Parse input tuple HeightLimit
        if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
            new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
        {
            hv_MinHeight = 400;
            hv_MaxHeight = 600;
        }
        else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
            1))) != 0)
        {
            hv_MinHeight = 0;
            hv_MaxHeight = hv_HeightLimit.Clone();
        }
        else
        {
            hv_MinHeight = hv_HeightLimit.TupleSelect(0);
            hv_MaxHeight = hv_HeightLimit.TupleSelect(1);
        }
        //
        //Test, if window size has to be changed.
        hv_ResizeFactor = 1;
        HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
        //First, expand window to the minimum extents (if necessary).
        if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
            hv_ImageHeight)))) != 0)
        {
            hv_ResizeFactor = (((((hv_MinWidth.TupleReal()) / hv_ImageWidth)).TupleConcat(
                (hv_MinHeight.TupleReal()) / hv_ImageHeight))).TupleMax();
        }
        hv_TempWidth = hv_ImageWidth * hv_ResizeFactor;
        hv_TempHeight = hv_ImageHeight * hv_ResizeFactor;
        //Then, shrink window to maximum extents (if necessary).
        if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
            hv_TempHeight)))) != 0)
        {
            hv_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()) / hv_TempWidth)).TupleConcat(
                (hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin());
        }
        hv_WindowWidth = hv_ImageWidth * hv_ResizeFactor;
        hv_WindowHeight = hv_ImageHeight * hv_ResizeFactor;
        //Resize window
        HOperatorSet.SetWindowAttr("background_color", "black");
        HOperatorSet.OpenWindow(hv_Row, hv_Column, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandle);
        HDevWindowStack.Push(hv_WindowHandle);
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageHeight - 1, hv_ImageWidth - 1);
        }

        return;
    }

    // Chapter: Graphics / Text
    // Short Description: Set font independent of OS 
    public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
        HTuple hv_Bold, HTuple hv_Slant)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_OS = null, hv_Fonts = new HTuple();
        HTuple hv_Style = null, hv_Exception = new HTuple(), hv_AvailableFonts = null;
        HTuple hv_Fdx = null, hv_Indices = new HTuple();
        HTuple hv_Font_COPY_INP_TMP = hv_Font.Clone();
        HTuple hv_Size_COPY_INP_TMP = hv_Size.Clone();

        // Initialize local and output iconic variables 
        //This procedure sets the text font of the current window with
        //the specified attributes.
        //
        //Input parameters:
        //WindowHandle: The graphics window for which the font will be set
        //Size: The font size. If Size=-1, the default of 16 is used.
        //Bold: If set to 'true', a bold font is used
        //Slant: If set to 'true', a slanted font is used
        //
        HOperatorSet.GetSystem("operating_system", out hv_OS);
        // dev_get_preferences(...); only in hdevelop
        // dev_set_preferences(...); only in hdevelop
        if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
            new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
        {
            hv_Size_COPY_INP_TMP = 16;
        }
        if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
        {
            //Restore previous behaviour
            hv_Size_COPY_INP_TMP = ((1.13677 * hv_Size_COPY_INP_TMP)).TupleInt();
        }
        else
        {
            hv_Size_COPY_INP_TMP = hv_Size_COPY_INP_TMP.TupleInt();
        }
        if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Courier";
            hv_Fonts[1] = "Courier 10 Pitch";
            hv_Fonts[2] = "Courier New";
            hv_Fonts[3] = "CourierNew";
            hv_Fonts[4] = "Liberation Mono";
        }
        else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Consolas";
            hv_Fonts[1] = "Menlo";
            hv_Fonts[2] = "Courier";
            hv_Fonts[3] = "Courier 10 Pitch";
            hv_Fonts[4] = "FreeMono";
            hv_Fonts[5] = "Liberation Mono";
        }
        else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Luxi Sans";
            hv_Fonts[1] = "DejaVu Sans";
            hv_Fonts[2] = "FreeSans";
            hv_Fonts[3] = "Arial";
            hv_Fonts[4] = "Liberation Sans";
        }
        else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Times New Roman";
            hv_Fonts[1] = "Luxi Serif";
            hv_Fonts[2] = "DejaVu Serif";
            hv_Fonts[3] = "FreeSerif";
            hv_Fonts[4] = "Utopia";
            hv_Fonts[5] = "Liberation Serif";
        }
        else
        {
            hv_Fonts = hv_Font_COPY_INP_TMP.Clone();
        }
        hv_Style = "";
        if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
        {
            hv_Style = hv_Style + "Bold";
        }
        else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
        {
            hv_Exception = "Wrong value of control parameter Bold";
            throw new HalconException(hv_Exception);
        }
        if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
        {
            hv_Style = hv_Style + "Italic";
        }
        else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
        {
            hv_Exception = "Wrong value of control parameter Slant";
            throw new HalconException(hv_Exception);
        }
        if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
        {
            hv_Style = "Normal";
        }
        HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
        hv_Font_COPY_INP_TMP = "";
        for (hv_Fdx = 0; (int)hv_Fdx <= (int)((new HTuple(hv_Fonts.TupleLength())) - 1); hv_Fdx = (int)hv_Fdx + 1)
        {
            hv_Indices = hv_AvailableFonts.TupleFind(hv_Fonts.TupleSelect(hv_Fdx));
            if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(0))) != 0)
            {
                if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
                {
                    hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(hv_Fdx);
                    break;
                }
            }
        }
        if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
        {
            throw new HalconException("Wrong value of control parameter Font");
        }
        hv_Font_COPY_INP_TMP = (((hv_Font_COPY_INP_TMP + "-") + hv_Style) + "-") + hv_Size_COPY_INP_TMP;
        HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);
        // dev_set_preferences(...); only in hdevelop

        return;
    }

    // Chapter: Develop
    // Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
    public void dev_update_off()
    {

        // Initialize local and output iconic variables 
        //This procedure sets different update settings to 'off'.
        //This is useful to get the best performance and reduce overhead.
        //
        // dev_update_pc(...); only in hdevelop
        // dev_update_var(...); only in hdevelop
        // dev_update_window(...); only in hdevelop

        return;
    }

    // Chapter: Graphics / Text
    // Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
    public void disp_continue_message(HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_GenParamName = null, hv_GenParamValue = null;
        HTuple hv_ContinueMessage = null;
        HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();

        // Initialize local and output iconic variables 
        //This procedure displays 'Press Run (F5) to continue' in the
        //lower right corner of the screen.
        //It uses the procedure disp_message.
        //
        //Input parameters:
        //WindowHandle: The window, where the text shall be displayed
        //Color: defines the text color.
        //   If set to '' or 'auto', the currently set color is used.
        //Box: If set to 'true', the text is displayed in a box.
        //
        //Convert the parameter Box to generic parameters.
        hv_GenParamName = new HTuple();
        hv_GenParamValue = new HTuple();
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
            {
                //Display no box
                hv_GenParamName = hv_GenParamName.TupleConcat("box");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
            {
                //Set a color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(0));
            }
        }
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
            {
                //Display no shadow.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
            {
                //Set a shadow color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(1));
            }
        }
        //
        if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
        {
            //disp_text does not accept an empty string for Color.
            hv_Color_COPY_INP_TMP = new HTuple();
        }
        //
        //Display the message.
        hv_ContinueMessage = "Press Run (F5) to continue";
        HOperatorSet.DispText(hv_WindowHandle, hv_ContinueMessage, "window", "bottom",
            "right", hv_Color_COPY_INP_TMP, hv_GenParamName, hv_GenParamValue);

        return;
    }

    // Chapter: Graphics / Text
    // Short Description: This procedure writes a text message. 
    public void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
        HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_GenParamName = null, hv_GenParamValue = null;
        HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
        HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
        HTuple hv_CoordSystem_COPY_INP_TMP = hv_CoordSystem.Clone();
        HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();

        // Initialize local and output iconic variables 
        //This procedure displays text in a graphics window.
        //
        //Input parameters:
        //WindowHandle: The WindowHandle of the graphics window, where
        //   the message should be displayed
        //String: A tuple of strings containing the text message to be displayed
        //CoordSystem: If set to 'window', the text position is given
        //   with respect to the window coordinate system.
        //   If set to 'image', image coordinates are used.
        //   (This may be useful in zoomed images.)
        //Row: The row coordinate of the desired text position
        //   A tuple of values is allowed to display text at different
        //   positions.
        //Column: The column coordinate of the desired text position
        //   A tuple of values is allowed to display text at different
        //   positions.
        //Color: defines the color of the text as string.
        //   If set to [], '' or 'auto' the currently set color is used.
        //   If a tuple of strings is passed, the colors are used cyclically...
        //   - if |Row| == |Column| == 1: for each new textline
        //   = else for each text position.
        //Box: If Box[0] is set to 'true', the text is written within an orange box.
        //     If set to' false', no box is displayed.
        //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
        //       the text is written in a box of that color.
        //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
        //       'true' -> display a shadow in a default color
        //       'false' -> display no shadow
        //       otherwise -> use given string as color string for the shadow color
        //
        //It is possible to display multiple text strings in a single call.
        //In this case, some restrictions apply:
        //- Multiple text positions can be defined by specifying a tuple
        //  with multiple Row and/or Column coordinates, i.e.:
        //  - |Row| == n, |Column| == n
        //  - |Row| == n, |Column| == 1
        //  - |Row| == 1, |Column| == n
        //- If |Row| == |Column| == 1,
        //  each element of String is display in a new textline.
        //- If multiple positions or specified, the number of Strings
        //  must match the number of positions, i.e.:
        //  - Either |String| == n (each string is displayed at the
        //                          corresponding position),
        //  - or     |String| == 1 (The string is displayed n times).
        //
        //
        //Convert the parameters for disp_text.
        if ((int)((new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
            new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
        {

            return;
        }
        if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Row_COPY_INP_TMP = 12;
        }
        if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Column_COPY_INP_TMP = 12;
        }
        //
        //Convert the parameter Box to generic parameters.
        hv_GenParamName = new HTuple();
        hv_GenParamValue = new HTuple();
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
            {
                //Display no box
                hv_GenParamName = hv_GenParamName.TupleConcat("box");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
            {
                //Set a color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(0));
            }
        }
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
            {
                //Display no shadow.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
            {
                //Set a shadow color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(1));
            }
        }
        //Restore default CoordSystem behavior.
        if ((int)(new HTuple(hv_CoordSystem_COPY_INP_TMP.TupleNotEqual("window"))) != 0)
        {
            hv_CoordSystem_COPY_INP_TMP = "image";
        }
        //
        if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
        {
            //disp_text does not accept an empty string for Color.
            hv_Color_COPY_INP_TMP = new HTuple();
        }
        //
        HOperatorSet.DispText(hv_WindowHandle, hv_String, hv_CoordSystem_COPY_INP_TMP,
            hv_Row_COPY_INP_TMP, hv_Column_COPY_INP_TMP, hv_Color_COPY_INP_TMP, hv_GenParamName,
            hv_GenParamValue);

        return;
    }

    // Local procedures 
    // Short Description: open window and set part 
    public void open_zoom_window(HTuple hv_RowPos, HTuple hv_ColPos, HTuple hv_RowROI1,
        HTuple hv_ColROI1, HTuple hv_RowROI2, HTuple hv_ColROI2, HTuple hv_ZoomFactor,
        out HTuple hv_WindowHandleZoom)
    {


        // Initialize local and output iconic variables 
        HOperatorSet.SetWindowAttr("background_color", "black");
        HOperatorSet.OpenWindow(hv_RowPos, hv_ColPos, (hv_ColROI2 - hv_ColROI1) * hv_ZoomFactor, (hv_RowROI2 - hv_RowROI1) * hv_ZoomFactor, 0, "visible", "", out hv_WindowHandleZoom);
        HDevWindowStack.Push(hv_WindowHandleZoom);
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.SetPart(HDevWindowStack.GetActive(), hv_RowROI1.TupleRound(),
                hv_ColROI1.TupleRound(), hv_RowROI2.TupleRound(), hv_ColROI2.TupleRound()
                );
        }

        return;
    }

    // Short Description: close zoom window and reset part 
    public void close_zoom_window(HTuple hv_WindowHandleZoom, HTuple hv_FormerWidth,
        HTuple hv_FormerHeight)
    {


        // Initialize local and output iconic variables 
        HDevWindowStack.SetActive(hv_WindowHandleZoom);
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_FormerHeight - 1,
                hv_FormerWidth - 1);
        }

        return;
    }

#if !NO_EXPORT_MAIN
    // Main procedure 
    public void action()
    {


        // Local iconic variables 

        HObject ho_Image, ho_ImageMean, ho_DarkPixels;
        HObject ho_ConnectedRegions, ho_SelectedRegions, ho_RegionUnion;
        HObject ho_RegionDilation, ho_Skeleton, ho_Errors, ho_Scratches;
        HObject ho_Dots;

        // Local control variables 

        HTuple hv_Width = null, hv_Height = null, hv_WindowID = null;
        HTuple hv_Message = null, hv_WindowHandleZoom = null;
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Image);
        HOperatorSet.GenEmptyObj(out ho_ImageMean);
        HOperatorSet.GenEmptyObj(out ho_DarkPixels);
        HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
        HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
        HOperatorSet.GenEmptyObj(out ho_RegionUnion);
        HOperatorSet.GenEmptyObj(out ho_RegionDilation);
        HOperatorSet.GenEmptyObj(out ho_Skeleton);
        HOperatorSet.GenEmptyObj(out ho_Errors);
        HOperatorSet.GenEmptyObj(out ho_Scratches);
        HOperatorSet.GenEmptyObj(out ho_Dots);
        try
        {
            //This programm shows the extraction of surface scratches via
            //local thresholding and morphological post-processing
            //
            dev_update_off();
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.CloseWindow(HDevWindowStack.Pop());
            }
            //
            //Step 1: Acquire image
            //
            ho_Image.Dispose();
            HOperatorSet.ReadImage(out ho_Image, "surface_scratch");
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            dev_open_window_fit_image(ho_Image, 0, 0, hv_Width, hv_Width, out hv_WindowID);
            set_display_font(hv_WindowID, 16, "mono", "true", "false");
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 4);
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
            hv_Message = "This program shows the extraction of";
            if (hv_Message == null)
                hv_Message = new HTuple();
            hv_Message[1] = "surface scratches via local thresholding";
            if (hv_Message == null)
                hv_Message = new HTuple();
            hv_Message[2] = "and morphological post-processing";
            disp_message(hv_WindowID, hv_Message, "window", 12, 12, "black", "true");
            disp_continue_message(hv_WindowID, "black", "true");
            // stop(...); only in hdevelop
            //
            //Step 2: Segment image
            //
            //Using a local threshold
            ho_ImageMean.Dispose();
            HOperatorSet.MeanImage(ho_Image, out ho_ImageMean, 7, 7);
            ho_DarkPixels.Dispose();
            HOperatorSet.DynThreshold(ho_Image, ho_ImageMean, out ho_DarkPixels, 5, "dark");
            //
            //Extract connected components
            ho_ConnectedRegions.Dispose();
            HOperatorSet.Connection(ho_DarkPixels, out ho_ConnectedRegions);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetColored(HDevWindowStack.GetActive(), 12);
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ConnectedRegions, HDevWindowStack.GetActive());
            }
            hv_Message = "Connected components after image segmentation";
            if (hv_Message == null)
                hv_Message = new HTuple();
            hv_Message[1] = "using a local threshold.";
            disp_message(hv_WindowID, hv_Message, "window", 12, 12, "black", "true");
            disp_continue_message(hv_WindowID, "black", "true");
            // stop(...); only in hdevelop
            //
            //Step 3: Process regions
            //
            //Select large regions
            ho_SelectedRegions.Dispose();
            HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions, "area",
                "and", 10, 1000);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_SelectedRegions, HDevWindowStack.GetActive());
            }
            disp_message(hv_WindowID, "Large Regions", "window", 12, 12, "black", "true");
            disp_continue_message(hv_WindowID, "black", "true");
            // stop(...); only in hdevelop
            //
            //Visualize fractioned scratch
            open_zoom_window(0, ((hv_Width / 2)).TupleRound(), 2, 303, 137, 496, 3, out hv_WindowHandleZoom);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetColor(HDevWindowStack.GetActive(), "blue");
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_SelectedRegions, HDevWindowStack.GetActive());
            }
            set_display_font(hv_WindowHandleZoom, 16, "mono", "true", "false");
            disp_message(hv_WindowHandleZoom, "Fractioned scratches", "window", 12, 12,
                "black", "true");
            disp_continue_message(hv_WindowHandleZoom, "black", "true");
            // stop(...); only in hdevelop
            //
            //Merge fractioned scratches via morphology
            ho_RegionUnion.Dispose();
            HOperatorSet.Union1(ho_SelectedRegions, out ho_RegionUnion);
            ho_RegionDilation.Dispose();
            HOperatorSet.DilationCircle(ho_RegionUnion, out ho_RegionDilation, 3.5);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_RegionDilation, HDevWindowStack.GetActive());
            }
            hv_Message = "Region of the scratches after dilation";
            disp_message(hv_WindowHandleZoom, hv_Message, "window", 12, 12, "black", "true");
            disp_continue_message(hv_WindowHandleZoom, "black", "true");
            // stop(...); only in hdevelop
            ho_Skeleton.Dispose();
            HOperatorSet.Skeleton(ho_RegionDilation, out ho_Skeleton);
            ho_Errors.Dispose();
            HOperatorSet.Connection(ho_Skeleton, out ho_Errors);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetColored(HDevWindowStack.GetActive(), 12);
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Errors, HDevWindowStack.GetActive());
            }
            hv_Message = "Fractioned scratches merged via morphology";
            disp_message(hv_WindowHandleZoom, hv_Message, "window", 12, 12, "black", "true");
            disp_continue_message(hv_WindowHandleZoom, "black", "true");
            // stop(...); only in hdevelop
            //
            //Distinguish small and large scratches
            close_zoom_window(hv_WindowHandleZoom, hv_Width, hv_Height);
            ho_Scratches.Dispose();
            HOperatorSet.SelectShape(ho_Errors, out ho_Scratches, "area", "and", 50, 10000);
            ho_Dots.Dispose();
            HOperatorSet.SelectShape(ho_Errors, out ho_Dots, "area", "and", 1, 50);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetColor(HDevWindowStack.GetActive(), "red");
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Scratches, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetColor(HDevWindowStack.GetActive(), "blue");
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Dots, HDevWindowStack.GetActive());
            }
            hv_Message = "Extracted surface scratches";
            if (hv_Message == null)
                hv_Message = new HTuple();
            hv_Message[1] = "Not categorized as scratches";
            disp_message(hv_WindowID, hv_Message, "window", 440, 310, (new HTuple("red")).TupleConcat(
                "blue"), "true");
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Image.Dispose();
            ho_ImageMean.Dispose();
            ho_DarkPixels.Dispose();
            ho_ConnectedRegions.Dispose();
            ho_SelectedRegions.Dispose();
            ho_RegionUnion.Dispose();
            ho_RegionDilation.Dispose();
            ho_Skeleton.Dispose();
            ho_Errors.Dispose();
            ho_Scratches.Dispose();
            ho_Dots.Dispose();

            throw HDevExpDefaultException;
        }
        ho_Image.Dispose();
        ho_ImageMean.Dispose();
        ho_DarkPixels.Dispose();
        ho_ConnectedRegions.Dispose();
        ho_SelectedRegions.Dispose();
        ho_RegionUnion.Dispose();
        ho_RegionDilation.Dispose();
        ho_Skeleton.Dispose();
        ho_Errors.Dispose();
        ho_Scratches.Dispose();
        ho_Dots.Dispose();

    }

#endif


}
//#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
//public class HDevelopExportApp
//{
//  static void Main(string[] args)
//  {
//    new HDevelopExport();
//  }
//}
//#endif

