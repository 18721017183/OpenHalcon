using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HalconDotNet
{
    /// <summary>Class grouping all HALCON operators.</summary>

    public class HOperatorSet
    {
        /// <summary>Compute the union of cotangential contours.</summary>
        /// <param name="contours">Input XLD contours.</param>
        /// <param name="unionContours">Output XLD contours.</param>
        /// <param name="fitClippingLength">Length of the part of a contour to skip for the determination of tangents. Default: 0.0</param>
        /// <param name="fitLength">Length of the part of a contour to use for the determination of tangents. Default: 30.0</param>
        /// <param name="maxTangAngle">Maximum angle difference between two contours' tangents. Default: 0.78539816</param>
        /// <param name="maxDist">Maximum distance of the contours' end points. Default: 25.0</param>
        /// <param name="maxDistPerp">Maximum distance of the contours' end points perpendicular to their tangents. Default: 10.0</param>
        /// <param name="maxOverlap">Maximum overlap of two contours. Default: 2.0</param>
        /// <param name="mode">Mode describing the treatment of the contours' attributes. Default: "attr_forget"</param>
        public static void UnionCotangentialContoursXld(
          HObject contours,
          out HObject unionContours,
          HTuple fitClippingLength,
          HTuple fitLength,
          HTuple maxTangAngle,
          HTuple maxDist,
          HTuple maxDistPerp,
          HTuple maxOverlap,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(0);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, fitClippingLength);
            HalconAPI.Store(proc, 1, fitLength);
            HalconAPI.Store(proc, 2, maxTangAngle);
            HalconAPI.Store(proc, 3, maxDist);
            HalconAPI.Store(proc, 4, maxDistPerp);
            HalconAPI.Store(proc, 5, maxOverlap);
            HalconAPI.Store(proc, 6, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fitClippingLength);
            HalconAPI.UnpinTuple(fitLength);
            HalconAPI.UnpinTuple(maxTangAngle);
            HalconAPI.UnpinTuple(maxDist);
            HalconAPI.UnpinTuple(maxDistPerp);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out unionContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Transform a contour in polar coordinates back to Cartesian coordinates</summary>
        /// <param name="polarContour">Input contour.</param>
        /// <param name="XYTransContour">Output contour.</param>
        /// <param name="row">Row coordinate of the center of the arc. Default: 256</param>
        /// <param name="column">Column coordinate of the center of the arc. Default: 256</param>
        /// <param name="angleStart">Angle of the ray to map the column coordinate 0 of PolarContour to. Default: 0.0</param>
        /// <param name="angleEnd">Angle of the ray to map the column coordinate $WidthIn-1$ of PolarContour to. Default: 6.2831853</param>
        /// <param name="radiusStart">Radius of the circle to map the row coordinate 0 of PolarContour to. Default: 0</param>
        /// <param name="radiusEnd">Radius of the circle to map the row coordinate $HeightIn-1$ of PolarContour to. Default: 100</param>
        /// <param name="widthIn">Width of the virtual input image. Default: 512</param>
        /// <param name="heightIn">Height of the virtual input image. Default: 512</param>
        /// <param name="width">Width of the virtual output image. Default: 512</param>
        /// <param name="height">Height of the virtual output image. Default: 512</param>
        public static void PolarTransContourXldInv(
          HObject polarContour,
          out HObject XYTransContour,
          HTuple row,
          HTuple column,
          HTuple angleStart,
          HTuple angleEnd,
          HTuple radiusStart,
          HTuple radiusEnd,
          HTuple widthIn,
          HTuple heightIn,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1);
            HalconAPI.Store(proc, 1, (HObjectBase)polarContour);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, angleStart);
            HalconAPI.Store(proc, 3, angleEnd);
            HalconAPI.Store(proc, 4, radiusStart);
            HalconAPI.Store(proc, 5, radiusEnd);
            HalconAPI.Store(proc, 6, widthIn);
            HalconAPI.Store(proc, 7, heightIn);
            HalconAPI.Store(proc, 8, width);
            HalconAPI.Store(proc, 9, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleEnd);
            HalconAPI.UnpinTuple(radiusStart);
            HalconAPI.UnpinTuple(radiusEnd);
            HalconAPI.UnpinTuple(widthIn);
            HalconAPI.UnpinTuple(heightIn);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out XYTransContour);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polarContour);
        }

        /// <summary>Transform a contour in an annular arc to polar coordinates.</summary>
        /// <param name="contour">Input contour.</param>
        /// <param name="polarTransContour">Output contour.</param>
        /// <param name="row">Row coordinate of the center of the arc. Default: 256</param>
        /// <param name="column">Column coordinate of the center of the arc. Default: 256</param>
        /// <param name="angleStart">Angle of the ray to be mapped to the column coordinate 0 of PolarTransContour. Default: 0.0</param>
        /// <param name="angleEnd">Angle of the ray to be mapped to the column coordinate $Width-1$ of PolarTransContour to. Default: 6.2831853</param>
        /// <param name="radiusStart">Radius of the circle to be mapped to the row coordinate 0 of PolarTransContour. Default: 0</param>
        /// <param name="radiusEnd">Radius of the circle to be mapped to the row coordinate $Height-1$ of PolarTransContour. Default: 100</param>
        /// <param name="width">Width of the virtual output image. Default: 512</param>
        /// <param name="height">Height of the virtual output image. Default: 512</param>
        public static void PolarTransContourXld(
          HObject contour,
          out HObject polarTransContour,
          HTuple row,
          HTuple column,
          HTuple angleStart,
          HTuple angleEnd,
          HTuple radiusStart,
          HTuple radiusEnd,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(2);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, angleStart);
            HalconAPI.Store(proc, 3, angleEnd);
            HalconAPI.Store(proc, 4, radiusStart);
            HalconAPI.Store(proc, 5, radiusEnd);
            HalconAPI.Store(proc, 6, width);
            HalconAPI.Store(proc, 7, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleEnd);
            HalconAPI.UnpinTuple(radiusStart);
            HalconAPI.UnpinTuple(radiusEnd);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out polarTransContour);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Create control data of a NURBS curve that interpolates given points.</summary>
        /// <param name="rows">Row coordinates of input point list.</param>
        /// <param name="cols">Column coordinates of input point list.</param>
        /// <param name="tangents">Tangents at first and last point. Default: []</param>
        /// <param name="degree">Order of the output curve. Default: 3</param>
        /// <param name="ctrlRows">Row coordinates of the control polygon.</param>
        /// <param name="ctrlCols">Column coordinates of the control polygon.</param>
        /// <param name="knots">The knot vector of the output curve.</param>
        public static void GenNurbsInterp(
          HTuple rows,
          HTuple cols,
          HTuple tangents,
          HTuple degree,
          out HTuple ctrlRows,
          out HTuple ctrlCols,
          out HTuple knots)
        {
            IntPtr proc = HalconAPI.PreCall(3);
            HalconAPI.Store(proc, 0, rows);
            HalconAPI.Store(proc, 1, cols);
            HalconAPI.Store(proc, 2, tangents);
            HalconAPI.Store(proc, 3, degree);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows);
            HalconAPI.UnpinTuple(cols);
            HalconAPI.UnpinTuple(tangents);
            HalconAPI.UnpinTuple(degree);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out ctrlRows);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out ctrlCols);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out knots);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transform a NURBS curve into an XLD contour.</summary>
        /// <param name="contour">The contour that approximates the NURBS curve.</param>
        /// <param name="rows">Row coordinates of the control polygon.</param>
        /// <param name="cols">Column coordinates of the control polygon.</param>
        /// <param name="knots">The knot vector $u$. Default: "auto"</param>
        /// <param name="weights">The weight vector $w$. Default: "auto"</param>
        /// <param name="degree">The degree $p$ of the NURBS curve. Default: 3</param>
        /// <param name="maxError">Maximum distance between the NURBS curve and its approximation. Default: 1.0</param>
        /// <param name="maxDistance">Maximum distance between two subsequent Contour points. Default: 5.0</param>
        public static void GenContourNurbsXld(
          out HObject contour,
          HTuple rows,
          HTuple cols,
          HTuple knots,
          HTuple weights,
          HTuple degree,
          HTuple maxError,
          HTuple maxDistance)
        {
            IntPtr proc = HalconAPI.PreCall(4);
            HalconAPI.Store(proc, 0, rows);
            HalconAPI.Store(proc, 1, cols);
            HalconAPI.Store(proc, 2, knots);
            HalconAPI.Store(proc, 3, weights);
            HalconAPI.Store(proc, 4, degree);
            HalconAPI.Store(proc, 5, maxError);
            HalconAPI.Store(proc, 6, maxDistance);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows);
            HalconAPI.UnpinTuple(cols);
            HalconAPI.UnpinTuple(knots);
            HalconAPI.UnpinTuple(weights);
            HalconAPI.UnpinTuple(degree);
            HalconAPI.UnpinTuple(maxError);
            HalconAPI.UnpinTuple(maxDistance);
            int procResult = HObject.LoadNew(proc, 1, err, out contour);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the union of closed polygons.</summary>
        /// <param name="polygons1">Polygons enclosing the first region.</param>
        /// <param name="polygons2">Polygons enclosing the second region.</param>
        /// <param name="polygonsUnion">Polygons enclosing the union.</param>
        public static void Union2ClosedPolygonsXld(
          HObject polygons1,
          HObject polygons2,
          out HObject polygonsUnion)
        {
            IntPtr proc = HalconAPI.PreCall(5);
            HalconAPI.Store(proc, 1, (HObjectBase)polygons1);
            HalconAPI.Store(proc, 2, (HObjectBase)polygons2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out polygonsUnion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygons1);
            GC.KeepAlive((object)polygons2);
        }

        /// <summary>Compute the union of closed contours.</summary>
        /// <param name="contours1">Contours enclosing the first region.</param>
        /// <param name="contours2">Contours enclosing the second region.</param>
        /// <param name="contoursUnion">Contours enclosing the union.</param>
        public static void Union2ClosedContoursXld(
          HObject contours1,
          HObject contours2,
          out HObject contoursUnion)
        {
            IntPtr proc = HalconAPI.PreCall(6);
            HalconAPI.Store(proc, 1, (HObjectBase)contours1);
            HalconAPI.Store(proc, 2, (HObjectBase)contours2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out contoursUnion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours1);
            GC.KeepAlive((object)contours2);
        }

        /// <summary>Compute the symmetric difference of closed polygons.</summary>
        /// <param name="polygons1">Polygons enclosing the first region.</param>
        /// <param name="polygons2">Polygons enclosing the second region.</param>
        /// <param name="polygonsDifference">Polygons enclosing the symmetric difference.</param>
        public static void SymmDifferenceClosedPolygonsXld(
          HObject polygons1,
          HObject polygons2,
          out HObject polygonsDifference)
        {
            IntPtr proc = HalconAPI.PreCall(7);
            HalconAPI.Store(proc, 1, (HObjectBase)polygons1);
            HalconAPI.Store(proc, 2, (HObjectBase)polygons2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out polygonsDifference);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygons1);
            GC.KeepAlive((object)polygons2);
        }

        /// <summary>Compute the symmetric difference of closed contours.</summary>
        /// <param name="contours1">Contours enclosing the first region.</param>
        /// <param name="contours2">Contours enclosing the second region.</param>
        /// <param name="contoursDifference">Contours enclosing the symmetric difference.</param>
        public static void SymmDifferenceClosedContoursXld(
          HObject contours1,
          HObject contours2,
          out HObject contoursDifference)
        {
            IntPtr proc = HalconAPI.PreCall(8);
            HalconAPI.Store(proc, 1, (HObjectBase)contours1);
            HalconAPI.Store(proc, 2, (HObjectBase)contours2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out contoursDifference);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours1);
            GC.KeepAlive((object)contours2);
        }

        /// <summary>Compute the difference of closed polygons.</summary>
        /// <param name="polygons">Polygons enclosing the region from which the second region is subtracted.</param>
        /// <param name="sub">Polygons enclosing the region that is subtracted from the first region.</param>
        /// <param name="polygonsDifference">Polygons enclosing the difference.</param>
        public static void DifferenceClosedPolygonsXld(
          HObject polygons,
          HObject sub,
          out HObject polygonsDifference)
        {
            IntPtr proc = HalconAPI.PreCall(9);
            HalconAPI.Store(proc, 1, (HObjectBase)polygons);
            HalconAPI.Store(proc, 2, (HObjectBase)sub);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out polygonsDifference);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygons);
            GC.KeepAlive((object)sub);
        }

        /// <summary>Compute the difference of closed contours.</summary>
        /// <param name="contours">Contours enclosing the region from which the second region is subtracted.</param>
        /// <param name="sub">Contours enclosing the region that is subtracted from the first region.</param>
        /// <param name="contoursDifference">Contours enclosing the difference.</param>
        public static void DifferenceClosedContoursXld(
          HObject contours,
          HObject sub,
          out HObject contoursDifference)
        {
            IntPtr proc = HalconAPI.PreCall(10);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 2, (HObjectBase)sub);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out contoursDifference);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
            GC.KeepAlive((object)sub);
        }

        /// <summary>Intersect closed polygons.</summary>
        /// <param name="polygons1">Polygons enclosing the first region to be intersected.</param>
        /// <param name="polygons2">Polygons enclosing the second region to be intersected.</param>
        /// <param name="polygonsIntersection">Polygons enclosing the intersection.</param>
        public static void IntersectionClosedPolygonsXld(
          HObject polygons1,
          HObject polygons2,
          out HObject polygonsIntersection)
        {
            IntPtr proc = HalconAPI.PreCall(11);
            HalconAPI.Store(proc, 1, (HObjectBase)polygons1);
            HalconAPI.Store(proc, 2, (HObjectBase)polygons2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out polygonsIntersection);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygons1);
            GC.KeepAlive((object)polygons2);
        }

        /// <summary>Intersect closed contours.</summary>
        /// <param name="contours1">Contours enclosing the first region to be intersected.</param>
        /// <param name="contours2">Contours enclosing the second region to be intersected.</param>
        /// <param name="contoursIntersection">Contours enclosing the intersection.</param>
        public static void IntersectionClosedContoursXld(
          HObject contours1,
          HObject contours2,
          out HObject contoursIntersection)
        {
            IntPtr proc = HalconAPI.PreCall(12);
            HalconAPI.Store(proc, 1, (HObjectBase)contours1);
            HalconAPI.Store(proc, 2, (HObjectBase)contours2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out contoursIntersection);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours1);
            GC.KeepAlive((object)contours2);
        }

        /// <summary>Compute the union of contours that belong to the same circle.</summary>
        /// <param name="contours">Contours to be merged.</param>
        /// <param name="unionContours">Merged contours.</param>
        /// <param name="maxArcAngleDiff">Maximum angular distance of two circular arcs. Default: 0.5</param>
        /// <param name="maxArcOverlap">Maximum overlap of two circular arcs. Default: 0.1</param>
        /// <param name="maxTangentAngle">Maximum angle between the connecting line and the tangents of circular arcs. Default: 0.2</param>
        /// <param name="maxDist">Maximum length of the gap between two circular arcs in pixels. Default: 30</param>
        /// <param name="maxRadiusDiff">Maximum radius difference of the circles fitted to two arcs. Default: 10</param>
        /// <param name="maxCenterDist">Maximum center distance of the circles fitted to two arcs. Default: 10</param>
        /// <param name="mergeSmallContours">Determine whether small contours without fitted circles should also be merged. Default: "true"</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void UnionCocircularContoursXld(
          HObject contours,
          out HObject unionContours,
          HTuple maxArcAngleDiff,
          HTuple maxArcOverlap,
          HTuple maxTangentAngle,
          HTuple maxDist,
          HTuple maxRadiusDiff,
          HTuple maxCenterDist,
          HTuple mergeSmallContours,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(13);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, maxArcAngleDiff);
            HalconAPI.Store(proc, 1, maxArcOverlap);
            HalconAPI.Store(proc, 2, maxTangentAngle);
            HalconAPI.Store(proc, 3, maxDist);
            HalconAPI.Store(proc, 4, maxRadiusDiff);
            HalconAPI.Store(proc, 5, maxCenterDist);
            HalconAPI.Store(proc, 6, mergeSmallContours);
            HalconAPI.Store(proc, 7, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maxArcAngleDiff);
            HalconAPI.UnpinTuple(maxArcOverlap);
            HalconAPI.UnpinTuple(maxTangentAngle);
            HalconAPI.UnpinTuple(maxDist);
            HalconAPI.UnpinTuple(maxRadiusDiff);
            HalconAPI.UnpinTuple(maxCenterDist);
            HalconAPI.UnpinTuple(mergeSmallContours);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out unionContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Crop an XLD contour.</summary>
        /// <param name="contours">Input contours.</param>
        /// <param name="croppedContours">Output contours.</param>
        /// <param name="row1">Upper border of the cropping rectangle. Default: 0</param>
        /// <param name="col1">Left border of the cropping rectangle. Default: 0</param>
        /// <param name="row2">Lower border of the cropping rectangle. Default: 512</param>
        /// <param name="col2">Right border of the cropping rectangle. Default: 512</param>
        /// <param name="closeContours">Should closed contours produce closed output contours? Default: "true"</param>
        public static void CropContoursXld(
          HObject contours,
          out HObject croppedContours,
          HTuple row1,
          HTuple col1,
          HTuple row2,
          HTuple col2,
          HTuple closeContours)
        {
            IntPtr proc = HalconAPI.PreCall(14);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, col1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, col2);
            HalconAPI.Store(proc, 4, closeContours);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(col1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(col2);
            HalconAPI.UnpinTuple(closeContours);
            int procResult = HObject.LoadNew(proc, 1, err, out croppedContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Generate one XLD contour in the shape of a cross for each input point.</summary>
        /// <param name="cross">Generated XLD contours.</param>
        /// <param name="row">Row coordinates of the input points.</param>
        /// <param name="col">Column coordinates of the input points.</param>
        /// <param name="size">Length of the cross bars. Default: 6.0</param>
        /// <param name="angle">Orientation of the crosses. Default: 0.785398</param>
        public static void GenCrossContourXld(
          out HObject cross,
          HTuple row,
          HTuple col,
          HTuple size,
          HTuple angle)
        {
            IntPtr proc = HalconAPI.PreCall(15);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, col);
            HalconAPI.Store(proc, 2, size);
            HalconAPI.Store(proc, 3, angle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(col);
            HalconAPI.UnpinTuple(size);
            HalconAPI.UnpinTuple(angle);
            int procResult = HObject.LoadNew(proc, 1, err, out cross);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Sort contours with respect to their relative position.</summary>
        /// <param name="contours">Contours to be sorted.</param>
        /// <param name="sortedContours">Sorted contours.</param>
        /// <param name="sortMode">Kind of sorting. Default: "upper_left"</param>
        /// <param name="order">Increasing or decreasing sorting order. Default: "true"</param>
        /// <param name="rowOrCol">Sorting first with respect to row, then to column. Default: "row"</param>
        public static void SortContoursXld(
          HObject contours,
          out HObject sortedContours,
          HTuple sortMode,
          HTuple order,
          HTuple rowOrCol)
        {
            IntPtr proc = HalconAPI.PreCall(16);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, sortMode);
            HalconAPI.Store(proc, 1, order);
            HalconAPI.Store(proc, 2, rowOrCol);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sortMode);
            HalconAPI.UnpinTuple(order);
            HalconAPI.UnpinTuple(rowOrCol);
            int procResult = HObject.LoadNew(proc, 1, err, out sortedContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Merge XLD contours from successive line scan images.</summary>
        /// <param name="currConts">Current input contours.</param>
        /// <param name="prevConts">Merged contours from the previous iteration.</param>
        /// <param name="currMergedConts">Current contours, merged with old ones where applicable.</param>
        /// <param name="prevMergedConts">Contours from the previous iteration which could not be merged with the current ones.</param>
        /// <param name="imageHeight">Height of the line scan images. Default: 512</param>
        /// <param name="margin">Maximum distance of contours from the image border. Default: 0.0</param>
        /// <param name="mergeBorder">Image line of the current image, which touches the previous image. Default: "top"</param>
        /// <param name="maxImagesCont">Maximum number of images covered by one contour. Default: 3</param>
        public static void MergeContLineScanXld(
          HObject currConts,
          HObject prevConts,
          out HObject currMergedConts,
          out HObject prevMergedConts,
          HTuple imageHeight,
          HTuple margin,
          HTuple mergeBorder,
          HTuple maxImagesCont)
        {
            IntPtr proc = HalconAPI.PreCall(17);
            HalconAPI.Store(proc, 1, (HObjectBase)currConts);
            HalconAPI.Store(proc, 2, (HObjectBase)prevConts);
            HalconAPI.Store(proc, 0, imageHeight);
            HalconAPI.Store(proc, 1, margin);
            HalconAPI.Store(proc, 2, mergeBorder);
            HalconAPI.Store(proc, 3, maxImagesCont);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(imageHeight);
            HalconAPI.UnpinTuple(margin);
            HalconAPI.UnpinTuple(mergeBorder);
            HalconAPI.UnpinTuple(maxImagesCont);
            int err2 = HObject.LoadNew(proc, 1, err1, out currMergedConts);
            int procResult = HObject.LoadNew(proc, 2, err2, out prevMergedConts);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)currConts);
            GC.KeepAlive((object)prevConts);
        }

        /// <summary>Read XLD polygons from a file in ARC/INFO generate format.</summary>
        /// <param name="polygons">Read XLD polygons.</param>
        /// <param name="fileName">Name of the ARC/INFO file.</param>
        public static void ReadPolygonXldArcInfo(out HObject polygons, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(18);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HObject.LoadNew(proc, 1, err, out polygons);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write XLD polygons to a file in ARC/INFO generate format.</summary>
        /// <param name="polygons">XLD polygons to be written.</param>
        /// <param name="fileName">Name of the ARC/INFO file.</param>
        public static void WritePolygonXldArcInfo(HObject polygons, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(19);
            HalconAPI.Store(proc, 1, (HObjectBase)polygons);
            HalconAPI.Store(proc, 0, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygons);
        }

        /// <summary>Read XLD contours to a file in ARC/INFO generate format.</summary>
        /// <param name="contours">Read XLD contours.</param>
        /// <param name="fileName">Name of the ARC/INFO file.</param>
        public static void ReadContourXldArcInfo(out HObject contours, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(20);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HObject.LoadNew(proc, 1, err, out contours);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write XLD contours to a file in ARC/INFO generate format.</summary>
        /// <param name="contours">XLD contours to be written.</param>
        /// <param name="fileName">Name of the ARC/INFO file.</param>
        public static void WriteContourXldArcInfo(HObject contours, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(21);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Read the geo coding from an ARC/INFO world file.</summary>
        /// <param name="fileName">Name of the ARC/INFO world file.</param>
        /// <param name="worldTransformation">Transformation matrix from image to world coordinates.</param>
        public static void ReadWorldFile(HTuple fileName, out HTuple worldTransformation)
        {
            IntPtr proc = HalconAPI.PreCall(22);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out worldTransformation);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the parallel contour of an XLD contour.</summary>
        /// <param name="contours">Contours to be transformed.</param>
        /// <param name="parallelContours">Parallel contours.</param>
        /// <param name="mode">Mode, with which the direction information is computed. Default: "regression_normal"</param>
        /// <param name="distance">Distance of the parallel contour. Default: 1</param>
        public static void GenParallelContourXld(
          HObject contours,
          out HObject parallelContours,
          HTuple mode,
          HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(23);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, distance);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(distance);
            int procResult = HObject.LoadNew(proc, 1, err, out parallelContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Create an XLD contour in the shape of a rectangle.</summary>
        /// <param name="rectangle">Rectangle contour.</param>
        /// <param name="row">Row coordinate of the center of the rectangle. Default: 300.0</param>
        /// <param name="column">Column coordinate of the center of the rectangle. Default: 200.0</param>
        /// <param name="phi">Orientation of the main axis of the rectangle [rad]. Default: 0.0</param>
        /// <param name="length1">First radius (half length) of the rectangle. Default: 100.5</param>
        /// <param name="length2">Second radius (half width) of the rectangle. Default: 20.5</param>
        public static void GenRectangle2ContourXld(
          out HObject rectangle,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple length1,
          HTuple length2)
        {
            IntPtr proc = HalconAPI.PreCall(24);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, phi);
            HalconAPI.Store(proc, 3, length1);
            HalconAPI.Store(proc, 4, length2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(length1);
            HalconAPI.UnpinTuple(length2);
            int procResult = HObject.LoadNew(proc, 1, err, out rectangle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the distances of all contour points to a rectangle.</summary>
        /// <param name="contour">Input contour.</param>
        /// <param name="clippingEndPoints">Number of points at the beginning and the end of the contours to be ignored for the computation of distances. Default: 0</param>
        /// <param name="row">Row coordinate of the center of the rectangle.</param>
        /// <param name="column">Column coordinate of the center of the rectangle.</param>
        /// <param name="phi">Orientation of the main axis of the rectangle [rad].</param>
        /// <param name="length1">First radius (half length) of the rectangle.</param>
        /// <param name="length2">Second radius (half width) of the rectangle.</param>
        /// <param name="distances">Distances of the contour points to the rectangle.</param>
        public static void DistRectangle2ContourPointsXld(
          HObject contour,
          HTuple clippingEndPoints,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple length1,
          HTuple length2,
          out HTuple distances)
        {
            IntPtr proc = HalconAPI.PreCall(25);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, clippingEndPoints);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, phi);
            HalconAPI.Store(proc, 4, length1);
            HalconAPI.Store(proc, 5, length2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(clippingEndPoints);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(length1);
            HalconAPI.UnpinTuple(length2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out distances);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Fit rectangles to XLD contours.</summary>
        /// <param name="contours">Input contours.</param>
        /// <param name="algorithm">Algorithm for fitting the rectangles. Default: "regression"</param>
        /// <param name="maxNumPoints">Maximum number of contour points used for the computation (-1 for all points). Default: -1</param>
        /// <param name="maxClosureDist">Maximum distance between the end points of a contour to be considered as closed. Default: 0.0</param>
        /// <param name="clippingEndPoints">Number of points at the beginning and at the end of the contours to be ignored for the fitting. Default: 0</param>
        /// <param name="iterations">Maximum number of iterations (not used for 'regression'). Default: 3</param>
        /// <param name="clippingFactor">Clipping factor for the elimination of outliers (typical: 1.0 for 'huber' and 2.0 for 'tukey'). Default: 2.0</param>
        /// <param name="row">Row coordinate of the center of the rectangle.</param>
        /// <param name="column">Column coordinate of the center of the rectangle.</param>
        /// <param name="phi">Orientation of the main axis of the rectangle [rad].</param>
        /// <param name="length1">First radius (half length) of the rectangle.</param>
        /// <param name="length2">Second radius (half width) of the rectangle.</param>
        /// <param name="pointOrder">Point order of the contour.</param>
        public static void FitRectangle2ContourXld(
          HObject contours,
          HTuple algorithm,
          HTuple maxNumPoints,
          HTuple maxClosureDist,
          HTuple clippingEndPoints,
          HTuple iterations,
          HTuple clippingFactor,
          out HTuple row,
          out HTuple column,
          out HTuple phi,
          out HTuple length1,
          out HTuple length2,
          out HTuple pointOrder)
        {
            IntPtr proc = HalconAPI.PreCall(26);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, algorithm);
            HalconAPI.Store(proc, 1, maxNumPoints);
            HalconAPI.Store(proc, 2, maxClosureDist);
            HalconAPI.Store(proc, 3, clippingEndPoints);
            HalconAPI.Store(proc, 4, iterations);
            HalconAPI.Store(proc, 5, clippingFactor);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(algorithm);
            HalconAPI.UnpinTuple(maxNumPoints);
            HalconAPI.UnpinTuple(maxClosureDist);
            HalconAPI.UnpinTuple(clippingEndPoints);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(clippingFactor);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out length1);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out length2);
            int procResult = HTuple.LoadNew(proc, 5, err6, out pointOrder);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Segment XLD contour parts whose local attributes fulfill given  conditions.</summary>
        /// <param name="contour">Contour to be segmented.</param>
        /// <param name="contourPart">Segmented contour parts.</param>
        /// <param name="attribute">Contour attributes to be checked. Default: "distance"</param>
        /// <param name="operation">Linkage type of the individual attributes. Default: "and"</param>
        /// <param name="min">Lower limits of the attribute values. Default: 150.0</param>
        /// <param name="max">Upper limits of the attribute values. Default: 99999.0</param>
        public static void SegmentContourAttribXld(
          HObject contour,
          out HObject contourPart,
          HTuple attribute,
          HTuple operation,
          HTuple min,
          HTuple max)
        {
            IntPtr proc = HalconAPI.PreCall(27);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, attribute);
            HalconAPI.Store(proc, 1, operation);
            HalconAPI.Store(proc, 2, min);
            HalconAPI.Store(proc, 3, max);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(attribute);
            HalconAPI.UnpinTuple(operation);
            HalconAPI.UnpinTuple(min);
            HalconAPI.UnpinTuple(max);
            int procResult = HObject.LoadNew(proc, 1, err, out contourPart);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Segment XLD contours into line segments and circular or elliptic arcs.</summary>
        /// <param name="contours">Contours to be segmented.</param>
        /// <param name="contoursSplit">Segmented contours.</param>
        /// <param name="mode">Mode for the segmentation of the contours. Default: "lines_circles"</param>
        /// <param name="smoothCont">Number of points used for smoothing the contours. Default: 5</param>
        /// <param name="maxLineDist1">Maximum distance between a contour and the approximating line (first iteration). Default: 4.0</param>
        /// <param name="maxLineDist2">Maximum distance between a contour and the approximating line (second iteration). Default: 2.0</param>
        public static void SegmentContoursXld(
          HObject contours,
          out HObject contoursSplit,
          HTuple mode,
          HTuple smoothCont,
          HTuple maxLineDist1,
          HTuple maxLineDist2)
        {
            IntPtr proc = HalconAPI.PreCall(28);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, smoothCont);
            HalconAPI.Store(proc, 2, maxLineDist1);
            HalconAPI.Store(proc, 3, maxLineDist2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(smoothCont);
            HalconAPI.UnpinTuple(maxLineDist1);
            HalconAPI.UnpinTuple(maxLineDist2);
            int procResult = HObject.LoadNew(proc, 1, err, out contoursSplit);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Approximate XLD contours by circles.</summary>
        /// <param name="contours">Input contours.</param>
        /// <param name="algorithm">Algorithm for the fitting of circles. Default: "algebraic"</param>
        /// <param name="maxNumPoints">Maximum number of contour points used for the computation (-1 for all points). Default: -1</param>
        /// <param name="maxClosureDist">Maximum distance between the end points of a contour to be considered as 'closed'. Default: 0.0</param>
        /// <param name="clippingEndPoints">Number of points at the beginning and at the end of the contours to be ignored for the fitting. Default: 0</param>
        /// <param name="iterations">Maximum number of iterations for the robust weighted fitting. Default: 3</param>
        /// <param name="clippingFactor">Clipping factor for the elimination of outliers (typical: 1.0 for Huber and 2.0 for Tukey). Default: 2.0</param>
        /// <param name="row">Row coordinate of the center of the circle.</param>
        /// <param name="column">Column coordinate of the center of the circle.</param>
        /// <param name="radius">Radius of circle.</param>
        /// <param name="startPhi">Angle of the start point [rad].</param>
        /// <param name="endPhi">Angle of the end point [rad].</param>
        /// <param name="pointOrder">Point order along the boundary.</param>
        public static void FitCircleContourXld(
          HObject contours,
          HTuple algorithm,
          HTuple maxNumPoints,
          HTuple maxClosureDist,
          HTuple clippingEndPoints,
          HTuple iterations,
          HTuple clippingFactor,
          out HTuple row,
          out HTuple column,
          out HTuple radius,
          out HTuple startPhi,
          out HTuple endPhi,
          out HTuple pointOrder)
        {
            IntPtr proc = HalconAPI.PreCall(29);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, algorithm);
            HalconAPI.Store(proc, 1, maxNumPoints);
            HalconAPI.Store(proc, 2, maxClosureDist);
            HalconAPI.Store(proc, 3, clippingEndPoints);
            HalconAPI.Store(proc, 4, iterations);
            HalconAPI.Store(proc, 5, clippingFactor);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(algorithm);
            HalconAPI.UnpinTuple(maxNumPoints);
            HalconAPI.UnpinTuple(maxClosureDist);
            HalconAPI.UnpinTuple(clippingEndPoints);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(clippingFactor);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out radius);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out startPhi);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out endPhi);
            int procResult = HTuple.LoadNew(proc, 5, err6, out pointOrder);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Approximate XLD contours by line segments.</summary>
        /// <param name="contours">Input contours.</param>
        /// <param name="algorithm">Algorithm for the fitting of lines. Default: "tukey"</param>
        /// <param name="maxNumPoints">Maximum number of contour points used for the computation (-1 for all points). Default: -1</param>
        /// <param name="clippingEndPoints">Number of points at the beginning and at the end of the contours to be ignored for the fitting. Default: 0</param>
        /// <param name="iterations">Maximum number of iterations (unused for 'regression'). Default: 5</param>
        /// <param name="clippingFactor">Clipping factor for the elimination of outliers (typical: 1.0 for 'huber' and 'drop' and 2.0 for  'tukey'). Default: 2.0</param>
        /// <param name="rowBegin">Row coordinates of the starting points of the line segments.</param>
        /// <param name="colBegin">Column coordinates of the starting points of the line segments.</param>
        /// <param name="rowEnd">Row coordinates of the end points of the line segments.</param>
        /// <param name="colEnd">Column coordinates of the end points of the line segments.</param>
        /// <param name="nr">Line parameter: Row coordinate of the normal vector</param>
        /// <param name="nc">Line parameter: Column coordinate of the normal vector</param>
        /// <param name="dist">Line parameter: Distance of the line from the origin</param>
        public static void FitLineContourXld(
          HObject contours,
          HTuple algorithm,
          HTuple maxNumPoints,
          HTuple clippingEndPoints,
          HTuple iterations,
          HTuple clippingFactor,
          out HTuple rowBegin,
          out HTuple colBegin,
          out HTuple rowEnd,
          out HTuple colEnd,
          out HTuple nr,
          out HTuple nc,
          out HTuple dist)
        {
            IntPtr proc = HalconAPI.PreCall(30);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, algorithm);
            HalconAPI.Store(proc, 1, maxNumPoints);
            HalconAPI.Store(proc, 2, clippingEndPoints);
            HalconAPI.Store(proc, 3, iterations);
            HalconAPI.Store(proc, 4, clippingFactor);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(algorithm);
            HalconAPI.UnpinTuple(maxNumPoints);
            HalconAPI.UnpinTuple(clippingEndPoints);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(clippingFactor);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowBegin);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out colBegin);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out rowEnd);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out colEnd);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out nr);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out nc);
            int procResult = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out dist);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Compute the distances of all contour points to an ellipse.</summary>
        /// <param name="contour">Input contours.</param>
        /// <param name="distanceMode">Mode for unsigned or signed distance values. Default: "unsigned"</param>
        /// <param name="clippingEndPoints">Number of points at the beginning and the end of the contours to be ignored for the computation of distances. Default: 0</param>
        /// <param name="row">Row coordinate of the center of the ellipse.</param>
        /// <param name="column">Column coordinate of the center of the ellipse.</param>
        /// <param name="phi">Orientation of the main axis in radian.</param>
        /// <param name="radius1">Length of the larger half axis.</param>
        /// <param name="radius2">Length of the smaller half axis.</param>
        /// <param name="distances">Distances of the contour points to the ellipse.</param>
        public static void DistEllipseContourPointsXld(
          HObject contour,
          HTuple distanceMode,
          HTuple clippingEndPoints,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple radius1,
          HTuple radius2,
          out HTuple distances)
        {
            IntPtr proc = HalconAPI.PreCall(31);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, distanceMode);
            HalconAPI.Store(proc, 1, clippingEndPoints);
            HalconAPI.Store(proc, 2, row);
            HalconAPI.Store(proc, 3, column);
            HalconAPI.Store(proc, 4, phi);
            HalconAPI.Store(proc, 5, radius1);
            HalconAPI.Store(proc, 6, radius2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distanceMode);
            HalconAPI.UnpinTuple(clippingEndPoints);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(radius1);
            HalconAPI.UnpinTuple(radius2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out distances);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Compute the distance of contours to an ellipse.</summary>
        /// <param name="contours">Input contours.</param>
        /// <param name="mode">Method for the determination of the distances. Default: "geometric"</param>
        /// <param name="maxNumPoints">Maximum number of contour points used for the computation (-1 for all points). Default: -1</param>
        /// <param name="clippingEndPoints">Number of points at the beginning and the end of the contours to be ignored for the computation of distances. Default: 0</param>
        /// <param name="row">Row coordinate of the center of the ellipse.</param>
        /// <param name="column">Column coordinate of the center of the ellipse.</param>
        /// <param name="phi">Orientation of the main axis in radian.</param>
        /// <param name="radius1">Length of the larger half axis.</param>
        /// <param name="radius2">Length of the smaller half axis.</param>
        /// <param name="minDist">Minimum distance.</param>
        /// <param name="maxDist">Maximum distance.</param>
        /// <param name="avgDist">Mean distance.</param>
        /// <param name="sigmaDist">Standard deviation of the distance.</param>
        public static void DistEllipseContourXld(
          HObject contours,
          HTuple mode,
          HTuple maxNumPoints,
          HTuple clippingEndPoints,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple radius1,
          HTuple radius2,
          out HTuple minDist,
          out HTuple maxDist,
          out HTuple avgDist,
          out HTuple sigmaDist)
        {
            IntPtr proc = HalconAPI.PreCall(32);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, maxNumPoints);
            HalconAPI.Store(proc, 2, clippingEndPoints);
            HalconAPI.Store(proc, 3, row);
            HalconAPI.Store(proc, 4, column);
            HalconAPI.Store(proc, 5, phi);
            HalconAPI.Store(proc, 6, radius1);
            HalconAPI.Store(proc, 7, radius2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(maxNumPoints);
            HalconAPI.UnpinTuple(clippingEndPoints);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(radius1);
            HalconAPI.UnpinTuple(radius2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out minDist);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out maxDist);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out avgDist);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out sigmaDist);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Approximate XLD contours by ellipses or elliptic arcs.</summary>
        /// <param name="contours">Input contours.</param>
        /// <param name="algorithm">Algorithm for the fitting of ellipses. Default: "fitzgibbon"</param>
        /// <param name="maxNumPoints">Maximum number of contour points used for the computation (-1 for all points). Default: -1</param>
        /// <param name="maxClosureDist">Maximum distance between the end points of a contour to be considered as 'closed'. Default: 0.0</param>
        /// <param name="clippingEndPoints">Number of points at the beginning and at the end of the contours to be ignored for the fitting. Default: 0</param>
        /// <param name="vossTabSize">Number of circular segments used for the Voss approach. Default: 200</param>
        /// <param name="iterations">Maximum number of iterations for the robust weighted fitting. Default: 3</param>
        /// <param name="clippingFactor">Clipping factor for the elimination of outliers (typical: 1.0 for '*huber' and 2.0 for '*tukey'). Default: 2.0</param>
        /// <param name="row">Row coordinate of the center of the ellipse.</param>
        /// <param name="column">Column coordinate of the center of the ellipse.</param>
        /// <param name="phi">Orientation of the main axis [rad].</param>
        /// <param name="radius1">Length of the larger half axis.</param>
        /// <param name="radius2">Length of the smaller half axis.</param>
        /// <param name="startPhi">Angle of the start point [rad].</param>
        /// <param name="endPhi">Angle of the end point [rad].</param>
        /// <param name="pointOrder">point order along the boundary.</param>
        public static void FitEllipseContourXld(
          HObject contours,
          HTuple algorithm,
          HTuple maxNumPoints,
          HTuple maxClosureDist,
          HTuple clippingEndPoints,
          HTuple vossTabSize,
          HTuple iterations,
          HTuple clippingFactor,
          out HTuple row,
          out HTuple column,
          out HTuple phi,
          out HTuple radius1,
          out HTuple radius2,
          out HTuple startPhi,
          out HTuple endPhi,
          out HTuple pointOrder)
        {
            IntPtr proc = HalconAPI.PreCall(33);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, algorithm);
            HalconAPI.Store(proc, 1, maxNumPoints);
            HalconAPI.Store(proc, 2, maxClosureDist);
            HalconAPI.Store(proc, 3, clippingEndPoints);
            HalconAPI.Store(proc, 4, vossTabSize);
            HalconAPI.Store(proc, 5, iterations);
            HalconAPI.Store(proc, 6, clippingFactor);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(algorithm);
            HalconAPI.UnpinTuple(maxNumPoints);
            HalconAPI.UnpinTuple(maxClosureDist);
            HalconAPI.UnpinTuple(clippingEndPoints);
            HalconAPI.UnpinTuple(vossTabSize);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(clippingFactor);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out radius1);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out radius2);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out startPhi);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out endPhi);
            int procResult = HTuple.LoadNew(proc, 7, err8, out pointOrder);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Create XLD contours corresponding to circles or circular arcs.</summary>
        /// <param name="contCircle">Resulting contours.</param>
        /// <param name="row">Row coordinate of the center of the circles or circular arcs. Default: 200.0</param>
        /// <param name="column">Column coordinate of the center of the circles or circular arcs. Default: 200.0</param>
        /// <param name="radius">Radius of the circles or circular arcs. Default: 100.0</param>
        /// <param name="startPhi">Angle of the start points of the circles or circular arcs [rad]. Default: 0.0</param>
        /// <param name="endPhi">Angle of the end points of the circles or circular arcs [rad]. Default: 6.28318</param>
        /// <param name="pointOrder">Point order along the circles or circular arcs. Default: "positive"</param>
        /// <param name="resolution">Distance between neighboring contour points. Default: 1.0</param>
        public static void GenCircleContourXld(
          out HObject contCircle,
          HTuple row,
          HTuple column,
          HTuple radius,
          HTuple startPhi,
          HTuple endPhi,
          HTuple pointOrder,
          HTuple resolution)
        {
            IntPtr proc = HalconAPI.PreCall(34);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, radius);
            HalconAPI.Store(proc, 3, startPhi);
            HalconAPI.Store(proc, 4, endPhi);
            HalconAPI.Store(proc, 5, pointOrder);
            HalconAPI.Store(proc, 6, resolution);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(startPhi);
            HalconAPI.UnpinTuple(endPhi);
            HalconAPI.UnpinTuple(pointOrder);
            HalconAPI.UnpinTuple(resolution);
            int procResult = HObject.LoadNew(proc, 1, err, out contCircle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an XLD contour that corresponds to an elliptic arc.</summary>
        /// <param name="contEllipse">Resulting contour.</param>
        /// <param name="row">Row coordinate of the center of the ellipse. Default: 200.0</param>
        /// <param name="column">Column coordinate of the center of the ellipse. Default: 200.0</param>
        /// <param name="phi">Orientation of the main axis [rad]. Default: 0.0</param>
        /// <param name="radius1">Length of the larger half axis. Default: 100.0</param>
        /// <param name="radius2">Length of the smaller half axis. Default: 50.0</param>
        /// <param name="startPhi">Angle of the start point on the smallest surrounding circle  [rad]. Default: 0.0</param>
        /// <param name="endPhi">Angle of the end point on the smallest surrounding circle  [rad]. Default: 6.28318</param>
        /// <param name="pointOrder">point order along the boundary. Default: "positive"</param>
        /// <param name="resolution">Resolution: Maximum distance between neighboring contour points. Default: 1.5</param>
        public static void GenEllipseContourXld(
          out HObject contEllipse,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple radius1,
          HTuple radius2,
          HTuple startPhi,
          HTuple endPhi,
          HTuple pointOrder,
          HTuple resolution)
        {
            IntPtr proc = HalconAPI.PreCall(35);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, phi);
            HalconAPI.Store(proc, 3, radius1);
            HalconAPI.Store(proc, 4, radius2);
            HalconAPI.Store(proc, 5, startPhi);
            HalconAPI.Store(proc, 6, endPhi);
            HalconAPI.Store(proc, 7, pointOrder);
            HalconAPI.Store(proc, 8, resolution);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(radius1);
            HalconAPI.UnpinTuple(radius2);
            HalconAPI.UnpinTuple(startPhi);
            HalconAPI.UnpinTuple(endPhi);
            HalconAPI.UnpinTuple(pointOrder);
            HalconAPI.UnpinTuple(resolution);
            int procResult = HObject.LoadNew(proc, 1, err, out contEllipse);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add noise to XLD contours.</summary>
        /// <param name="contours">Original contours.</param>
        /// <param name="noisyContours">Noisy contours.</param>
        /// <param name="numRegrPoints">Number of points used to calculate the regression line. Default: 5</param>
        /// <param name="amp">Maximum amplitude of the added noise (equally distributed in [-Amp,Amp]). Default: 1.0</param>
        public static void AddNoiseWhiteContourXld(
          HObject contours,
          out HObject noisyContours,
          HTuple numRegrPoints,
          HTuple amp)
        {
            IntPtr proc = HalconAPI.PreCall(36);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, numRegrPoints);
            HalconAPI.Store(proc, 1, amp);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numRegrPoints);
            HalconAPI.UnpinTuple(amp);
            int procResult = HObject.LoadNew(proc, 1, err, out noisyContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Combine road hypotheses from two resolution levels.</summary>
        /// <param name="edgePolygons">XLD polygons to be examined.</param>
        /// <param name="modParallels">Modified parallels obtained from EdgePolygons.</param>
        /// <param name="extParallels">Extended parallels obtained from EdgePolygons.</param>
        /// <param name="centerLines">Road-center-line polygons to be examined.</param>
        /// <param name="roadSides">Roadsides found.</param>
        /// <param name="maxAngleParallel">Maximum angle between two parallel line segments. Default: 0.523598775598</param>
        /// <param name="maxAngleColinear">Maximum angle between two collinear line segments. Default: 0.261799387799</param>
        /// <param name="maxDistanceParallel">Maximum distance between two parallel line segments. Default: 40</param>
        /// <param name="maxDistanceColinear">Maximum distance between two collinear line segments. Default: 40</param>
        public static void CombineRoadsXld(
          HObject edgePolygons,
          HObject modParallels,
          HObject extParallels,
          HObject centerLines,
          out HObject roadSides,
          HTuple maxAngleParallel,
          HTuple maxAngleColinear,
          HTuple maxDistanceParallel,
          HTuple maxDistanceColinear)
        {
            IntPtr proc = HalconAPI.PreCall(37);
            HalconAPI.Store(proc, 1, (HObjectBase)edgePolygons);
            HalconAPI.Store(proc, 2, (HObjectBase)modParallels);
            HalconAPI.Store(proc, 3, (HObjectBase)extParallels);
            HalconAPI.Store(proc, 4, (HObjectBase)centerLines);
            HalconAPI.Store(proc, 0, maxAngleParallel);
            HalconAPI.Store(proc, 1, maxAngleColinear);
            HalconAPI.Store(proc, 2, maxDistanceParallel);
            HalconAPI.Store(proc, 3, maxDistanceColinear);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maxAngleParallel);
            HalconAPI.UnpinTuple(maxAngleColinear);
            HalconAPI.UnpinTuple(maxDistanceParallel);
            HalconAPI.UnpinTuple(maxDistanceColinear);
            int procResult = HObject.LoadNew(proc, 1, err, out roadSides);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)edgePolygons);
            GC.KeepAlive((object)modParallels);
            GC.KeepAlive((object)extParallels);
            GC.KeepAlive((object)centerLines);
        }

        /// <summary>Join modified XLD parallels lying on the same polygon.</summary>
        /// <param name="extParallels">Extended XLD parallels.</param>
        /// <param name="maxPolygons">Maximally extended parallels.</param>
        public static void MaxParallelsXld(HObject extParallels, out HObject maxPolygons)
        {
            IntPtr proc = HalconAPI.PreCall(38);
            HalconAPI.Store(proc, 1, (HObjectBase)extParallels);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out maxPolygons);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)extParallels);
        }

        /// <summary>Extract parallel XLD polygons enclosing a homogeneous area.</summary>
        /// <param name="parallels">Input XLD parallels.</param>
        /// <param name="image">Corresponding gray value image.</param>
        /// <param name="modParallels">Modified XLD parallels.</param>
        /// <param name="extParallels">Extended XLD parallels.</param>
        /// <param name="quality">Minimum quality factor (measure of parallelism). Default: 0.4</param>
        /// <param name="minGray">Minimum mean gray value. Default: 160</param>
        /// <param name="maxGray">Maximum mean gray value. Default: 220</param>
        /// <param name="maxStandard">Maximum allowed standard deviation. Default: 10.0</param>
        public static void ModParallelsXld(
          HObject parallels,
          HObject image,
          out HObject modParallels,
          out HObject extParallels,
          HTuple quality,
          HTuple minGray,
          HTuple maxGray,
          HTuple maxStandard)
        {
            IntPtr proc = HalconAPI.PreCall(39);
            HalconAPI.Store(proc, 1, (HObjectBase)parallels);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, quality);
            HalconAPI.Store(proc, 1, minGray);
            HalconAPI.Store(proc, 2, maxGray);
            HalconAPI.Store(proc, 3, maxStandard);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(quality);
            HalconAPI.UnpinTuple(minGray);
            HalconAPI.UnpinTuple(maxGray);
            HalconAPI.UnpinTuple(maxStandard);
            int err2 = HObject.LoadNew(proc, 1, err1, out modParallels);
            int procResult = HObject.LoadNew(proc, 2, err2, out extParallels);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)parallels);
            GC.KeepAlive((object)image);
        }

        /// <summary>Return information about the gray values of the area enclosed by XLD parallels.</summary>
        /// <param name="parallels">Input XLD Parallels.</param>
        /// <param name="image">Corresponding gray value image.</param>
        /// <param name="qualityMin">Minimum quality factor.</param>
        /// <param name="qualityMax">Maximum quality factor.</param>
        /// <param name="grayMin">Minimum mean gray value.</param>
        /// <param name="grayMax">Maximum mean gray value.</param>
        /// <param name="standardMin">Minimum standard deviation.</param>
        /// <param name="standardMax">Maximum standard deviation.</param>
        public static void InfoParallelsXld(
          HObject parallels,
          HObject image,
          out HTuple qualityMin,
          out HTuple qualityMax,
          out HTuple grayMin,
          out HTuple grayMax,
          out HTuple standardMin,
          out HTuple standardMax)
        {
            IntPtr proc = HalconAPI.PreCall(40);
            HalconAPI.Store(proc, 1, (HObjectBase)parallels);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out qualityMin);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out qualityMax);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out grayMin);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out grayMax);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out standardMin);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out standardMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)parallels);
            GC.KeepAlive((object)image);
        }

        /// <summary>Return an XLD parallel's data (as lines).</summary>
        /// <param name="parallels">Input XLD parallels.</param>
        /// <param name="row1">Row coordinates of the points on polygon P1.</param>
        /// <param name="col1">Column coordinates of the points on polygon P1.</param>
        /// <param name="length1">Lengths of the line segments on polygon P1.</param>
        /// <param name="phi1">Angles of the line segments on polygon P1.</param>
        /// <param name="row2">Row coordinates of the points on polygon P2.</param>
        /// <param name="col2">Column coordinates of the points on polygon P2.</param>
        /// <param name="length2">Lengths of the line segments on polygon P2.</param>
        /// <param name="phi2">Angles of the line segments on polygon P2.</param>
        public static void GetParallelsXld(
          HObject parallels,
          out HTuple row1,
          out HTuple col1,
          out HTuple length1,
          out HTuple phi1,
          out HTuple row2,
          out HTuple col2,
          out HTuple length2,
          out HTuple phi2)
        {
            IntPtr proc = HalconAPI.PreCall(41);
            HalconAPI.Store(proc, 1, (HObjectBase)parallels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out col1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out length1);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out phi1);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out row2);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out col2);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out length2);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out phi2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)parallels);
        }

        /// <summary>Extract parallel XLD polygons.</summary>
        /// <param name="polygons">Input polygons.</param>
        /// <param name="parallels">Parallel polygons.</param>
        /// <param name="len">Minimum length of the individual polygon segments. Default: 10.0</param>
        /// <param name="dist">Maximum distance between the polygon segments. Default: 30.0</param>
        /// <param name="alpha">Maximum angle difference of the polygon segments. Default: 0.15</param>
        /// <param name="merge">Should adjacent parallel relations be merged? Default: "true"</param>
        public static void GenParallelsXld(
          HObject polygons,
          out HObject parallels,
          HTuple len,
          HTuple dist,
          HTuple alpha,
          HTuple merge)
        {
            IntPtr proc = HalconAPI.PreCall(42);
            HalconAPI.Store(proc, 1, (HObjectBase)polygons);
            HalconAPI.Store(proc, 0, len);
            HalconAPI.Store(proc, 1, dist);
            HalconAPI.Store(proc, 2, alpha);
            HalconAPI.Store(proc, 3, merge);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(len);
            HalconAPI.UnpinTuple(dist);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.UnpinTuple(merge);
            int procResult = HObject.LoadNew(proc, 1, err, out parallels);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygons);
        }

        /// <summary>Return an XLD polygon's data (as lines).</summary>
        /// <param name="polygon">Input XLD polygons.</param>
        /// <param name="beginRow">Row coordinates of the lines' start points.</param>
        /// <param name="beginCol">Column coordinates of the lines' start points.</param>
        /// <param name="endRow">Column coordinates of the lines' end points.</param>
        /// <param name="endCol">Column coordinates of the lines' end points.</param>
        /// <param name="length">Lengths of the line segments.</param>
        /// <param name="phi">Angles of the line segments.</param>
        public static void GetLinesXld(
          HObject polygon,
          out HTuple beginRow,
          out HTuple beginCol,
          out HTuple endRow,
          out HTuple endCol,
          out HTuple length,
          out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(43);
            HalconAPI.Store(proc, 1, (HObjectBase)polygon);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out beginRow);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out beginCol);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out endRow);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out endCol);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out length);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out phi);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygon);
        }

        /// <summary>Return an XLD polygon's data.</summary>
        /// <param name="polygon">Input XLD polygon.</param>
        /// <param name="row">Row coordinates of the polygons' points.</param>
        /// <param name="col">Column coordinates of the polygons' points.</param>
        /// <param name="length">Lengths of the line segments.</param>
        /// <param name="phi">Angles of the line segments.</param>
        public static void GetPolygonXld(
          HObject polygon,
          out HTuple row,
          out HTuple col,
          out HTuple length,
          out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(44);
            HalconAPI.Store(proc, 1, (HObjectBase)polygon);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out col);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out length);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out phi);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygon);
        }

        /// <summary>Approximate XLD contours by polygons.</summary>
        /// <param name="contours">Contours to be approximated.</param>
        /// <param name="polygons">Approximating polygons.</param>
        /// <param name="type">Type of approximation. Default: "ramer"</param>
        /// <param name="alpha">Threshold for the approximation. Default: 2.0</param>
        public static void GenPolygonsXld(
          HObject contours,
          out HObject polygons,
          HTuple type,
          HTuple alpha)
        {
            IntPtr proc = HalconAPI.PreCall(45);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, alpha);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(alpha);
            int procResult = HObject.LoadNew(proc, 1, err, out polygons);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Split XLD contours at dominant points.</summary>
        /// <param name="polygons">Polygons for which the corresponding contours are to be split.</param>
        /// <param name="contours">Split contours.</param>
        /// <param name="mode">Mode for the splitting of the contours. Default: "polygon"</param>
        /// <param name="weight">Weight for the sensitiveness. Default: 1</param>
        /// <param name="smooth">Width of the smoothing mask. Default: 5</param>
        public static void SplitContoursXld(
          HObject polygons,
          out HObject contours,
          HTuple mode,
          HTuple weight,
          HTuple smooth)
        {
            IntPtr proc = HalconAPI.PreCall(46);
            HalconAPI.Store(proc, 1, (HObjectBase)polygons);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, weight);
            HalconAPI.Store(proc, 2, smooth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(weight);
            HalconAPI.UnpinTuple(smooth);
            int procResult = HObject.LoadNew(proc, 1, err, out contours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygons);
        }

        /// <summary>Apply a projective transformation to an XLD contour.</summary>
        /// <param name="contours">Input contours.</param>
        /// <param name="contoursProjTrans">Output contours.</param>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        public static void ProjectiveTransContourXld(
          HObject contours,
          out HObject contoursProjTrans,
          HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(47);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            int procResult = HObject.LoadNew(proc, 1, err, out contoursProjTrans);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Apply an arbitrary affine transformation to XLD polygons.</summary>
        /// <param name="polygons">Input XLD polygons.</param>
        /// <param name="polygonsAffineTrans">Transformed XLD polygons.</param>
        /// <param name="homMat2D">Input transformation matrix.</param>
        public static void AffineTransPolygonXld(
          HObject polygons,
          out HObject polygonsAffineTrans,
          HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(48);
            HalconAPI.Store(proc, 1, (HObjectBase)polygons);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            int procResult = HObject.LoadNew(proc, 1, err, out polygonsAffineTrans);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygons);
        }

        /// <summary>Apply an arbitrary affine 2D transformation to XLD contours.</summary>
        /// <param name="contours">Input XLD contours.</param>
        /// <param name="contoursAffineTrans">Transformed XLD contours.</param>
        /// <param name="homMat2D">Input transformation matrix.</param>
        public static void AffineTransContourXld(
          HObject contours,
          out HObject contoursAffineTrans,
          HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(49);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            int procResult = HObject.LoadNew(proc, 1, err, out contoursAffineTrans);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Close an XLD contour.</summary>
        /// <param name="contours">Contours to be closed.</param>
        /// <param name="closedContours">Closed contours.</param>
        public static void CloseContoursXld(HObject contours, out HObject closedContours)
        {
            IntPtr proc = HalconAPI.PreCall(50);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out closedContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Clip the end points of an XLD contour.</summary>
        /// <param name="contours">Input contour</param>
        /// <param name="clippedContours">Clipped contour</param>
        /// <param name="mode">Clipping mode. Default: "num_points"</param>
        /// <param name="length">Clipping length in unit pixels (Mode $=$ 'length') or number (Mode $=$ 'num_points') Default: 3</param>
        public static void ClipEndPointsContoursXld(
          HObject contours,
          out HObject clippedContours,
          HTuple mode,
          HTuple length)
        {
            IntPtr proc = HalconAPI.PreCall(51);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, length);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(length);
            int procResult = HObject.LoadNew(proc, 1, err, out clippedContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Clip an XLD contour.</summary>
        /// <param name="contours">Contours to be clipped.</param>
        /// <param name="clippedContours">Clipped contours.</param>
        /// <param name="row1">Row coordinate of the upper left corner of the clip rectangle. Default: 0</param>
        /// <param name="column1">Column coordinate of the upper left corner of the clip rectangle. Default: 0</param>
        /// <param name="row2">Row coordinate of the lower right corner of the clip rectangle. Default: 512</param>
        /// <param name="column2">Column coordinate of the lower right corner of the clip rectangle. Default: 512</param>
        public static void ClipContoursXld(
          HObject contours,
          out HObject clippedContours,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(52);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int procResult = HObject.LoadNew(proc, 1, err, out clippedContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Select XLD contours with a local maximum of gray values.</summary>
        /// <param name="contours">XLD contours to be examined.</param>
        /// <param name="image">Corresponding gray value image.</param>
        /// <param name="localMaxContours">Selected contours.</param>
        /// <param name="minPercent">Minimum percentage of maximum points. Default: 70</param>
        /// <param name="minDiff">Minimum amount by which the gray value at the maximum must be larger than in the profile. Default: 15</param>
        /// <param name="distance">Maximum width of profile used to check for maxima. Default: 4</param>
        public static void LocalMaxContoursXld(
          HObject contours,
          HObject image,
          out HObject localMaxContours,
          HTuple minPercent,
          HTuple minDiff,
          HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(53);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, minPercent);
            HalconAPI.Store(proc, 1, minDiff);
            HalconAPI.Store(proc, 2, distance);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minPercent);
            HalconAPI.UnpinTuple(minDiff);
            HalconAPI.UnpinTuple(distance);
            int procResult = HObject.LoadNew(proc, 1, err, out localMaxContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute the union of neighboring straight contours that have a similar  distance from a given line.</summary>
        /// <param name="contours">Input XLD contours.</param>
        /// <param name="unionContours">Output XLD contours.</param>
        /// <param name="selectedContours">Output XLD contours.</param>
        /// <param name="refLineStartRow">y coordinate of the starting point of the reference line. Default: 0</param>
        /// <param name="refLineStartColumn">x coordinate of the starting point of the reference line. Default: 0</param>
        /// <param name="refLineEndRow">y coordinate of the endpoint of the reference line. Default: 0</param>
        /// <param name="refLineEndColumn">x coordinate of the endpoint of the reference line. Default: 0</param>
        /// <param name="width">Maximum distance. Default: 1</param>
        /// <param name="maxWidth">Maximum Width between two minimas. Default: 1</param>
        /// <param name="filterSize">Size of Smoothfilter Default: 1</param>
        /// <param name="histoValues">Output Values of Histogram.</param>
        public static void UnionStraightContoursHistoXld(
          HObject contours,
          out HObject unionContours,
          out HObject selectedContours,
          HTuple refLineStartRow,
          HTuple refLineStartColumn,
          HTuple refLineEndRow,
          HTuple refLineEndColumn,
          HTuple width,
          HTuple maxWidth,
          HTuple filterSize,
          out HTuple histoValues)
        {
            IntPtr proc = HalconAPI.PreCall(54);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, refLineStartRow);
            HalconAPI.Store(proc, 1, refLineStartColumn);
            HalconAPI.Store(proc, 2, refLineEndRow);
            HalconAPI.Store(proc, 3, refLineEndColumn);
            HalconAPI.Store(proc, 4, width);
            HalconAPI.Store(proc, 5, maxWidth);
            HalconAPI.Store(proc, 6, filterSize);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(refLineStartRow);
            HalconAPI.UnpinTuple(refLineStartColumn);
            HalconAPI.UnpinTuple(refLineEndRow);
            HalconAPI.UnpinTuple(refLineEndColumn);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(maxWidth);
            HalconAPI.UnpinTuple(filterSize);
            int err2 = HObject.LoadNew(proc, 1, err1, out unionContours);
            int err3 = HObject.LoadNew(proc, 2, err2, out selectedContours);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err3, out histoValues);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Compute the union of neighboring straight contours that have a similar  direction.</summary>
        /// <param name="contours">Input XLD contours.</param>
        /// <param name="unionContours">Output XLD contours.</param>
        /// <param name="maxDist">Maximum distance of the contours' endpoints. Default: 5.0</param>
        /// <param name="maxDiff">Maximum difference in direction. Default: 0.5</param>
        /// <param name="percent">Weighting factor for the two selection criteria. Default: 50.0</param>
        /// <param name="mode">Should parallel contours be taken into account? Default: "noparallel"</param>
        /// <param name="iterations">Number of iterations or 'maximum'. Default: "maximum"</param>
        public static void UnionStraightContoursXld(
          HObject contours,
          out HObject unionContours,
          HTuple maxDist,
          HTuple maxDiff,
          HTuple percent,
          HTuple mode,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(55);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, maxDist);
            HalconAPI.Store(proc, 1, maxDiff);
            HalconAPI.Store(proc, 2, percent);
            HalconAPI.Store(proc, 3, mode);
            HalconAPI.Store(proc, 4, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maxDist);
            HalconAPI.UnpinTuple(maxDiff);
            HalconAPI.UnpinTuple(percent);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out unionContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Compute the union of collinear contours  (operator with extended functionality).</summary>
        /// <param name="contours">Input XLD contours.</param>
        /// <param name="unionContours">Output XLD contours.</param>
        /// <param name="maxDistAbs">Maximum distance of the contours' end points in the direction of the reference regression line. Default: 10.0</param>
        /// <param name="maxDistRel">Maximum distance of the contours' end points in the direction of the reference regression line in relation to the length of the contour which is to be elongated. Default: 1.0</param>
        /// <param name="maxShift">Maximum distance of the contour from the reference regression line (i.e., perpendicular to the line). Default: 2.0</param>
        /// <param name="maxAngle">Maximum angle difference between the two contours. Default: 0.1</param>
        /// <param name="maxOverlap">Maximum range of the overlap. Default: 0.0</param>
        /// <param name="maxRegrError">Maximum regression error of the resulting contours (NOT USED).  Default: -1.0</param>
        /// <param name="maxCosts">Threshold for reducing the total costs of unification. Default: 1.0</param>
        /// <param name="weightDist">Influence of the distance in the line direction on the total costs. Default: 1.0</param>
        /// <param name="weightShift">Influence of the distance from the regression line on the total costs. Default: 1.0</param>
        /// <param name="weightAngle">Influence of the angle difference on the total costs. Default: 1.0</param>
        /// <param name="weightLink">Influence of the line disturbance by the linking segment (overlap and angle difference) on the total costs. Default: 1.0</param>
        /// <param name="weightRegr">Influence of the regression error on the total costs (NOT USED). Default: 0.0</param>
        /// <param name="mode">Mode describing the treatment of the contours' attributes Default: "attr_keep"</param>
        public static void UnionCollinearContoursExtXld(
          HObject contours,
          out HObject unionContours,
          HTuple maxDistAbs,
          HTuple maxDistRel,
          HTuple maxShift,
          HTuple maxAngle,
          HTuple maxOverlap,
          HTuple maxRegrError,
          HTuple maxCosts,
          HTuple weightDist,
          HTuple weightShift,
          HTuple weightAngle,
          HTuple weightLink,
          HTuple weightRegr,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(56);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, maxDistAbs);
            HalconAPI.Store(proc, 1, maxDistRel);
            HalconAPI.Store(proc, 2, maxShift);
            HalconAPI.Store(proc, 3, maxAngle);
            HalconAPI.Store(proc, 4, maxOverlap);
            HalconAPI.Store(proc, 5, maxRegrError);
            HalconAPI.Store(proc, 6, maxCosts);
            HalconAPI.Store(proc, 7, weightDist);
            HalconAPI.Store(proc, 8, weightShift);
            HalconAPI.Store(proc, 9, weightAngle);
            HalconAPI.Store(proc, 10, weightLink);
            HalconAPI.Store(proc, 11, weightRegr);
            HalconAPI.Store(proc, 12, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maxDistAbs);
            HalconAPI.UnpinTuple(maxDistRel);
            HalconAPI.UnpinTuple(maxShift);
            HalconAPI.UnpinTuple(maxAngle);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(maxRegrError);
            HalconAPI.UnpinTuple(maxCosts);
            HalconAPI.UnpinTuple(weightDist);
            HalconAPI.UnpinTuple(weightShift);
            HalconAPI.UnpinTuple(weightAngle);
            HalconAPI.UnpinTuple(weightLink);
            HalconAPI.UnpinTuple(weightRegr);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out unionContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Unite approximately collinear contours.</summary>
        /// <param name="contours">Input XLD contours.</param>
        /// <param name="unionContours">Output XLD contours.</param>
        /// <param name="maxDistAbs">Maximum length of the gap between two contours, measured along the regression line of the reference contour. Default: 10.0</param>
        /// <param name="maxDistRel">Maximum length of the gap between two contours, relative to the length of the reference contour, both measured along the regression line of the reference contour. Default: 1.0</param>
        /// <param name="maxShift">Maximum distance of the second contour from the regression line of the reference contour. Default: 2.0</param>
        /// <param name="maxAngle">Maximum angle between the regression lines of two contours. Default: 0.1</param>
        /// <param name="mode">Mode that defines the treatment of contour attributes, i.e., if the contour attributes are kept or discarded. Default: "attr_keep"</param>
        public static void UnionCollinearContoursXld(
          HObject contours,
          out HObject unionContours,
          HTuple maxDistAbs,
          HTuple maxDistRel,
          HTuple maxShift,
          HTuple maxAngle,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(57);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, maxDistAbs);
            HalconAPI.Store(proc, 1, maxDistRel);
            HalconAPI.Store(proc, 2, maxShift);
            HalconAPI.Store(proc, 3, maxAngle);
            HalconAPI.Store(proc, 4, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maxDistAbs);
            HalconAPI.UnpinTuple(maxDistRel);
            HalconAPI.UnpinTuple(maxShift);
            HalconAPI.UnpinTuple(maxAngle);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out unionContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Compute the union of contours whose end points are close together.</summary>
        /// <param name="contours">Input XLD contours.</param>
        /// <param name="unionContours">Output XLD contours.</param>
        /// <param name="maxDistAbs">Maximum distance of the contours' end points. Default: 10.0</param>
        /// <param name="maxDistRel">Maximum distance of the contours' end points in relation to the length of the longer contour. Default: 1.0</param>
        /// <param name="mode">Mode describing the treatment of the contours' attributes. Default: "attr_keep"</param>
        public static void UnionAdjacentContoursXld(
          HObject contours,
          out HObject unionContours,
          HTuple maxDistAbs,
          HTuple maxDistRel,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(58);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, maxDistAbs);
            HalconAPI.Store(proc, 1, maxDistRel);
            HalconAPI.Store(proc, 2, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maxDistAbs);
            HalconAPI.UnpinTuple(maxDistRel);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out unionContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Select XLD contours according to several features.</summary>
        /// <param name="contours">Input XLD contours.</param>
        /// <param name="selectedContours">Output XLD contours.</param>
        /// <param name="feature">Feature to select contours with. Default: "contour_length"</param>
        /// <param name="min1">Lower threshold. Default: 0.5</param>
        /// <param name="max1">Upper threshold. Default: 200.0</param>
        /// <param name="min2">Lower threshold. Default: -0.5</param>
        /// <param name="max2">Upper threshold. Default: 0.5</param>
        public static void SelectContoursXld(
          HObject contours,
          out HObject selectedContours,
          HTuple feature,
          HTuple min1,
          HTuple max1,
          HTuple min2,
          HTuple max2)
        {
            IntPtr proc = HalconAPI.PreCall(59);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, feature);
            HalconAPI.Store(proc, 1, min1);
            HalconAPI.Store(proc, 2, max1);
            HalconAPI.Store(proc, 3, min2);
            HalconAPI.Store(proc, 4, max2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(feature);
            HalconAPI.UnpinTuple(min1);
            HalconAPI.UnpinTuple(max1);
            HalconAPI.UnpinTuple(min2);
            HalconAPI.UnpinTuple(max2);
            int procResult = HObject.LoadNew(proc, 1, err, out selectedContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Return XLD contour parameters.</summary>
        /// <param name="contours">Input XLD contours.</param>
        /// <param name="length">Number of contour points.</param>
        /// <param name="nx">X-coordinate of the normal vector of the regression line.</param>
        /// <param name="ny">Y-coordinate of the normal vector of the regression line.</param>
        /// <param name="dist">Distance of the regression line from the origin.</param>
        /// <param name="fpx">X-coordinate of the projection of the start point of the contour onto the regression line.</param>
        /// <param name="fpy">Y-coordinate of the projection of the start point of the contour onto the regression line.</param>
        /// <param name="lpx">X-coordinate of the projection of the end point of the contour onto the regression line.</param>
        /// <param name="lpy">Y-coordinate of the projection of the end point of the contour onto the regression line.</param>
        /// <param name="mean">Mean distance of the contour points from the regression line.</param>
        /// <param name="deviation">Standard deviation of the distances from the regression line.</param>
        public static void GetRegressParamsXld(
          HObject contours,
          out HTuple length,
          out HTuple nx,
          out HTuple ny,
          out HTuple dist,
          out HTuple fpx,
          out HTuple fpy,
          out HTuple lpx,
          out HTuple lpy,
          out HTuple mean,
          out HTuple deviation)
        {
            IntPtr proc = HalconAPI.PreCall(60);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out length);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out nx);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out ny);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out dist);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out fpx);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out fpy);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out lpx);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out lpy);
            int err10 = HTuple.LoadNew(proc, 8, HTupleType.DOUBLE, err9, out mean);
            int procResult = HTuple.LoadNew(proc, 9, HTupleType.DOUBLE, err10, out deviation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Calculate the parameters of a regression line to an XLD contour.</summary>
        /// <param name="contours">Input XLD contours.</param>
        /// <param name="regressContours">Resulting XLD contours.</param>
        /// <param name="mode">Type of outlier treatment. Default: "no"</param>
        /// <param name="iterations">Number of iterations for the outlier treatment. Default: 1</param>
        public static void RegressContoursXld(
          HObject contours,
          out HObject regressContours,
          HTuple mode,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(61);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regressContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Calculate the direction of an XLD contour for each contour point.</summary>
        /// <param name="contour">Input contour.</param>
        /// <param name="angleMode">Return type of the angles. Default: "abs"</param>
        /// <param name="calcMode">Method for computing the angles. Default: "range"</param>
        /// <param name="lookaround">Number of points to take into account. Default: 3</param>
        /// <param name="angles">Direction of the tangent to the contour points.</param>
        public static void GetContourAngleXld(
          HObject contour,
          HTuple angleMode,
          HTuple calcMode,
          HTuple lookaround,
          out HTuple angles)
        {
            IntPtr proc = HalconAPI.PreCall(62);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, angleMode);
            HalconAPI.Store(proc, 1, calcMode);
            HalconAPI.Store(proc, 2, lookaround);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(angleMode);
            HalconAPI.UnpinTuple(calcMode);
            HalconAPI.UnpinTuple(lookaround);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out angles);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Smooth an XLD contour.</summary>
        /// <param name="contours">Contour to be smoothed.</param>
        /// <param name="smoothedContours">Smoothed contour.</param>
        /// <param name="numRegrPoints">Number of points used to calculate the regression line. Default: 5</param>
        public static void SmoothContoursXld(
          HObject contours,
          out HObject smoothedContours,
          HTuple numRegrPoints)
        {
            IntPtr proc = HalconAPI.PreCall(63);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, numRegrPoints);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numRegrPoints);
            int procResult = HObject.LoadNew(proc, 1, err, out smoothedContours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Return the number of points in an XLD contour.</summary>
        /// <param name="contour">Input XLD contour.</param>
        /// <param name="length">Number of contour points.</param>
        public static void ContourPointNumXld(HObject contour, out HTuple length)
        {
            IntPtr proc = HalconAPI.PreCall(64);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out length);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Return the names of the defined global attributes of an XLD contour.</summary>
        /// <param name="contour">Input contour.</param>
        /// <param name="attribs">List of the defined global contour attributes.</param>
        public static void QueryContourGlobalAttribsXld(HObject contour, out HTuple attribs)
        {
            IntPtr proc = HalconAPI.PreCall(65);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, err, out attribs);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Return global attributes values of an XLD contour.</summary>
        /// <param name="contour">Input XLD contour.</param>
        /// <param name="name">Name of the attribute. Default: "regr_norm_row"</param>
        /// <param name="attrib">Attribute values.</param>
        public static void GetContourGlobalAttribXld(HObject contour, HTuple name, out HTuple attrib)
        {
            IntPtr proc = HalconAPI.PreCall(66);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, name);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(name);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out attrib);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Return the names of the defined attributes of an XLD contour.</summary>
        /// <param name="contour">Input contour.</param>
        /// <param name="attribs">List of the defined contour attributes.</param>
        public static void QueryContourAttribsXld(HObject contour, out HTuple attribs)
        {
            IntPtr proc = HalconAPI.PreCall(67);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, err, out attribs);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Return point attribute values of an XLD contour.</summary>
        /// <param name="contour">Input XLD contour.</param>
        /// <param name="name">Name of the attribute. Default: "angle"</param>
        /// <param name="attrib">Attribute values.</param>
        public static void GetContourAttribXld(HObject contour, HTuple name, out HTuple attrib)
        {
            IntPtr proc = HalconAPI.PreCall(68);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, name);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(name);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out attrib);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Return the coordinates of an XLD contour.</summary>
        /// <param name="contour">Input XLD contour.</param>
        /// <param name="row">Row coordinate of the contour's points.</param>
        /// <param name="col">Column coordinate of the contour's points.</param>
        public static void GetContourXld(HObject contour, out HTuple row, out HTuple col)
        {
            IntPtr proc = HalconAPI.PreCall(69);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out col);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Generate XLD contours from regions.</summary>
        /// <param name="regions">Input regions.</param>
        /// <param name="contours">Resulting contours.</param>
        /// <param name="mode">Mode of contour generation. Default: "border"</param>
        public static void GenContourRegionXld(HObject regions, out HObject contours, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(70);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out contours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Generate an XLD contour with rounded corners from a polygon (given as tuples).</summary>
        /// <param name="contour">Resulting contour.</param>
        /// <param name="row">Row coordinates of the polygon. Default: [20,80,80,20,20]</param>
        /// <param name="col">Column coordinates of the polygon. Default: [20,20,80,80,20]</param>
        /// <param name="radius">Radii of the rounded corners. Default: [20,20,20,20,20]</param>
        /// <param name="samplingInterval">Distance of the samples. Default: 1.0</param>
        public static void GenContourPolygonRoundedXld(
          out HObject contour,
          HTuple row,
          HTuple col,
          HTuple radius,
          HTuple samplingInterval)
        {
            IntPtr proc = HalconAPI.PreCall(71);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, col);
            HalconAPI.Store(proc, 2, radius);
            HalconAPI.Store(proc, 3, samplingInterval);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(col);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(samplingInterval);
            int procResult = HObject.LoadNew(proc, 1, err, out contour);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate an XLD contour from a polygon (given as tuples).</summary>
        /// <param name="contour">Resulting contour.</param>
        /// <param name="row">Row coordinates of the polygon. Default: [0,1,2,2,2]</param>
        /// <param name="col">Column coordinates of the polygon. Default: [0,0,0,1,2]</param>
        public static void GenContourPolygonXld(out HObject contour, HTuple row, HTuple col)
        {
            IntPtr proc = HalconAPI.PreCall(72);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, col);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(col);
            int procResult = HObject.LoadNew(proc, 1, err, out contour);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a skeleton into XLD contours.</summary>
        /// <param name="skeleton">Skeleton of which the contours are to be determined.</param>
        /// <param name="contours">Resulting contours.</param>
        /// <param name="length">Minimum number of points a contour has to have. Default: 1</param>
        /// <param name="mode">Contour filter mode. Default: "filter"</param>
        public static void GenContoursSkeletonXld(
          HObject skeleton,
          out HObject contours,
          HTuple length,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(73);
            HalconAPI.Store(proc, 1, (HObjectBase)skeleton);
            HalconAPI.Store(proc, 0, length);
            HalconAPI.Store(proc, 1, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(length);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out contours);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)skeleton);
        }

        /// <summary>Display an XLD object.</summary>
        /// <param name="XLDObject">XLD object to display.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void DispXld(HObject XLDObject, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(74);
            HalconAPI.Store(proc, 1, (HObjectBase)XLDObject);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLDObject);
        }

        /// <summary>Image restoration by Wiener filtering.</summary>
        /// <param name="image">Corrupted image.</param>
        /// <param name="psf">impulse response (PSF) of degradation (in spatial domain).</param>
        /// <param name="noiseRegion">Region for noise estimation.</param>
        /// <param name="restoredImage">Restored image.</param>
        /// <param name="maskWidth">Width of filter mask. Default: 3</param>
        /// <param name="maskHeight">Height of filter mask. Default: 3</param>
        public static void WienerFilterNi(
          HObject image,
          HObject psf,
          HObject noiseRegion,
          out HObject restoredImage,
          HTuple maskWidth,
          HTuple maskHeight)
        {
            IntPtr proc = HalconAPI.PreCall(75);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)psf);
            HalconAPI.Store(proc, 3, (HObjectBase)noiseRegion);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            int procResult = HObject.LoadNew(proc, 1, err, out restoredImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)psf);
            GC.KeepAlive((object)noiseRegion);
        }

        /// <summary>Image restoration by Wiener filtering.</summary>
        /// <param name="image">Corrupted image.</param>
        /// <param name="psf">impulse response (PSF) of degradation (in spatial domain).</param>
        /// <param name="filteredImage">Smoothed version of corrupted image.</param>
        /// <param name="restoredImage">Restored image.</param>
        public static void WienerFilter(
          HObject image,
          HObject psf,
          HObject filteredImage,
          out HObject restoredImage)
        {
            IntPtr proc = HalconAPI.PreCall(76);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)psf);
            HalconAPI.Store(proc, 3, (HObjectBase)filteredImage);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out restoredImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)psf);
            GC.KeepAlive((object)filteredImage);
        }

        /// <summary>Generate an impulse response of a (linearly) motion blurring.</summary>
        /// <param name="psf">Impulse response of motion-blur.</param>
        /// <param name="PSFwidth">Width of impulse response image. Default: 256</param>
        /// <param name="PSFheight">Height of impulse response image. Default: 256</param>
        /// <param name="blurring">Degree of motion-blur. Default: 20.0</param>
        /// <param name="angle">Angle between direction of motion and x-axis (anticlockwise). Default: 0</param>
        /// <param name="type">PSF prototype resp. type of motion. Default: 3</param>
        public static void GenPsfMotion(
          out HObject psf,
          HTuple PSFwidth,
          HTuple PSFheight,
          HTuple blurring,
          HTuple angle,
          HTuple type)
        {
            IntPtr proc = HalconAPI.PreCall(77);
            HalconAPI.Store(proc, 0, PSFwidth);
            HalconAPI.Store(proc, 1, PSFheight);
            HalconAPI.Store(proc, 2, blurring);
            HalconAPI.Store(proc, 3, angle);
            HalconAPI.Store(proc, 4, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(PSFwidth);
            HalconAPI.UnpinTuple(PSFheight);
            HalconAPI.UnpinTuple(blurring);
            HalconAPI.UnpinTuple(angle);
            HalconAPI.UnpinTuple(type);
            int procResult = HObject.LoadNew(proc, 1, err, out psf);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Simulation of (linearly) motion blur.</summary>
        /// <param name="image">image to be blurred.</param>
        /// <param name="movedImage">motion blurred image.</param>
        /// <param name="blurring">extent of blurring. Default: 20.0</param>
        /// <param name="angle">Angle between direction of motion and x-axis (anticlockwise). Default: 0</param>
        /// <param name="type">impulse response of motion blur. Default: 3</param>
        public static void SimulateMotion(
          HObject image,
          out HObject movedImage,
          HTuple blurring,
          HTuple angle,
          HTuple type)
        {
            IntPtr proc = HalconAPI.PreCall(78);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, blurring);
            HalconAPI.Store(proc, 1, angle);
            HalconAPI.Store(proc, 2, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(blurring);
            HalconAPI.UnpinTuple(angle);
            HalconAPI.UnpinTuple(type);
            int procResult = HObject.LoadNew(proc, 1, err, out movedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Generate an impulse response of an uniform out-of-focus blurring.</summary>
        /// <param name="psf">Impulse response of uniform out-of-focus blurring.</param>
        /// <param name="PSFwidth">Width of result image. Default: 256</param>
        /// <param name="PSFheight">Height of result image. Default: 256</param>
        /// <param name="blurring">Degree of Blurring. Default: 5.0</param>
        public static void GenPsfDefocus(
          out HObject psf,
          HTuple PSFwidth,
          HTuple PSFheight,
          HTuple blurring)
        {
            IntPtr proc = HalconAPI.PreCall(79);
            HalconAPI.Store(proc, 0, PSFwidth);
            HalconAPI.Store(proc, 1, PSFheight);
            HalconAPI.Store(proc, 2, blurring);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(PSFwidth);
            HalconAPI.UnpinTuple(PSFheight);
            HalconAPI.UnpinTuple(blurring);
            int procResult = HObject.LoadNew(proc, 1, err, out psf);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Simulate an uniform out-of-focus blurring of an image.</summary>
        /// <param name="image">Image to blur.</param>
        /// <param name="defocusedImage">Blurred image.</param>
        /// <param name="blurring">Degree of blurring. Default: 5.0</param>
        public static void SimulateDefocus(HObject image, out HObject defocusedImage, HTuple blurring)
        {
            IntPtr proc = HalconAPI.PreCall(80);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, blurring);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(blurring);
            int procResult = HObject.LoadNew(proc, 1, err, out defocusedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Deserialize a variation model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="modelID">ID of the variation model.</param>
        public static void DeserializeVariationModel(HTuple serializedItemHandle, out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(81);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a variation model.</summary>
        /// <param name="modelID">ID of the variation model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeVariationModel(HTuple modelID, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(82);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a variation model from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="modelID">ID of the variation model.</param>
        public static void ReadVariationModel(HTuple fileName, out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(83);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a variation model to a file.</summary>
        /// <param name="modelID">ID of the variation model.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteVariationModel(HTuple modelID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(84);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the threshold images used for image comparison by a variation model.</summary>
        /// <param name="minImage">Threshold image for the lower threshold.</param>
        /// <param name="maxImage">Threshold image for the upper threshold.</param>
        /// <param name="modelID">ID of the variation model.</param>
        public static void GetThreshImagesVariationModel(
          out HObject minImage,
          out HObject maxImage,
          HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(85);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int err2 = HObject.LoadNew(proc, 1, err1, out minImage);
            int procResult = HObject.LoadNew(proc, 2, err2, out maxImage);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the images used for image comparison by a variation model.</summary>
        /// <param name="image">Image of the trained object.</param>
        /// <param name="varImage">Variation image of the trained object.</param>
        /// <param name="modelID">ID of the variation model.</param>
        public static void GetVariationModel(out HObject image, out HObject varImage, HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(86);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int err2 = HObject.LoadNew(proc, 1, err1, out image);
            int procResult = HObject.LoadNew(proc, 2, err2, out varImage);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compare an image to a variation model.</summary>
        /// <param name="image">Image of the object to be compared.</param>
        /// <param name="region">Region containing the points that differ substantially from the model.</param>
        /// <param name="modelID">ID of the variation model.</param>
        /// <param name="mode">Method used for comparing the variation model. Default: "absolute"</param>
        public static void CompareExtVariationModel(
          HObject image,
          out HObject region,
          HTuple modelID,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(87);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compare an image to a variation model.</summary>
        /// <param name="image">Image of the object to be compared.</param>
        /// <param name="region">Region containing the points that differ substantially from the model.</param>
        /// <param name="modelID">ID of the variation model.</param>
        public static void CompareVariationModel(HObject image, out HObject region, HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(88);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Prepare a variation model for comparison with an image.</summary>
        /// <param name="refImage">Reference image of the object.</param>
        /// <param name="varImage">Variation image of the object.</param>
        /// <param name="modelID">ID of the variation model.</param>
        /// <param name="absThreshold">Absolute minimum threshold for the differences between the image and the variation model. Default: 10</param>
        /// <param name="varThreshold">Threshold for the differences based on the variation of the variation model. Default: 2</param>
        public static void PrepareDirectVariationModel(
          HObject refImage,
          HObject varImage,
          HTuple modelID,
          HTuple absThreshold,
          HTuple varThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(89);
            HalconAPI.Store(proc, 1, (HObjectBase)refImage);
            HalconAPI.Store(proc, 2, (HObjectBase)varImage);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, absThreshold);
            HalconAPI.Store(proc, 2, varThreshold);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(absThreshold);
            HalconAPI.UnpinTuple(varThreshold);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)refImage);
            GC.KeepAlive((object)varImage);
        }

        /// <summary>Prepare a variation model for comparison with an image.</summary>
        /// <param name="modelID">ID of the variation model.</param>
        /// <param name="absThreshold">Absolute minimum threshold for the differences between the image and the variation model. Default: 10</param>
        /// <param name="varThreshold">Threshold for the differences based on the variation of the variation model. Default: 2</param>
        public static void PrepareVariationModel(
          HTuple modelID,
          HTuple absThreshold,
          HTuple varThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(90);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, absThreshold);
            HalconAPI.Store(proc, 2, varThreshold);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(absThreshold);
            HalconAPI.UnpinTuple(varThreshold);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train a variation model.</summary>
        /// <param name="images">Images of the object to be trained.</param>
        /// <param name="modelID">ID of the variation model.</param>
        public static void TrainVariationModel(HObject images, HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(91);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, modelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Free the memory of all variation models.</summary>
        public static void ClearAllVariationModels()
        {
            IntPtr proc = HalconAPI.PreCall(92);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a variation model.</summary>
        /// <param name="modelID">ID of the variation model.</param>
        public static void ClearVariationModel(HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(93);
            HalconAPI.Store(proc, 0, modelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of the training data of a variation model.</summary>
        /// <param name="modelID">ID of the variation model.</param>
        public static void ClearTrainDataVariationModel(HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(94);
            HalconAPI.Store(proc, 0, modelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a variation model for image comparison.</summary>
        /// <param name="width">Width of the images to be compared. Default: 640</param>
        /// <param name="height">Height of the images to be compared. Default: 480</param>
        /// <param name="type">Type of the images to be compared. Default: "byte"</param>
        /// <param name="mode">Method used for computing the variation model. Default: "standard"</param>
        /// <param name="modelID">ID of the variation model.</param>
        public static void CreateVariationModel(
          HTuple width,
          HTuple height,
          HTuple type,
          HTuple mode,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(95);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.Store(proc, 2, type);
            HalconAPI.Store(proc, 3, mode);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(mode);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the union set of two input tuples.</summary>
        /// <param name="set1">Input tuple.</param>
        /// <param name="set2">Input tuple.</param>
        /// <param name="union">The union set of two input tuples.</param>
        public static void TupleUnion(HTuple set1, HTuple set2, out HTuple union)
        {
            IntPtr proc = HalconAPI.PreCall(96);
            HalconAPI.Store(proc, 0, set1);
            HalconAPI.Store(proc, 1, set2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(set1);
            HalconAPI.UnpinTuple(set2);
            int procResult = HTuple.LoadNew(proc, 0, err, out union);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the intersection set of two input tuples.</summary>
        /// <param name="set1">Input tuple.</param>
        /// <param name="set2">Input tuple.</param>
        /// <param name="intersection">The intersection set of two input tuples.</param>
        public static void TupleIntersection(HTuple set1, HTuple set2, out HTuple intersection)
        {
            IntPtr proc = HalconAPI.PreCall(97);
            HalconAPI.Store(proc, 0, set1);
            HalconAPI.Store(proc, 1, set2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(set1);
            HalconAPI.UnpinTuple(set2);
            int procResult = HTuple.LoadNew(proc, 0, err, out intersection);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the difference set of two input tuples.</summary>
        /// <param name="set1">Input tuple.</param>
        /// <param name="set2">Input tuple.</param>
        /// <param name="difference">The difference set of two input tuples.</param>
        public static void TupleDifference(HTuple set1, HTuple set2, out HTuple difference)
        {
            IntPtr proc = HalconAPI.PreCall(98);
            HalconAPI.Store(proc, 0, set1);
            HalconAPI.Store(proc, 1, set2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(set1);
            HalconAPI.UnpinTuple(set2);
            int procResult = HTuple.LoadNew(proc, 0, err, out difference);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the symmetric difference set of two input tuples.</summary>
        /// <param name="set1">Input tuple.</param>
        /// <param name="set2">Input tuple.</param>
        /// <param name="symmDiff">The symmetric difference set of two input tuples.</param>
        public static void TupleSymmdiff(HTuple set1, HTuple set2, out HTuple symmDiff)
        {
            IntPtr proc = HalconAPI.PreCall(99);
            HalconAPI.Store(proc, 0, set1);
            HalconAPI.Store(proc, 1, set2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(set1);
            HalconAPI.UnpinTuple(set2);
            int procResult = HTuple.LoadNew(proc, 0, err, out symmDiff);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test whether the types of the elements of a tuple are of type string.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="isString">Are the elements of the input tuple of type string?</param>
        public static void TupleIsStringElem(HTuple t, out HTuple isString)
        {
            IntPtr proc = HalconAPI.PreCall(100);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isString);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test whether the types of the elements of a tuple are of type real.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="isReal">Are the elements of the input tuple of type real?</param>
        public static void TupleIsRealElem(HTuple t, out HTuple isReal)
        {
            IntPtr proc = HalconAPI.PreCall(101);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isReal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test whether the types of the elements of a tuple are of type integer.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="isInt">Are the elements of the input tuple of type integer?</param>
        public static void TupleIsIntElem(HTuple t, out HTuple isInt)
        {
            IntPtr proc = HalconAPI.PreCall(102);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isInt);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the types of the elements of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="types">Types of the elements of the input tuple as integer values.</param>
        public static void TupleTypeElem(HTuple t, out HTuple types)
        {
            IntPtr proc = HalconAPI.PreCall(103);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out types);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test whether a tuple is of type mixed.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="isMixed">Is the input tuple of type mixed?</param>
        public static void TupleIsMixed(HTuple t, out HTuple isMixed)
        {
            IntPtr proc = HalconAPI.PreCall(104);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isMixed);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test if the internal representation of a tuple is of type string.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="isString">Is the input tuple of type string?</param>
        public static void TupleIsString(HTuple t, out HTuple isString)
        {
            IntPtr proc = HalconAPI.PreCall(105);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isString);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test if the internal representation of a tuple is of type real.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="isReal">Is the input tuple of type real?</param>
        public static void TupleIsReal(HTuple t, out HTuple isReal)
        {
            IntPtr proc = HalconAPI.PreCall(106);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isReal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test if the internal representation of a tuple is of type integer.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="isInt">Is the input tuple of type integer?</param>
        public static void TupleIsInt(HTuple t, out HTuple isInt)
        {
            IntPtr proc = HalconAPI.PreCall(107);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isInt);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the type of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="type">Type of the input tuple as an integer number.</param>
        public static void TupleType(HTuple t, out HTuple type)
        {
            IntPtr proc = HalconAPI.PreCall(108);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out type);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the value distribution of a tuple within a certain value range.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="min">Minimum value.</param>
        /// <param name="max">Maximum value.</param>
        /// <param name="numBins">Number of bins.</param>
        /// <param name="histo">Histogram to be calculated.</param>
        /// <param name="binSize">Bin size.</param>
        public static void TupleHistoRange(
          HTuple tuple,
          HTuple min,
          HTuple max,
          HTuple numBins,
          out HTuple histo,
          out HTuple binSize)
        {
            IntPtr proc = HalconAPI.PreCall(109);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, min);
            HalconAPI.Store(proc, 2, max);
            HalconAPI.Store(proc, 3, numBins);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(min);
            HalconAPI.UnpinTuple(max);
            HalconAPI.UnpinTuple(numBins);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out histo);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out binSize);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select tuple elements matching a regular expression.</summary>
        /// <param name="data">Input strings to match.</param>
        /// <param name="expression">Regular expression. Default: ".*"</param>
        /// <param name="selection">Matching strings</param>
        public static void TupleRegexpSelect(HTuple data, HTuple expression, out HTuple selection)
        {
            IntPtr proc = HalconAPI.PreCall(110);
            HalconAPI.Store(proc, 0, data);
            HalconAPI.Store(proc, 1, expression);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(data);
            HalconAPI.UnpinTuple(expression);
            int procResult = HTuple.LoadNew(proc, 0, err, out selection);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test if a string matches a regular expression.</summary>
        /// <param name="data">Input strings to match.</param>
        /// <param name="expression">Regular expression. Default: ".*"</param>
        /// <param name="numMatches">Number of matching strings</param>
        public static void TupleRegexpTest(HTuple data, HTuple expression, out HTuple numMatches)
        {
            IntPtr proc = HalconAPI.PreCall(111);
            HalconAPI.Store(proc, 0, data);
            HalconAPI.Store(proc, 1, expression);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(data);
            HalconAPI.UnpinTuple(expression);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out numMatches);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Replace a substring using regular expressions.</summary>
        /// <param name="data">Input strings to process.</param>
        /// <param name="expression">Regular expression. Default: ".*"</param>
        /// <param name="replace">Replacement expression.</param>
        /// <param name="result">Processed strings.</param>
        public static void TupleRegexpReplace(
          HTuple data,
          HTuple expression,
          HTuple replace,
          out HTuple result)
        {
            IntPtr proc = HalconAPI.PreCall(112);
            HalconAPI.Store(proc, 0, data);
            HalconAPI.Store(proc, 1, expression);
            HalconAPI.Store(proc, 2, replace);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(data);
            HalconAPI.UnpinTuple(expression);
            HalconAPI.UnpinTuple(replace);
            int procResult = HTuple.LoadNew(proc, 0, err, out result);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Extract substrings using regular expressions.</summary>
        /// <param name="data">Input strings to match.</param>
        /// <param name="expression">Regular expression. Default: ".*"</param>
        /// <param name="matches">Found matches.</param>
        public static void TupleRegexpMatch(HTuple data, HTuple expression, out HTuple matches)
        {
            IntPtr proc = HalconAPI.PreCall(113);
            HalconAPI.Store(proc, 0, data);
            HalconAPI.Store(proc, 1, expression);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(data);
            HalconAPI.UnpinTuple(expression);
            int procResult = HTuple.LoadNew(proc, 0, err, out matches);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return a tuple of random numbers between 0 and 1.</summary>
        /// <param name="length">Length of tuple to generate.</param>
        /// <param name="rand">Tuple of random numbers.</param>
        public static void TupleRand(HTuple length, out HTuple rand)
        {
            IntPtr proc = HalconAPI.PreCall(114);
            HalconAPI.Store(proc, 0, length);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(length);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out rand);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the number of elements of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="length">Number of elements of input tuple.</param>
        public static void TupleLength(HTuple tuple, out HTuple length)
        {
            IntPtr proc = HalconAPI.PreCall(115);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out length);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the sign of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="sgn">Signs of the input tuple as integer numbers.</param>
        public static void TupleSgn(HTuple t, out HTuple sgn)
        {
            IntPtr proc = HalconAPI.PreCall(116);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out sgn);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the elementwise maximum of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="max2">Elementwise maximum of the input tuples.</param>
        public static void TupleMax2(HTuple t1, HTuple t2, out HTuple max2)
        {
            IntPtr proc = HalconAPI.PreCall(117);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, err, out max2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the elementwise minimum of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="min2">Elementwise minimum of the input tuples.</param>
        public static void TupleMin2(HTuple t1, HTuple t2, out HTuple min2)
        {
            IntPtr proc = HalconAPI.PreCall(118);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, err, out min2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the maximal element of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="max">Maximal element of the input tuple elements.</param>
        public static void TupleMax(HTuple tuple, out HTuple max)
        {
            IntPtr proc = HalconAPI.PreCall(119);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, err, out max);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the minimal element of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="min">Minimal element of the input tuple elements.</param>
        public static void TupleMin(HTuple tuple, out HTuple min)
        {
            IntPtr proc = HalconAPI.PreCall(120);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, err, out min);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the cumulative sums of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="cumul">Cumulative sum of the corresponding tuple elements.</param>
        public static void TupleCumul(HTuple tuple, out HTuple cumul)
        {
            IntPtr proc = HalconAPI.PreCall(121);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, err, out cumul);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select the element of rank n of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="rankIndex">Rank of the element to select.</param>
        /// <param name="selected">Selected tuple element.</param>
        public static void TupleSelectRank(HTuple tuple, HTuple rankIndex, out HTuple selected)
        {
            IntPtr proc = HalconAPI.PreCall(122);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, rankIndex);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(rankIndex);
            int procResult = HTuple.LoadNew(proc, 0, err, out selected);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the median of the elements of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="median">Median of the tuple elements.</param>
        public static void TupleMedian(HTuple tuple, out HTuple median)
        {
            IntPtr proc = HalconAPI.PreCall(123);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, err, out median);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the sum of all elements of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="sum">Sum of tuple elements.</param>
        public static void TupleSum(HTuple tuple, out HTuple sum)
        {
            IntPtr proc = HalconAPI.PreCall(124);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, err, out sum);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the mean value of a tuple of numbers.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="mean">Mean value of tuple elements.</param>
        public static void TupleMean(HTuple tuple, out HTuple mean)
        {
            IntPtr proc = HalconAPI.PreCall(125);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out mean);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the standard deviation of the elements of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="deviation">Standard deviation of tuple elements.</param>
        public static void TupleDeviation(HTuple tuple, out HTuple deviation)
        {
            IntPtr proc = HalconAPI.PreCall(126);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out deviation);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Discard all but one of successive identical elements of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="uniq">Tuple without successive identical elements.</param>
        public static void TupleUniq(HTuple tuple, out HTuple uniq)
        {
            IntPtr proc = HalconAPI.PreCall((int)sbyte.MaxValue);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, err, out uniq);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the index of the last occurrence of a tuple within another tuple.</summary>
        /// <param name="tuple">Input tuple to examine.</param>
        /// <param name="toFind">Input tuple with values to find.</param>
        /// <param name="index">Index of the last occurrence of the values to find.</param>
        public static void TupleFindLast(HTuple tuple, HTuple toFind, out HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(128);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, toFind);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(toFind);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the index of the first occurrence of a tuple within another tuple.</summary>
        /// <param name="tuple">Input tuple to examine.</param>
        /// <param name="toFind">Input tuple with values to find.</param>
        /// <param name="index">Index of the first occurrence of the values to find.</param>
        public static void TupleFindFirst(HTuple tuple, HTuple toFind, out HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(129);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, toFind);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(toFind);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the indices of all occurrences of a tuple within another tuple.</summary>
        /// <param name="tuple">Input tuple to examine.</param>
        /// <param name="toFind">Input tuple with values to find.</param>
        /// <param name="indices">Indices of the occurrences of the values to find in the  tuple to examine.</param>
        public static void TupleFind(HTuple tuple, HTuple toFind, out HTuple indices)
        {
            IntPtr proc = HalconAPI.PreCall(130);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, toFind);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(toFind);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out indices);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Sort the elements of a tuple and return the indices of the sorted tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="indices">Sorted tuple.</param>
        public static void TupleSortIndex(HTuple tuple, out HTuple indices)
        {
            IntPtr proc = HalconAPI.PreCall(131);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out indices);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Sort the elements of a tuple in ascending order.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="sorted">Sorted tuple.</param>
        public static void TupleSort(HTuple tuple, out HTuple sorted)
        {
            IntPtr proc = HalconAPI.PreCall(132);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, err, out sorted);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Invert a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="inverted">Inverted input tuple.</param>
        public static void TupleInverse(HTuple tuple, out HTuple inverted)
        {
            IntPtr proc = HalconAPI.PreCall(133);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, err, out inverted);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Concatenate two tuples to a new one.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="concat">Concatenation of input tuples.</param>
        public static void TupleConcat(HTuple t1, HTuple t2, out HTuple concat)
        {
            IntPtr proc = HalconAPI.PreCall(134);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, err, out concat);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select several elements of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="leftindex">Index of first element to select.</param>
        /// <param name="rightindex">Index of last element to select.</param>
        /// <param name="selected">Selected tuple elements.</param>
        public static void TupleSelectRange(
          HTuple tuple,
          HTuple leftindex,
          HTuple rightindex,
          out HTuple selected)
        {
            IntPtr proc = HalconAPI.PreCall(135);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, leftindex);
            HalconAPI.Store(proc, 2, rightindex);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(leftindex);
            HalconAPI.UnpinTuple(rightindex);
            int procResult = HTuple.LoadNew(proc, 0, err, out selected);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select all elements from index "n" to the end of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="index">Index of the first element to select.</param>
        /// <param name="selected">Selected tuple elements.</param>
        public static void TupleLastN(HTuple tuple, HTuple index, out HTuple selected)
        {
            IntPtr proc = HalconAPI.PreCall(136);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(index);
            int procResult = HTuple.LoadNew(proc, 0, err, out selected);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select the first elements of a tuple up to the index "n".</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="index">Index of the last element to select.</param>
        /// <param name="selected">Selected tuple elements.</param>
        public static void TupleFirstN(HTuple tuple, HTuple index, out HTuple selected)
        {
            IntPtr proc = HalconAPI.PreCall(137);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(index);
            int procResult = HTuple.LoadNew(proc, 0, err, out selected);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Inserts one or more elements into a tuple at index.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="index">Start index of elements to be inserted.</param>
        /// <param name="insertTuple">Element(s) to insert at index.</param>
        /// <param name="extended">Tuple with inserted elements.</param>
        public static void TupleInsert(
          HTuple tuple,
          HTuple index,
          HTuple insertTuple,
          out HTuple extended)
        {
            IntPtr proc = HalconAPI.PreCall(138);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, insertTuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(insertTuple);
            int procResult = HTuple.LoadNew(proc, 0, err, out extended);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Replaces one or more elements of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="index">Index/Indices of elements to be replaced.</param>
        /// <param name="replaceTuple">Element(s) to replace.</param>
        /// <param name="replaced">Tuple with replaced elements.</param>
        public static void TupleReplace(
          HTuple tuple,
          HTuple index,
          HTuple replaceTuple,
          out HTuple replaced)
        {
            IntPtr proc = HalconAPI.PreCall(139);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, replaceTuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(replaceTuple);
            int procResult = HTuple.LoadNew(proc, 0, err, out replaced);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Remove elements from a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="index">Indices of the elements to remove.</param>
        /// <param name="reduced">Reduced tuple.</param>
        public static void TupleRemove(HTuple tuple, HTuple index, out HTuple reduced)
        {
            IntPtr proc = HalconAPI.PreCall(140);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(index);
            int procResult = HTuple.LoadNew(proc, 0, err, out reduced);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select in mask specified elements of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="mask"> greater than  0 specifies the elements to select.</param>
        /// <param name="selected">Selected tuple elements.</param>
        public static void TupleSelectMask(HTuple tuple, HTuple mask, out HTuple selected)
        {
            IntPtr proc = HalconAPI.PreCall(141);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, mask);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(mask);
            int procResult = HTuple.LoadNew(proc, 0, err, out selected);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select single elements of a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="index">Indices of the elements to select.</param>
        /// <param name="selected">Selected tuple element.</param>
        public static void TupleSelect(HTuple tuple, HTuple index, out HTuple selected)
        {
            IntPtr proc = HalconAPI.PreCall(142);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(index);
            int procResult = HTuple.LoadNew(proc, 0, err, out selected);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select single character or bit from a tuple.</summary>
        /// <param name="tuple">Input tuple.</param>
        /// <param name="index">Position of character or bit to select.</param>
        /// <param name="selected">Tuple containing the selected characters and bits.</param>
        public static void TupleStrBitSelect(HTuple tuple, HTuple index, out HTuple selected)
        {
            IntPtr proc = HalconAPI.PreCall(143);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(index);
            int procResult = HTuple.LoadNew(proc, 0, err, out selected);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate a tuple with a sequence of equidistant values.</summary>
        /// <param name="start">Start value of the tuple.</param>
        /// <param name="end">Maximum value for the last entry.</param>
        /// <param name="step">Increment value.</param>
        /// <param name="sequence">The resulting sequence.</param>
        public static void TupleGenSequence(
          HTuple start,
          HTuple end,
          HTuple step,
          out HTuple sequence)
        {
            IntPtr proc = HalconAPI.PreCall(144);
            HalconAPI.Store(proc, 0, start);
            HalconAPI.Store(proc, 1, end);
            HalconAPI.Store(proc, 2, step);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(start);
            HalconAPI.UnpinTuple(end);
            HalconAPI.UnpinTuple(step);
            int procResult = HTuple.LoadNew(proc, 0, err, out sequence);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate a tuple of a specific length and initialize its elements.</summary>
        /// <param name="length">Length of tuple to generate.</param>
        /// <param name="constVal">Constant for initializing the tuple elements.</param>
        /// <param name="newtuple">New Tuple.</param>
        public static void TupleGenConst(HTuple length, HTuple constVal, out HTuple newtuple)
        {
            IntPtr proc = HalconAPI.PreCall(145);
            HalconAPI.Store(proc, 0, length);
            HalconAPI.Store(proc, 1, constVal);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(length);
            HalconAPI.UnpinTuple(constVal);
            int procResult = HTuple.LoadNew(proc, 0, err, out newtuple);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read one or more environment variables.</summary>
        /// <param name="names">Tuple containing name(s) of the environment variable(s).</param>
        /// <param name="values">Content of the environment variable(s).</param>
        public static void TupleEnvironment(HTuple names, out HTuple values)
        {
            IntPtr proc = HalconAPI.PreCall(146);
            HalconAPI.Store(proc, 0, names);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(names);
            int procResult = HTuple.LoadNew(proc, 0, err, out values);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Split strings into substrings using predefined separator symbol(s).</summary>
        /// <param name="stringVal">Input tuple with string(s) to split.</param>
        /// <param name="separator">Input tuple with separator symbol(s).</param>
        /// <param name="substrings">Substrings after splitting the input strings.</param>
        public static void TupleSplit(HTuple stringVal, HTuple separator, out HTuple substrings)
        {
            IntPtr proc = HalconAPI.PreCall(147);
            HalconAPI.Store(proc, 0, stringVal);
            HalconAPI.Store(proc, 1, separator);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stringVal);
            HalconAPI.UnpinTuple(separator);
            int procResult = HTuple.LoadNew(proc, 0, err, out substrings);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Cut characters from position "n1" through "n2" out of a string tuple.</summary>
        /// <param name="stringVal">Input tuple with string(s) to examine.</param>
        /// <param name="position1">Input tuple with start position(s) "n1".</param>
        /// <param name="position2">Input tuple with end position(s) "n2".</param>
        /// <param name="substring">Characters of the string(s) from position "n1" to "n2".</param>
        public static void TupleSubstr(
          HTuple stringVal,
          HTuple position1,
          HTuple position2,
          out HTuple substring)
        {
            IntPtr proc = HalconAPI.PreCall(148);
            HalconAPI.Store(proc, 0, stringVal);
            HalconAPI.Store(proc, 1, position1);
            HalconAPI.Store(proc, 2, position2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stringVal);
            HalconAPI.UnpinTuple(position1);
            HalconAPI.UnpinTuple(position2);
            int procResult = HTuple.LoadNew(proc, 0, err, out substring);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Cut all characters starting at position "n" out of a string tuple.</summary>
        /// <param name="stringVal">Input tuple with string(s) to examine.</param>
        /// <param name="position">Input tuple with position(s) "n".</param>
        /// <param name="substring">The last characters of the string(s) starting at position "n".</param>
        public static void TupleStrLastN(HTuple stringVal, HTuple position, out HTuple substring)
        {
            IntPtr proc = HalconAPI.PreCall(149);
            HalconAPI.Store(proc, 0, stringVal);
            HalconAPI.Store(proc, 1, position);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stringVal);
            HalconAPI.UnpinTuple(position);
            int procResult = HTuple.LoadNew(proc, 0, err, out substring);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Cut the first characters up to position "n" out of a string tuple.</summary>
        /// <param name="stringVal">Input tuple with string(s) to examine.</param>
        /// <param name="position">Input tuple with position(s) "n".</param>
        /// <param name="substring">The first characters of the string(s) up to position "n".</param>
        public static void TupleStrFirstN(HTuple stringVal, HTuple position, out HTuple substring)
        {
            IntPtr proc = HalconAPI.PreCall(150);
            HalconAPI.Store(proc, 0, stringVal);
            HalconAPI.Store(proc, 1, position);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stringVal);
            HalconAPI.UnpinTuple(position);
            int procResult = HTuple.LoadNew(proc, 0, err, out substring);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Backward search for characters within a string tuple.</summary>
        /// <param name="stringVal">Input tuple with string(s) to examine.</param>
        /// <param name="toFind">Input tuple with character(s) to search.</param>
        /// <param name="position">Position of searched character(s) within the string(s).</param>
        public static void TupleStrrchr(HTuple stringVal, HTuple toFind, out HTuple position)
        {
            IntPtr proc = HalconAPI.PreCall(151);
            HalconAPI.Store(proc, 0, stringVal);
            HalconAPI.Store(proc, 1, toFind);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stringVal);
            HalconAPI.UnpinTuple(toFind);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out position);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Forward search for characters within a string tuple.</summary>
        /// <param name="stringVal">Input tuple with string(s) to examine.</param>
        /// <param name="toFind">Input tuple with character(s) to search.</param>
        /// <param name="position">Position of searched character(s) within the string(s).</param>
        public static void TupleStrchr(HTuple stringVal, HTuple toFind, out HTuple position)
        {
            IntPtr proc = HalconAPI.PreCall(152);
            HalconAPI.Store(proc, 0, stringVal);
            HalconAPI.Store(proc, 1, toFind);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stringVal);
            HalconAPI.UnpinTuple(toFind);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out position);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Backward search for strings within a string tuple.</summary>
        /// <param name="stringVal">Input tuple with string(s) to examine.</param>
        /// <param name="toFind">Input tuple with string(s) to search.</param>
        /// <param name="position">Position of searched string(s) within the examined string(s).</param>
        public static void TupleStrrstr(HTuple stringVal, HTuple toFind, out HTuple position)
        {
            IntPtr proc = HalconAPI.PreCall(153);
            HalconAPI.Store(proc, 0, stringVal);
            HalconAPI.Store(proc, 1, toFind);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stringVal);
            HalconAPI.UnpinTuple(toFind);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out position);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Forward search for strings within a string tuple.</summary>
        /// <param name="stringVal">Input tuple with string(s) to examine.</param>
        /// <param name="toFind">Input tuple with string(s) to search.</param>
        /// <param name="position">Position of searched string(s) within the examined string(s).</param>
        public static void TupleStrstr(HTuple stringVal, HTuple toFind, out HTuple position)
        {
            IntPtr proc = HalconAPI.PreCall(154);
            HalconAPI.Store(proc, 0, stringVal);
            HalconAPI.Store(proc, 1, toFind);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stringVal);
            HalconAPI.UnpinTuple(toFind);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out position);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Determine the length of every string within a tuple of strings.</summary>
        /// <param name="t1">Input tuple.</param>
        /// <param name="length">Lengths of the single strings of the input tuple.</param>
        public static void TupleStrlen(HTuple t1, out HTuple length)
        {
            IntPtr proc = HalconAPI.PreCall(155);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out length);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test, whether a tuple is elementwise less or equal to another tuple.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="lesseq">Result of the comparison of the input tuples.</param>
        public static void TupleLessEqualElem(HTuple t1, HTuple t2, out HTuple lesseq)
        {
            IntPtr proc = HalconAPI.PreCall(156);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out lesseq);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test, whether a tuple is elementwise less than another tuple.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="less">Result of the comparison of the input tuples.</param>
        public static void TupleLessElem(HTuple t1, HTuple t2, out HTuple less)
        {
            IntPtr proc = HalconAPI.PreCall(157);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out less);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test, whether a tuple is elementwise greater or equal to another tuple.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="greatereq">Result of the comparison of the input tuples.</param>
        public static void TupleGreaterEqualElem(HTuple t1, HTuple t2, out HTuple greatereq)
        {
            IntPtr proc = HalconAPI.PreCall(158);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out greatereq);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test, whether a tuple is elementwise greater than another tuple.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="greater">Result of the comparison of the input tuples.</param>
        public static void TupleGreaterElem(HTuple t1, HTuple t2, out HTuple greater)
        {
            IntPtr proc = HalconAPI.PreCall(159);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out greater);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test, whether two tuples are elementwise not equal.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="nequal">Result of the comparison of the input tuples.</param>
        public static void TupleNotEqualElem(HTuple t1, HTuple t2, out HTuple nequal)
        {
            IntPtr proc = HalconAPI.PreCall(160);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out nequal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test, whether two tuples are elementwise equal.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="equal">Result of the comparison of the input tuples.</param>
        public static void TupleEqualElem(HTuple t1, HTuple t2, out HTuple equal)
        {
            IntPtr proc = HalconAPI.PreCall(161);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out equal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test whether a tuple is less or equal to another tuple.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="lesseq">Result of the comparison of the input tuples.</param>
        public static void TupleLessEqual(HTuple t1, HTuple t2, out HTuple lesseq)
        {
            IntPtr proc = HalconAPI.PreCall(162);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out lesseq);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test whether a tuple is less than another tuple.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="less">Result of the comparison of the input tuples.</param>
        public static void TupleLess(HTuple t1, HTuple t2, out HTuple less)
        {
            IntPtr proc = HalconAPI.PreCall(163);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out less);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test whether a tuple is greater or equal to another tuple.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="greatereq">Result of the comparison of the input tuples.</param>
        public static void TupleGreaterEqual(HTuple t1, HTuple t2, out HTuple greatereq)
        {
            IntPtr proc = HalconAPI.PreCall(164);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out greatereq);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test whether a tuple is greater than another tuple.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="greater">Result of the comparison of the input tuples.</param>
        public static void TupleGreater(HTuple t1, HTuple t2, out HTuple greater)
        {
            IntPtr proc = HalconAPI.PreCall(165);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out greater);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test whether two tuples are not equal.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="nequal">Result of the comparison of the input tuples.</param>
        public static void TupleNotEqual(HTuple t1, HTuple t2, out HTuple nequal)
        {
            IntPtr proc = HalconAPI.PreCall(166);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out nequal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test whether two tuples are equal.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="equal">Result of the comparison of the input tuples.</param>
        public static void TupleEqual(HTuple t1, HTuple t2, out HTuple equal)
        {
            IntPtr proc = HalconAPI.PreCall(167);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out equal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the logical not of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="not">Binary not of the input tuple.</param>
        public static void TupleNot(HTuple t, out HTuple not)
        {
            IntPtr proc = HalconAPI.PreCall(168);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out not);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the logical exclusive or of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="xor">Binary exclusive or of the input tuples.</param>
        public static void TupleXor(HTuple t1, HTuple t2, out HTuple xor)
        {
            IntPtr proc = HalconAPI.PreCall(169);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out xor);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the logical or of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="or">Logical or of the input tuples.</param>
        public static void TupleOr(HTuple t1, HTuple t2, out HTuple or)
        {
            IntPtr proc = HalconAPI.PreCall(170);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out or);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the logical and of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="and">Logical and of the input tuples.</param>
        public static void TupleAnd(HTuple t1, HTuple t2, out HTuple and)
        {
            IntPtr proc = HalconAPI.PreCall(171);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out and);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the bitwise not of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="BNot">Binary not of the input tuple.</param>
        public static void TupleBnot(HTuple t, out HTuple BNot)
        {
            IntPtr proc = HalconAPI.PreCall(172);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out BNot);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the bitwise exclusive or of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="BXor">Binary exclusive or of the input tuples.</param>
        public static void TupleBxor(HTuple t1, HTuple t2, out HTuple BXor)
        {
            IntPtr proc = HalconAPI.PreCall(173);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out BXor);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the bitwise or of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="BOr">Binary or of the input tuples.</param>
        public static void TupleBor(HTuple t1, HTuple t2, out HTuple BOr)
        {
            IntPtr proc = HalconAPI.PreCall(174);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out BOr);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the bitwise and of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="BAnd">Binary and of the input tuples.</param>
        public static void TupleBand(HTuple t1, HTuple t2, out HTuple BAnd)
        {
            IntPtr proc = HalconAPI.PreCall(175);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out BAnd);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Shift a tuple bitwise to the right.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="shift">Number of places to shift the input tuple.</param>
        /// <param name="rsh">Shifted input tuple.</param>
        public static void TupleRsh(HTuple t, HTuple shift, out HTuple rsh)
        {
            IntPtr proc = HalconAPI.PreCall(176);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.Store(proc, 1, shift);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            HalconAPI.UnpinTuple(shift);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out rsh);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Shift a tuple bitwise to the left.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="shift">Number of places to shift the input tuple.</param>
        /// <param name="lsh">Shifted input tuple.</param>
        public static void TupleLsh(HTuple t, HTuple shift, out HTuple lsh)
        {
            IntPtr proc = HalconAPI.PreCall(177);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.Store(proc, 1, shift);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            HalconAPI.UnpinTuple(shift);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out lsh);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a tuple of integer numbers into strings.</summary>
        /// <param name="t">Input tuple with integer numbers.</param>
        /// <param name="chrt">Output tuple with strings that are separated by the integer number 0.</param>
        public static void TupleChrt(HTuple t, out HTuple chrt)
        {
            IntPtr proc = HalconAPI.PreCall(178);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, err, out chrt);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a tuple of strings into a tuple of integer numbers.</summary>
        /// <param name="t">Input tuple with strings.</param>
        /// <param name="ords">Output tuple with integer numbers.</param>
        public static void TupleOrds(HTuple t, out HTuple ords)
        {
            IntPtr proc = HalconAPI.PreCall(179);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out ords);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a tuple of integer numbers into strings.</summary>
        /// <param name="t">Input tuple with integer numbers.</param>
        /// <param name="chr">Output tuple with strings.</param>
        public static void TupleChr(HTuple t, out HTuple chr)
        {
            IntPtr proc = HalconAPI.PreCall(180);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, err, out chr);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a tuple of strings of length 1 into a tuple of integer numbers.</summary>
        /// <param name="t">Input tuple with strings of length 1.</param>
        /// <param name="ord">Output tuple with integer numbers.</param>
        public static void TupleOrd(HTuple t, out HTuple ord)
        {
            IntPtr proc = HalconAPI.PreCall(181);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out ord);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a tuple into a tuple of strings.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="format">Format string.</param>
        /// <param name="stringVal">Input tuple converted to strings.</param>
        public static void TupleString(HTuple t, HTuple format, out HTuple stringVal)
        {
            IntPtr proc = HalconAPI.PreCall(182);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.Store(proc, 1, format);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            HalconAPI.UnpinTuple(format);
            int procResult = HTuple.LoadNew(proc, 0, err, out stringVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Check a tuple (of strings) whether it represents numbers.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="isNumber">Tuple with boolean numbers.</param>
        public static void TupleIsNumber(HTuple t, out HTuple isNumber)
        {
            IntPtr proc = HalconAPI.PreCall(183);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isNumber);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a tuple (of strings) into a tuple of numbers.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="number">Input tuple as numbers.</param>
        public static void TupleNumber(HTuple t, out HTuple number)
        {
            IntPtr proc = HalconAPI.PreCall(184);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, err, out number);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a tuple into a tuple of integer numbers.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="round">Result of the rounding.</param>
        public static void TupleRound(HTuple t, out HTuple round)
        {
            IntPtr proc = HalconAPI.PreCall(185);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out round);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a tuple into a tuple of integer numbers.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="intVal">Result of the conversion into integer numbers.</param>
        public static void TupleInt(HTuple t, out HTuple intVal)
        {
            IntPtr proc = HalconAPI.PreCall(186);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out intVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a tuple into a tuple of floating point numbers.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="real">Input tuple as floating point numbers.</param>
        public static void TupleReal(HTuple t, out HTuple real)
        {
            IntPtr proc = HalconAPI.PreCall(187);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out real);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the ldexp function of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="ldexp">Ldexp function of the input tuples.</param>
        public static void TupleLdexp(HTuple t1, HTuple t2, out HTuple ldexp)
        {
            IntPtr proc = HalconAPI.PreCall(188);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out ldexp);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the remainder of the floating point division of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="fmod">Remainder of the division of the input tuples.</param>
        public static void TupleFmod(HTuple t1, HTuple t2, out HTuple fmod)
        {
            IntPtr proc = HalconAPI.PreCall(189);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out fmod);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the remainder of the integer division of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="mod">Remainder of the division of the input tuples.</param>
        public static void TupleMod(HTuple t1, HTuple t2, out HTuple mod)
        {
            IntPtr proc = HalconAPI.PreCall(190);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out mod);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the ceiling function of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="ceil">Ceiling function of the input tuple.</param>
        public static void TupleCeil(HTuple t, out HTuple ceil)
        {
            IntPtr proc = HalconAPI.PreCall(191);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out ceil);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the floor function of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="floor">Floor function of the input tuple.</param>
        public static void TupleFloor(HTuple t, out HTuple floor)
        {
            IntPtr proc = HalconAPI.PreCall(192);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out floor);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the power function of two tuples.</summary>
        /// <param name="t1">Input tuple 1.</param>
        /// <param name="t2">Input tuple 2.</param>
        /// <param name="pow">Power function of the input tuples.</param>
        public static void TuplePow(HTuple t1, HTuple t2, out HTuple pow)
        {
            IntPtr proc = HalconAPI.PreCall(193);
            HalconAPI.Store(proc, 0, t1);
            HalconAPI.Store(proc, 1, t2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t1);
            HalconAPI.UnpinTuple(t2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out pow);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the base 10 logarithm of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="log">Base 10 logarithm of the input tuple.</param>
        public static void TupleLog10(HTuple t, out HTuple log)
        {
            IntPtr proc = HalconAPI.PreCall(194);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out log);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the natural logarithm of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="log">Natural logarithm of the input tuple.</param>
        public static void TupleLog(HTuple t, out HTuple log)
        {
            IntPtr proc = HalconAPI.PreCall(195);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out log);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the exponential of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="exp">Exponential of the input tuple.</param>
        public static void TupleExp(HTuple t, out HTuple exp)
        {
            IntPtr proc = HalconAPI.PreCall(196);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out exp);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the hyperbolic tangent of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="tanh">Hyperbolic tangent of the input tuple.</param>
        public static void TupleTanh(HTuple t, out HTuple tanh)
        {
            IntPtr proc = HalconAPI.PreCall(197);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tanh);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the hyperbolic cosine of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="cosh">Hyperbolic cosine of the input tuple.</param>
        public static void TupleCosh(HTuple t, out HTuple cosh)
        {
            IntPtr proc = HalconAPI.PreCall(198);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out cosh);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the hyperbolic sine of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="sinh">Hyperbolic sine of the input tuple.</param>
        public static void TupleSinh(HTuple t, out HTuple sinh)
        {
            IntPtr proc = HalconAPI.PreCall(199);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out sinh);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a tuple from degrees to radians.</summary>
        /// <param name="deg">Input tuple.</param>
        /// <param name="rad">Input tuple in radians.</param>
        public static void TupleRad(HTuple deg, out HTuple rad)
        {
            IntPtr proc = HalconAPI.PreCall(200);
            HalconAPI.Store(proc, 0, deg);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deg);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out rad);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a tuple from radians to degrees.</summary>
        /// <param name="rad">Input tuple.</param>
        /// <param name="deg">Input tuple in degrees.</param>
        public static void TupleDeg(HTuple rad, out HTuple deg)
        {
            IntPtr proc = HalconAPI.PreCall(201);
            HalconAPI.Store(proc, 0, rad);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rad);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out deg);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the arctangent of a tuple for all four quadrants.</summary>
        /// <param name="y">Input tuple of the y-values.</param>
        /// <param name="x">Input tuple of the x-values.</param>
        /// <param name="ATan">Arctangent of the input tuple.</param>
        public static void TupleAtan2(HTuple y, HTuple x, out HTuple ATan)
        {
            IntPtr proc = HalconAPI.PreCall(202);
            HalconAPI.Store(proc, 0, y);
            HalconAPI.Store(proc, 1, x);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(y);
            HalconAPI.UnpinTuple(x);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out ATan);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the arctangent of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="ATan">Arctangent of the input tuple.</param>
        public static void TupleAtan(HTuple t, out HTuple ATan)
        {
            IntPtr proc = HalconAPI.PreCall(203);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out ATan);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the arccosine of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="ACos">Arccosine of the input tuple.</param>
        public static void TupleAcos(HTuple t, out HTuple ACos)
        {
            IntPtr proc = HalconAPI.PreCall(204);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out ACos);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the arcsine of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="ASin">Arcsine of the input tuple.</param>
        public static void TupleAsin(HTuple t, out HTuple ASin)
        {
            IntPtr proc = HalconAPI.PreCall(205);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out ASin);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the tangent of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="tan">Tangent of the input tuple.</param>
        public static void TupleTan(HTuple t, out HTuple tan)
        {
            IntPtr proc = HalconAPI.PreCall(206);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tan);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the cosine of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="cos">Cosine of the input tuple.</param>
        public static void TupleCos(HTuple t, out HTuple cos)
        {
            IntPtr proc = HalconAPI.PreCall(207);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out cos);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the sine of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="sin">Sine of the input tuple.</param>
        public static void TupleSin(HTuple t, out HTuple sin)
        {
            IntPtr proc = HalconAPI.PreCall(208);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out sin);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the absolute value of a tuple (as floating point numbers).</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="abs">Absolute value of the input tuple.</param>
        public static void TupleFabs(HTuple t, out HTuple abs)
        {
            IntPtr proc = HalconAPI.PreCall(209);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out abs);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the square root of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="sqrt">Square root of the input tuple.</param>
        public static void TupleSqrt(HTuple t, out HTuple sqrt)
        {
            IntPtr proc = HalconAPI.PreCall(210);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out sqrt);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the absolute value of a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="abs">Absolute value of the input tuple.</param>
        public static void TupleAbs(HTuple t, out HTuple abs)
        {
            IntPtr proc = HalconAPI.PreCall(211);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, err, out abs);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Negate a tuple.</summary>
        /// <param name="t">Input tuple.</param>
        /// <param name="neg">Negation of the input tuple.</param>
        public static void TupleNeg(HTuple t, out HTuple neg)
        {
            IntPtr proc = HalconAPI.PreCall(212);
            HalconAPI.Store(proc, 0, t);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(t);
            int procResult = HTuple.LoadNew(proc, 0, err, out neg);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Divide two tuples.</summary>
        /// <param name="q1">Input tuple 1.</param>
        /// <param name="q2">Input tuple 2.</param>
        /// <param name="quot">Quotient of the input tuples.</param>
        public static void TupleDiv(HTuple q1, HTuple q2, out HTuple quot)
        {
            IntPtr proc = HalconAPI.PreCall(213);
            HalconAPI.Store(proc, 0, q1);
            HalconAPI.Store(proc, 1, q2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(q1);
            HalconAPI.UnpinTuple(q2);
            int procResult = HTuple.LoadNew(proc, 0, err, out quot);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Multiply two tuples.</summary>
        /// <param name="p1">Input tuple 1.</param>
        /// <param name="p2">Input tuple 2.</param>
        /// <param name="prod">Product of the input tuples.</param>
        public static void TupleMult(HTuple p1, HTuple p2, out HTuple prod)
        {
            IntPtr proc = HalconAPI.PreCall(214);
            HalconAPI.Store(proc, 0, p1);
            HalconAPI.Store(proc, 1, p2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(p1);
            HalconAPI.UnpinTuple(p2);
            int procResult = HTuple.LoadNew(proc, 0, err, out prod);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Subtract two tuples.</summary>
        /// <param name="d1">Input tuple 1.</param>
        /// <param name="d2">Input tuple 2.</param>
        /// <param name="diff">Difference of the input tuples.</param>
        public static void TupleSub(HTuple d1, HTuple d2, out HTuple diff)
        {
            IntPtr proc = HalconAPI.PreCall(215);
            HalconAPI.Store(proc, 0, d1);
            HalconAPI.Store(proc, 1, d2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(d1);
            HalconAPI.UnpinTuple(d2);
            int procResult = HTuple.LoadNew(proc, 0, err, out diff);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add two tuples.</summary>
        /// <param name="s1">Input tuple 1.</param>
        /// <param name="s2">Input tuple 2.</param>
        /// <param name="sum">Sum of the input tuples.</param>
        public static void TupleAdd(HTuple s1, HTuple s2, out HTuple sum)
        {
            IntPtr proc = HalconAPI.PreCall(216);
            HalconAPI.Store(proc, 0, s1);
            HalconAPI.Store(proc, 1, s2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(s1);
            HalconAPI.UnpinTuple(s2);
            int procResult = HTuple.LoadNew(proc, 0, err, out sum);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized tuple.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="tuple">Tuple.</param>
        public static void DeserializeTuple(HTuple serializedItemHandle, out HTuple tuple)
        {
            IntPtr proc = HalconAPI.PreCall(217);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a tuple.</summary>
        /// <param name="tuple">Tuple.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeTuple(HTuple tuple, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(218);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a tuple to a file.</summary>
        /// <param name="tuple">Tuple with any kind of data.</param>
        /// <param name="fileName">Name of the file to be written.</param>
        public static void WriteTuple(HTuple tuple, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(219);
            HalconAPI.Store(proc, 0, tuple);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a tuple from a file.</summary>
        /// <param name="fileName">Name of the file to be read.</param>
        /// <param name="tuple">Tuple with any kind of data.</param>
        public static void ReadTuple(HTuple fileName, out HTuple tuple)
        {
            IntPtr proc = HalconAPI.PreCall(220);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the average of a set of poses.</summary>
        /// <param name="poses">Set of poses of which the average if computed.</param>
        /// <param name="weights">Empty tuple, or one weight per pose. Default: []</param>
        /// <param name="mode">Averaging mode. Default: "iterative"</param>
        /// <param name="sigmaT">Weight of the translation. Default: "auto"</param>
        /// <param name="sigmaR">Weight of the rotation. Default: "auto"</param>
        /// <param name="averagePose">Weighted mean of the poses.</param>
        /// <param name="quality">Deviation of the mean from the input poses.</param>
        public static void PoseAverage(
          HTuple poses,
          HTuple weights,
          HTuple mode,
          HTuple sigmaT,
          HTuple sigmaR,
          out HTuple averagePose,
          out HTuple quality)
        {
            IntPtr proc = HalconAPI.PreCall(221);
            HalconAPI.Store(proc, 0, poses);
            HalconAPI.Store(proc, 1, weights);
            HalconAPI.Store(proc, 2, mode);
            HalconAPI.Store(proc, 3, sigmaT);
            HalconAPI.Store(proc, 4, sigmaR);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(poses);
            HalconAPI.UnpinTuple(weights);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(sigmaT);
            HalconAPI.UnpinTuple(sigmaR);
            int err2 = HTuple.LoadNew(proc, 0, err1, out averagePose);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out quality);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Perform a rotation by a unit quaternion.</summary>
        /// <param name="quaternion">Rotation quaternion.</param>
        /// <param name="px">X coordinate of the point to be rotated.</param>
        /// <param name="py">Y coordinate of the point to be rotated.</param>
        /// <param name="pz">Z coordinate of the point to be rotated.</param>
        /// <param name="qx">X coordinate of the rotated point.</param>
        /// <param name="qy">Y coordinate of the rotated point.</param>
        /// <param name="qz">Z coordinate of the rotated point.</param>
        public static void QuatRotatePoint3d(
          HTuple quaternion,
          HTuple px,
          HTuple py,
          HTuple pz,
          out HTuple qx,
          out HTuple qy,
          out HTuple qz)
        {
            IntPtr proc = HalconAPI.PreCall(222);
            HalconAPI.Store(proc, 0, quaternion);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.Store(proc, 3, pz);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(quaternion);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(pz);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out qx);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out qy);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out qz);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate the conjugation of a quaternion.</summary>
        /// <param name="quaternion">Input quaternion.</param>
        /// <param name="conjugatedQuaternion">Conjugated quaternion.</param>
        public static void QuatConjugate(HTuple quaternion, out HTuple conjugatedQuaternion)
        {
            IntPtr proc = HalconAPI.PreCall(223);
            HalconAPI.Store(proc, 0, quaternion);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(quaternion);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out conjugatedQuaternion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Normalize a quaternion.</summary>
        /// <param name="quaternion">Input quaternion.</param>
        /// <param name="normalizedQuaternion">Normalized quaternion.</param>
        public static void QuatNormalize(HTuple quaternion, out HTuple normalizedQuaternion)
        {
            IntPtr proc = HalconAPI.PreCall(224);
            HalconAPI.Store(proc, 0, quaternion);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(quaternion);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out normalizedQuaternion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a rotation quaternion.</summary>
        /// <param name="axisX">X component of the rotation axis.</param>
        /// <param name="axisY">Y component of the rotation axis.</param>
        /// <param name="axisZ">Z component of the rotation axis.</param>
        /// <param name="angle">Rotation angle in radians.</param>
        /// <param name="quaternion">Rotation quaternion.</param>
        public static void AxisAngleToQuat(
          HTuple axisX,
          HTuple axisY,
          HTuple axisZ,
          HTuple angle,
          out HTuple quaternion)
        {
            IntPtr proc = HalconAPI.PreCall(225);
            HalconAPI.Store(proc, 0, axisX);
            HalconAPI.Store(proc, 1, axisY);
            HalconAPI.Store(proc, 2, axisZ);
            HalconAPI.Store(proc, 3, angle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(axisX);
            HalconAPI.UnpinTuple(axisY);
            HalconAPI.UnpinTuple(axisZ);
            HalconAPI.UnpinTuple(angle);
            int procResult = HTuple.LoadNew(proc, 0, err, out quaternion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a quaternion into the corresponding 3D pose.</summary>
        /// <param name="quaternion">Rotation quaternion.</param>
        /// <param name="pose">3D Pose.</param>
        public static void QuatToPose(HTuple quaternion, out HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(226);
            HalconAPI.Store(proc, 0, quaternion);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(quaternion);
            int procResult = HTuple.LoadNew(proc, 0, err, out pose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Invert each pose in a tuple of 3D poses.</summary>
        /// <param name="pose">Tuple of 3D poses.</param>
        /// <param name="poseInvert">Tuple of inverted 3D poses.</param>
        public static void PoseInvert(HTuple pose, out HTuple poseInvert)
        {
            IntPtr proc = HalconAPI.PreCall(227);
            HalconAPI.Store(proc, 0, pose);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pose);
            int procResult = HTuple.LoadNew(proc, 0, err, out poseInvert);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Combine 3D poses given in two tuples.</summary>
        /// <param name="poseLeft">Tuple containing the left poses.</param>
        /// <param name="poseRight">Tuple containing the right poses.</param>
        /// <param name="poseCompose">Tuple containing the returned poses.</param>
        public static void PoseCompose(HTuple poseLeft, HTuple poseRight, out HTuple poseCompose)
        {
            IntPtr proc = HalconAPI.PreCall(228);
            HalconAPI.Store(proc, 0, poseLeft);
            HalconAPI.Store(proc, 1, poseRight);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(poseLeft);
            HalconAPI.UnpinTuple(poseRight);
            int procResult = HTuple.LoadNew(proc, 0, err, out poseCompose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a quaternion into the corresponding rotation matrix.</summary>
        /// <param name="quaternion">Rotation quaternion.</param>
        /// <param name="rotationMatrix">Rotation matrix.</param>
        public static void QuatToHomMat3d(HTuple quaternion, out HTuple rotationMatrix)
        {
            IntPtr proc = HalconAPI.PreCall(229);
            HalconAPI.Store(proc, 0, quaternion);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(quaternion);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out rotationMatrix);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert the rotational part of a 3D pose to a quaternion.</summary>
        /// <param name="pose">3D Pose.</param>
        /// <param name="quaternion">Rotation quaternion.</param>
        public static void PoseToQuat(HTuple pose, out HTuple quaternion)
        {
            IntPtr proc = HalconAPI.PreCall(230);
            HalconAPI.Store(proc, 0, pose);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pose);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out quaternion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interpolation of two quaternions.</summary>
        /// <param name="quaternionStart">Start quaternion.</param>
        /// <param name="quaternionEnd">End quaternion.</param>
        /// <param name="interpPos">Interpolation parameter. Default: 0.5</param>
        /// <param name="quaternionInterpolated">Interpolated quaternion.</param>
        public static void QuatInterpolate(
          HTuple quaternionStart,
          HTuple quaternionEnd,
          HTuple interpPos,
          out HTuple quaternionInterpolated)
        {
            IntPtr proc = HalconAPI.PreCall(231);
            HalconAPI.Store(proc, 0, quaternionStart);
            HalconAPI.Store(proc, 1, quaternionEnd);
            HalconAPI.Store(proc, 2, interpPos);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(quaternionStart);
            HalconAPI.UnpinTuple(quaternionEnd);
            HalconAPI.UnpinTuple(interpPos);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out quaternionInterpolated);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Multiply two quaternions.</summary>
        /// <param name="quaternionLeft">Left quaternion.</param>
        /// <param name="quaternionRight">Right quaternion.</param>
        /// <param name="quaternionComposed">Product of the input quaternions.</param>
        public static void QuatCompose(
          HTuple quaternionLeft,
          HTuple quaternionRight,
          out HTuple quaternionComposed)
        {
            IntPtr proc = HalconAPI.PreCall(232);
            HalconAPI.Store(proc, 0, quaternionLeft);
            HalconAPI.Store(proc, 1, quaternionRight);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(quaternionLeft);
            HalconAPI.UnpinTuple(quaternionRight);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out quaternionComposed);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized homogeneous 3D transformation matrix.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="homMat3D">Transformation matrix.</param>
        public static void DeserializeHomMat3d(HTuple serializedItemHandle, out HTuple homMat3D)
        {
            IntPtr proc = HalconAPI.PreCall(233);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a homogeneous 3D transformation matrix.</summary>
        /// <param name="homMat3D">Transformation matrix.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeHomMat3d(HTuple homMat3D, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(234);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized homogeneous 2D transformation matrix.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="homMat2D">Transformation matrix.</param>
        public static void DeserializeHomMat2d(HTuple serializedItemHandle, out HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(235);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Transformation matrix.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeHomMat2d(HTuple homMat2D, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(236);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized quaternion.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="quaternion">Quaternion.</param>
        public static void DeserializeQuat(HTuple serializedItemHandle, out HTuple quaternion)
        {
            IntPtr proc = HalconAPI.PreCall(237);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out quaternion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a quaternion.</summary>
        /// <param name="quaternion">Quaternion.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeQuat(HTuple quaternion, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(238);
            HalconAPI.Store(proc, 0, quaternion);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(quaternion);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Project a homogeneous 3D point using a projective transformation matrix.</summary>
        /// <param name="homMat3D">Homogeneous projective transformation matrix.</param>
        /// <param name="px">Input point (x coordinate).</param>
        /// <param name="py">Input point (y coordinate).</param>
        /// <param name="pz">Input point (z coordinate).</param>
        /// <param name="pw">Input point (w coordinate).</param>
        /// <param name="qx">Output point (x coordinate).</param>
        /// <param name="qy">Output point (y coordinate).</param>
        /// <param name="qz">Output point (z coordinate).</param>
        /// <param name="qw">Output point (w coordinate).</param>
        public static void ProjectiveTransHomPoint3d(
          HTuple homMat3D,
          HTuple px,
          HTuple py,
          HTuple pz,
          HTuple pw,
          out HTuple qx,
          out HTuple qy,
          out HTuple qz,
          out HTuple qw)
        {
            IntPtr proc = HalconAPI.PreCall(239);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.Store(proc, 3, pz);
            HalconAPI.Store(proc, 4, pw);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(pz);
            HalconAPI.UnpinTuple(pw);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out qx);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out qy);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out qz);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out qw);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Project a 3D point using a projective transformation matrix.</summary>
        /// <param name="homMat3D">Homogeneous projective transformation matrix.</param>
        /// <param name="px">Input point (x coordinate).</param>
        /// <param name="py">Input point (y coordinate).</param>
        /// <param name="pz">Input point (z coordinate).</param>
        /// <param name="qx">Output point (x coordinate).</param>
        /// <param name="qy">Output point (y coordinate).</param>
        /// <param name="qz">Output point (z coordinate).</param>
        public static void ProjectiveTransPoint3d(
          HTuple homMat3D,
          HTuple px,
          HTuple py,
          HTuple pz,
          out HTuple qx,
          out HTuple qy,
          out HTuple qz)
        {
            IntPtr proc = HalconAPI.PreCall(240);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.Store(proc, 3, pz);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(pz);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out qx);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out qy);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out qz);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Apply an arbitrary affine 3D transformation to points.</summary>
        /// <param name="homMat3D">Input transformation matrix.</param>
        /// <param name="px">Input point(s) (x coordinate). Default: 64</param>
        /// <param name="py">Input point(s) (y coordinate). Default: 64</param>
        /// <param name="pz">Input point(s) (z coordinate). Default: 64</param>
        /// <param name="qx">Output point(s) (x coordinate).</param>
        /// <param name="qy">Output point(s) (y coordinate).</param>
        /// <param name="qz">Output point(s) (z coordinate).</param>
        public static void AffineTransPoint3d(
          HTuple homMat3D,
          HTuple px,
          HTuple py,
          HTuple pz,
          out HTuple qx,
          out HTuple qy,
          out HTuple qz)
        {
            IntPtr proc = HalconAPI.PreCall(241);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.Store(proc, 3, pz);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(pz);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out qx);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out qy);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out qz);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Approximate a 3D transformation from point correspondences.</summary>
        /// <param name="transformationType">Type of the transformation to compute. Default: "rigid"</param>
        /// <param name="px">X coordinates of the original points.</param>
        /// <param name="py">Y coordinates of the original points.</param>
        /// <param name="pz">Z coordinates of the original points.</param>
        /// <param name="qx">X coordinates of the transformed points.</param>
        /// <param name="qy">Y coordinates of the transformed points.</param>
        /// <param name="qz">Z coordinates of the transformed points.</param>
        /// <param name="homMat3D">Output transformation matrix.</param>
        public static void VectorToHomMat3d(
          HTuple transformationType,
          HTuple px,
          HTuple py,
          HTuple pz,
          HTuple qx,
          HTuple qy,
          HTuple qz,
          out HTuple homMat3D)
        {
            IntPtr proc = HalconAPI.PreCall(242);
            HalconAPI.Store(proc, 0, transformationType);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.Store(proc, 3, pz);
            HalconAPI.Store(proc, 4, qx);
            HalconAPI.Store(proc, 5, qy);
            HalconAPI.Store(proc, 6, qz);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(transformationType);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(pz);
            HalconAPI.UnpinTuple(qx);
            HalconAPI.UnpinTuple(qy);
            HalconAPI.UnpinTuple(qz);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the determinant of a homogeneous 3D transformation matrix.</summary>
        /// <param name="homMat3D">Input transformation matrix.</param>
        /// <param name="determinant">Determinant of the input matrix.</param>
        public static void HomMat3dDeterminant(HTuple homMat3D, out HTuple determinant)
        {
            IntPtr proc = HalconAPI.PreCall(243);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out determinant);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transpose a homogeneous 3D transformation matrix.</summary>
        /// <param name="homMat3D">Input transformation matrix.</param>
        /// <param name="homMat3DTranspose">Output transformation matrix.</param>
        public static void HomMat3dTranspose(HTuple homMat3D, out HTuple homMat3DTranspose)
        {
            IntPtr proc = HalconAPI.PreCall(244);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3DTranspose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Invert a homogeneous 3D transformation matrix.</summary>
        /// <param name="homMat3D">Input transformation matrix.</param>
        /// <param name="homMat3DInvert">Output transformation matrix.</param>
        public static void HomMat3dInvert(HTuple homMat3D, out HTuple homMat3DInvert)
        {
            IntPtr proc = HalconAPI.PreCall(245);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3DInvert);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Multiply two homogeneous 3D transformation matrices.</summary>
        /// <param name="homMat3DLeft">Left input transformation matrix.</param>
        /// <param name="homMat3DRight">Right input transformation matrix.</param>
        /// <param name="homMat3DCompose">Output transformation matrix.</param>
        public static void HomMat3dCompose(
          HTuple homMat3DLeft,
          HTuple homMat3DRight,
          out HTuple homMat3DCompose)
        {
            IntPtr proc = HalconAPI.PreCall(246);
            HalconAPI.Store(proc, 0, homMat3DLeft);
            HalconAPI.Store(proc, 1, homMat3DRight);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3DLeft);
            HalconAPI.UnpinTuple(homMat3DRight);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3DCompose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a rotation to a homogeneous 3D transformation matrix.</summary>
        /// <param name="homMat3D">Input transformation matrix.</param>
        /// <param name="phi">Rotation angle. Default: 0.78</param>
        /// <param name="axis">Axis, to be rotated around. Default: "x"</param>
        /// <param name="homMat3DRotate">Output transformation matrix.</param>
        public static void HomMat3dRotateLocal(
          HTuple homMat3D,
          HTuple phi,
          HTuple axis,
          out HTuple homMat3DRotate)
        {
            IntPtr proc = HalconAPI.PreCall(247);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, phi);
            HalconAPI.Store(proc, 2, axis);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(axis);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3DRotate);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a rotation to a homogeneous 3D transformation matrix.</summary>
        /// <param name="homMat3D">Input transformation matrix.</param>
        /// <param name="phi">Rotation angle. Default: 0.78</param>
        /// <param name="axis">Axis, to be rotated around. Default: "x"</param>
        /// <param name="px">Fixed point of the transformation (x coordinate). Default: 0</param>
        /// <param name="py">Fixed point of the transformation (y coordinate). Default: 0</param>
        /// <param name="pz">Fixed point of the transformation (z coordinate). Default: 0</param>
        /// <param name="homMat3DRotate">Output transformation matrix.</param>
        public static void HomMat3dRotate(
          HTuple homMat3D,
          HTuple phi,
          HTuple axis,
          HTuple px,
          HTuple py,
          HTuple pz,
          out HTuple homMat3DRotate)
        {
            IntPtr proc = HalconAPI.PreCall(248);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, phi);
            HalconAPI.Store(proc, 2, axis);
            HalconAPI.Store(proc, 3, px);
            HalconAPI.Store(proc, 4, py);
            HalconAPI.Store(proc, 5, pz);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(axis);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(pz);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3DRotate);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a scaling to a homogeneous 3D transformation matrix.</summary>
        /// <param name="homMat3D">Input transformation matrix.</param>
        /// <param name="sx">Scale factor along the x-axis. Default: 2</param>
        /// <param name="sy">Scale factor along the y-axis. Default: 2</param>
        /// <param name="sz">Scale factor along the z-axis. Default: 2</param>
        /// <param name="homMat3DScale">Output transformation matrix.</param>
        public static void HomMat3dScaleLocal(
          HTuple homMat3D,
          HTuple sx,
          HTuple sy,
          HTuple sz,
          out HTuple homMat3DScale)
        {
            IntPtr proc = HalconAPI.PreCall(249);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, sx);
            HalconAPI.Store(proc, 2, sy);
            HalconAPI.Store(proc, 3, sz);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(sx);
            HalconAPI.UnpinTuple(sy);
            HalconAPI.UnpinTuple(sz);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3DScale);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a scaling to a homogeneous 3D transformation matrix.</summary>
        /// <param name="homMat3D">Input transformation matrix.</param>
        /// <param name="sx">Scale factor along the x-axis. Default: 2</param>
        /// <param name="sy">Scale factor along the y-axis. Default: 2</param>
        /// <param name="sz">Scale factor along the z-axis. Default: 2</param>
        /// <param name="px">Fixed point of the transformation (x coordinate). Default: 0</param>
        /// <param name="py">Fixed point of the transformation (y coordinate). Default: 0</param>
        /// <param name="pz">Fixed point of the transformation (z coordinate). Default: 0</param>
        /// <param name="homMat3DScale">Output transformation matrix.</param>
        public static void HomMat3dScale(
          HTuple homMat3D,
          HTuple sx,
          HTuple sy,
          HTuple sz,
          HTuple px,
          HTuple py,
          HTuple pz,
          out HTuple homMat3DScale)
        {
            IntPtr proc = HalconAPI.PreCall(250);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, sx);
            HalconAPI.Store(proc, 2, sy);
            HalconAPI.Store(proc, 3, sz);
            HalconAPI.Store(proc, 4, px);
            HalconAPI.Store(proc, 5, py);
            HalconAPI.Store(proc, 6, pz);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(sx);
            HalconAPI.UnpinTuple(sy);
            HalconAPI.UnpinTuple(sz);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(pz);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3DScale);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a translation to a homogeneous 3D transformation matrix.</summary>
        /// <param name="homMat3D">Input transformation matrix.</param>
        /// <param name="tx">Translation along the x-axis. Default: 64</param>
        /// <param name="ty">Translation along the y-axis. Default: 64</param>
        /// <param name="tz">Translation along the z-axis. Default: 64</param>
        /// <param name="homMat3DTranslate">Output transformation matrix.</param>
        public static void HomMat3dTranslateLocal(
          HTuple homMat3D,
          HTuple tx,
          HTuple ty,
          HTuple tz,
          out HTuple homMat3DTranslate)
        {
            IntPtr proc = HalconAPI.PreCall(251);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, tx);
            HalconAPI.Store(proc, 2, ty);
            HalconAPI.Store(proc, 3, tz);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(tx);
            HalconAPI.UnpinTuple(ty);
            HalconAPI.UnpinTuple(tz);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3DTranslate);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a translation to a homogeneous 3D transformation matrix.</summary>
        /// <param name="homMat3D">Input transformation matrix.</param>
        /// <param name="tx">Translation along the x-axis. Default: 64</param>
        /// <param name="ty">Translation along the y-axis. Default: 64</param>
        /// <param name="tz">Translation along the z-axis. Default: 64</param>
        /// <param name="homMat3DTranslate">Output transformation matrix.</param>
        public static void HomMat3dTranslate(
          HTuple homMat3D,
          HTuple tx,
          HTuple ty,
          HTuple tz,
          out HTuple homMat3DTranslate)
        {
            IntPtr proc = HalconAPI.PreCall(252);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, tx);
            HalconAPI.Store(proc, 2, ty);
            HalconAPI.Store(proc, 3, tz);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(tx);
            HalconAPI.UnpinTuple(ty);
            HalconAPI.UnpinTuple(tz);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3DTranslate);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate the homogeneous transformation matrix of the identical 3D transformation.</summary>
        /// <param name="homMat3DIdentity">Transformation matrix.</param>
        public static void HomMat3dIdentity(out HTuple homMat3DIdentity)
        {
            IntPtr proc = HalconAPI.PreCall(253);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3DIdentity);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Project an affine 3D transformation matrix to a 2D projective transformation matrix.</summary>
        /// <param name="homMat3D">3x4 3D transformation matrix.</param>
        /// <param name="principalPointRow">Row coordinate of the principal point. Default: 256</param>
        /// <param name="principalPointCol">Column coordinate of the principal point. Default: 256</param>
        /// <param name="focus">Focal length in pixels. Default: 256</param>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        public static void HomMat3dProject(
          HTuple homMat3D,
          HTuple principalPointRow,
          HTuple principalPointCol,
          HTuple focus,
          out HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(254);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, principalPointRow);
            HalconAPI.Store(proc, 2, principalPointCol);
            HalconAPI.Store(proc, 3, focus);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(principalPointRow);
            HalconAPI.UnpinTuple(principalPointCol);
            HalconAPI.UnpinTuple(focus);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Perform a bundle adjustment of an image mosaic.</summary>
        /// <param name="numImages">Number of different images that are used for the calibration.</param>
        /// <param name="referenceImage">Index of the reference image.</param>
        /// <param name="mappingSource">Indices of the source images of the transformations.</param>
        /// <param name="mappingDest">Indices of the target images of the transformations.</param>
        /// <param name="homMatrices2D">Array of 3x3 projective transformation matrices.</param>
        /// <param name="rows1">Row coordinates of corresponding points in the respective source images.</param>
        /// <param name="cols1">Column coordinates of corresponding points in the respective source images.</param>
        /// <param name="rows2">Row coordinates of corresponding points in the respective destination images.</param>
        /// <param name="cols2">Column coordinates of corresponding points in the respective destination images.</param>
        /// <param name="numCorrespondences">Number of point correspondences in the respective image pair.</param>
        /// <param name="transformation">Transformation class to be used. Default: "projective"</param>
        /// <param name="mosaicMatrices2D">Array of 3x3 projective transformation matrices that determine the position of the images in the mosaic.</param>
        /// <param name="rows">Row coordinates of the points reconstructed by the bundle adjustment.</param>
        /// <param name="cols">Column coordinates of the points reconstructed by the bundle adjustment.</param>
        /// <param name="error">Average error per reconstructed point.</param>
        public static void BundleAdjustMosaic(
          HTuple numImages,
          HTuple referenceImage,
          HTuple mappingSource,
          HTuple mappingDest,
          HTuple homMatrices2D,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple numCorrespondences,
          HTuple transformation,
          out HTuple mosaicMatrices2D,
          out HTuple rows,
          out HTuple cols,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall((int)byte.MaxValue);
            HalconAPI.Store(proc, 0, numImages);
            HalconAPI.Store(proc, 1, referenceImage);
            HalconAPI.Store(proc, 2, mappingSource);
            HalconAPI.Store(proc, 3, mappingDest);
            HalconAPI.Store(proc, 4, homMatrices2D);
            HalconAPI.Store(proc, 5, rows1);
            HalconAPI.Store(proc, 6, cols1);
            HalconAPI.Store(proc, 7, rows2);
            HalconAPI.Store(proc, 8, cols2);
            HalconAPI.Store(proc, 9, numCorrespondences);
            HalconAPI.Store(proc, 10, transformation);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numImages);
            HalconAPI.UnpinTuple(referenceImage);
            HalconAPI.UnpinTuple(mappingSource);
            HalconAPI.UnpinTuple(mappingDest);
            HalconAPI.UnpinTuple(homMatrices2D);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(numCorrespondences);
            HalconAPI.UnpinTuple(transformation);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out mosaicMatrices2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out rows);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out cols);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out error);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute a projective transformation matrix and the radial distortion coefficient between two images by finding correspondences between points based on known approximations of the projective transformation matrix and the radial distortion coefficient.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="grayMatchMethod">Gray value match metric. Default: "ncc"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="homMat2DGuide">Approximation of the homogeneous projective transformation matrix between the two images.</param>
        /// <param name="kappaGuide">Approximation of the radial distortion coefficient in the two images.</param>
        /// <param name="distanceTolerance">Tolerance for the matching search window. Default: 20.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 0.7</param>
        /// <param name="estimationMethod">Algorithm for the computation of the projective transformation matrix. Default: "gold_standard"</param>
        /// <param name="distanceThreshold">Threshold for transformation consistency check. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="homMat2D">Computed homogeneous projective transformation matrix.</param>
        /// <param name="kappa">Computed radial distortion coefficient.</param>
        /// <param name="error">Root-Mean-Square transformation error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        public static void ProjMatchPointsDistortionRansacGuided(
          HObject image1,
          HObject image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple grayMatchMethod,
          HTuple maskSize,
          HTuple homMat2DGuide,
          HTuple kappaGuide,
          HTuple distanceTolerance,
          HTuple matchThreshold,
          HTuple estimationMethod,
          HTuple distanceThreshold,
          HTuple randSeed,
          out HTuple homMat2D,
          out HTuple kappa,
          out HTuple error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(256);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, grayMatchMethod);
            HalconAPI.Store(proc, 5, maskSize);
            HalconAPI.Store(proc, 6, homMat2DGuide);
            HalconAPI.Store(proc, 7, kappaGuide);
            HalconAPI.Store(proc, 8, distanceTolerance);
            HalconAPI.Store(proc, 9, matchThreshold);
            HalconAPI.Store(proc, 10, estimationMethod);
            HalconAPI.Store(proc, 11, distanceThreshold);
            HalconAPI.Store(proc, 12, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(grayMatchMethod);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(homMat2DGuide);
            HalconAPI.UnpinTuple(kappaGuide);
            HalconAPI.UnpinTuple(distanceTolerance);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(estimationMethod);
            HalconAPI.UnpinTuple(distanceThreshold);
            HalconAPI.UnpinTuple(randSeed);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out homMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out kappa);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Compute a projective transformation matrix between two images and the radial distortion coefficient by automatically finding correspondences between points.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="grayMatchMethod">Gray value match metric. Default: "ncc"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate offset of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate offset of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative rotation of the second image with respect to the first image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 0.7</param>
        /// <param name="estimationMethod">Algorithm for the computation of the projective transformation matrix. Default: "gold_standard"</param>
        /// <param name="distanceThreshold">Threshold for the transformation consistency check. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="homMat2D">Computed homogeneous projective transformation matrix.</param>
        /// <param name="kappa">Computed radial distortion coefficient.</param>
        /// <param name="error">Root-Mean-Square transformation error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        public static void ProjMatchPointsDistortionRansac(
          HObject image1,
          HObject image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple grayMatchMethod,
          HTuple maskSize,
          HTuple rowMove,
          HTuple colMove,
          HTuple rowTolerance,
          HTuple colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          HTuple estimationMethod,
          HTuple distanceThreshold,
          HTuple randSeed,
          out HTuple homMat2D,
          out HTuple kappa,
          out HTuple error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(257);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, grayMatchMethod);
            HalconAPI.Store(proc, 5, maskSize);
            HalconAPI.Store(proc, 6, rowMove);
            HalconAPI.Store(proc, 7, colMove);
            HalconAPI.Store(proc, 8, rowTolerance);
            HalconAPI.Store(proc, 9, colTolerance);
            HalconAPI.Store(proc, 10, rotation);
            HalconAPI.Store(proc, 11, matchThreshold);
            HalconAPI.Store(proc, 12, estimationMethod);
            HalconAPI.Store(proc, 13, distanceThreshold);
            HalconAPI.Store(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(grayMatchMethod);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(rowMove);
            HalconAPI.UnpinTuple(colMove);
            HalconAPI.UnpinTuple(rowTolerance);
            HalconAPI.UnpinTuple(colTolerance);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(estimationMethod);
            HalconAPI.UnpinTuple(distanceThreshold);
            HalconAPI.UnpinTuple(randSeed);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out homMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out kappa);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Compute a projective transformation matrix between two images by finding correspondences between points based on a known approximation of the projective transformation matrix.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="homMat2DGuide">Approximation of the Homogeneous projective transformation matrix between the two images.</param>
        /// <param name="distanceTolerance">Tolerance for the matching search window. Default: 20.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Transformation matrix estimation algorithm. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Threshold for transformation consistency check. Default: 0.2</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        public static void ProjMatchPointsRansacGuided(
          HObject image1,
          HObject image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple grayMatchMethod,
          HTuple maskSize,
          HTuple homMat2DGuide,
          HTuple distanceTolerance,
          HTuple matchThreshold,
          HTuple estimationMethod,
          HTuple distanceThreshold,
          HTuple randSeed,
          out HTuple homMat2D,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(258);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, grayMatchMethod);
            HalconAPI.Store(proc, 5, maskSize);
            HalconAPI.Store(proc, 6, homMat2DGuide);
            HalconAPI.Store(proc, 7, distanceTolerance);
            HalconAPI.Store(proc, 8, matchThreshold);
            HalconAPI.Store(proc, 9, estimationMethod);
            HalconAPI.Store(proc, 10, distanceThreshold);
            HalconAPI.Store(proc, 11, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(grayMatchMethod);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(homMat2DGuide);
            HalconAPI.UnpinTuple(distanceTolerance);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(estimationMethod);
            HalconAPI.UnpinTuple(distanceThreshold);
            HalconAPI.UnpinTuple(randSeed);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out homMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out points1);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Compute a projective transformation matrix between two images by finding correspondences between points.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 256</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 256</param>
        /// <param name="rotation">Range of rotation angles. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Transformation matrix estimation algorithm. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Threshold for transformation consistency check. Default: 0.2</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        public static void ProjMatchPointsRansac(
          HObject image1,
          HObject image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple grayMatchMethod,
          HTuple maskSize,
          HTuple rowMove,
          HTuple colMove,
          HTuple rowTolerance,
          HTuple colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          HTuple estimationMethod,
          HTuple distanceThreshold,
          HTuple randSeed,
          out HTuple homMat2D,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(259);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, grayMatchMethod);
            HalconAPI.Store(proc, 5, maskSize);
            HalconAPI.Store(proc, 6, rowMove);
            HalconAPI.Store(proc, 7, colMove);
            HalconAPI.Store(proc, 8, rowTolerance);
            HalconAPI.Store(proc, 9, colTolerance);
            HalconAPI.Store(proc, 10, rotation);
            HalconAPI.Store(proc, 11, matchThreshold);
            HalconAPI.Store(proc, 12, estimationMethod);
            HalconAPI.Store(proc, 13, distanceThreshold);
            HalconAPI.Store(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(grayMatchMethod);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(rowMove);
            HalconAPI.UnpinTuple(colMove);
            HalconAPI.UnpinTuple(rowTolerance);
            HalconAPI.UnpinTuple(colTolerance);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(estimationMethod);
            HalconAPI.UnpinTuple(distanceThreshold);
            HalconAPI.UnpinTuple(randSeed);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out homMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out points1);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Compute a projective transformation matrix and the radial distortion coefficient using given image point correspondences.</summary>
        /// <param name="points1Row">Input points in image 1 (row coordinate).</param>
        /// <param name="points1Col">Input points in image 1 (column coordinate).</param>
        /// <param name="points2Row">Input points in image 2 (row coordinate).</param>
        /// <param name="points2Col">Input points in image 2 (column coordinate).</param>
        /// <param name="covRR1">Row coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRC1">Covariance of the points in image 1. Default: []</param>
        /// <param name="covCC1">Column coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRR2">Row coordinate variance of the points in image 2. Default: []</param>
        /// <param name="covRC2">Covariance of the points in image 2. Default: []</param>
        /// <param name="covCC2">Column coordinate variance of the points in image 2. Default: []</param>
        /// <param name="imageWidth">Width of the images from which the points were extracted.</param>
        /// <param name="imageHeight">Height of the images from which the points were extracted.</param>
        /// <param name="method">Estimation algorithm. Default: "gold_standard"</param>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        /// <param name="kappa">Computed radial distortion coefficient.</param>
        /// <param name="error">Root-Mean-Square transformation error.</param>
        public static void VectorToProjHomMat2dDistortion(
          HTuple points1Row,
          HTuple points1Col,
          HTuple points2Row,
          HTuple points2Col,
          HTuple covRR1,
          HTuple covRC1,
          HTuple covCC1,
          HTuple covRR2,
          HTuple covRC2,
          HTuple covCC2,
          HTuple imageWidth,
          HTuple imageHeight,
          HTuple method,
          out HTuple homMat2D,
          out HTuple kappa,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(260);
            HalconAPI.Store(proc, 0, points1Row);
            HalconAPI.Store(proc, 1, points1Col);
            HalconAPI.Store(proc, 2, points2Row);
            HalconAPI.Store(proc, 3, points2Col);
            HalconAPI.Store(proc, 4, covRR1);
            HalconAPI.Store(proc, 5, covRC1);
            HalconAPI.Store(proc, 6, covCC1);
            HalconAPI.Store(proc, 7, covRR2);
            HalconAPI.Store(proc, 8, covRC2);
            HalconAPI.Store(proc, 9, covCC2);
            HalconAPI.Store(proc, 10, imageWidth);
            HalconAPI.Store(proc, 11, imageHeight);
            HalconAPI.Store(proc, 12, method);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(points1Row);
            HalconAPI.UnpinTuple(points1Col);
            HalconAPI.UnpinTuple(points2Row);
            HalconAPI.UnpinTuple(points2Col);
            HalconAPI.UnpinTuple(covRR1);
            HalconAPI.UnpinTuple(covRC1);
            HalconAPI.UnpinTuple(covCC1);
            HalconAPI.UnpinTuple(covRR2);
            HalconAPI.UnpinTuple(covRC2);
            HalconAPI.UnpinTuple(covCC2);
            HalconAPI.UnpinTuple(imageWidth);
            HalconAPI.UnpinTuple(imageHeight);
            HalconAPI.UnpinTuple(method);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out homMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out kappa);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute a homogeneous transformation matrix using given point correspondences.</summary>
        /// <param name="px">Input points 1 (x coordinate).</param>
        /// <param name="py">Input points 1 (y coordinate).</param>
        /// <param name="pw">Input points 1 (w coordinate).</param>
        /// <param name="qx">Input points 2 (x coordinate).</param>
        /// <param name="qy">Input points 2 (y coordinate).</param>
        /// <param name="qw">Input points 2 (w coordinate).</param>
        /// <param name="method">Estimation algorithm. Default: "normalized_dlt"</param>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        public static void HomVectorToProjHomMat2d(
          HTuple px,
          HTuple py,
          HTuple pw,
          HTuple qx,
          HTuple qy,
          HTuple qw,
          HTuple method,
          out HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(261);
            HalconAPI.Store(proc, 0, px);
            HalconAPI.Store(proc, 1, py);
            HalconAPI.Store(proc, 2, pw);
            HalconAPI.Store(proc, 3, qx);
            HalconAPI.Store(proc, 4, qy);
            HalconAPI.Store(proc, 5, qw);
            HalconAPI.Store(proc, 6, method);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(pw);
            HalconAPI.UnpinTuple(qx);
            HalconAPI.UnpinTuple(qy);
            HalconAPI.UnpinTuple(qw);
            HalconAPI.UnpinTuple(method);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute a projective transformation matrix using given point correspondences.</summary>
        /// <param name="px">Input points in image 1 (row coordinate).</param>
        /// <param name="py">Input points in image 1 (column coordinate).</param>
        /// <param name="qx">Input points in image 2 (row coordinate).</param>
        /// <param name="qy">Input points in image 2 (column coordinate).</param>
        /// <param name="method">Estimation algorithm. Default: "normalized_dlt"</param>
        /// <param name="covXX1">Row coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covYY1">Column coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covXY1">Covariance of the points in image 1. Default: []</param>
        /// <param name="covXX2">Row coordinate variance of the points in image 2. Default: []</param>
        /// <param name="covYY2">Column coordinate variance of the points in image 2. Default: []</param>
        /// <param name="covXY2">Covariance of the points in image 2. Default: []</param>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        /// <param name="covariance">9x9 covariance matrix of the projective transformation matrix.</param>
        public static void VectorToProjHomMat2d(
          HTuple px,
          HTuple py,
          HTuple qx,
          HTuple qy,
          HTuple method,
          HTuple covXX1,
          HTuple covYY1,
          HTuple covXY1,
          HTuple covXX2,
          HTuple covYY2,
          HTuple covXY2,
          out HTuple homMat2D,
          out HTuple covariance)
        {
            IntPtr proc = HalconAPI.PreCall(262);
            HalconAPI.Store(proc, 0, px);
            HalconAPI.Store(proc, 1, py);
            HalconAPI.Store(proc, 2, qx);
            HalconAPI.Store(proc, 3, qy);
            HalconAPI.Store(proc, 4, method);
            HalconAPI.Store(proc, 5, covXX1);
            HalconAPI.Store(proc, 6, covYY1);
            HalconAPI.Store(proc, 7, covXY1);
            HalconAPI.Store(proc, 8, covXX2);
            HalconAPI.Store(proc, 9, covYY2);
            HalconAPI.Store(proc, 10, covXY2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(qx);
            HalconAPI.UnpinTuple(qy);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(covXX1);
            HalconAPI.UnpinTuple(covYY1);
            HalconAPI.UnpinTuple(covXY1);
            HalconAPI.UnpinTuple(covXX2);
            HalconAPI.UnpinTuple(covYY2);
            HalconAPI.UnpinTuple(covXY2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out homMat2D);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covariance);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the affine transformation parameters from a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="sx">Scaling factor along the x direction.</param>
        /// <param name="sy">Scaling factor along the y direction.</param>
        /// <param name="phi">Rotation angle.</param>
        /// <param name="theta">Slant angle.</param>
        /// <param name="tx">Translation along the x direction.</param>
        /// <param name="ty">Translation along the y direction.</param>
        public static void HomMat2dToAffinePar(
          HTuple homMat2D,
          out HTuple sx,
          out HTuple sy,
          out HTuple phi,
          out HTuple theta,
          out HTuple tx,
          out HTuple ty)
        {
            IntPtr proc = HalconAPI.PreCall(263);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out sx);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out sy);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out theta);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out tx);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out ty);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute a rigid affine transformation from points and angles.</summary>
        /// <param name="row1">Row coordinate of the original point.</param>
        /// <param name="column1">Column coordinate of the original point.</param>
        /// <param name="angle1">Angle of the original point.</param>
        /// <param name="row2">Row coordinate of the transformed point.</param>
        /// <param name="column2">Column coordinate of the transformed point.</param>
        /// <param name="angle2">Angle of the transformed point.</param>
        /// <param name="homMat2D">Output transformation matrix.</param>
        public static void VectorAngleToRigid(
          HTuple row1,
          HTuple column1,
          HTuple angle1,
          HTuple row2,
          HTuple column2,
          HTuple angle2,
          out HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(264);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, angle1);
            HalconAPI.Store(proc, 3, row2);
            HalconAPI.Store(proc, 4, column2);
            HalconAPI.Store(proc, 5, angle2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(angle1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            HalconAPI.UnpinTuple(angle2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Approximate an affine transformation from point-to-line correspondences.</summary>
        /// <param name="transformationType">Type of the transformation to compute. Default: "rigid"</param>
        /// <param name="px">X coordinates of the original points.</param>
        /// <param name="py">Y coordinates of the original points.</param>
        /// <param name="l1x">X coordinates of the first point on the corresponding line.</param>
        /// <param name="l1y">Y coordinates of the first point on the corresponding line.</param>
        /// <param name="l2x">X coordinates of the second point on the corresponding line.</param>
        /// <param name="l2y">Y coordinates of the second point on the corresponding line.</param>
        /// <param name="homMat2D">Output transformation matrix.</param>
        public static void PointLineToHomMat2d(
          HTuple transformationType,
          HTuple px,
          HTuple py,
          HTuple l1x,
          HTuple l1y,
          HTuple l2x,
          HTuple l2y,
          out HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(265);
            HalconAPI.Store(proc, 0, transformationType);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.Store(proc, 3, l1x);
            HalconAPI.Store(proc, 4, l1y);
            HalconAPI.Store(proc, 5, l2x);
            HalconAPI.Store(proc, 6, l2y);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(transformationType);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(l1x);
            HalconAPI.UnpinTuple(l1y);
            HalconAPI.UnpinTuple(l2x);
            HalconAPI.UnpinTuple(l2y);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Approximate a rigid affine transformation from point correspondences.</summary>
        /// <param name="px">X coordinates of the original points.</param>
        /// <param name="py">Y coordinates of the original points.</param>
        /// <param name="qx">X coordinates of the transformed points.</param>
        /// <param name="qy">Y coordinates of the transformed points.</param>
        /// <param name="homMat2D">Output transformation matrix.</param>
        public static void VectorToRigid(
          HTuple px,
          HTuple py,
          HTuple qx,
          HTuple qy,
          out HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(266);
            HalconAPI.Store(proc, 0, px);
            HalconAPI.Store(proc, 1, py);
            HalconAPI.Store(proc, 2, qx);
            HalconAPI.Store(proc, 3, qy);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(qx);
            HalconAPI.UnpinTuple(qy);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Approximate an similarity transformation from point correspondences.</summary>
        /// <param name="px">X coordinates of the original points.</param>
        /// <param name="py">Y coordinates of the original points.</param>
        /// <param name="qx">X coordinates of the transformed points.</param>
        /// <param name="qy">Y coordinates of the transformed points.</param>
        /// <param name="homMat2D">Output transformation matrix.</param>
        public static void VectorToSimilarity(
          HTuple px,
          HTuple py,
          HTuple qx,
          HTuple qy,
          out HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(267);
            HalconAPI.Store(proc, 0, px);
            HalconAPI.Store(proc, 1, py);
            HalconAPI.Store(proc, 2, qx);
            HalconAPI.Store(proc, 3, qy);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(qx);
            HalconAPI.UnpinTuple(qy);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Approximate an anisotropic similarity transformation from point correspondences.</summary>
        /// <param name="px">X coordinates of the original points.</param>
        /// <param name="py">Y coordinates of the original points.</param>
        /// <param name="qx">X coordinates of the transformed points.</param>
        /// <param name="qy">Y coordinates of the transformed points.</param>
        /// <param name="homMat2D">Output transformation matrix.</param>
        public static void VectorToAniso(
          HTuple px,
          HTuple py,
          HTuple qx,
          HTuple qy,
          out HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(268);
            HalconAPI.Store(proc, 0, px);
            HalconAPI.Store(proc, 1, py);
            HalconAPI.Store(proc, 2, qx);
            HalconAPI.Store(proc, 3, qy);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(qx);
            HalconAPI.UnpinTuple(qy);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Approximate an affine transformation from point correspondences.</summary>
        /// <param name="px">X coordinates of the original points.</param>
        /// <param name="py">Y coordinates of the original points.</param>
        /// <param name="qx">X coordinates of the transformed points.</param>
        /// <param name="qy">Y coordinates of the transformed points.</param>
        /// <param name="homMat2D">Output transformation matrix.</param>
        public static void VectorToHomMat2d(
          HTuple px,
          HTuple py,
          HTuple qx,
          HTuple qy,
          out HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(269);
            HalconAPI.Store(proc, 0, px);
            HalconAPI.Store(proc, 1, py);
            HalconAPI.Store(proc, 2, qx);
            HalconAPI.Store(proc, 3, qy);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(qx);
            HalconAPI.UnpinTuple(qy);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Project pixel coordinates using a homogeneous projective transformation matrix.</summary>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        /// <param name="row">Input pixel(s) (row coordinate). Default: 64</param>
        /// <param name="col">Input pixel(s) (column coordinate). Default: 64</param>
        /// <param name="rowTrans">Output pixel(s) (row coordinate).</param>
        /// <param name="colTrans">Output pixel(s) (column coordinate).</param>
        public static void ProjectiveTransPixel(
          HTuple homMat2D,
          HTuple row,
          HTuple col,
          out HTuple rowTrans,
          out HTuple colTrans)
        {
            IntPtr proc = HalconAPI.PreCall(270);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, col);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(col);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowTrans);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out colTrans);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Project a homogeneous 2D point using a projective transformation matrix.</summary>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        /// <param name="px">Input point (x coordinate).</param>
        /// <param name="py">Input point (y coordinate).</param>
        /// <param name="pw">Input point (w coordinate).</param>
        /// <param name="qx">Output point (x coordinate).</param>
        /// <param name="qy">Output point (y coordinate).</param>
        /// <param name="qw">Output point (w coordinate).</param>
        public static void ProjectiveTransPoint2d(
          HTuple homMat2D,
          HTuple px,
          HTuple py,
          HTuple pw,
          out HTuple qx,
          out HTuple qy,
          out HTuple qw)
        {
            IntPtr proc = HalconAPI.PreCall(271);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.Store(proc, 3, pw);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(pw);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out qx);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out qy);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out qw);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Apply an arbitrary affine 2D transformation to pixel coordinates.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="row">Input pixel(s) (row coordinate). Default: 64</param>
        /// <param name="col">Input pixel(s) (column coordinate). Default: 64</param>
        /// <param name="rowTrans">Output pixel(s) (row coordinate).</param>
        /// <param name="colTrans">Output pixel(s) (column coordinate).</param>
        public static void AffineTransPixel(
          HTuple homMat2D,
          HTuple row,
          HTuple col,
          out HTuple rowTrans,
          out HTuple colTrans)
        {
            IntPtr proc = HalconAPI.PreCall(272);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, col);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(col);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowTrans);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out colTrans);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Apply an arbitrary affine 2D transformation to points.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="px">Input point(s) (x or row coordinate). Default: 64</param>
        /// <param name="py">Input point(s) (y or column coordinate). Default: 64</param>
        /// <param name="qx">Output point(s) (x or row coordinate).</param>
        /// <param name="qy">Output point(s) (y or column coordinate).</param>
        public static void AffineTransPoint2d(
          HTuple homMat2D,
          HTuple px,
          HTuple py,
          out HTuple qx,
          out HTuple qy)
        {
            IntPtr proc = HalconAPI.PreCall(273);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out qx);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out qy);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the determinant of a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="determinant">Determinant of the input matrix.</param>
        public static void HomMat2dDeterminant(HTuple homMat2D, out HTuple determinant)
        {
            IntPtr proc = HalconAPI.PreCall(274);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out determinant);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transpose a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="homMat2DTranspose">Output transformation matrix.</param>
        public static void HomMat2dTranspose(HTuple homMat2D, out HTuple homMat2DTranspose)
        {
            IntPtr proc = HalconAPI.PreCall(275);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DTranspose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Invert a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="homMat2DInvert">Output transformation matrix.</param>
        public static void HomMat2dInvert(HTuple homMat2D, out HTuple homMat2DInvert)
        {
            IntPtr proc = HalconAPI.PreCall(276);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DInvert);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Multiply two homogeneous 2D transformation matrices.</summary>
        /// <param name="homMat2DLeft">Left input transformation matrix.</param>
        /// <param name="homMat2DRight">Right input transformation matrix.</param>
        /// <param name="homMat2DCompose">Output transformation matrix.</param>
        public static void HomMat2dCompose(
          HTuple homMat2DLeft,
          HTuple homMat2DRight,
          out HTuple homMat2DCompose)
        {
            IntPtr proc = HalconAPI.PreCall(277);
            HalconAPI.Store(proc, 0, homMat2DLeft);
            HalconAPI.Store(proc, 1, homMat2DRight);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2DLeft);
            HalconAPI.UnpinTuple(homMat2DRight);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DCompose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a reflection to a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="px">Point that defines the axis (x coordinate). Default: 16</param>
        /// <param name="py">Point that defines the axis (y coordinate). Default: 32</param>
        /// <param name="homMat2DReflect">Output transformation matrix.</param>
        public static void HomMat2dReflectLocal(
          HTuple homMat2D,
          HTuple px,
          HTuple py,
          out HTuple homMat2DReflect)
        {
            IntPtr proc = HalconAPI.PreCall(278);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DReflect);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a reflection to a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="px">First point of the axis (x coordinate). Default: 0</param>
        /// <param name="py">First point of the axis (y coordinate). Default: 0</param>
        /// <param name="qx">Second point of the axis (x coordinate). Default: 16</param>
        /// <param name="qy">Second point of the axis (y coordinate). Default: 32</param>
        /// <param name="homMat2DReflect">Output transformation matrix.</param>
        public static void HomMat2dReflect(
          HTuple homMat2D,
          HTuple px,
          HTuple py,
          HTuple qx,
          HTuple qy,
          out HTuple homMat2DReflect)
        {
            IntPtr proc = HalconAPI.PreCall(279);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.Store(proc, 3, qx);
            HalconAPI.Store(proc, 4, qy);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(qx);
            HalconAPI.UnpinTuple(qy);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DReflect);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a slant to a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="theta">Slant angle. Default: 0.78</param>
        /// <param name="axis">Coordinate axis that is slanted. Default: "x"</param>
        /// <param name="homMat2DSlant">Output transformation matrix.</param>
        public static void HomMat2dSlantLocal(
          HTuple homMat2D,
          HTuple theta,
          HTuple axis,
          out HTuple homMat2DSlant)
        {
            IntPtr proc = HalconAPI.PreCall(280);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, theta);
            HalconAPI.Store(proc, 2, axis);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(theta);
            HalconAPI.UnpinTuple(axis);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DSlant);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a slant to a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="theta">Slant angle. Default: 0.78</param>
        /// <param name="axis">Coordinate axis that is slanted. Default: "x"</param>
        /// <param name="px">Fixed point of the transformation (x coordinate). Default: 0</param>
        /// <param name="py">Fixed point of the transformation (y coordinate). Default: 0</param>
        /// <param name="homMat2DSlant">Output transformation matrix.</param>
        public static void HomMat2dSlant(
          HTuple homMat2D,
          HTuple theta,
          HTuple axis,
          HTuple px,
          HTuple py,
          out HTuple homMat2DSlant)
        {
            IntPtr proc = HalconAPI.PreCall(281);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, theta);
            HalconAPI.Store(proc, 2, axis);
            HalconAPI.Store(proc, 3, px);
            HalconAPI.Store(proc, 4, py);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(theta);
            HalconAPI.UnpinTuple(axis);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DSlant);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a rotation to a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="phi">Rotation angle. Default: 0.78</param>
        /// <param name="homMat2DRotate">Output transformation matrix.</param>
        public static void HomMat2dRotateLocal(HTuple homMat2D, HTuple phi, out HTuple homMat2DRotate)
        {
            IntPtr proc = HalconAPI.PreCall(282);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, phi);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(phi);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DRotate);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a rotation to a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="phi">Rotation angle. Default: 0.78</param>
        /// <param name="px">Fixed point of the transformation (x coordinate). Default: 0</param>
        /// <param name="py">Fixed point of the transformation (y coordinate). Default: 0</param>
        /// <param name="homMat2DRotate">Output transformation matrix.</param>
        public static void HomMat2dRotate(
          HTuple homMat2D,
          HTuple phi,
          HTuple px,
          HTuple py,
          out HTuple homMat2DRotate)
        {
            IntPtr proc = HalconAPI.PreCall(283);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, phi);
            HalconAPI.Store(proc, 2, px);
            HalconAPI.Store(proc, 3, py);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DRotate);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a scaling to a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="sx">Scale factor along the x-axis. Default: 2</param>
        /// <param name="sy">Scale factor along the y-axis. Default: 2</param>
        /// <param name="homMat2DScale">Output transformation matrix.</param>
        public static void HomMat2dScaleLocal(
          HTuple homMat2D,
          HTuple sx,
          HTuple sy,
          out HTuple homMat2DScale)
        {
            IntPtr proc = HalconAPI.PreCall(284);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, sx);
            HalconAPI.Store(proc, 2, sy);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(sx);
            HalconAPI.UnpinTuple(sy);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DScale);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a scaling to a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="sx">Scale factor along the x-axis. Default: 2</param>
        /// <param name="sy">Scale factor along the y-axis. Default: 2</param>
        /// <param name="px">Fixed point of the transformation (x coordinate). Default: 0</param>
        /// <param name="py">Fixed point of the transformation (y coordinate). Default: 0</param>
        /// <param name="homMat2DScale">Output transformation matrix.</param>
        public static void HomMat2dScale(
          HTuple homMat2D,
          HTuple sx,
          HTuple sy,
          HTuple px,
          HTuple py,
          out HTuple homMat2DScale)
        {
            IntPtr proc = HalconAPI.PreCall(285);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, sx);
            HalconAPI.Store(proc, 2, sy);
            HalconAPI.Store(proc, 3, px);
            HalconAPI.Store(proc, 4, py);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(sx);
            HalconAPI.UnpinTuple(sy);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DScale);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a translation to a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="tx">Translation along the x-axis. Default: 64</param>
        /// <param name="ty">Translation along the y-axis. Default: 64</param>
        /// <param name="homMat2DTranslate">Output transformation matrix.</param>
        public static void HomMat2dTranslateLocal(
          HTuple homMat2D,
          HTuple tx,
          HTuple ty,
          out HTuple homMat2DTranslate)
        {
            IntPtr proc = HalconAPI.PreCall(286);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, tx);
            HalconAPI.Store(proc, 2, ty);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(tx);
            HalconAPI.UnpinTuple(ty);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DTranslate);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a translation to a homogeneous 2D transformation matrix.</summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="tx">Translation along the x-axis. Default: 64</param>
        /// <param name="ty">Translation along the y-axis. Default: 64</param>
        /// <param name="homMat2DTranslate">Output transformation matrix.</param>
        public static void HomMat2dTranslate(
          HTuple homMat2D,
          HTuple tx,
          HTuple ty,
          out HTuple homMat2DTranslate)
        {
            IntPtr proc = HalconAPI.PreCall(287);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, tx);
            HalconAPI.Store(proc, 2, ty);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(tx);
            HalconAPI.UnpinTuple(ty);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DTranslate);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate the homogeneous transformation matrix of the identical 2D transformation.</summary>
        /// <param name="homMat2DIdentity">Transformation matrix.</param>
        public static void HomMat2dIdentity(out HTuple homMat2DIdentity)
        {
            IntPtr proc = HalconAPI.PreCall(288);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2DIdentity);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all scattered data interpolators.</summary>
        public static void ClearAllScatteredDataInterpolators()
        {
            IntPtr proc = HalconAPI.PreCall(289);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a scattered data interpolator.</summary>
        /// <param name="scatteredDataInterpolatorHandle">Handle of the scattered data interpolator</param>
        public static void ClearScatteredDataInterpolator(HTuple scatteredDataInterpolatorHandle)
        {
            IntPtr proc = HalconAPI.PreCall(290);
            HalconAPI.Store(proc, 0, scatteredDataInterpolatorHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scatteredDataInterpolatorHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interpolation of scattered data using a scattered data interpolator.</summary>
        /// <param name="scatteredDataInterpolatorHandle">Handle of the scattered data interpolator</param>
        /// <param name="row">Row coordinates of points  to be interpolated</param>
        /// <param name="column">Column coordinates of points  to be interpolated</param>
        /// <param name="valueInterpolated">Values of interpolated points</param>
        public static void InterpolateScatteredData(
          HTuple scatteredDataInterpolatorHandle,
          HTuple row,
          HTuple column,
          out HTuple valueInterpolated)
        {
            IntPtr proc = HalconAPI.PreCall(291);
            HalconAPI.Store(proc, 0, scatteredDataInterpolatorHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scatteredDataInterpolatorHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HTuple.LoadNew(proc, 0, err, out valueInterpolated);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Creates an interpolator for the interpolation of scattered data.</summary>
        /// <param name="method">Method for the interpolation Default: "thin_plate_splines"</param>
        /// <param name="rows">Row coordinates of the points used  for the interpolation</param>
        /// <param name="columns">Column coordinates of the points used  for the interpolation</param>
        /// <param name="values">Values of the points used  for the interpolation</param>
        /// <param name="genParamName">Names of the generic parameters  that can be adjusted Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted Default: []</param>
        /// <param name="scatteredDataInterpolatorHandle">Handle of the scattered data interpolator</param>
        public static void CreateScatteredDataInterpolator(
          HTuple method,
          HTuple rows,
          HTuple columns,
          HTuple values,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple scatteredDataInterpolatorHandle)
        {
            IntPtr proc = HalconAPI.PreCall(292);
            HalconAPI.Store(proc, 0, method);
            HalconAPI.Store(proc, 1, rows);
            HalconAPI.Store(proc, 2, columns);
            HalconAPI.Store(proc, 3, values);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(rows);
            HalconAPI.UnpinTuple(columns);
            HalconAPI.UnpinTuple(values);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out scatteredDataInterpolatorHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Creating an image from the interpolation of scattered data.</summary>
        /// <param name="imageInterpolated">Interpolated image</param>
        /// <param name="method">Method for the interpolation Default: "thin_plate_splines"</param>
        /// <param name="rows">Row coordinates of the points used for the interpolation</param>
        /// <param name="columns">Column coordinates of the points  used for the interpolation</param>
        /// <param name="values">Values of the points used for the interpolation</param>
        /// <param name="width">Width of the interpolated image Default: 640</param>
        /// <param name="height">Height of the interpolated image Default: 480</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted Default: []</param>
        public static void InterpolateScatteredDataPointsToImage(
          out HObject imageInterpolated,
          HTuple method,
          HTuple rows,
          HTuple columns,
          HTuple values,
          HTuple width,
          HTuple height,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(293);
            HalconAPI.Store(proc, 0, method);
            HalconAPI.Store(proc, 1, rows);
            HalconAPI.Store(proc, 2, columns);
            HalconAPI.Store(proc, 3, values);
            HalconAPI.Store(proc, 4, width);
            HalconAPI.Store(proc, 5, height);
            HalconAPI.Store(proc, 6, genParamName);
            HalconAPI.Store(proc, 7, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(rows);
            HalconAPI.UnpinTuple(columns);
            HalconAPI.UnpinTuple(values);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HObject.LoadNew(proc, 1, err, out imageInterpolated);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interpolation of an image.</summary>
        /// <param name="image">Image to interpolate</param>
        /// <param name="regionInterpolate">Region to interpolate</param>
        /// <param name="imageInterpolated">Interpolated image</param>
        /// <param name="method">Method for the interpolation Default: "thin_plate_splines"</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted Default: []</param>
        public static void InterpolateScatteredDataImage(
          HObject image,
          HObject regionInterpolate,
          out HObject imageInterpolated,
          HTuple method,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(294);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)regionInterpolate);
            HalconAPI.Store(proc, 0, method);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HObject.LoadNew(proc, 1, err, out imageInterpolated);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)regionInterpolate);
        }

        /// <summary>Read out the system time.</summary>
        /// <param name="MSecond">Milliseconds (0..999).</param>
        /// <param name="second">Seconds (0..59).</param>
        /// <param name="minute">Minutes (0..59).</param>
        /// <param name="hour">Hours (0..23).</param>
        /// <param name="day">Day of the month (1..31).</param>
        /// <param name="YDay">Day of the year (1..366).</param>
        /// <param name="month">Month (1..12).</param>
        /// <param name="year">Year (xxxx).</param>
        public static void GetSystemTime(
          out HTuple MSecond,
          out HTuple second,
          out HTuple minute,
          out HTuple hour,
          out HTuple day,
          out HTuple YDay,
          out HTuple month,
          out HTuple year)
        {
            IntPtr proc = HalconAPI.PreCall(295);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out MSecond);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out second);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out minute);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out hour);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out day);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out YDay);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.INTEGER, err7, out month);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.INTEGER, err8, out year);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query compute device parameters.</summary>
        /// <param name="deviceHandle">Compute device handle.</param>
        /// <param name="genParamName">Name of the parameter to query. Default: "buffer_cache_capacity"</param>
        /// <param name="genParamValue">Value of the parameter.</param>
        public static void GetComputeDeviceParam(
          HTuple deviceHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(296);
            HalconAPI.Store(proc, 0, deviceHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deviceHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters of an compute device.</summary>
        /// <param name="deviceHandle">Compute device handle.</param>
        /// <param name="genParamName">Name of the parameter to set. Default: "buffer_cache_capacity"</param>
        /// <param name="genParamValue">New parameter value.</param>
        public static void SetComputeDeviceParam(
          HTuple deviceHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(297);
            HalconAPI.Store(proc, 0, deviceHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deviceHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close all compute devices.</summary>
        public static void ReleaseAllComputeDevices()
        {
            IntPtr proc = HalconAPI.PreCall(298);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close a compute_device.</summary>
        /// <param name="deviceHandle">Compute device handle.</param>
        public static void ReleaseComputeDevice(HTuple deviceHandle)
        {
            IntPtr proc = HalconAPI.PreCall(299);
            HalconAPI.Store(proc, 0, deviceHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deviceHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deactivate all compute devices.</summary>
        public static void DeactivateAllComputeDevices()
        {
            IntPtr proc = HalconAPI.PreCall(300);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deactivate a compute device.</summary>
        /// <param name="deviceHandle">Compute device handle.</param>
        public static void DeactivateComputeDevice(HTuple deviceHandle)
        {
            IntPtr proc = HalconAPI.PreCall(301);
            HalconAPI.Store(proc, 0, deviceHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deviceHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Activate a compute device.</summary>
        /// <param name="deviceHandle">Compute device handle.</param>
        public static void ActivateComputeDevice(HTuple deviceHandle)
        {
            IntPtr proc = HalconAPI.PreCall(302);
            HalconAPI.Store(proc, 0, deviceHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deviceHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Initialize a compute device.</summary>
        /// <param name="deviceHandle">Compute device handle.</param>
        /// <param name="operators">List of operators to prepare. Default: "all"</param>
        public static void InitComputeDevice(HTuple deviceHandle, HTuple operators)
        {
            IntPtr proc = HalconAPI.PreCall(303);
            HalconAPI.Store(proc, 0, deviceHandle);
            HalconAPI.Store(proc, 1, operators);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deviceHandle);
            HalconAPI.UnpinTuple(operators);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open a compute device.</summary>
        /// <param name="deviceIdentifier">Compute device Identifier.</param>
        /// <param name="deviceHandle">Compute device handle.</param>
        public static void OpenComputeDevice(HTuple deviceIdentifier, out HTuple deviceHandle)
        {
            IntPtr proc = HalconAPI.PreCall(304);
            HalconAPI.Store(proc, 0, deviceIdentifier);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deviceIdentifier);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out deviceHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get information on a compute device.</summary>
        /// <param name="deviceIdentifier">Compute device handle.</param>
        /// <param name="infoName">Name of Information to query. Default: "name"</param>
        /// <param name="info">Returned information.</param>
        public static void GetComputeDeviceInfo(
          HTuple deviceIdentifier,
          HTuple infoName,
          out HTuple info)
        {
            IntPtr proc = HalconAPI.PreCall(305);
            HalconAPI.Store(proc, 0, deviceIdentifier);
            HalconAPI.Store(proc, 1, infoName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deviceIdentifier);
            HalconAPI.UnpinTuple(infoName);
            int procResult = HTuple.LoadNew(proc, 0, err, out info);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the list of available compute devices.</summary>
        /// <param name="deviceIdentifier">List of available compute devices.</param>
        public static void QueryAvailableComputeDevices(out HTuple deviceIdentifier)
        {
            IntPtr proc = HalconAPI.PreCall(306);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out deviceIdentifier);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear the buffer of a serial connection.</summary>
        /// <param name="serialHandle">Serial interface handle.</param>
        /// <param name="channel">Buffer to be cleared. Default: "input"</param>
        public static void ClearSerial(HTuple serialHandle, HTuple channel)
        {
            IntPtr proc = HalconAPI.PreCall(307);
            HalconAPI.Store(proc, 0, serialHandle);
            HalconAPI.Store(proc, 1, channel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serialHandle);
            HalconAPI.UnpinTuple(channel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write to a serial connection.</summary>
        /// <param name="serialHandle">Serial interface handle.</param>
        /// <param name="data">Characters to write (as tuple of integers).</param>
        public static void WriteSerial(HTuple serialHandle, HTuple data)
        {
            IntPtr proc = HalconAPI.PreCall(308);
            HalconAPI.Store(proc, 0, serialHandle);
            HalconAPI.Store(proc, 1, data);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serialHandle);
            HalconAPI.UnpinTuple(data);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read from a serial device.</summary>
        /// <param name="serialHandle">Serial interface handle.</param>
        /// <param name="numCharacters">Number of characters to read. Default: 1</param>
        /// <param name="data">Read characters (as tuple of integers).</param>
        public static void ReadSerial(HTuple serialHandle, HTuple numCharacters, out HTuple data)
        {
            IntPtr proc = HalconAPI.PreCall(309);
            HalconAPI.Store(proc, 0, serialHandle);
            HalconAPI.Store(proc, 1, numCharacters);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serialHandle);
            HalconAPI.UnpinTuple(numCharacters);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out data);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the parameters of a serial device.</summary>
        /// <param name="serialHandle">Serial interface handle.</param>
        /// <param name="baudRate">Speed of the serial interface.</param>
        /// <param name="dataBits">Number of data bits of the serial interface.</param>
        /// <param name="flowControl">Type of flow control of the serial interface.</param>
        /// <param name="parity">Parity of the serial interface.</param>
        /// <param name="stopBits">Number of stop bits of the serial interface.</param>
        /// <param name="totalTimeOut">Total timeout of the serial interface in ms.</param>
        /// <param name="interCharTimeOut">Inter-character timeout of the serial interface in ms.</param>
        public static void GetSerialParam(
          HTuple serialHandle,
          out HTuple baudRate,
          out HTuple dataBits,
          out HTuple flowControl,
          out HTuple parity,
          out HTuple stopBits,
          out HTuple totalTimeOut,
          out HTuple interCharTimeOut)
        {
            IntPtr proc = HalconAPI.PreCall(310);
            HalconAPI.Store(proc, 0, serialHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serialHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out baudRate);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out dataBits);
            int err4 = HTuple.LoadNew(proc, 2, err3, out flowControl);
            int err5 = HTuple.LoadNew(proc, 3, err4, out parity);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out stopBits);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out totalTimeOut);
            int procResult = HTuple.LoadNew(proc, 6, HTupleType.INTEGER, err7, out interCharTimeOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the parameters of a serial device.</summary>
        /// <param name="serialHandle">Serial interface handle.</param>
        /// <param name="baudRate">Speed of the serial interface. Default: "unchanged"</param>
        /// <param name="dataBits">Number of data bits of the serial interface. Default: "unchanged"</param>
        /// <param name="flowControl">Type of flow control of the serial interface. Default: "unchanged"</param>
        /// <param name="parity">Parity of the serial interface. Default: "unchanged"</param>
        /// <param name="stopBits">Number of stop bits of the serial interface. Default: "unchanged"</param>
        /// <param name="totalTimeOut">Total timeout of the serial interface in ms. Default: "unchanged"</param>
        /// <param name="interCharTimeOut">Inter-character timeout of the serial interface in ms. Default: "unchanged"</param>
        public static void SetSerialParam(
          HTuple serialHandle,
          HTuple baudRate,
          HTuple dataBits,
          HTuple flowControl,
          HTuple parity,
          HTuple stopBits,
          HTuple totalTimeOut,
          HTuple interCharTimeOut)
        {
            IntPtr proc = HalconAPI.PreCall(311);
            HalconAPI.Store(proc, 0, serialHandle);
            HalconAPI.Store(proc, 1, baudRate);
            HalconAPI.Store(proc, 2, dataBits);
            HalconAPI.Store(proc, 3, flowControl);
            HalconAPI.Store(proc, 4, parity);
            HalconAPI.Store(proc, 5, stopBits);
            HalconAPI.Store(proc, 6, totalTimeOut);
            HalconAPI.Store(proc, 7, interCharTimeOut);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serialHandle);
            HalconAPI.UnpinTuple(baudRate);
            HalconAPI.UnpinTuple(dataBits);
            HalconAPI.UnpinTuple(flowControl);
            HalconAPI.UnpinTuple(parity);
            HalconAPI.UnpinTuple(stopBits);
            HalconAPI.UnpinTuple(totalTimeOut);
            HalconAPI.UnpinTuple(interCharTimeOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close all serial devices.</summary>
        public static void CloseAllSerials()
        {
            IntPtr proc = HalconAPI.PreCall(312);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close a serial device.</summary>
        /// <param name="serialHandle">Serial interface handle.</param>
        public static void CloseSerial(HTuple serialHandle)
        {
            IntPtr proc = HalconAPI.PreCall(313);
            HalconAPI.Store(proc, 0, serialHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serialHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open a serial device.</summary>
        /// <param name="portName">Name of the serial port. Default: "COM1"</param>
        /// <param name="serialHandle">Serial interface handle.</param>
        public static void OpenSerial(HTuple portName, out HTuple serialHandle)
        {
            IntPtr proc = HalconAPI.PreCall(314);
            HalconAPI.Store(proc, 0, portName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(portName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serialHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delaying the execution of the program.</summary>
        /// <param name="seconds">Number of seconds by which the execution of the program will be delayed. Default: 10</param>
        public static void WaitSeconds(HTuple seconds)
        {
            IntPtr proc = HalconAPI.PreCall(315);
            HalconAPI.Store(proc, 0, seconds);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(seconds);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Execute a system command.</summary>
        /// <param name="command">Command to be called by the system. Default: "ls"</param>
        public static void SystemCall(HTuple command)
        {
            IntPtr proc = HalconAPI.PreCall(316);
            HalconAPI.Store(proc, 0, command);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(command);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set HALCON system parameters.</summary>
        /// <param name="systemParameter">Name of the system parameter to be changed. Default: "init_new_image"</param>
        /// <param name="value">New value of the system parameter. Default: "true"</param>
        public static void SetSystem(HTuple systemParameter, HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(317);
            HalconAPI.Store(proc, 0, systemParameter);
            HalconAPI.Store(proc, 1, value);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(systemParameter);
            HalconAPI.UnpinTuple(value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Activating and deactivating of HALCON control modes.</summary>
        /// <param name="check">Desired control mode. Default: "default"</param>
        public static void SetCheck(HTuple check)
        {
            //IntPtr proc = HalconAPI.PreCall(318);
            //HalconAPI.Store(proc, 0, check);
            //int procResult = HalconAPI.CallProcedure(proc);
            //HalconAPI.UnpinTuple(check);
            //HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Initialization of the HALCON system.</summary>
        /// <param name="defaultImageWidth">Default image width (in pixels). Default: 128</param>
        /// <param name="defaultImageHeight">Default image height (in pixels). Default: 128</param>
        /// <param name="defaultChannels">Usual number of channels. Default: 0</param>
        public static void ResetObjDb(
          HTuple defaultImageWidth,
          HTuple defaultImageHeight,
          HTuple defaultChannels)
        {
            IntPtr proc = HalconAPI.PreCall(319);
            HalconAPI.Store(proc, 0, defaultImageWidth);
            HalconAPI.Store(proc, 1, defaultImageHeight);
            HalconAPI.Store(proc, 2, defaultChannels);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(defaultImageWidth);
            HalconAPI.UnpinTuple(defaultImageHeight);
            HalconAPI.UnpinTuple(defaultChannels);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get current value of HALCON system parameters.</summary>
        /// <param name="query">Desired system parameter. Default: "init_new_image"</param>
        /// <param name="information">Current value of the system parameter.</param>
        public static void GetSystem(HTuple query, out HTuple information)
        {
            IntPtr proc = HalconAPI.PreCall(320);
            HalconAPI.Store(proc, 0, query);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(query);
            int procResult = HTuple.LoadNew(proc, 0, err, out information);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>State of the HALCON control modes.</summary>
        /// <param name="check">Tuplet of the currently activated control modes.</param>
        public static void GetCheck(out HTuple check)
        {
            IntPtr proc = HalconAPI.PreCall(321);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, err, out check);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Inquiry after the error text of a HALCON error number.</summary>
        /// <param name="errorCode">HALCON error code.</param>
        /// <param name="errorMessage">Corresponding error message.</param>
        public static void GetErrorText(HTuple errorCode, out HTuple errorMessage)
        {
            IntPtr proc = HalconAPI.PreCall(322);
            HalconAPI.Store(proc, 0, errorCode);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(errorCode);
            int procResult = HTuple.LoadNew(proc, 0, err, out errorMessage);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Passed Time.</summary>
        /// <param name="seconds">Processtime since the program start.</param>
        public static void CountSeconds(out HTuple seconds)
        {
            IntPtr proc = HalconAPI.PreCall(323);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out seconds);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Number of entries in the HALCON database.</summary>
        /// <param name="relationName">Relation of interest of the HALCON database. Default: "object"</param>
        /// <param name="numOfTuples">Number of tuples in the relation.</param>
        public static void CountRelation(HTuple relationName, out HTuple numOfTuples)
        {
            IntPtr proc = HalconAPI.PreCall(324);
            HalconAPI.Store(proc, 0, relationName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(relationName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out numOfTuples);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Receive an image over a socket connection.</summary>
        /// <param name="image">Received image.</param>
        /// <param name="socket">Socket number.</param>
        public static void ReceiveImage(out HObject image, HTuple socket)
        {
            IntPtr proc = HalconAPI.PreCall(325);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Send an image over a socket connection.</summary>
        /// <param name="image">Image to be sent.</param>
        /// <param name="socket">Socket number.</param>
        public static void SendImage(HObject image, HTuple socket)
        {
            IntPtr proc = HalconAPI.PreCall(326);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, socket);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Receive regions over a socket connection.</summary>
        /// <param name="region">Received regions.</param>
        /// <param name="socket">Socket number.</param>
        public static void ReceiveRegion(out HObject region, HTuple socket)
        {
            IntPtr proc = HalconAPI.PreCall(327);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Send regions over a socket connection.</summary>
        /// <param name="region">Regions to be sent.</param>
        /// <param name="socket">Socket number.</param>
        public static void SendRegion(HObject region, HTuple socket)
        {
            IntPtr proc = HalconAPI.PreCall(328);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, socket);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Receive an XLD object over a socket connection.</summary>
        /// <param name="XLD">Received XLD object.</param>
        /// <param name="socket">Socket number.</param>
        public static void ReceiveXld(out HObject XLD, HTuple socket)
        {
            IntPtr proc = HalconAPI.PreCall(329);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            int procResult = HObject.LoadNew(proc, 1, err, out XLD);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Send an XLD object over a socket connection.</summary>
        /// <param name="XLD">XLD object to be sent.</param>
        /// <param name="socket">Socket number.</param>
        public static void SendXld(HObject XLD, HTuple socket)
        {
            IntPtr proc = HalconAPI.PreCall(330);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.Store(proc, 0, socket);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Receive a tuple over a socket connection.</summary>
        /// <param name="socket">Socket number.</param>
        /// <param name="tuple">Received tuple.</param>
        public static void ReceiveTuple(HTuple socket, out HTuple tuple)
        {
            IntPtr proc = HalconAPI.PreCall(331);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            int procResult = HTuple.LoadNew(proc, 0, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Send a tuple over a socket connection.</summary>
        /// <param name="socket">Socket number.</param>
        /// <param name="tuple">Tuple to be sent.</param>
        public static void SendTuple(HTuple socket, HTuple tuple)
        {
            IntPtr proc = HalconAPI.PreCall(332);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.Store(proc, 1, tuple);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            HalconAPI.UnpinTuple(tuple);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Receive arbitrary data from external devices or applications using a generic socket connection.</summary>
        /// <param name="socket">Socket number.</param>
        /// <param name="format">Specification how to convert the data to tuples. Default: "z"</param>
        /// <param name="data">Value (or tuple of values) holding the received and converted data.</param>
        /// <param name="from">IP address or hostname and network port of the communication partner.</param>
        public static void ReceiveData(HTuple socket, HTuple format, out HTuple data, out HTuple from)
        {
            IntPtr proc = HalconAPI.PreCall(333);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.Store(proc, 1, format);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            HalconAPI.UnpinTuple(format);
            int err2 = HTuple.LoadNew(proc, 0, err1, out data);
            int procResult = HTuple.LoadNew(proc, 1, err2, out from);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Send arbitrary data to external devices or applications using a generic socket communication.</summary>
        /// <param name="socket">Socket number.</param>
        /// <param name="format">Specification how to convert the data. Default: "z"</param>
        /// <param name="data">Value (or tuple of values) holding the data to send.</param>
        /// <param name="to">IP address or hostname and network port of the communication partner. Default: []</param>
        public static void SendData(HTuple socket, HTuple format, HTuple data, HTuple to)
        {
            IntPtr proc = HalconAPI.PreCall(334);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.Store(proc, 1, format);
            HalconAPI.Store(proc, 2, data);
            HalconAPI.Store(proc, 3, to);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            HalconAPI.UnpinTuple(format);
            HalconAPI.UnpinTuple(data);
            HalconAPI.UnpinTuple(to);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the value of a socket parameter.</summary>
        /// <param name="socket">Socket number.</param>
        /// <param name="genParamName">Name of the socket parameter.</param>
        /// <param name="genParamValue">Value of the socket parameter.</param>
        public static void GetSocketParam(HTuple socket, HTuple genParamName, out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(335);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set a socket parameter.</summary>
        /// <param name="socket">Socket number.</param>
        /// <param name="genParamName">Name of the socket parameter.</param>
        /// <param name="genParamValue">Value of the socket parameter. Default: "on"</param>
        public static void SetSocketParam(HTuple socket, HTuple genParamName, HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(336);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Determine the HALCON data type of the next socket data.</summary>
        /// <param name="socket">Socket number.</param>
        /// <param name="dataType">Data type of next HALCON data.</param>
        public static void GetNextSocketDataType(HTuple socket, out HTuple dataType)
        {
            IntPtr proc = HalconAPI.PreCall(337);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            int procResult = HTuple.LoadNew(proc, 0, err, out dataType);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the socket descriptor of a socket used by the operating system.</summary>
        /// <param name="socket">Socket number.</param>
        /// <param name="socketDescriptor">Socket descriptor used by the operating system.</param>
        public static void GetSocketDescriptor(HTuple socket, out HTuple socketDescriptor)
        {
            IntPtr proc = HalconAPI.PreCall(338);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out socketDescriptor);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close all opened sockets.</summary>
        public static void CloseAllSockets()
        {
            IntPtr proc = HalconAPI.PreCall(339);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close a socket.</summary>
        /// <param name="socket">Socket number.</param>
        public static void CloseSocket(HTuple socket)
        {
            IntPtr proc = HalconAPI.PreCall(340);
            HalconAPI.Store(proc, 0, socket);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Accept a connection request on a listening socket of the protocol type 'HALCON' or 'TCP'/'TCP4'/'TCP6'.</summary>
        /// <param name="acceptingSocket">Socket number of the accepting socket.</param>
        /// <param name="wait">Should the operator wait until a connection request arrives? Default: "auto"</param>
        /// <param name="socket">Socket number.</param>
        public static void SocketAcceptConnect(HTuple acceptingSocket, HTuple wait, out HTuple socket)
        {
            IntPtr proc = HalconAPI.PreCall(341);
            HalconAPI.Store(proc, 0, acceptingSocket);
            HalconAPI.Store(proc, 1, wait);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acceptingSocket);
            HalconAPI.UnpinTuple(wait);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out socket);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open a socket and connect it to an accepting socket.</summary>
        /// <param name="hostName">Hostname of the computer to connect to. Default: "localhost"</param>
        /// <param name="port">Port number.</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the socket. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the socket. Default: []</param>
        /// <param name="socket">Socket number.</param>
        public static void OpenSocketConnect(
          HTuple hostName,
          HTuple port,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple socket)
        {
            IntPtr proc = HalconAPI.PreCall(342);
            HalconAPI.Store(proc, 0, hostName);
            HalconAPI.Store(proc, 1, port);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(hostName);
            HalconAPI.UnpinTuple(port);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out socket);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open a socket that accepts connection requests.</summary>
        /// <param name="port">Port number. Default: 3000</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the socket. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the socket. Default: []</param>
        /// <param name="acceptingSocket">Socket number.</param>
        public static void OpenSocketAccept(
          HTuple port,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple acceptingSocket)
        {
            IntPtr proc = HalconAPI.PreCall(343);
            HalconAPI.Store(proc, 0, port);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(port);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out acceptingSocket);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Returns the extended error information for the calling thread's last HALCON error.</summary>
        /// <param name="operatorName">Operator that set the error code.</param>
        /// <param name="errorCode">Extended error code.</param>
        /// <param name="errorMessage">Extended error message.</param>
        public static void GetExtendedErrorInfo(
          out HTuple operatorName,
          out HTuple errorCode,
          out HTuple errorMessage)
        {
            IntPtr proc = HalconAPI.PreCall(344);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, err1, out operatorName);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out errorCode);
            int procResult = HTuple.LoadNew(proc, 2, err3, out errorMessage);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query of used modules and the module key.</summary>
        /// <param name="usedModules">Names of used modules.</param>
        /// <param name="moduleKey">Key for license manager.</param>
        public static void GetModules(out HTuple usedModules, out HTuple moduleKey)
        {
            IntPtr proc = HalconAPI.PreCall(345);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, err1, out usedModules);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out moduleKey);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the distance values for a rectified stereo image pair using multi-scanline optimization.</summary>
        /// <param name="imageRect1">Rectified image of camera 1.</param>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="distance">Distance image.</param>
        /// <param name="score">Score of the calculated disparity.</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: -30</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="surfaceSmoothing">Smoothing of surfaces. Default: 50</param>
        /// <param name="edgeSmoothing">Smoothing of edges. Default: 50</param>
        /// <param name="genParamName">Parameter name(s) for the multi-scanline algorithm. Default: []</param>
        /// <param name="genParamValue">Parameter value(s) for the multi-scanline algorithm. Default: []</param>
        public static void BinocularDistanceMs(
          HObject imageRect1,
          HObject imageRect2,
          out HObject distance,
          out HObject score,
          HTuple camParamRect1,
          HTuple camParamRect2,
          HTuple relPoseRect,
          HTuple minDisparity,
          HTuple maxDisparity,
          HTuple surfaceSmoothing,
          HTuple edgeSmoothing,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(346);
            HalconAPI.Store(proc, 1, (HObjectBase)imageRect1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, camParamRect1);
            HalconAPI.Store(proc, 1, camParamRect2);
            HalconAPI.Store(proc, 2, relPoseRect);
            HalconAPI.Store(proc, 3, minDisparity);
            HalconAPI.Store(proc, 4, maxDisparity);
            HalconAPI.Store(proc, 5, surfaceSmoothing);
            HalconAPI.Store(proc, 6, edgeSmoothing);
            HalconAPI.Store(proc, 7, genParamName);
            HalconAPI.Store(proc, 8, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParamRect1);
            HalconAPI.UnpinTuple(camParamRect2);
            HalconAPI.UnpinTuple(relPoseRect);
            HalconAPI.UnpinTuple(minDisparity);
            HalconAPI.UnpinTuple(maxDisparity);
            HalconAPI.UnpinTuple(surfaceSmoothing);
            HalconAPI.UnpinTuple(edgeSmoothing);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HObject.LoadNew(proc, 1, err1, out distance);
            int procResult = HObject.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageRect1);
            GC.KeepAlive((object)imageRect2);
        }

        /// <summary>Compute the disparities of a rectified stereo image pair using multi-scanline optimization.</summary>
        /// <param name="imageRect1">Rectified image of camera 1.</param>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="disparity">Disparity map.</param>
        /// <param name="score">Score of the calculated disparity.</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: -30</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="surfaceSmoothing">Smoothing of surfaces. Default: 50</param>
        /// <param name="edgeSmoothing">Smoothing of edges. Default: 50</param>
        /// <param name="genParamName">Parameter name(s) for the multi-scanline algorithm. Default: []</param>
        /// <param name="genParamValue">Parameter value(s) for the multi-scanline algorithm. Default: []</param>
        public static void BinocularDisparityMs(
          HObject imageRect1,
          HObject imageRect2,
          out HObject disparity,
          out HObject score,
          HTuple minDisparity,
          HTuple maxDisparity,
          HTuple surfaceSmoothing,
          HTuple edgeSmoothing,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(347);
            HalconAPI.Store(proc, 1, (HObjectBase)imageRect1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, minDisparity);
            HalconAPI.Store(proc, 1, maxDisparity);
            HalconAPI.Store(proc, 2, surfaceSmoothing);
            HalconAPI.Store(proc, 3, edgeSmoothing);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minDisparity);
            HalconAPI.UnpinTuple(maxDisparity);
            HalconAPI.UnpinTuple(surfaceSmoothing);
            HalconAPI.UnpinTuple(edgeSmoothing);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HObject.LoadNew(proc, 1, err1, out disparity);
            int procResult = HObject.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageRect1);
            GC.KeepAlive((object)imageRect2);
        }

        /// <summary>Compute the distance values for a rectified stereo image pair using multigrid methods.</summary>
        /// <param name="imageRect1">Rectified image of camera 1.</param>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="distance">Distance image.</param>
        /// <param name="score">Score of the calculated disparity if CalculateScore is set to 'true'.</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <param name="grayConstancy">Weight of the gray value constancy in the data term. Default: 1.0</param>
        /// <param name="gradientConstancy">Weight of the gradient constancy in the data term. Default: 30.0</param>
        /// <param name="smoothness">Weight of the smoothness term in relation to the data term. Default: 5.0</param>
        /// <param name="initialGuess">Initial guess of the disparity. Default: 0.0</param>
        /// <param name="calculateScore">Should the quality measure be returned in Score? Default: "false"</param>
        /// <param name="MGParamName">Parameter name(s) for the multigrid algorithm. Default: "default_parameters"</param>
        /// <param name="MGParamValue">Parameter value(s) for the multigrid algorithm. Default: "fast_accurate"</param>
        public static void BinocularDistanceMg(
          HObject imageRect1,
          HObject imageRect2,
          out HObject distance,
          out HObject score,
          HTuple camParamRect1,
          HTuple camParamRect2,
          HTuple relPoseRect,
          HTuple grayConstancy,
          HTuple gradientConstancy,
          HTuple smoothness,
          HTuple initialGuess,
          HTuple calculateScore,
          HTuple MGParamName,
          HTuple MGParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(348);
            HalconAPI.Store(proc, 1, (HObjectBase)imageRect1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, camParamRect1);
            HalconAPI.Store(proc, 1, camParamRect2);
            HalconAPI.Store(proc, 2, relPoseRect);
            HalconAPI.Store(proc, 3, grayConstancy);
            HalconAPI.Store(proc, 4, gradientConstancy);
            HalconAPI.Store(proc, 5, smoothness);
            HalconAPI.Store(proc, 6, initialGuess);
            HalconAPI.Store(proc, 7, calculateScore);
            HalconAPI.Store(proc, 8, MGParamName);
            HalconAPI.Store(proc, 9, MGParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParamRect1);
            HalconAPI.UnpinTuple(camParamRect2);
            HalconAPI.UnpinTuple(relPoseRect);
            HalconAPI.UnpinTuple(grayConstancy);
            HalconAPI.UnpinTuple(gradientConstancy);
            HalconAPI.UnpinTuple(smoothness);
            HalconAPI.UnpinTuple(initialGuess);
            HalconAPI.UnpinTuple(calculateScore);
            HalconAPI.UnpinTuple(MGParamName);
            HalconAPI.UnpinTuple(MGParamValue);
            int err2 = HObject.LoadNew(proc, 1, err1, out distance);
            int procResult = HObject.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageRect1);
            GC.KeepAlive((object)imageRect2);
        }

        /// <summary>Compute the disparities of a rectified stereo image pair using multigrid methods.</summary>
        /// <param name="imageRect1">Rectified image of camera 1.</param>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="disparity">Disparity map.</param>
        /// <param name="score">Score of the calculated disparity if CalculateScore is set to 'true'.</param>
        /// <param name="grayConstancy">Weight of the gray value constancy in the data term. Default: 1.0</param>
        /// <param name="gradientConstancy">Weight of the gradient constancy in the data term. Default: 30.0</param>
        /// <param name="smoothness">Weight of the smoothness term in relation to the data term. Default: 5.0</param>
        /// <param name="initialGuess">Initial guess of the disparity. Default: 0.0</param>
        /// <param name="calculateScore">Should the quality measure should be returned in Score? Default: "false"</param>
        /// <param name="MGParamName">Parameter name(s) for the multigrid algorithm. Default: "default_parameters"</param>
        /// <param name="MGParamValue">Parameter value(s) for the multigrid algorithm. Default: "fast_accurate"</param>
        public static void BinocularDisparityMg(
          HObject imageRect1,
          HObject imageRect2,
          out HObject disparity,
          out HObject score,
          HTuple grayConstancy,
          HTuple gradientConstancy,
          HTuple smoothness,
          HTuple initialGuess,
          HTuple calculateScore,
          HTuple MGParamName,
          HTuple MGParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(349);
            HalconAPI.Store(proc, 1, (HObjectBase)imageRect1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, grayConstancy);
            HalconAPI.Store(proc, 1, gradientConstancy);
            HalconAPI.Store(proc, 2, smoothness);
            HalconAPI.Store(proc, 3, initialGuess);
            HalconAPI.Store(proc, 4, calculateScore);
            HalconAPI.Store(proc, 5, MGParamName);
            HalconAPI.Store(proc, 6, MGParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(grayConstancy);
            HalconAPI.UnpinTuple(gradientConstancy);
            HalconAPI.UnpinTuple(smoothness);
            HalconAPI.UnpinTuple(initialGuess);
            HalconAPI.UnpinTuple(calculateScore);
            HalconAPI.UnpinTuple(MGParamName);
            HalconAPI.UnpinTuple(MGParamValue);
            int err2 = HObject.LoadNew(proc, 1, err1, out disparity);
            int procResult = HObject.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageRect1);
            GC.KeepAlive((object)imageRect2);
        }

        /// <summary>Compute the projective 3d reconstruction of points based on the fundamental matrix.</summary>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="covRR1">Row coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRC1">Covariance of the points in image 1. Default: []</param>
        /// <param name="covCC1">Column coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRR2">Row coordinate variance of the points in image 2. Default: []</param>
        /// <param name="covRC2">Covariance of the points in image 2. Default: []</param>
        /// <param name="covCC2">Column coordinate variance of the points in image 2. Default: []</param>
        /// <param name="FMatrix">Fundamental matrix.</param>
        /// <param name="covFMat">9x9 covariance matrix of the fundamental matrix. Default: []</param>
        /// <param name="x">X coordinates of the reconstructed points in projective 3D space.</param>
        /// <param name="y">Y coordinates of the reconstructed points in projective 3D space.</param>
        /// <param name="z">Z coordinates of the reconstructed points in projective 3D space.</param>
        /// <param name="w">W coordinates of the reconstructed points in projective 3D space.</param>
        /// <param name="covXYZW">Covariance matrices of the reconstructed points.</param>
        public static void Reconst3dFromFundamentalMatrix(
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple covRR1,
          HTuple covRC1,
          HTuple covCC1,
          HTuple covRR2,
          HTuple covRC2,
          HTuple covCC2,
          HTuple FMatrix,
          HTuple covFMat,
          out HTuple x,
          out HTuple y,
          out HTuple z,
          out HTuple w,
          out HTuple covXYZW)
        {
            IntPtr proc = HalconAPI.PreCall(350);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, covRR1);
            HalconAPI.Store(proc, 5, covRC1);
            HalconAPI.Store(proc, 6, covCC1);
            HalconAPI.Store(proc, 7, covRR2);
            HalconAPI.Store(proc, 8, covRC2);
            HalconAPI.Store(proc, 9, covCC2);
            HalconAPI.Store(proc, 10, FMatrix);
            HalconAPI.Store(proc, 11, covFMat);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(covRR1);
            HalconAPI.UnpinTuple(covRC1);
            HalconAPI.UnpinTuple(covCC1);
            HalconAPI.UnpinTuple(covRR2);
            HalconAPI.UnpinTuple(covRC2);
            HalconAPI.UnpinTuple(covCC2);
            HalconAPI.UnpinTuple(FMatrix);
            HalconAPI.UnpinTuple(covFMat);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out x);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out y);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out z);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out w);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out covXYZW);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the projective rectification of weakly calibrated binocular stereo images.</summary>
        /// <param name="map1">Image coding the rectification of the 1. image.</param>
        /// <param name="map2">Image coding the rectification of the 2. image.</param>
        /// <param name="FMatrix">Fundamental matrix.</param>
        /// <param name="covFMat">9x9 covariance matrix of the fundamental matrix. Default: []</param>
        /// <param name="width1">Width of the 1. image. Default: 512</param>
        /// <param name="height1">Height of the 1. image. Default: 512</param>
        /// <param name="width2">Width of the 2. image. Default: 512</param>
        /// <param name="height2">Height of the 2. image. Default: 512</param>
        /// <param name="subSampling">Subsampling factor. Default: 1</param>
        /// <param name="mapping">Type of mapping. Default: "no_map"</param>
        /// <param name="covFMatRect">9x9 covariance matrix of the rectified fundamental matrix.</param>
        /// <param name="h1">Projective transformation of the 1. image.</param>
        /// <param name="h2">Projective transformation of the 2. image.</param>
        public static void GenBinocularProjRectification(
          out HObject map1,
          out HObject map2,
          HTuple FMatrix,
          HTuple covFMat,
          HTuple width1,
          HTuple height1,
          HTuple width2,
          HTuple height2,
          HTuple subSampling,
          HTuple mapping,
          out HTuple covFMatRect,
          out HTuple h1,
          out HTuple h2)
        {
            IntPtr proc = HalconAPI.PreCall(351);
            HalconAPI.Store(proc, 0, FMatrix);
            HalconAPI.Store(proc, 1, covFMat);
            HalconAPI.Store(proc, 2, width1);
            HalconAPI.Store(proc, 3, height1);
            HalconAPI.Store(proc, 4, width2);
            HalconAPI.Store(proc, 5, height2);
            HalconAPI.Store(proc, 6, subSampling);
            HalconAPI.Store(proc, 7, mapping);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(FMatrix);
            HalconAPI.UnpinTuple(covFMat);
            HalconAPI.UnpinTuple(width1);
            HalconAPI.UnpinTuple(height1);
            HalconAPI.UnpinTuple(width2);
            HalconAPI.UnpinTuple(height2);
            HalconAPI.UnpinTuple(subSampling);
            HalconAPI.UnpinTuple(mapping);
            int err2 = HObject.LoadNew(proc, 1, err1, out map1);
            int err3 = HObject.LoadNew(proc, 2, err2, out map2);
            int err4 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err3, out covFMatRect);
            int err5 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err4, out h1);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err5, out h2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the fundamental matrix and the radial distortion coefficient given a set of image point correspondences and reconstruct 3D points.</summary>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="covRR1">Row coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRC1">Covariance of the points in image 1. Default: []</param>
        /// <param name="covCC1">Column coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRR2">Row coordinate variance of the points in image 2. Default: []</param>
        /// <param name="covRC2">Covariance of the points in image 2. Default: []</param>
        /// <param name="covCC2">Column coordinate variance of the points in image 2. Default: []</param>
        /// <param name="imageWidth">Width of the images from which the points were extracted.</param>
        /// <param name="imageHeight">Height of the images from which the points were extracted.</param>
        /// <param name="method">Estimation algorithm. Default: "gold_standard"</param>
        /// <param name="FMatrix">Computed fundamental matrix.</param>
        /// <param name="kappa">Computed radial distortion coefficient.</param>
        /// <param name="error">Root-Mean-Square epipolar distance error.</param>
        /// <param name="x">X coordinates of the reconstructed points in projective 3D space.</param>
        /// <param name="y">Y coordinates of the reconstructed points in projective 3D space.</param>
        /// <param name="z">Z coordinates of the reconstructed points in projective 3D space.</param>
        /// <param name="w">W coordinates of the reconstructed points in projective 3D space.</param>
        public static void VectorToFundamentalMatrixDistortion(
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple covRR1,
          HTuple covRC1,
          HTuple covCC1,
          HTuple covRR2,
          HTuple covRC2,
          HTuple covCC2,
          HTuple imageWidth,
          HTuple imageHeight,
          HTuple method,
          out HTuple FMatrix,
          out HTuple kappa,
          out HTuple error,
          out HTuple x,
          out HTuple y,
          out HTuple z,
          out HTuple w)
        {
            IntPtr proc = HalconAPI.PreCall(352);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, covRR1);
            HalconAPI.Store(proc, 5, covRC1);
            HalconAPI.Store(proc, 6, covCC1);
            HalconAPI.Store(proc, 7, covRR2);
            HalconAPI.Store(proc, 8, covRC2);
            HalconAPI.Store(proc, 9, covCC2);
            HalconAPI.Store(proc, 10, imageWidth);
            HalconAPI.Store(proc, 11, imageHeight);
            HalconAPI.Store(proc, 12, method);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(covRR1);
            HalconAPI.UnpinTuple(covRC1);
            HalconAPI.UnpinTuple(covCC1);
            HalconAPI.UnpinTuple(covRR2);
            HalconAPI.UnpinTuple(covRC2);
            HalconAPI.UnpinTuple(covCC2);
            HalconAPI.UnpinTuple(imageWidth);
            HalconAPI.UnpinTuple(imageHeight);
            HalconAPI.UnpinTuple(method);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out FMatrix);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out kappa);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out x);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out y);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out z);
            int procResult = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out w);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the fundamental matrix from the relative orientation of two cameras.</summary>
        /// <param name="relPose">Relative orientation of the cameras (3D pose).</param>
        /// <param name="covRelPose">6x6 covariance matrix of relative pose. Default: []</param>
        /// <param name="camPar1">Parameters of the 1. camera.</param>
        /// <param name="camPar2">Parameters of the 2. camera.</param>
        /// <param name="FMatrix">Computed fundamental matrix.</param>
        /// <param name="covFMat">9x9 covariance matrix of the fundamental matrix.</param>
        public static void RelPoseToFundamentalMatrix(
          HTuple relPose,
          HTuple covRelPose,
          HTuple camPar1,
          HTuple camPar2,
          out HTuple FMatrix,
          out HTuple covFMat)
        {
            IntPtr proc = HalconAPI.PreCall(353);
            HalconAPI.Store(proc, 0, relPose);
            HalconAPI.Store(proc, 1, covRelPose);
            HalconAPI.Store(proc, 2, camPar1);
            HalconAPI.Store(proc, 3, camPar2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(relPose);
            HalconAPI.UnpinTuple(covRelPose);
            HalconAPI.UnpinTuple(camPar1);
            HalconAPI.UnpinTuple(camPar2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out FMatrix);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covFMat);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the fundamental matrix from an essential matrix.</summary>
        /// <param name="EMatrix">Essential matrix.</param>
        /// <param name="covEMat">9x9 covariance matrix of the essential matrix. Default: []</param>
        /// <param name="camMat1">Camera matrix of the 1. camera.</param>
        /// <param name="camMat2">Camera matrix of the 2. camera.</param>
        /// <param name="FMatrix">Computed fundamental matrix.</param>
        /// <param name="covFMat">9x9 covariance matrix of the fundamental matrix.</param>
        public static void EssentialToFundamentalMatrix(
          HTuple EMatrix,
          HTuple covEMat,
          HTuple camMat1,
          HTuple camMat2,
          out HTuple FMatrix,
          out HTuple covFMat)
        {
            IntPtr proc = HalconAPI.PreCall(354);
            HalconAPI.Store(proc, 0, EMatrix);
            HalconAPI.Store(proc, 1, covEMat);
            HalconAPI.Store(proc, 2, camMat1);
            HalconAPI.Store(proc, 3, camMat2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(EMatrix);
            HalconAPI.UnpinTuple(covEMat);
            HalconAPI.UnpinTuple(camMat1);
            HalconAPI.UnpinTuple(camMat2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out FMatrix);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covFMat);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the relative orientation between two cameras given image point correspondences and known camera parameters and reconstruct 3D space points.</summary>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="covRR1">Row coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRC1">Covariance of the points in image 1. Default: []</param>
        /// <param name="covCC1">Column coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRR2">Row coordinate variance of the points in image 2. Default: []</param>
        /// <param name="covRC2">Covariance of the points in image 2. Default: []</param>
        /// <param name="covCC2">Column coordinate variance of the points in image 2. Default: []</param>
        /// <param name="camPar1">Camera parameters of the 1st camera.</param>
        /// <param name="camPar2">Camera parameters of the 2nd camera.</param>
        /// <param name="method">Algorithm for the computation of the relative pose and for special pose types. Default: "normalized_dlt"</param>
        /// <param name="relPose">Computed relative orientation of the cameras (3D pose).</param>
        /// <param name="covRelPose">6x6 covariance matrix of the relative camera orientation.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="x">X coordinates of the reconstructed 3D points.</param>
        /// <param name="y">Y coordinates of the reconstructed 3D points.</param>
        /// <param name="z">Z coordinates of the reconstructed 3D points.</param>
        /// <param name="covXYZ">Covariance matrices of the  reconstructed 3D points.</param>
        public static void VectorToRelPose(
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple covRR1,
          HTuple covRC1,
          HTuple covCC1,
          HTuple covRR2,
          HTuple covRC2,
          HTuple covCC2,
          HTuple camPar1,
          HTuple camPar2,
          HTuple method,
          out HTuple relPose,
          out HTuple covRelPose,
          out HTuple error,
          out HTuple x,
          out HTuple y,
          out HTuple z,
          out HTuple covXYZ)
        {
            IntPtr proc = HalconAPI.PreCall(355);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, covRR1);
            HalconAPI.Store(proc, 5, covRC1);
            HalconAPI.Store(proc, 6, covCC1);
            HalconAPI.Store(proc, 7, covRR2);
            HalconAPI.Store(proc, 8, covRC2);
            HalconAPI.Store(proc, 9, covCC2);
            HalconAPI.Store(proc, 10, camPar1);
            HalconAPI.Store(proc, 11, camPar2);
            HalconAPI.Store(proc, 12, method);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(covRR1);
            HalconAPI.UnpinTuple(covRC1);
            HalconAPI.UnpinTuple(covCC1);
            HalconAPI.UnpinTuple(covRR2);
            HalconAPI.UnpinTuple(covRC2);
            HalconAPI.UnpinTuple(covCC2);
            HalconAPI.UnpinTuple(camPar1);
            HalconAPI.UnpinTuple(camPar2);
            HalconAPI.UnpinTuple(method);
            int err2 = HTuple.LoadNew(proc, 0, err1, out relPose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covRelPose);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out x);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out y);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out z);
            int procResult = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out covXYZ);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the essential matrix given image point correspondences and known camera matrices and reconstruct 3D points.</summary>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="covRR1">Row coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRC1">Covariance of the points in image 1. Default: []</param>
        /// <param name="covCC1">Column coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRR2">Row coordinate variance of the points in image 2. Default: []</param>
        /// <param name="covRC2">Covariance of the points in image 2. Default: []</param>
        /// <param name="covCC2">Column coordinate variance of the points in image 2. Default: []</param>
        /// <param name="camMat1">Camera matrix of the 1st camera.</param>
        /// <param name="camMat2">Camera matrix of the 2nd camera.</param>
        /// <param name="method">Algorithm for the computation of the essential matrix and for special camera orientations. Default: "normalized_dlt"</param>
        /// <param name="EMatrix">Computed essential matrix.</param>
        /// <param name="covEMat">9x9 covariance matrix of the essential matrix.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="x">X coordinates of the reconstructed 3D points.</param>
        /// <param name="y">Y coordinates of the reconstructed 3D points.</param>
        /// <param name="z">Z coordinates of the reconstructed 3D points.</param>
        /// <param name="covXYZ">Covariance matrices of the reconstructed 3D points.</param>
        public static void VectorToEssentialMatrix(
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple covRR1,
          HTuple covRC1,
          HTuple covCC1,
          HTuple covRR2,
          HTuple covRC2,
          HTuple covCC2,
          HTuple camMat1,
          HTuple camMat2,
          HTuple method,
          out HTuple EMatrix,
          out HTuple covEMat,
          out HTuple error,
          out HTuple x,
          out HTuple y,
          out HTuple z,
          out HTuple covXYZ)
        {
            IntPtr proc = HalconAPI.PreCall(356);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, covRR1);
            HalconAPI.Store(proc, 5, covRC1);
            HalconAPI.Store(proc, 6, covCC1);
            HalconAPI.Store(proc, 7, covRR2);
            HalconAPI.Store(proc, 8, covRC2);
            HalconAPI.Store(proc, 9, covCC2);
            HalconAPI.Store(proc, 10, camMat1);
            HalconAPI.Store(proc, 11, camMat2);
            HalconAPI.Store(proc, 12, method);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(covRR1);
            HalconAPI.UnpinTuple(covRC1);
            HalconAPI.UnpinTuple(covCC1);
            HalconAPI.UnpinTuple(covRR2);
            HalconAPI.UnpinTuple(covRC2);
            HalconAPI.UnpinTuple(covCC2);
            HalconAPI.UnpinTuple(camMat1);
            HalconAPI.UnpinTuple(camMat2);
            HalconAPI.UnpinTuple(method);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out EMatrix);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covEMat);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out x);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out y);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out z);
            int procResult = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out covXYZ);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the fundamental matrix given a set of image point correspondences and reconstruct 3D points.</summary>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="covRR1">Row coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRC1">Covariance of the points in image 1. Default: []</param>
        /// <param name="covCC1">Column coordinate variance of the points in image 1. Default: []</param>
        /// <param name="covRR2">Row coordinate variance of the points in image 2. Default: []</param>
        /// <param name="covRC2">Covariance of the points in image 2. Default: []</param>
        /// <param name="covCC2">Column coordinate variance of the points in image 2. Default: []</param>
        /// <param name="method">Estimation algorithm. Default: "normalized_dlt"</param>
        /// <param name="FMatrix">Computed fundamental matrix.</param>
        /// <param name="covFMat">9x9 covariance matrix of the fundamental matrix.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="x">X coordinates of the reconstructed points in projective 3D space.</param>
        /// <param name="y">Y coordinates of the reconstructed points in projective 3D space.</param>
        /// <param name="z">Z coordinates of the reconstructed points in projective 3D space.</param>
        /// <param name="w">W coordinates of the reconstructed points in projective 3D space.</param>
        /// <param name="covXYZW">Covariance matrices of the reconstructed 3D points.</param>
        public static void VectorToFundamentalMatrix(
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple covRR1,
          HTuple covRC1,
          HTuple covCC1,
          HTuple covRR2,
          HTuple covRC2,
          HTuple covCC2,
          HTuple method,
          out HTuple FMatrix,
          out HTuple covFMat,
          out HTuple error,
          out HTuple x,
          out HTuple y,
          out HTuple z,
          out HTuple w,
          out HTuple covXYZW)
        {
            IntPtr proc = HalconAPI.PreCall(357);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, covRR1);
            HalconAPI.Store(proc, 5, covRC1);
            HalconAPI.Store(proc, 6, covCC1);
            HalconAPI.Store(proc, 7, covRR2);
            HalconAPI.Store(proc, 8, covRC2);
            HalconAPI.Store(proc, 9, covCC2);
            HalconAPI.Store(proc, 10, method);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(covRR1);
            HalconAPI.UnpinTuple(covRC1);
            HalconAPI.UnpinTuple(covCC1);
            HalconAPI.UnpinTuple(covRR2);
            HalconAPI.UnpinTuple(covRC2);
            HalconAPI.UnpinTuple(covCC2);
            HalconAPI.UnpinTuple(method);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out FMatrix);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covFMat);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out x);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out y);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out z);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out w);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out covXYZW);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the fundamental matrix and the radial distortion coefficient for a pair of stereo images by automatically finding correspondences between image points.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="grayMatchMethod">Gray value match metric. Default: "ncc"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate offset of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate offset of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative rotation of the second image with respect to the first image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 0.7</param>
        /// <param name="estimationMethod">Algorithm for the computation of the fundamental matrix and for special camera orientations. Default: "gold_standard"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="FMatrix">Computed fundamental matrix.</param>
        /// <param name="kappa">Computed radial distortion coefficient.</param>
        /// <param name="error">Root-Mean-Square epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        public static void MatchFundamentalMatrixDistortionRansac(
          HObject image1,
          HObject image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple grayMatchMethod,
          HTuple maskSize,
          HTuple rowMove,
          HTuple colMove,
          HTuple rowTolerance,
          HTuple colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          HTuple estimationMethod,
          HTuple distanceThreshold,
          HTuple randSeed,
          out HTuple FMatrix,
          out HTuple kappa,
          out HTuple error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(358);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, grayMatchMethod);
            HalconAPI.Store(proc, 5, maskSize);
            HalconAPI.Store(proc, 6, rowMove);
            HalconAPI.Store(proc, 7, colMove);
            HalconAPI.Store(proc, 8, rowTolerance);
            HalconAPI.Store(proc, 9, colTolerance);
            HalconAPI.Store(proc, 10, rotation);
            HalconAPI.Store(proc, 11, matchThreshold);
            HalconAPI.Store(proc, 12, estimationMethod);
            HalconAPI.Store(proc, 13, distanceThreshold);
            HalconAPI.Store(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(grayMatchMethod);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(rowMove);
            HalconAPI.UnpinTuple(colMove);
            HalconAPI.UnpinTuple(rowTolerance);
            HalconAPI.UnpinTuple(colTolerance);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(estimationMethod);
            HalconAPI.UnpinTuple(distanceThreshold);
            HalconAPI.UnpinTuple(randSeed);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out FMatrix);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out kappa);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Compute the relative orientation between two cameras by automatically finding correspondences between image points.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="camPar1">Parameters of the 1st camera.</param>
        /// <param name="camPar2">Parameters of the 2nd camera.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative orientation of the right image with respect to the left image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Algorithm for the computation of the relative pose and for special pose types. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="relPose">Computed relative orientation of the cameras (3D pose).</param>
        /// <param name="covRelPose">6x6 covariance matrix of the relative orientation.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        public static void MatchRelPoseRansac(
          HObject image1,
          HObject image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple camPar1,
          HTuple camPar2,
          HTuple grayMatchMethod,
          HTuple maskSize,
          HTuple rowMove,
          HTuple colMove,
          HTuple rowTolerance,
          HTuple colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          HTuple estimationMethod,
          HTuple distanceThreshold,
          HTuple randSeed,
          out HTuple relPose,
          out HTuple covRelPose,
          out HTuple error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(359);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, camPar1);
            HalconAPI.Store(proc, 5, camPar2);
            HalconAPI.Store(proc, 6, grayMatchMethod);
            HalconAPI.Store(proc, 7, maskSize);
            HalconAPI.Store(proc, 8, rowMove);
            HalconAPI.Store(proc, 9, colMove);
            HalconAPI.Store(proc, 10, rowTolerance);
            HalconAPI.Store(proc, 11, colTolerance);
            HalconAPI.Store(proc, 12, rotation);
            HalconAPI.Store(proc, 13, matchThreshold);
            HalconAPI.Store(proc, 14, estimationMethod);
            HalconAPI.Store(proc, 15, distanceThreshold);
            HalconAPI.Store(proc, 16, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(camPar1);
            HalconAPI.UnpinTuple(camPar2);
            HalconAPI.UnpinTuple(grayMatchMethod);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(rowMove);
            HalconAPI.UnpinTuple(colMove);
            HalconAPI.UnpinTuple(rowTolerance);
            HalconAPI.UnpinTuple(colTolerance);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(estimationMethod);
            HalconAPI.UnpinTuple(distanceThreshold);
            HalconAPI.UnpinTuple(randSeed);
            int err2 = HTuple.LoadNew(proc, 0, err1, out relPose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covRelPose);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Compute the essential matrix for a pair of stereo images by automatically finding correspondences between image points.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="camMat1">Camera matrix of the 1st camera.</param>
        /// <param name="camMat2">Camera matrix of the 2nd camera.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative orientation of the right image with respect to the left image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Algorithm for the computation of the essential matrix and for special camera orientations. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="EMatrix">Computed essential matrix.</param>
        /// <param name="covEMat">9x9 covariance matrix of the essential matrix.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        public static void MatchEssentialMatrixRansac(
          HObject image1,
          HObject image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple camMat1,
          HTuple camMat2,
          HTuple grayMatchMethod,
          HTuple maskSize,
          HTuple rowMove,
          HTuple colMove,
          HTuple rowTolerance,
          HTuple colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          HTuple estimationMethod,
          HTuple distanceThreshold,
          HTuple randSeed,
          out HTuple EMatrix,
          out HTuple covEMat,
          out HTuple error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(360);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, camMat1);
            HalconAPI.Store(proc, 5, camMat2);
            HalconAPI.Store(proc, 6, grayMatchMethod);
            HalconAPI.Store(proc, 7, maskSize);
            HalconAPI.Store(proc, 8, rowMove);
            HalconAPI.Store(proc, 9, colMove);
            HalconAPI.Store(proc, 10, rowTolerance);
            HalconAPI.Store(proc, 11, colTolerance);
            HalconAPI.Store(proc, 12, rotation);
            HalconAPI.Store(proc, 13, matchThreshold);
            HalconAPI.Store(proc, 14, estimationMethod);
            HalconAPI.Store(proc, 15, distanceThreshold);
            HalconAPI.Store(proc, 16, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(camMat1);
            HalconAPI.UnpinTuple(camMat2);
            HalconAPI.UnpinTuple(grayMatchMethod);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(rowMove);
            HalconAPI.UnpinTuple(colMove);
            HalconAPI.UnpinTuple(rowTolerance);
            HalconAPI.UnpinTuple(colTolerance);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(estimationMethod);
            HalconAPI.UnpinTuple(distanceThreshold);
            HalconAPI.UnpinTuple(randSeed);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out EMatrix);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covEMat);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Compute the fundamental matrix for a pair of stereo images by automatically finding correspondences between image points.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative orientation of the right image with respect to the left image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Algorithm for the computation of the fundamental matrix and for special camera orientations. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="FMatrix">Computed fundamental matrix.</param>
        /// <param name="covFMat">9x9 covariance matrix of the fundamental matrix.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        public static void MatchFundamentalMatrixRansac(
          HObject image1,
          HObject image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple grayMatchMethod,
          HTuple maskSize,
          HTuple rowMove,
          HTuple colMove,
          HTuple rowTolerance,
          HTuple colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          HTuple estimationMethod,
          HTuple distanceThreshold,
          HTuple randSeed,
          out HTuple FMatrix,
          out HTuple covFMat,
          out HTuple error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(361);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, grayMatchMethod);
            HalconAPI.Store(proc, 5, maskSize);
            HalconAPI.Store(proc, 6, rowMove);
            HalconAPI.Store(proc, 7, colMove);
            HalconAPI.Store(proc, 8, rowTolerance);
            HalconAPI.Store(proc, 9, colTolerance);
            HalconAPI.Store(proc, 10, rotation);
            HalconAPI.Store(proc, 11, matchThreshold);
            HalconAPI.Store(proc, 12, estimationMethod);
            HalconAPI.Store(proc, 13, distanceThreshold);
            HalconAPI.Store(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(grayMatchMethod);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(rowMove);
            HalconAPI.UnpinTuple(colMove);
            HalconAPI.UnpinTuple(rowTolerance);
            HalconAPI.UnpinTuple(colTolerance);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(estimationMethod);
            HalconAPI.UnpinTuple(distanceThreshold);
            HalconAPI.UnpinTuple(randSeed);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out FMatrix);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covFMat);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Compute the distance values for a rectified stereo image pair using correlation techniques.</summary>
        /// <param name="imageRect1">Rectified image of camera 1.</param>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="distance">Distance image.</param>
        /// <param name="score">Evaluation of a distance value.</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <param name="method">Matching function. Default: "ncc"</param>
        /// <param name="maskWidth">Width of the correlation window. Default: 11</param>
        /// <param name="maskHeight">Height of the correlation window. Default: 11</param>
        /// <param name="textureThresh">Variance threshold of textured image regions. Default: 0.0</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: 0</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="numLevels">Number of pyramid levels. Default: 1</param>
        /// <param name="scoreThresh">Threshold of the correlation function. Default: 0.0</param>
        /// <param name="filter">Downstream filters. Default: "none"</param>
        /// <param name="subDistance">Distance interpolation. Default: "none"</param>
        public static void BinocularDistance(
          HObject imageRect1,
          HObject imageRect2,
          out HObject distance,
          out HObject score,
          HTuple camParamRect1,
          HTuple camParamRect2,
          HTuple relPoseRect,
          HTuple method,
          HTuple maskWidth,
          HTuple maskHeight,
          HTuple textureThresh,
          HTuple minDisparity,
          HTuple maxDisparity,
          HTuple numLevels,
          HTuple scoreThresh,
          HTuple filter,
          HTuple subDistance)
        {
            IntPtr proc = HalconAPI.PreCall(362);
            HalconAPI.Store(proc, 1, (HObjectBase)imageRect1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, camParamRect1);
            HalconAPI.Store(proc, 1, camParamRect2);
            HalconAPI.Store(proc, 2, relPoseRect);
            HalconAPI.Store(proc, 3, method);
            HalconAPI.Store(proc, 4, maskWidth);
            HalconAPI.Store(proc, 5, maskHeight);
            HalconAPI.Store(proc, 6, textureThresh);
            HalconAPI.Store(proc, 7, minDisparity);
            HalconAPI.Store(proc, 8, maxDisparity);
            HalconAPI.Store(proc, 9, numLevels);
            HalconAPI.Store(proc, 10, scoreThresh);
            HalconAPI.Store(proc, 11, filter);
            HalconAPI.Store(proc, 12, subDistance);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParamRect1);
            HalconAPI.UnpinTuple(camParamRect2);
            HalconAPI.UnpinTuple(relPoseRect);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(textureThresh);
            HalconAPI.UnpinTuple(minDisparity);
            HalconAPI.UnpinTuple(maxDisparity);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(scoreThresh);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(subDistance);
            int err2 = HObject.LoadNew(proc, 1, err1, out distance);
            int procResult = HObject.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageRect1);
            GC.KeepAlive((object)imageRect2);
        }

        /// <summary>Compute the disparities of a rectified image pair using correlation techniques.</summary>
        /// <param name="imageRect1">Rectified image of camera 1.</param>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="disparity">Disparity map.</param>
        /// <param name="score">Evaluation of the disparity values.</param>
        /// <param name="method">Matching function. Default: "ncc"</param>
        /// <param name="maskWidth">Width of the correlation window. Default: 11</param>
        /// <param name="maskHeight">Height of the correlation window. Default: 11</param>
        /// <param name="textureThresh">Variance threshold of textured image regions. Default: 0.0</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: -30</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="numLevels">Number of pyramid levels. Default: 1</param>
        /// <param name="scoreThresh">Threshold of the correlation function. Default: 0.5</param>
        /// <param name="filter">Downstream filters. Default: "none"</param>
        /// <param name="subDisparity">Subpixel interpolation of disparities. Default: "none"</param>
        public static void BinocularDisparity(
          HObject imageRect1,
          HObject imageRect2,
          out HObject disparity,
          out HObject score,
          HTuple method,
          HTuple maskWidth,
          HTuple maskHeight,
          HTuple textureThresh,
          HTuple minDisparity,
          HTuple maxDisparity,
          HTuple numLevels,
          HTuple scoreThresh,
          HTuple filter,
          HTuple subDisparity)
        {
            IntPtr proc = HalconAPI.PreCall(363);
            HalconAPI.Store(proc, 1, (HObjectBase)imageRect1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, method);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.Store(proc, 2, maskHeight);
            HalconAPI.Store(proc, 3, textureThresh);
            HalconAPI.Store(proc, 4, minDisparity);
            HalconAPI.Store(proc, 5, maxDisparity);
            HalconAPI.Store(proc, 6, numLevels);
            HalconAPI.Store(proc, 7, scoreThresh);
            HalconAPI.Store(proc, 8, filter);
            HalconAPI.Store(proc, 9, subDisparity);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(textureThresh);
            HalconAPI.UnpinTuple(minDisparity);
            HalconAPI.UnpinTuple(maxDisparity);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(scoreThresh);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(subDisparity);
            int err2 = HObject.LoadNew(proc, 1, err1, out disparity);
            int procResult = HObject.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageRect1);
            GC.KeepAlive((object)imageRect2);
        }

        /// <summary>Get a 3D point from the intersection of two lines of sight within a binocular camera system.</summary>
        /// <param name="camParam1">Internal parameters of the projective camera 1.</param>
        /// <param name="camParam2">Internal parameters of the projective camera 2.</param>
        /// <param name="relPose">Point transformation from camera 2 to camera 1.</param>
        /// <param name="row1">Row coordinate of a point in image 1.</param>
        /// <param name="col1">Column coordinate of a point in image 1.</param>
        /// <param name="row2">Row coordinate of the corresponding point in image 2.</param>
        /// <param name="col2">Column coordinate of the corresponding point in image 2.</param>
        /// <param name="x">X coordinate of the 3D point.</param>
        /// <param name="y">Y coordinate of the 3D point.</param>
        /// <param name="z">Z coordinate of the 3D point.</param>
        /// <param name="dist">Distance of the 3D point to the lines of sight.</param>
        public static void IntersectLinesOfSight(
          HTuple camParam1,
          HTuple camParam2,
          HTuple relPose,
          HTuple row1,
          HTuple col1,
          HTuple row2,
          HTuple col2,
          out HTuple x,
          out HTuple y,
          out HTuple z,
          out HTuple dist)
        {
            IntPtr proc = HalconAPI.PreCall(364);
            HalconAPI.Store(proc, 0, camParam1);
            HalconAPI.Store(proc, 1, camParam2);
            HalconAPI.Store(proc, 2, relPose);
            HalconAPI.Store(proc, 3, row1);
            HalconAPI.Store(proc, 4, col1);
            HalconAPI.Store(proc, 5, row2);
            HalconAPI.Store(proc, 6, col2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParam1);
            HalconAPI.UnpinTuple(camParam2);
            HalconAPI.UnpinTuple(relPose);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(col1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(col2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out x);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out y);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out z);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out dist);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transform a disparity image into 3D points in a rectified stereo system.</summary>
        /// <param name="disparity">Disparity image.</param>
        /// <param name="x">X coordinates of the points in the rectified camera system 1.</param>
        /// <param name="y">Y coordinates of the points in the rectified camera system 1.</param>
        /// <param name="z">Z coordinates of the points in the rectified camera system 1.</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Pose of the rectified camera 2 in relation to the rectified camera 1.</param>
        public static void DisparityImageToXyz(
          HObject disparity,
          out HObject x,
          out HObject y,
          out HObject z,
          HTuple camParamRect1,
          HTuple camParamRect2,
          HTuple relPoseRect)
        {
            IntPtr proc = HalconAPI.PreCall(365);
            HalconAPI.Store(proc, 1, (HObjectBase)disparity);
            HalconAPI.Store(proc, 0, camParamRect1);
            HalconAPI.Store(proc, 1, camParamRect2);
            HalconAPI.Store(proc, 2, relPoseRect);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParamRect1);
            HalconAPI.UnpinTuple(camParamRect2);
            HalconAPI.UnpinTuple(relPoseRect);
            int err2 = HObject.LoadNew(proc, 1, err1, out x);
            int err3 = HObject.LoadNew(proc, 2, err2, out y);
            int procResult = HObject.LoadNew(proc, 3, err3, out z);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)disparity);
        }

        /// <summary>Transform an image point and its disparity into a 3D point in a rectified stereo system.</summary>
        /// <param name="camParamRect1">Rectified internal camera parameters of camera 1.</param>
        /// <param name="camParamRect2">Rectified internal camera parameters of camera 2.</param>
        /// <param name="relPoseRect">Pose of the rectified camera 2 in relation to the rectified camera 1.</param>
        /// <param name="row1">Row coordinate of a point in the rectified image 1.</param>
        /// <param name="col1">Column coordinate of a point in the rectified image 1.</param>
        /// <param name="disparity">Disparity of the images of the world point.</param>
        /// <param name="x">X coordinate of the 3D point.</param>
        /// <param name="y">Y coordinate of the 3D point.</param>
        /// <param name="z">Z coordinate of the 3D point.</param>
        public static void DisparityToPoint3d(
          HTuple camParamRect1,
          HTuple camParamRect2,
          HTuple relPoseRect,
          HTuple row1,
          HTuple col1,
          HTuple disparity,
          out HTuple x,
          out HTuple y,
          out HTuple z)
        {
            IntPtr proc = HalconAPI.PreCall(366);
            HalconAPI.Store(proc, 0, camParamRect1);
            HalconAPI.Store(proc, 1, camParamRect2);
            HalconAPI.Store(proc, 2, relPoseRect);
            HalconAPI.Store(proc, 3, row1);
            HalconAPI.Store(proc, 4, col1);
            HalconAPI.Store(proc, 5, disparity);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParamRect1);
            HalconAPI.UnpinTuple(camParamRect2);
            HalconAPI.UnpinTuple(relPoseRect);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(col1);
            HalconAPI.UnpinTuple(disparity);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out x);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out y);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out z);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transform a disparity value into a distance value in a rectified binocular stereo system.</summary>
        /// <param name="camParamRect1">Rectified internal camera parameters of camera 1.</param>
        /// <param name="camParamRect2">Rectified internal camera parameters of camera 2.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <param name="disparity">Disparity between the images of the world point.</param>
        /// <param name="distance">Distance of a world point to the rectified camera system.</param>
        public static void DisparityToDistance(
          HTuple camParamRect1,
          HTuple camParamRect2,
          HTuple relPoseRect,
          HTuple disparity,
          out HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(367);
            HalconAPI.Store(proc, 0, camParamRect1);
            HalconAPI.Store(proc, 1, camParamRect2);
            HalconAPI.Store(proc, 2, relPoseRect);
            HalconAPI.Store(proc, 3, disparity);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParamRect1);
            HalconAPI.UnpinTuple(camParamRect2);
            HalconAPI.UnpinTuple(relPoseRect);
            HalconAPI.UnpinTuple(disparity);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out distance);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transfrom a distance value into a disparity in a rectified stereo system.</summary>
        /// <param name="camParamRect1">Rectified internal camera parameters of camera 1.</param>
        /// <param name="camParamRect2">Rectified internal camera parameters of camera 2.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <param name="distance">Distance of a world point to camera 1.</param>
        /// <param name="disparity">Disparity between the images of the point.</param>
        public static void DistanceToDisparity(
          HTuple camParamRect1,
          HTuple camParamRect2,
          HTuple relPoseRect,
          HTuple distance,
          out HTuple disparity)
        {
            IntPtr proc = HalconAPI.PreCall(368);
            HalconAPI.Store(proc, 0, camParamRect1);
            HalconAPI.Store(proc, 1, camParamRect2);
            HalconAPI.Store(proc, 2, relPoseRect);
            HalconAPI.Store(proc, 3, distance);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParamRect1);
            HalconAPI.UnpinTuple(camParamRect2);
            HalconAPI.UnpinTuple(relPoseRect);
            HalconAPI.UnpinTuple(distance);
            int procResult = HTuple.LoadNew(proc, 0, err, out disparity);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate transformation maps that describe the mapping of the images of a binocular camera pair to a common rectified image plane.</summary>
        /// <param name="map1">Image containing the mapping data of camera 1.</param>
        /// <param name="map2">Image containing the mapping data of camera 2.</param>
        /// <param name="camParam1">Internal parameters of camera 1.</param>
        /// <param name="camParam2">Internal parameters of camera 2.</param>
        /// <param name="relPose">Point transformation from camera 2 to camera 1.</param>
        /// <param name="subSampling">Subsampling factor. Default: 1.0</param>
        /// <param name="method">Type of rectification. Default: "geometric"</param>
        /// <param name="mapType">Type of mapping. Default: "bilinear"</param>
        /// <param name="camParamRect1">Rectified internal parameters of camera 1.</param>
        /// <param name="camParamRect2">Rectified internal parameters of camera 2.</param>
        /// <param name="camPoseRect1">Point transformation from the rectified camera 1 to the original camera 1.</param>
        /// <param name="camPoseRect2">Point transformation from the rectified camera 1 to the original camera 1.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        public static void GenBinocularRectificationMap(
          out HObject map1,
          out HObject map2,
          HTuple camParam1,
          HTuple camParam2,
          HTuple relPose,
          HTuple subSampling,
          HTuple method,
          HTuple mapType,
          out HTuple camParamRect1,
          out HTuple camParamRect2,
          out HTuple camPoseRect1,
          out HTuple camPoseRect2,
          out HTuple relPoseRect)
        {
            IntPtr proc = HalconAPI.PreCall(369);
            HalconAPI.Store(proc, 0, camParam1);
            HalconAPI.Store(proc, 1, camParam2);
            HalconAPI.Store(proc, 2, relPose);
            HalconAPI.Store(proc, 3, subSampling);
            HalconAPI.Store(proc, 4, method);
            HalconAPI.Store(proc, 5, mapType);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParam1);
            HalconAPI.UnpinTuple(camParam2);
            HalconAPI.UnpinTuple(relPose);
            HalconAPI.UnpinTuple(subSampling);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(mapType);
            int err2 = HObject.LoadNew(proc, 1, err1, out map1);
            int err3 = HObject.LoadNew(proc, 2, err2, out map2);
            int err4 = HTuple.LoadNew(proc, 0, err3, out camParamRect1);
            int err5 = HTuple.LoadNew(proc, 1, err4, out camParamRect2);
            int err6 = HTuple.LoadNew(proc, 2, err5, out camPoseRect1);
            int err7 = HTuple.LoadNew(proc, 3, err6, out camPoseRect2);
            int procResult = HTuple.LoadNew(proc, 4, err7, out relPoseRect);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Determine all camera parameters of a binocular stereo system.</summary>
        /// <param name="NX">Ordered Tuple with all X-coordinates of the calibration marks (in meters).</param>
        /// <param name="NY">Ordered Tuple with all Y-coordinates of the calibration marks (in meters).</param>
        /// <param name="NZ">Ordered Tuple with all Z-coordinates of the calibration marks (in meters).</param>
        /// <param name="NRow1">Ordered Tuple with all row-coordinates of the extracted calibration marks of camera 1 (in pixels).</param>
        /// <param name="NCol1">Ordered Tuple with all column-coordinates of the extracted calibration marks of camera 1 (in pixels).</param>
        /// <param name="NRow2">Ordered Tuple with all row-coordinates of the extracted calibration marks of camera 2 (in pixels).</param>
        /// <param name="NCol2">Ordered Tuple with all column-coordinates of the extracted calibration marks of camera 2 (in pixels).</param>
        /// <param name="startCamParam1">Initial values for the internal parameters of camera 1.</param>
        /// <param name="startCamParam2">Initial values for the internal parameters of camera 2.</param>
        /// <param name="NStartPose1">Ordered tuple with all initial values for the poses of the calibration model in relation to camera 1.</param>
        /// <param name="NStartPose2">Ordered tuple with all initial values for the poses of the calibration model in relation to camera 2.</param>
        /// <param name="estimateParams">Camera parameters to be estimated. Default: "all"</param>
        /// <param name="camParam1">Internal parameters of camera 1.</param>
        /// <param name="camParam2">Internal parameters of camera 2.</param>
        /// <param name="NFinalPose1">Ordered tuple with all poses of the calibration model in relation to camera 1.</param>
        /// <param name="NFinalPose2">Ordered tuple with all poses of the calibration model in relation to camera 2.</param>
        /// <param name="relPose">Pose of camera 2 in relation to camera 1.</param>
        /// <param name="errors">Average error distances in pixels.</param>
        public static void BinocularCalibration(
          HTuple NX,
          HTuple NY,
          HTuple NZ,
          HTuple NRow1,
          HTuple NCol1,
          HTuple NRow2,
          HTuple NCol2,
          HTuple startCamParam1,
          HTuple startCamParam2,
          HTuple NStartPose1,
          HTuple NStartPose2,
          HTuple estimateParams,
          out HTuple camParam1,
          out HTuple camParam2,
          out HTuple NFinalPose1,
          out HTuple NFinalPose2,
          out HTuple relPose,
          out HTuple errors)
        {
            IntPtr proc = HalconAPI.PreCall(370);
            HalconAPI.Store(proc, 0, NX);
            HalconAPI.Store(proc, 1, NY);
            HalconAPI.Store(proc, 2, NZ);
            HalconAPI.Store(proc, 3, NRow1);
            HalconAPI.Store(proc, 4, NCol1);
            HalconAPI.Store(proc, 5, NRow2);
            HalconAPI.Store(proc, 6, NCol2);
            HalconAPI.Store(proc, 7, startCamParam1);
            HalconAPI.Store(proc, 8, startCamParam2);
            HalconAPI.Store(proc, 9, NStartPose1);
            HalconAPI.Store(proc, 10, NStartPose2);
            HalconAPI.Store(proc, 11, estimateParams);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(NX);
            HalconAPI.UnpinTuple(NY);
            HalconAPI.UnpinTuple(NZ);
            HalconAPI.UnpinTuple(NRow1);
            HalconAPI.UnpinTuple(NCol1);
            HalconAPI.UnpinTuple(NRow2);
            HalconAPI.UnpinTuple(NCol2);
            HalconAPI.UnpinTuple(startCamParam1);
            HalconAPI.UnpinTuple(startCamParam2);
            HalconAPI.UnpinTuple(NStartPose1);
            HalconAPI.UnpinTuple(NStartPose2);
            HalconAPI.UnpinTuple(estimateParams);
            int err2 = HTuple.LoadNew(proc, 0, err1, out camParam1);
            int err3 = HTuple.LoadNew(proc, 1, err2, out camParam2);
            int err4 = HTuple.LoadNew(proc, 2, err3, out NFinalPose1);
            int err5 = HTuple.LoadNew(proc, 3, err4, out NFinalPose2);
            int err6 = HTuple.LoadNew(proc, 4, err5, out relPose);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out errors);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Inquiring for possible settings of the HALCON debugging tool.</summary>
        /// <param name="classes">Available control modes (see also set_spy).</param>
        /// <param name="values">Corresponding state of the control modes.</param>
        public static void QuerySpy(out HTuple classes, out HTuple values)
        {
            IntPtr proc = HalconAPI.PreCall(371);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classes);
            int procResult = HTuple.LoadNew(proc, 1, err2, out values);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Control of the HALCON Debugging Tools.</summary>
        /// <param name="classVal">Control mode Default: "mode"</param>
        /// <param name="value">State of the control mode to be set. Default: "on"</param>
        public static void SetSpy(HTuple classVal, HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(372);
            HalconAPI.Store(proc, 0, classVal);
            HalconAPI.Store(proc, 1, value);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classVal);
            HalconAPI.UnpinTuple(value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Current configuration of the HALCON debugging-tool.</summary>
        /// <param name="classVal">Control mode Default: "mode"</param>
        /// <param name="value">State of the control mode.</param>
        public static void GetSpy(HTuple classVal, out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(373);
            HalconAPI.Store(proc, 0, classVal);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classVal);
            int procResult = HTuple.LoadNew(proc, 0, err, out value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a sheet-of-light model from a file and create a new model.</summary>
        /// <param name="fileName">Name of the sheet-of-light model file. Default: "sheet_of_light_model.solm"</param>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        public static void ReadSheetOfLightModel(HTuple fileName, out HTuple sheetOfLightModelID)
        {
            IntPtr proc = HalconAPI.PreCall(374);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out sheetOfLightModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a sheet-of-light model to a file.</summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        /// <param name="fileName">Name of the sheet-of-light model file. Default: "sheet_of_light_model.solm"</param>
        public static void WriteSheetOfLightModel(HTuple sheetOfLightModelID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(375);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a sheet-of-light model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        public static void DeserializeSheetOfLightModel(
          HTuple serializedItemHandle,
          out HTuple sheetOfLightModelID)
        {
            IntPtr proc = HalconAPI.PreCall(376);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out sheetOfLightModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a sheet-of-light model.</summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeSheetOfLightModel(
          HTuple sheetOfLightModelID,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(377);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a calibration object for sheet-of-light calibration.</summary>
        /// <param name="width">Width of the object. Default: 0.1</param>
        /// <param name="length">Length of the object. Default: 0.15</param>
        /// <param name="heightMin">Minimum height of the ramp. Default: 0.005</param>
        /// <param name="heightMax">Maximum height of the ramp. Default: 0.04</param>
        /// <param name="fileName">Filename of the model of the calibration object. Default: "calib_object.dxf"</param>
        public static void CreateSheetOfLightCalibObject(
          HTuple width,
          HTuple length,
          HTuple heightMin,
          HTuple heightMax,
          HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(378);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, length);
            HalconAPI.Store(proc, 2, heightMin);
            HalconAPI.Store(proc, 3, heightMax);
            HalconAPI.Store(proc, 4, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(length);
            HalconAPI.UnpinTuple(heightMin);
            HalconAPI.UnpinTuple(heightMax);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calibrate a sheet-of-light setup with a 3D calibration object.</summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        /// <param name="error">Average back projection error of the optimization.</param>
        public static void CalibrateSheetOfLight(HTuple sheetOfLightModelID, out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(379);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out error);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the result of a calibrated measurement performed with the  sheet-of-light technique as a 3D object model.</summary>
        /// <param name="sheetOfLightModelID">Handle for accessing the sheet-of-light model.</param>
        /// <param name="objectModel3D">Handle of the resulting 3D object model.</param>
        public static void GetSheetOfLightResultObjectModel3d(
          HTuple sheetOfLightModelID,
          out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(380);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the iconic results of a measurement performed with the sheet-of light technique.</summary>
        /// <param name="resultValue">Desired measurement result.</param>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model to be used.</param>
        /// <param name="resultName">Specify which result of the measurement shall be provided. Default: "disparity"</param>
        public static void GetSheetOfLightResult(
          out HObject resultValue,
          HTuple sheetOfLightModelID,
          HTuple resultName)
        {
            IntPtr proc = HalconAPI.PreCall(381);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            HalconAPI.Store(proc, 1, resultName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            HalconAPI.UnpinTuple(resultName);
            int procResult = HObject.LoadNew(proc, 1, err, out resultValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Apply the calibration transformations to the input disparity image.</summary>
        /// <param name="disparity">Height or range image to be calibrated.</param>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        public static void ApplySheetOfLightCalibration(HObject disparity, HTuple sheetOfLightModelID)
        {
            IntPtr proc = HalconAPI.PreCall(382);
            HalconAPI.Store(proc, 1, (HObjectBase)disparity);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)disparity);
        }

        /// <summary>Set sheet of light profiles by measured disparities.</summary>
        /// <param name="profileDisparityImage">Disparity image that contains several profiles.</param>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        /// <param name="movementPoses">Poses describing the movement of the scene under measurement between the previously processed profile image and the current profile image.</param>
        public static void SetProfileSheetOfLight(
          HObject profileDisparityImage,
          HTuple sheetOfLightModelID,
          HTuple movementPoses)
        {
            IntPtr proc = HalconAPI.PreCall(383);
            HalconAPI.Store(proc, 1, (HObjectBase)profileDisparityImage);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            HalconAPI.Store(proc, 1, movementPoses);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            HalconAPI.UnpinTuple(movementPoses);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)profileDisparityImage);
        }

        /// <summary>Process the profile image provided as input and store the resulting disparity to the sheet-of-light model.</summary>
        /// <param name="profileImage">Input image.</param>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        /// <param name="movementPose">Pose describing the movement of the scene under measurement between the previously processed profile image and the current profile image.</param>
        public static void MeasureProfileSheetOfLight(
          HObject profileImage,
          HTuple sheetOfLightModelID,
          HTuple movementPose)
        {
            IntPtr proc = HalconAPI.PreCall(384);
            HalconAPI.Store(proc, 1, (HObjectBase)profileImage);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            HalconAPI.Store(proc, 1, movementPose);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            HalconAPI.UnpinTuple(movementPose);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)profileImage);
        }

        /// <summary>Set selected parameters of the sheet-of-light model.</summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        /// <param name="genParamName">Name of the model parameter that shall be adjusted for the sheet-of-light model. Default: "method"</param>
        /// <param name="genParamValue">Value of the model parameter that shall be adjusted for the sheet-of-light model. Default: "center_of_gravity"</param>
        public static void SetSheetOfLightParam(
          HTuple sheetOfLightModelID,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(385);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the value of a parameter, which has been set in a sheet-of-light model.</summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        /// <param name="genParamName">Name of the generic parameter that shall be queried. Default: "method"</param>
        /// <param name="genParamValue">Value of the model parameter that shall be queried.</param>
        public static void GetSheetOfLightParam(
          HTuple sheetOfLightModelID,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(386);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>For a given sheet-of-light model get the names of the generic iconic or control parameters that can be used in the different sheet-of-light operators.</summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        /// <param name="queryName">Name of the parameter group. Default: "create_model_params"</param>
        /// <param name="genParamName">List containing the names of the supported generic parameters.</param>
        public static void QuerySheetOfLightParams(
          HTuple sheetOfLightModelID,
          HTuple queryName,
          out HTuple genParamName)
        {
            IntPtr proc = HalconAPI.PreCall(387);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            HalconAPI.Store(proc, 1, queryName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            HalconAPI.UnpinTuple(queryName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Reset a sheet-of-light model.</summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        public static void ResetSheetOfLightModel(HTuple sheetOfLightModelID)
        {
            IntPtr proc = HalconAPI.PreCall(388);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete all sheet-of-light models and free the allocated memory.</summary>
        public static void ClearAllSheetOfLightModels()
        {
            IntPtr proc = HalconAPI.PreCall(389);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete a sheet-of-light model and free the allocated memory.</summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        public static void ClearSheetOfLightModel(HTuple sheetOfLightModelID)
        {
            IntPtr proc = HalconAPI.PreCall(390);
            HalconAPI.Store(proc, 0, sheetOfLightModelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sheetOfLightModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a model to perform 3D-measurements using the sheet-of-light technique.</summary>
        /// <param name="profileRegion">Region of the images containing the profiles to be processed. If the provided region is not rectangular, its smallest enclosing rectangle will be used.</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the sheet-of-light model. Default: "min_gray"</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the sheet-of-light model. Default: 50</param>
        /// <param name="sheetOfLightModelID">Handle for using and accessing the sheet-of-light model.</param>
        public static void CreateSheetOfLightModel(
          HObject profileRegion,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple sheetOfLightModelID)
        {
            IntPtr proc = HalconAPI.PreCall(391);
            HalconAPI.Store(proc, 1, (HObjectBase)profileRegion);
            HalconAPI.Store(proc, 0, genParamName);
            HalconAPI.Store(proc, 1, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out sheetOfLightModelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)profileRegion);
        }

        /// <summary>Shade a height field.</summary>
        /// <param name="imageHeight">Height field to be shaded.</param>
        /// <param name="imageShade">Shaded image.</param>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 0.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 0.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        /// <param name="shadows">Should shadows be calculated? Default: "false"</param>
        public static void ShadeHeightField(
          HObject imageHeight,
          out HObject imageShade,
          HTuple slant,
          HTuple tilt,
          HTuple albedo,
          HTuple ambient,
          HTuple shadows)
        {
            IntPtr proc = HalconAPI.PreCall(392);
            HalconAPI.Store(proc, 1, (HObjectBase)imageHeight);
            HalconAPI.Store(proc, 0, slant);
            HalconAPI.Store(proc, 1, tilt);
            HalconAPI.Store(proc, 2, albedo);
            HalconAPI.Store(proc, 3, ambient);
            HalconAPI.Store(proc, 4, shadows);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(slant);
            HalconAPI.UnpinTuple(tilt);
            HalconAPI.UnpinTuple(albedo);
            HalconAPI.UnpinTuple(ambient);
            HalconAPI.UnpinTuple(shadows);
            int procResult = HObject.LoadNew(proc, 1, err, out imageShade);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageHeight);
        }

        /// <summary>Estimate the albedo of a surface and the amount of ambient light.</summary>
        /// <param name="image">Image for which albedo and ambient are to be estimated.</param>
        /// <param name="albedo">Amount of light reflected by the surface.</param>
        /// <param name="ambient">Amount of ambient light.</param>
        public static void EstimateAlAm(HObject image, out HTuple albedo, out HTuple ambient)
        {
            IntPtr proc = HalconAPI.PreCall(393);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out albedo);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out ambient);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Estimate the slant of a light source and the albedo of a surface.</summary>
        /// <param name="image">Image for which slant and albedo are to be estimated.</param>
        /// <param name="slant">Angle of the light sources and the positive z-axis (in degrees).</param>
        /// <param name="albedo">Amount of light reflected by the surface.</param>
        public static void EstimateSlAlZc(HObject image, out HTuple slant, out HTuple albedo)
        {
            IntPtr proc = HalconAPI.PreCall(394);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out slant);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out albedo);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Estimate the slant of a light source and the albedo of a surface.</summary>
        /// <param name="image">Image for which slant and albedo are to be estimated.</param>
        /// <param name="slant">Angle between the light sources and the positive z-axis (in degrees).</param>
        /// <param name="albedo">Amount of light reflected by the surface.</param>
        public static void EstimateSlAlLr(HObject image, out HTuple slant, out HTuple albedo)
        {
            IntPtr proc = HalconAPI.PreCall(395);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out slant);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out albedo);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Estimate the tilt of a light source.</summary>
        /// <param name="image">Image for which the tilt is to be estimated.</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees).</param>
        public static void EstimateTiltZc(HObject image, out HTuple tilt)
        {
            IntPtr proc = HalconAPI.PreCall(396);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tilt);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Estimate the tilt of a light source.</summary>
        /// <param name="image">Image for which the tilt is to be estimated.</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees).</param>
        public static void EstimateTiltLr(HObject image, out HTuple tilt)
        {
            IntPtr proc = HalconAPI.PreCall(397);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tilt);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Reconstruct a surface from surface gradients.</summary>
        /// <param name="gradient">The gradient field of the image.</param>
        /// <param name="heightField">Reconstructed height field.</param>
        /// <param name="reconstructionMethod">Type of the reconstruction method. Default: "poisson"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        public static void ReconstructHeightFieldFromGradient(
          HObject gradient,
          out HObject heightField,
          HTuple reconstructionMethod,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(398);
            HalconAPI.Store(proc, 1, (HObjectBase)gradient);
            HalconAPI.Store(proc, 0, reconstructionMethod);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(reconstructionMethod);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HObject.LoadNew(proc, 1, err, out heightField);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)gradient);
        }

        /// <summary>Reconstruct a surface according to the photometric stereo technique.</summary>
        /// <param name="images">Array with at least three input images with different directions of illumination.</param>
        /// <param name="heightField">Reconstructed height field.</param>
        /// <param name="gradient">The gradient field of the surface.</param>
        /// <param name="albedo">The albedo of the surface.</param>
        /// <param name="slants">Angle between the camera and the direction of  illumination (in degrees). Default: 45.0</param>
        /// <param name="tilts">Angle of the direction of illumination within the object plane (in degrees). Default: 45.0</param>
        /// <param name="resultType">Types of the requested results. Default: "all"</param>
        /// <param name="reconstructionMethod">Type of the reconstruction method. Default: "poisson"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        public static void PhotometricStereo(
          HObject images,
          out HObject heightField,
          out HObject gradient,
          out HObject albedo,
          HTuple slants,
          HTuple tilts,
          HTuple resultType,
          HTuple reconstructionMethod,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(399);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, slants);
            HalconAPI.Store(proc, 1, tilts);
            HalconAPI.Store(proc, 2, resultType);
            HalconAPI.Store(proc, 3, reconstructionMethod);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(slants);
            HalconAPI.UnpinTuple(tilts);
            HalconAPI.UnpinTuple(resultType);
            HalconAPI.UnpinTuple(reconstructionMethod);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HObject.LoadNew(proc, 1, err1, out heightField);
            int err3 = HObject.LoadNew(proc, 2, err2, out gradient);
            int procResult = HObject.LoadNew(proc, 3, err3, out albedo);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Reconstruct a surface from a gray value image.</summary>
        /// <param name="image">Shaded input image.</param>
        /// <param name="height">Reconstructed height field.</param>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 45.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 45.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        public static void SfsPentland(
          HObject image,
          out HObject height,
          HTuple slant,
          HTuple tilt,
          HTuple albedo,
          HTuple ambient)
        {
            IntPtr proc = HalconAPI.PreCall(400);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, slant);
            HalconAPI.Store(proc, 1, tilt);
            HalconAPI.Store(proc, 2, albedo);
            HalconAPI.Store(proc, 3, ambient);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(slant);
            HalconAPI.UnpinTuple(tilt);
            HalconAPI.UnpinTuple(albedo);
            HalconAPI.UnpinTuple(ambient);
            int procResult = HObject.LoadNew(proc, 1, err, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Reconstruct a surface from a gray value image.</summary>
        /// <param name="image">Shaded input image.</param>
        /// <param name="height">Reconstructed height field.</param>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 45.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 45.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        public static void SfsOrigLr(
          HObject image,
          out HObject height,
          HTuple slant,
          HTuple tilt,
          HTuple albedo,
          HTuple ambient)
        {
            IntPtr proc = HalconAPI.PreCall(401);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, slant);
            HalconAPI.Store(proc, 1, tilt);
            HalconAPI.Store(proc, 2, albedo);
            HalconAPI.Store(proc, 3, ambient);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(slant);
            HalconAPI.UnpinTuple(tilt);
            HalconAPI.UnpinTuple(albedo);
            HalconAPI.UnpinTuple(ambient);
            int procResult = HObject.LoadNew(proc, 1, err, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Reconstruct a surface from a gray value image.</summary>
        /// <param name="image">Shaded input image.</param>
        /// <param name="height">Reconstructed height field.</param>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 45.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 45.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        public static void SfsModLr(
          HObject image,
          out HObject height,
          HTuple slant,
          HTuple tilt,
          HTuple albedo,
          HTuple ambient)
        {
            IntPtr proc = HalconAPI.PreCall(402);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, slant);
            HalconAPI.Store(proc, 1, tilt);
            HalconAPI.Store(proc, 2, albedo);
            HalconAPI.Store(proc, 3, ambient);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(slant);
            HalconAPI.UnpinTuple(tilt);
            HalconAPI.UnpinTuple(albedo);
            HalconAPI.UnpinTuple(ambient);
            int procResult = HObject.LoadNew(proc, 1, err, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Receive a serialized item over a socket connection.</summary>
        /// <param name="socket">Socket number.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void ReceiveSerializedItem(HTuple socket, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(403);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Send a serialized item over a socket connection.</summary>
        /// <param name="socket">Socket number.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SendSerializedItem(HTuple socket, HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(404);
            HalconAPI.Store(proc, 0, socket);
            HalconAPI.Store(proc, 1, serializedItemHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(socket);
            HalconAPI.UnpinTuple(serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a serialized item to a file.</summary>
        /// <param name="fileHandle">File handle.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void FwriteSerializedItem(HTuple fileHandle, HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(405);
            HalconAPI.Store(proc, 0, fileHandle);
            HalconAPI.Store(proc, 1, serializedItemHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileHandle);
            HalconAPI.UnpinTuple(serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a serialized item from a file.</summary>
        /// <param name="fileHandle">File handle.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void FreadSerializedItem(HTuple fileHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(406);
            HalconAPI.Store(proc, 0, fileHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete all current existing serialized items.</summary>
        public static void ClearAllSerializedItems()
        {
            IntPtr proc = HalconAPI.PreCall(407);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete a serialized item.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void ClearSerializedItem(HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(408);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Access the data pointer of a serialized item.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="pointer">Data pointer of the serialized item.</param>
        /// <param name="size">Size of the serialized item.</param>
        public static void GetSerializedItemPtr(
          HTuple serializedItemHandle,
          out HTuple pointer,
          out HTuple size)
        {
            IntPtr proc = HalconAPI.PreCall(409);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out pointer);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out size);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a serialized item.</summary>
        /// <param name="pointer">Data pointer of the serialized item.</param>
        /// <param name="size">Size of the serialized item.</param>
        /// <param name="copy">Copy mode of the serialized item. Default: "true"</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void CreateSerializedItemPtr(
          HTuple pointer,
          HTuple size,
          HTuple copy,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(410);
            HalconAPI.Store(proc, 0, pointer);
            HalconAPI.Store(proc, 1, size);
            HalconAPI.Store(proc, 2, copy);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pointer);
            HalconAPI.UnpinTuple(size);
            HalconAPI.UnpinTuple(copy);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Fit 3D primitives into a set of 3D points.</summary>
        /// <param name="objectModel3D">Handle of the input 3D object model.</param>
        /// <param name="genParamName">Names of the generic parameters.</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        /// <param name="objectModel3DOut">Handle of the output 3D object model.</param>
        public static void FitPrimitivesObjectModel3d(
          HTuple objectModel3D,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple objectModel3DOut)
        {
            IntPtr proc = HalconAPI.PreCall(411);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Segment a set of 3D points into sub-sets with similar characteristics.</summary>
        /// <param name="objectModel3D">Handle of the input 3D object model.</param>
        /// <param name="genParamName">Names of the generic parameters.</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        /// <param name="objectModel3DOut">Handle of the output 3D object model.</param>
        public static void SegmentObjectModel3d(
          HTuple objectModel3D,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple objectModel3DOut)
        {
            IntPtr proc = HalconAPI.PreCall(412);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all text results.</summary>
        public static void ClearAllTextResults()
        {
            IntPtr proc = HalconAPI.PreCall(413);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a text result.</summary>
        /// <param name="textResultID">Text result to be cleared.</param>
        public static void ClearTextResult(HTuple textResultID)
        {
            IntPtr proc = HalconAPI.PreCall(414);
            HalconAPI.Store(proc, 0, textResultID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textResultID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query an iconic value of a text segmentation result.</summary>
        /// <param name="characters">Returned result.</param>
        /// <param name="textResultID">Text result.</param>
        /// <param name="resultName">Name of the result to be returned. Default: "all_lines"</param>
        public static void GetTextObject(
          out HObject characters,
          HTuple textResultID,
          HTuple resultName)
        {
            IntPtr proc = HalconAPI.PreCall(415);
            HalconAPI.Store(proc, 0, textResultID);
            HalconAPI.Store(proc, 1, resultName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textResultID);
            HalconAPI.UnpinTuple(resultName);
            int procResult = HObject.LoadNew(proc, 1, err, out characters);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query a control value of a text segmentation result.</summary>
        /// <param name="textResultID">Text result.</param>
        /// <param name="resultName">Name of the result to be returned. Default: "class"</param>
        /// <param name="resultValue">Value of ResultName.</param>
        public static void GetTextResult(
          HTuple textResultID,
          HTuple resultName,
          out HTuple resultValue)
        {
            IntPtr proc = HalconAPI.PreCall(416);
            HalconAPI.Store(proc, 0, textResultID);
            HalconAPI.Store(proc, 1, resultName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textResultID);
            HalconAPI.UnpinTuple(resultName);
            int procResult = HTuple.LoadNew(proc, 0, err, out resultValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find text in an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="textModel">Text model specifying the text to be segmented.</param>
        /// <param name="textResultID">Result of the segmentation.</param>
        public static void FindText(HObject image, HTuple textModel, out HTuple textResultID)
        {
            IntPtr proc = HalconAPI.PreCall(417);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, textModel);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textModel);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out textResultID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Query parameters of a text model.</summary>
        /// <param name="textModel">Text model.</param>
        /// <param name="genParamName">Parameters to be queried. Default: "min_contrast"</param>
        /// <param name="genParamValue">Values of Parameters.</param>
        public static void GetTextModelParam(
          HTuple textModel,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(418);
            HalconAPI.Store(proc, 0, textModel);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textModel);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters of a text model.</summary>
        /// <param name="textModel">Text model.</param>
        /// <param name="genParamName">Names of the parameters to be set. Default: "min_contrast"</param>
        /// <param name="genParamValue">Values of the parameters to be set. Default: 10</param>
        public static void SetTextModelParam(
          HTuple textModel,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(419);
            HalconAPI.Store(proc, 0, textModel);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textModel);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all text models.</summary>
        public static void ClearAllTextModels()
        {
            IntPtr proc = HalconAPI.PreCall(420);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a text model.</summary>
        /// <param name="textModel">Text model to be cleared.</param>
        public static void ClearTextModel(HTuple textModel)
        {
            IntPtr proc = HalconAPI.PreCall(421);
            HalconAPI.Store(proc, 0, textModel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a text model.</summary>
        /// <param name="mode">The Mode of the text model. Default: "auto"</param>
        /// <param name="OCRClassifier">OCR Classifier. Default: "Universal_Rej.occ"</param>
        /// <param name="textModel">New text model.</param>
        public static void CreateTextModelReader(
          HTuple mode,
          HTuple OCRClassifier,
          out HTuple textModel)
        {
            IntPtr proc = HalconAPI.PreCall(422);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, OCRClassifier);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(OCRClassifier);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out textModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a text model.</summary>
        /// <param name="textModel">New text model.</param>
        public static void CreateTextModel(out HTuple textModel)
        {
            IntPtr proc = HalconAPI.PreCall(423);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out textModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Selects characters from a given region.</summary>
        /// <param name="region">Region of text lines in which to select the characters.</param>
        /// <param name="regionCharacters">Selected characters.</param>
        /// <param name="dotPrint">Should dot print characters be detected? Default: "false"</param>
        /// <param name="strokeWidth">Stroke width of a character. Default: "medium"</param>
        /// <param name="charWidth">Width of a character. Default: 25</param>
        /// <param name="charHeight">Height of a character. Default: 25</param>
        /// <param name="punctuation">Add punctuation? Default: "false"</param>
        /// <param name="diacriticMarks">Exist diacritic marks? Default: "false"</param>
        /// <param name="partitionMethod">Method to partition neighbored characters. Default: "none"</param>
        /// <param name="partitionLines">Should lines be partitioned? Default: "false"</param>
        /// <param name="fragmentDistance">Distance of fragments. Default: "medium"</param>
        /// <param name="connectFragments">Connect fragments? Default: "false"</param>
        /// <param name="clutterSizeMax">Maximum size of clutter. Default: 0</param>
        /// <param name="stopAfter">Stop execution after this step. Default: "completion"</param>
        public static void SelectCharacters(
          HObject region,
          out HObject regionCharacters,
          HTuple dotPrint,
          HTuple strokeWidth,
          HTuple charWidth,
          HTuple charHeight,
          HTuple punctuation,
          HTuple diacriticMarks,
          HTuple partitionMethod,
          HTuple partitionLines,
          HTuple fragmentDistance,
          HTuple connectFragments,
          HTuple clutterSizeMax,
          HTuple stopAfter)
        {
            IntPtr proc = HalconAPI.PreCall(424);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, dotPrint);
            HalconAPI.Store(proc, 1, strokeWidth);
            HalconAPI.Store(proc, 2, charWidth);
            HalconAPI.Store(proc, 3, charHeight);
            HalconAPI.Store(proc, 4, punctuation);
            HalconAPI.Store(proc, 5, diacriticMarks);
            HalconAPI.Store(proc, 6, partitionMethod);
            HalconAPI.Store(proc, 7, partitionLines);
            HalconAPI.Store(proc, 8, fragmentDistance);
            HalconAPI.Store(proc, 9, connectFragments);
            HalconAPI.Store(proc, 10, clutterSizeMax);
            HalconAPI.Store(proc, 11, stopAfter);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dotPrint);
            HalconAPI.UnpinTuple(strokeWidth);
            HalconAPI.UnpinTuple(charWidth);
            HalconAPI.UnpinTuple(charHeight);
            HalconAPI.UnpinTuple(punctuation);
            HalconAPI.UnpinTuple(diacriticMarks);
            HalconAPI.UnpinTuple(partitionMethod);
            HalconAPI.UnpinTuple(partitionLines);
            HalconAPI.UnpinTuple(fragmentDistance);
            HalconAPI.UnpinTuple(connectFragments);
            HalconAPI.UnpinTuple(clutterSizeMax);
            HalconAPI.UnpinTuple(stopAfter);
            int procResult = HObject.LoadNew(proc, 1, err, out regionCharacters);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Segments characters in a given region of an image.</summary>
        /// <param name="region">Area in the image where the text lines are located.</param>
        /// <param name="image">Input image.</param>
        /// <param name="imageForeground">Image used for the segmentation.</param>
        /// <param name="regionForeground">Region of characters.</param>
        /// <param name="method">Method to segment the characters. Default: "local_auto_shape"</param>
        /// <param name="eliminateLines">Eliminate horizontal and vertical lines? Default: "false"</param>
        /// <param name="dotPrint">Should dot print characters be detected? Default: "false"</param>
        /// <param name="strokeWidth">Stroke width of a character. Default: "medium"</param>
        /// <param name="charWidth">Width of a character. Default: 25</param>
        /// <param name="charHeight">Height of a character. Default: 25</param>
        /// <param name="thresholdOffset">Value to adjust the segmentation. Default: 0</param>
        /// <param name="contrast">Minimum gray value difference between text and background. Default: 10</param>
        /// <param name="usedThreshold">Threshold used to segment the characters.</param>
        public static void SegmentCharacters(
          HObject region,
          HObject image,
          out HObject imageForeground,
          out HObject regionForeground,
          HTuple method,
          HTuple eliminateLines,
          HTuple dotPrint,
          HTuple strokeWidth,
          HTuple charWidth,
          HTuple charHeight,
          HTuple thresholdOffset,
          HTuple contrast,
          out HTuple usedThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(425);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, method);
            HalconAPI.Store(proc, 1, eliminateLines);
            HalconAPI.Store(proc, 2, dotPrint);
            HalconAPI.Store(proc, 3, strokeWidth);
            HalconAPI.Store(proc, 4, charWidth);
            HalconAPI.Store(proc, 5, charHeight);
            HalconAPI.Store(proc, 6, thresholdOffset);
            HalconAPI.Store(proc, 7, contrast);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(eliminateLines);
            HalconAPI.UnpinTuple(dotPrint);
            HalconAPI.UnpinTuple(strokeWidth);
            HalconAPI.UnpinTuple(charWidth);
            HalconAPI.UnpinTuple(charHeight);
            HalconAPI.UnpinTuple(thresholdOffset);
            HalconAPI.UnpinTuple(contrast);
            int err2 = HObject.LoadNew(proc, 1, err1, out imageForeground);
            int err3 = HObject.LoadNew(proc, 2, err2, out regionForeground);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err3, out usedThreshold);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determines the slant of characters of a text line or paragraph.</summary>
        /// <param name="region">Area of text lines.</param>
        /// <param name="image">Input image.</param>
        /// <param name="charHeight">Height of the text lines. Default: 25</param>
        /// <param name="slantFrom">Minimum slant of the characters Default: -0.523599</param>
        /// <param name="slantTo">Maximum slant of the characters Default: 0.523599</param>
        /// <param name="slantAngle">Calculated slant of the characters in the region</param>
        public static void TextLineSlant(
          HObject region,
          HObject image,
          HTuple charHeight,
          HTuple slantFrom,
          HTuple slantTo,
          out HTuple slantAngle)
        {
            IntPtr proc = HalconAPI.PreCall(426);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, charHeight);
            HalconAPI.Store(proc, 1, slantFrom);
            HalconAPI.Store(proc, 2, slantTo);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(charHeight);
            HalconAPI.UnpinTuple(slantFrom);
            HalconAPI.UnpinTuple(slantTo);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out slantAngle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determines the orientation of a text line or paragraph.</summary>
        /// <param name="region">Area of text lines.</param>
        /// <param name="image">Input image.</param>
        /// <param name="charHeight">Height of the text lines. Default: 25</param>
        /// <param name="orientationFrom">Minimum rotation of the text lines. Default: -0.523599</param>
        /// <param name="orientationTo">Maximum rotation of the text lines. Default: 0.523599</param>
        /// <param name="orientationAngle">Calculated rotation angle of the text lines.</param>
        public static void TextLineOrientation(
          HObject region,
          HObject image,
          HTuple charHeight,
          HTuple orientationFrom,
          HTuple orientationTo,
          out HTuple orientationAngle)
        {
            IntPtr proc = HalconAPI.PreCall(427);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, charHeight);
            HalconAPI.Store(proc, 1, orientationFrom);
            HalconAPI.Store(proc, 2, orientationTo);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(charHeight);
            HalconAPI.UnpinTuple(orientationFrom);
            HalconAPI.UnpinTuple(orientationTo);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out orientationAngle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)image);
        }

        /// <summary>Classify a byte image using a look-up table.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="classRegions">Segmented classes.</param>
        /// <param name="classLUTHandle">Handle of the LUT classifier.</param>
        public static void ClassifyImageClassLut(
          HObject image,
          out HObject classRegions,
          HTuple classLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(428);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, classLUTHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classLUTHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out classRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Classify an image with a k-Nearest-Neighbor classifier.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="classRegions">Segmented classes.</param>
        /// <param name="distanceImage">Distance of the pixel's nearest neighbor.</param>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="rejectionThreshold">Threshold for the rejection of the classification. Default: 0.5</param>
        public static void ClassifyImageClassKnn(
          HObject image,
          out HObject classRegions,
          out HObject distanceImage,
          HTuple KNNHandle,
          HTuple rejectionThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(429);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.Store(proc, 1, rejectionThreshold);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.UnpinTuple(rejectionThreshold);
            int err2 = HObject.LoadNew(proc, 1, err1, out classRegions);
            int procResult = HObject.LoadNew(proc, 2, err2, out distanceImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Add training samples from an image to the training data of a k-Nearest-Neighbor classifier.</summary>
        /// <param name="image">Training image.</param>
        /// <param name="classRegions">Regions of the classes to be trained.</param>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        public static void AddSamplesImageClassKnn(
          HObject image,
          HObject classRegions,
          HTuple KNNHandle)
        {
            IntPtr proc = HalconAPI.PreCall(430);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)classRegions);
            HalconAPI.Store(proc, 0, KNNHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)classRegions);
        }

        /// <summary>Classify an image with a Gaussian Mixture Model.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="classRegions">Segmented classes.</param>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="rejectionThreshold">Threshold for the rejection of the classification. Default: 0.5</param>
        public static void ClassifyImageClassGmm(
          HObject image,
          out HObject classRegions,
          HTuple GMMHandle,
          HTuple rejectionThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(431);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, rejectionThreshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(rejectionThreshold);
            int procResult = HObject.LoadNew(proc, 1, err, out classRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Add training samples from an image to the training data of a Gaussian Mixture Model.</summary>
        /// <param name="image">Training image.</param>
        /// <param name="classRegions">Regions of the classes to be trained.</param>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="randomize">Standard deviation of the Gaussian noise added to the training data. Default: 0.0</param>
        public static void AddSamplesImageClassGmm(
          HObject image,
          HObject classRegions,
          HTuple GMMHandle,
          HTuple randomize)
        {
            IntPtr proc = HalconAPI.PreCall(432);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)classRegions);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, randomize);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(randomize);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)classRegions);
        }

        /// <summary>Classify an image with a support vector machine.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="classRegions">Segmented classes.</param>
        /// <param name="SVMHandle">SVM handle.</param>
        public static void ClassifyImageClassSvm(
          HObject image,
          out HObject classRegions,
          HTuple SVMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(433);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out classRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Add training samples from an image to the training data of a support vector machine.</summary>
        /// <param name="image">Training image.</param>
        /// <param name="classRegions">Regions of the classes to be trained.</param>
        /// <param name="SVMHandle">SVM handle.</param>
        public static void AddSamplesImageClassSvm(
          HObject image,
          HObject classRegions,
          HTuple SVMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(434);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)classRegions);
            HalconAPI.Store(proc, 0, SVMHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)classRegions);
        }

        /// <summary>Classify an image with a multilayer perceptron.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="classRegions">Segmented classes.</param>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="rejectionThreshold">Threshold for the rejection of the classification. Default: 0.5</param>
        public static void ClassifyImageClassMlp(
          HObject image,
          out HObject classRegions,
          HTuple MLPHandle,
          HTuple rejectionThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(435);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, rejectionThreshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(rejectionThreshold);
            int procResult = HObject.LoadNew(proc, 1, err, out classRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Add training samples from an image to the training data of a multilayer perceptron.</summary>
        /// <param name="image">Training image.</param>
        /// <param name="classRegions">Regions of the classes to be trained.</param>
        /// <param name="MLPHandle">MLP handle.</param>
        public static void AddSamplesImageClassMlp(
          HObject image,
          HObject classRegions,
          HTuple MLPHandle)
        {
            IntPtr proc = HalconAPI.PreCall(436);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)classRegions);
            HalconAPI.Store(proc, 0, MLPHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)classRegions);
        }

        /// <summary>Construct classes for class_ndim_norm.</summary>
        /// <param name="foreground">Foreground pixels to be trained.</param>
        /// <param name="background">Background pixels to be trained (rejection class).</param>
        /// <param name="image">Multi-channel training image.</param>
        /// <param name="metric">Metric to be used. Default: "euclid"</param>
        /// <param name="distance">Maximum cluster radius. Default: 10.0</param>
        /// <param name="minNumberPercent">The ratio of the number of pixels in a cluster to the total number of pixels (in percent) must be larger than MinNumberPercent (otherwise the cluster is not output). Default: 0.01</param>
        /// <param name="radius">Cluster radii or half edge lengths.</param>
        /// <param name="center">Coordinates of all cluster centers.</param>
        /// <param name="quality">Overlap of the rejection class with the classified objects (1: no overlap).</param>
        public static void LearnNdimNorm(
          HObject foreground,
          HObject background,
          HObject image,
          HTuple metric,
          HTuple distance,
          HTuple minNumberPercent,
          out HTuple radius,
          out HTuple center,
          out HTuple quality)
        {
            IntPtr proc = HalconAPI.PreCall(437);
            HalconAPI.Store(proc, 1, (HObjectBase)foreground);
            HalconAPI.Store(proc, 2, (HObjectBase)background);
            HalconAPI.Store(proc, 3, (HObjectBase)image);
            HalconAPI.Store(proc, 0, metric);
            HalconAPI.Store(proc, 1, distance);
            HalconAPI.Store(proc, 2, minNumberPercent);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(distance);
            HalconAPI.UnpinTuple(minNumberPercent);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out radius);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out center);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out quality);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)foreground);
            GC.KeepAlive((object)background);
            GC.KeepAlive((object)image);
        }

        /// <summary>Train a classificator using a multi-channel image.</summary>
        /// <param name="foreground">Foreground pixels to be trained.</param>
        /// <param name="background">Background pixels to be trained (rejection class).</param>
        /// <param name="multiChannelImage">Multi-channel training image.</param>
        /// <param name="classifHandle">Handle of the classifier.</param>
        public static void LearnNdimBox(
          HObject foreground,
          HObject background,
          HObject multiChannelImage,
          HTuple classifHandle)
        {
            IntPtr proc = HalconAPI.PreCall(438);
            HalconAPI.Store(proc, 1, (HObjectBase)foreground);
            HalconAPI.Store(proc, 2, (HObjectBase)background);
            HalconAPI.Store(proc, 3, (HObjectBase)multiChannelImage);
            HalconAPI.Store(proc, 0, classifHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)foreground);
            GC.KeepAlive((object)background);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Classify pixels using hyper-cuboids.</summary>
        /// <param name="multiChannelImage">Multi channel input image.</param>
        /// <param name="regions">Classification result.</param>
        /// <param name="classifHandle">Handle of the classifier.</param>
        public static void ClassNdimBox(
          HObject multiChannelImage,
          out HObject regions,
          HTuple classifHandle)
        {
            IntPtr proc = HalconAPI.PreCall(439);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out regions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Classify pixels using hyper-spheres or hyper-cubes.</summary>
        /// <param name="multiChannelImage">Multi channel input image.</param>
        /// <param name="regions">Classification result.</param>
        /// <param name="metric">Metric to be used. Default: "euclid"</param>
        /// <param name="singleMultiple">Return one region or one region for each cluster. Default: "single"</param>
        /// <param name="radius">Cluster radii or half edge lengths (returned by learn_ndim_norm).</param>
        /// <param name="center">Coordinates of the cluster centers (returned by learn_ndim_norm).</param>
        public static void ClassNdimNorm(
          HObject multiChannelImage,
          out HObject regions,
          HTuple metric,
          HTuple singleMultiple,
          HTuple radius,
          HTuple center)
        {
            IntPtr proc = HalconAPI.PreCall(440);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.Store(proc, 0, metric);
            HalconAPI.Store(proc, 1, singleMultiple);
            HalconAPI.Store(proc, 2, radius);
            HalconAPI.Store(proc, 3, center);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(singleMultiple);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(center);
            int procResult = HObject.LoadNew(proc, 1, err, out regions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Segment an image using two-dimensional pixel classification.</summary>
        /// <param name="imageCol">Input image (first channel).</param>
        /// <param name="imageRow">Input image (second channel).</param>
        /// <param name="featureSpace">Region defining the feature space.</param>
        /// <param name="regionClass2Dim">Classified regions.</param>
        public static void Class2dimSup(
          HObject imageCol,
          HObject imageRow,
          HObject featureSpace,
          out HObject regionClass2Dim)
        {
            IntPtr proc = HalconAPI.PreCall(441);
            HalconAPI.Store(proc, 1, (HObjectBase)imageCol);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRow);
            HalconAPI.Store(proc, 3, (HObjectBase)featureSpace);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionClass2Dim);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageCol);
            GC.KeepAlive((object)imageRow);
            GC.KeepAlive((object)featureSpace);
        }

        /// <summary>Segment two images by clustering.</summary>
        /// <param name="image1">First input image.</param>
        /// <param name="image2">Second input image.</param>
        /// <param name="classes">Classification result.</param>
        /// <param name="threshold">Threshold (maximum distance to the cluster's center). Default: 15</param>
        /// <param name="numClasses">Number of classes (cluster centers). Default: 5</param>
        public static void Class2dimUnsup(
          HObject image1,
          HObject image2,
          out HObject classes,
          HTuple threshold,
          HTuple numClasses)
        {
            IntPtr proc = HalconAPI.PreCall(442);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, threshold);
            HalconAPI.Store(proc, 1, numClasses);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(threshold);
            HalconAPI.UnpinTuple(numClasses);
            int procResult = HObject.LoadNew(proc, 1, err, out classes);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Compare two images pixel by pixel.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="pattern">Comparison image.</param>
        /// <param name="selected">Points in which the two images are similar/different.</param>
        /// <param name="mode">Mode: return similar or different pixels. Default: "diff_outside"</param>
        /// <param name="diffLowerBound">Lower bound of the tolerated gray value difference. Default: -5</param>
        /// <param name="diffUpperBound">Upper bound of the tolerated gray value difference. Default: 5</param>
        /// <param name="grayOffset">Offset gray value subtracted from the input image. Default: 0</param>
        /// <param name="addRow">Row coordinate by which the comparison image is translated. Default: 0</param>
        /// <param name="addCol">Column coordinate by which the comparison image is translated. Default: 0</param>
        public static void CheckDifference(
          HObject image,
          HObject pattern,
          out HObject selected,
          HTuple mode,
          HTuple diffLowerBound,
          HTuple diffUpperBound,
          HTuple grayOffset,
          HTuple addRow,
          HTuple addCol)
        {
            IntPtr proc = HalconAPI.PreCall(443);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)pattern);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, diffLowerBound);
            HalconAPI.Store(proc, 2, diffUpperBound);
            HalconAPI.Store(proc, 3, grayOffset);
            HalconAPI.Store(proc, 4, addRow);
            HalconAPI.Store(proc, 5, addCol);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(diffLowerBound);
            HalconAPI.UnpinTuple(diffUpperBound);
            HalconAPI.UnpinTuple(grayOffset);
            HalconAPI.UnpinTuple(addRow);
            HalconAPI.UnpinTuple(addCol);
            int procResult = HObject.LoadNew(proc, 1, err, out selected);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)pattern);
        }

        /// <summary>Perform a threshold segmentation for extracting characters.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="histoRegion">Region in which the histogram is computed.</param>
        /// <param name="characters">Dark regions (characters).</param>
        /// <param name="sigma">Sigma for the Gaussian smoothing of the histogram. Default: 2.0</param>
        /// <param name="percent">Percentage for the gray value difference. Default: 95</param>
        /// <param name="threshold">Calculated threshold.</param>
        public static void CharThreshold(
          HObject image,
          HObject histoRegion,
          out HObject characters,
          HTuple sigma,
          HTuple percent,
          out HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(444);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)histoRegion);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, percent);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(percent);
            int err2 = HObject.LoadNew(proc, 1, err1, out characters);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err2, out threshold);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)histoRegion);
        }

        /// <summary>Extract regions with equal gray values from an image.</summary>
        /// <param name="labelImage">Label image.</param>
        /// <param name="regions">Regions having a constant gray value.</param>
        public static void LabelToRegion(HObject labelImage, out HObject regions)
        {
            IntPtr proc = HalconAPI.PreCall(445);
            HalconAPI.Store(proc, 1, (HObjectBase)labelImage);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)labelImage);
        }

        /// <summary>Suppress non-maximum points on an edge.</summary>
        /// <param name="imgAmp">Amplitude (gradient magnitude) image.</param>
        /// <param name="imageResult">Image with thinned edge regions.</param>
        /// <param name="mode">Select horizontal/vertical or undirected NMS. Default: "hvnms"</param>
        public static void NonmaxSuppressionAmp(HObject imgAmp, out HObject imageResult, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(446);
            HalconAPI.Store(proc, 1, (HObjectBase)imgAmp);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imgAmp);
        }

        /// <summary>Suppress non-maximum points on an edge using a direction image.</summary>
        /// <param name="imgAmp">Amplitude (gradient magnitude) image.</param>
        /// <param name="imgDir">Direction image.</param>
        /// <param name="imageResult">Image with thinned edge regions.</param>
        /// <param name="mode">Select non-maximum-suppression or interpolating NMS. Default: "nms"</param>
        public static void NonmaxSuppressionDir(
          HObject imgAmp,
          HObject imgDir,
          out HObject imageResult,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(447);
            HalconAPI.Store(proc, 1, (HObjectBase)imgAmp);
            HalconAPI.Store(proc, 2, (HObjectBase)imgDir);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imgAmp);
            GC.KeepAlive((object)imgDir);
        }

        /// <summary>Perform a hysteresis threshold operation on an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="regionHysteresis">Segmented region.</param>
        /// <param name="low">Lower threshold for the gray values. Default: 30</param>
        /// <param name="high">Upper threshold for the gray values. Default: 60</param>
        /// <param name="maxLength">Maximum length of a path of "potential" points to reach a "secure" point. Default: 10</param>
        public static void HysteresisThreshold(
          HObject image,
          out HObject regionHysteresis,
          HTuple low,
          HTuple high,
          HTuple maxLength)
        {
            IntPtr proc = HalconAPI.PreCall(448);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, low);
            HalconAPI.Store(proc, 1, high);
            HalconAPI.Store(proc, 2, maxLength);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            HalconAPI.UnpinTuple(maxLength);
            int procResult = HObject.LoadNew(proc, 1, err, out regionHysteresis);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Segment an image using binary thresholding.</summary>
        /// <param name="image">Input Image.</param>
        /// <param name="region">Segmented output region.</param>
        /// <param name="method">Segmentation method. Default: "max_separability"</param>
        /// <param name="lightDark">Extract foreground or background? Default: "dark"</param>
        /// <param name="usedThreshold">Used threshold.</param>
        public static void BinaryThreshold(
          HObject image,
          out HObject region,
          HTuple method,
          HTuple lightDark,
          out HTuple usedThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(449);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, method);
            HalconAPI.Store(proc, 1, lightDark);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(lightDark);
            int err2 = HObject.LoadNew(proc, 1, err1, out region);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err2, out usedThreshold);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Segment an image using local thresholding.</summary>
        /// <param name="image">Input Image.</param>
        /// <param name="region">Segmented output region.</param>
        /// <param name="method">Segmentation method. Default: "adapted_std_deviation"</param>
        /// <param name="lightDark">Extract foreground or background? Default: "dark"</param>
        /// <param name="genParamName">List of generic parameter names. Default: []</param>
        /// <param name="genParamValue">List of generic parameter values. Default: []</param>
        public static void LocalThreshold(
          HObject image,
          out HObject region,
          HTuple method,
          HTuple lightDark,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(450);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, method);
            HalconAPI.Store(proc, 1, lightDark);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(lightDark);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Threshold an image by local mean and standard deviation analysis.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="region">Segmented regions.</param>
        /// <param name="maskWidth">Mask width for mean and deviation calculation. Default: 15</param>
        /// <param name="maskHeight">Mask height for mean and deviation calculation. Default: 15</param>
        /// <param name="stdDevScale">Factor for the standard deviation of the gray values. Default: 0.2</param>
        /// <param name="absThreshold">Minimum gray value difference from the mean. Default: 2</param>
        /// <param name="lightDark">Threshold type. Default: "dark"</param>
        public static void VarThreshold(
          HObject image,
          out HObject region,
          HTuple maskWidth,
          HTuple maskHeight,
          HTuple stdDevScale,
          HTuple absThreshold,
          HTuple lightDark)
        {
            IntPtr proc = HalconAPI.PreCall(451);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.Store(proc, 2, stdDevScale);
            HalconAPI.Store(proc, 3, absThreshold);
            HalconAPI.Store(proc, 4, lightDark);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(stdDevScale);
            HalconAPI.UnpinTuple(absThreshold);
            HalconAPI.UnpinTuple(lightDark);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Segment an image using a local threshold.</summary>
        /// <param name="origImage">Input image.</param>
        /// <param name="thresholdImage">Image containing the local thresholds.</param>
        /// <param name="regionDynThresh">Segmented regions.</param>
        /// <param name="offset">Offset applied to ThresholdImage. Default: 5.0</param>
        /// <param name="lightDark">Extract light, dark or similar areas? Default: "light"</param>
        public static void DynThreshold(
          HObject origImage,
          HObject thresholdImage,
          out HObject regionDynThresh,
          HTuple offset,
          HTuple lightDark)
        {
            IntPtr proc = HalconAPI.PreCall(452);
            HalconAPI.Store(proc, 1, (HObjectBase)origImage);
            HalconAPI.Store(proc, 2, (HObjectBase)thresholdImage);
            HalconAPI.Store(proc, 0, offset);
            HalconAPI.Store(proc, 1, lightDark);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(offset);
            HalconAPI.UnpinTuple(lightDark);
            int procResult = HObject.LoadNew(proc, 1, err, out regionDynThresh);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)origImage);
            GC.KeepAlive((object)thresholdImage);
        }

        /// <summary>Segment an image using global threshold.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="region">Segmented region.</param>
        /// <param name="minGray">Lower threshold for the gray values. Default: 128.0</param>
        /// <param name="maxGray">Upper threshold for the gray values. Default: 255.0</param>
        public static void Threshold(
          HObject image,
          out HObject region,
          HTuple minGray,
          HTuple maxGray)
        {
            IntPtr proc = HalconAPI.PreCall(453);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, minGray);
            HalconAPI.Store(proc, 1, maxGray);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minGray);
            HalconAPI.UnpinTuple(maxGray);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract level crossings from an image with subpixel accuracy.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="border">Extracted level crossings.</param>
        /// <param name="threshold">Threshold for the level crossings. Default: 128</param>
        public static void ThresholdSubPix(HObject image, out HObject border, HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(454);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(threshold);
            int procResult = HObject.LoadNew(proc, 1, err, out border);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Segment an image using regiongrowing for multi-channel images.</summary>
        /// <param name="multiChannelImage">Input image.</param>
        /// <param name="regions">Segmented regions.</param>
        /// <param name="metric">Metric for the distance of the feature vectors. Default: "2-norm"</param>
        /// <param name="minTolerance">Lower threshold for the features' distance. Default: 0.0</param>
        /// <param name="maxTolerance">Upper threshold for the features' distance. Default: 20.0</param>
        /// <param name="minSize">Minimum size of the output regions. Default: 30</param>
        public static void RegiongrowingN(
          HObject multiChannelImage,
          out HObject regions,
          HTuple metric,
          HTuple minTolerance,
          HTuple maxTolerance,
          HTuple minSize)
        {
            IntPtr proc = HalconAPI.PreCall(455);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.Store(proc, 0, metric);
            HalconAPI.Store(proc, 1, minTolerance);
            HalconAPI.Store(proc, 2, maxTolerance);
            HalconAPI.Store(proc, 3, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(minTolerance);
            HalconAPI.UnpinTuple(maxTolerance);
            HalconAPI.UnpinTuple(minSize);
            int procResult = HObject.LoadNew(proc, 1, err, out regions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Segment an image using regiongrowing.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="regions">Segmented regions.</param>
        /// <param name="row">Vertical distance between tested pixels (height of the raster). Default: 3</param>
        /// <param name="column">Horizontal distance between tested pixels (height of the raster). Default: 3</param>
        /// <param name="tolerance">Points with a gray value difference less then or equal to tolerance are accumulated into the same object. Default: 6.0</param>
        /// <param name="minSize">Minimum size of the output regions. Default: 100</param>
        public static void Regiongrowing(
          HObject image,
          out HObject regions,
          HTuple row,
          HTuple column,
          HTuple tolerance,
          HTuple minSize)
        {
            IntPtr proc = HalconAPI.PreCall(456);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, tolerance);
            HalconAPI.Store(proc, 3, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(tolerance);
            HalconAPI.UnpinTuple(minSize);
            int procResult = HObject.LoadNew(proc, 1, err, out regions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Perform a regiongrowing using mean gray values.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="regions">Segmented regions.</param>
        /// <param name="startRows">Row coordinates of the starting points. Default: []</param>
        /// <param name="startColumns">Column coordinates of the starting points. Default: []</param>
        /// <param name="tolerance">Maximum deviation from the mean. Default: 5.0</param>
        /// <param name="minSize">Minimum size of a region. Default: 100</param>
        public static void RegiongrowingMean(
          HObject image,
          out HObject regions,
          HTuple startRows,
          HTuple startColumns,
          HTuple tolerance,
          HTuple minSize)
        {
            IntPtr proc = HalconAPI.PreCall(457);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, startRows);
            HalconAPI.Store(proc, 1, startColumns);
            HalconAPI.Store(proc, 2, tolerance);
            HalconAPI.Store(proc, 3, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(startRows);
            HalconAPI.UnpinTuple(startColumns);
            HalconAPI.UnpinTuple(tolerance);
            HalconAPI.UnpinTuple(minSize);
            int procResult = HObject.LoadNew(proc, 1, err, out regions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Segment an image by "pouring water" over it.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="regions">Segmented regions.</param>
        /// <param name="mode">Mode of operation. Default: "all"</param>
        /// <param name="minGray">All gray values smaller than this threshold are disregarded. Default: 0</param>
        /// <param name="maxGray">All gray values larger than this threshold are disregarded. Default: 255</param>
        public static void Pouring(
          HObject image,
          out HObject regions,
          HTuple mode,
          HTuple minGray,
          HTuple maxGray)
        {
            IntPtr proc = HalconAPI.PreCall(458);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, minGray);
            HalconAPI.Store(proc, 2, maxGray);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(minGray);
            HalconAPI.UnpinTuple(maxGray);
            int procResult = HObject.LoadNew(proc, 1, err, out regions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract watershed basins from an image using a threshold.</summary>
        /// <param name="image">Image to be segmented.</param>
        /// <param name="basins">Segments found (dark basins).</param>
        /// <param name="threshold">Threshold for the watersheds. Default: 10</param>
        public static void WatershedsThreshold(HObject image, out HObject basins, HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(459);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(threshold);
            int procResult = HObject.LoadNew(proc, 1, err, out basins);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract watersheds and basins from an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="basins">Segmented basins.</param>
        /// <param name="watersheds">Watersheds between the basins.</param>
        public static void Watersheds(HObject image, out HObject basins, out HObject watersheds)
        {
            IntPtr proc = HalconAPI.PreCall(460);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out basins);
            int procResult = HObject.LoadNew(proc, 2, err2, out watersheds);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract zero crossings from an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="regionCrossing">Zero crossings.</param>
        public static void ZeroCrossing(HObject image, out HObject regionCrossing)
        {
            IntPtr proc = HalconAPI.PreCall(461);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionCrossing);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract zero crossings from an image with subpixel accuracy.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="zeroCrossings">Extracted zero crossings.</param>
        public static void ZeroCrossingSubPix(HObject image, out HObject zeroCrossings)
        {
            IntPtr proc = HalconAPI.PreCall(462);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out zeroCrossings);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Threshold operator for signed images.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="regionCrossings">Positive and negative regions.</param>
        /// <param name="minSize">Regions smaller than MinSize are suppressed. Default: 20</param>
        /// <param name="minGray">Regions whose maximum absolute gray value is smaller than MinGray are suppressed. Default: 5.0</param>
        /// <param name="threshold">Regions that have a gray value smaller than Threshold (or larger than -Threshold) are suppressed. Default: 2.0</param>
        public static void DualThreshold(
          HObject image,
          out HObject regionCrossings,
          HTuple minSize,
          HTuple minGray,
          HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(463);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, minSize);
            HalconAPI.Store(proc, 1, minGray);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minSize);
            HalconAPI.UnpinTuple(minGray);
            HalconAPI.UnpinTuple(threshold);
            int procResult = HObject.LoadNew(proc, 1, err, out regionCrossings);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Expand a region starting at a given line.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="regionExpand">Extracted segments.</param>
        /// <param name="coordinate">Row or column coordinate. Default: 256</param>
        /// <param name="expandType">Stopping criterion. Default: "gradient"</param>
        /// <param name="rowColumn">Segmentation mode (row or column). Default: "row"</param>
        /// <param name="threshold">Threshold for the expansion. Default: 3.0</param>
        public static void ExpandLine(
          HObject image,
          out HObject regionExpand,
          HTuple coordinate,
          HTuple expandType,
          HTuple rowColumn,
          HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(464);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, coordinate);
            HalconAPI.Store(proc, 1, expandType);
            HalconAPI.Store(proc, 2, rowColumn);
            HalconAPI.Store(proc, 3, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(coordinate);
            HalconAPI.UnpinTuple(expandType);
            HalconAPI.UnpinTuple(rowColumn);
            HalconAPI.UnpinTuple(threshold);
            int procResult = HObject.LoadNew(proc, 1, err, out regionExpand);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect all local minima in an image.</summary>
        /// <param name="image">Image to be processed.</param>
        /// <param name="localMinima">Extracted local minima as regions.</param>
        public static void LocalMin(HObject image, out HObject localMinima)
        {
            IntPtr proc = HalconAPI.PreCall(465);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out localMinima);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect all gray value lowlands.</summary>
        /// <param name="image">Image to be processed.</param>
        /// <param name="lowlands">Extracted lowlands as regions (one region for each lowland).</param>
        public static void Lowlands(HObject image, out HObject lowlands)
        {
            IntPtr proc = HalconAPI.PreCall(466);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out lowlands);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect the centers of all gray value lowlands.</summary>
        /// <param name="image">Image to be processed.</param>
        /// <param name="lowlands">Centers of gravity of the extracted lowlands as regions (one region for each lowland).</param>
        public static void LowlandsCenter(HObject image, out HObject lowlands)
        {
            IntPtr proc = HalconAPI.PreCall(467);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out lowlands);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect all local maxima in an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="localMaxima">Extracted local maxima as a region.</param>
        public static void LocalMax(HObject image, out HObject localMaxima)
        {
            IntPtr proc = HalconAPI.PreCall(468);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out localMaxima);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect all gray value plateaus.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="plateaus">Extracted plateaus as regions (one region for each plateau).</param>
        public static void Plateaus(HObject image, out HObject plateaus)
        {
            IntPtr proc = HalconAPI.PreCall(469);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out plateaus);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect the centers of all gray value plateaus.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="plateaus">Centers of gravity of the extracted plateaus as regions (one region for each plateau).</param>
        public static void PlateausCenter(HObject image, out HObject plateaus)
        {
            IntPtr proc = HalconAPI.PreCall(470);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out plateaus);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determine gray value thresholds from a histogram.</summary>
        /// <param name="histogramm">Gray value histogram.</param>
        /// <param name="sigma">Sigma for the Gaussian smoothing of the histogram. Default: 2.0</param>
        /// <param name="minThresh">Minimum thresholds.</param>
        /// <param name="maxThresh">Maximum thresholds.</param>
        public static void HistoToThresh(
          HTuple histogramm,
          HTuple sigma,
          out HTuple minThresh,
          out HTuple maxThresh)
        {
            IntPtr proc = HalconAPI.PreCall(471);
            HalconAPI.Store(proc, 0, histogramm);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(histogramm);
            HalconAPI.UnpinTuple(sigma);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out minThresh);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out maxThresh);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Segment an image using thresholds determined from its histogram.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="regions">Regions with gray values within the automatically determined intervals.</param>
        /// <param name="sigma">Sigma for the Gaussian smoothing of the histogram. Default: 2.0</param>
        public static void AutoThreshold(HObject image, out HObject regions, HTuple sigma)
        {
            IntPtr proc = HalconAPI.PreCall(472);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            int procResult = HObject.LoadNew(proc, 1, err, out regions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Segment an image using an automatically determined threshold.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="region">Dark regions of the image.</param>
        public static void BinThreshold(HObject image, out HObject region)
        {
            IntPtr proc = HalconAPI.PreCall(473);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Fast thresholding of images using global thresholds.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="region">Segmented regions.</param>
        /// <param name="minGray">Lower threshold for the gray values. Default: 128</param>
        /// <param name="maxGray">Upper threshold for the gray values. Default: 255.0</param>
        /// <param name="minSize">Minimum size of objects to be extracted. Default: 20</param>
        public static void FastThreshold(
          HObject image,
          out HObject region,
          HTuple minGray,
          HTuple maxGray,
          HTuple minSize)
        {
            IntPtr proc = HalconAPI.PreCall(474);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, minGray);
            HalconAPI.Store(proc, 1, maxGray);
            HalconAPI.Store(proc, 2, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minGray);
            HalconAPI.UnpinTuple(maxGray);
            HalconAPI.UnpinTuple(minSize);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Transform a region in polar coordinates back to cartesian coordinates.</summary>
        /// <param name="polarRegion">Input region.</param>
        /// <param name="XYTransRegion">Output region.</param>
        /// <param name="row">Row coordinate of the center of the arc. Default: 256</param>
        /// <param name="column">Column coordinate of the center of the arc. Default: 256</param>
        /// <param name="angleStart">Angle of the ray to map the column coordinate 0 of PolarRegion to. Default: 0.0</param>
        /// <param name="angleEnd">Angle of the ray to map the column coordinate $WidthIn-1$ of PolarRegion to. Default: 6.2831853</param>
        /// <param name="radiusStart">Radius of the circle to map the row coordinate 0 of PolarRegion to. Default: 0</param>
        /// <param name="radiusEnd">Radius of the circle to map the row coordinate $HeightIn-1$ of PolarRegion to. Default: 100</param>
        /// <param name="widthIn">Width of the virtual input image. Default: 512</param>
        /// <param name="heightIn">Height of the virtual input image. Default: 512</param>
        /// <param name="width">Width of the virtual output image. Default: 512</param>
        /// <param name="height">Height of the virtual output image. Default: 512</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "nearest_neighbor"</param>
        public static void PolarTransRegionInv(
          HObject polarRegion,
          out HObject XYTransRegion,
          HTuple row,
          HTuple column,
          HTuple angleStart,
          HTuple angleEnd,
          HTuple radiusStart,
          HTuple radiusEnd,
          HTuple widthIn,
          HTuple heightIn,
          HTuple width,
          HTuple height,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(475);
            HalconAPI.Store(proc, 1, (HObjectBase)polarRegion);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, angleStart);
            HalconAPI.Store(proc, 3, angleEnd);
            HalconAPI.Store(proc, 4, radiusStart);
            HalconAPI.Store(proc, 5, radiusEnd);
            HalconAPI.Store(proc, 6, widthIn);
            HalconAPI.Store(proc, 7, heightIn);
            HalconAPI.Store(proc, 8, width);
            HalconAPI.Store(proc, 9, height);
            HalconAPI.Store(proc, 10, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleEnd);
            HalconAPI.UnpinTuple(radiusStart);
            HalconAPI.UnpinTuple(radiusEnd);
            HalconAPI.UnpinTuple(widthIn);
            HalconAPI.UnpinTuple(heightIn);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HObject.LoadNew(proc, 1, err, out XYTransRegion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polarRegion);
        }

        /// <summary>Transform a region within an annular arc to polar coordinates.</summary>
        /// <param name="region">Input region.</param>
        /// <param name="polarTransRegion">Output region.</param>
        /// <param name="row">Row coordinate of the center of the arc. Default: 256</param>
        /// <param name="column">Column coordinate of the center of the arc. Default: 256</param>
        /// <param name="angleStart">Angle of the ray to be mapped to column coordinate 0 of PolarTransRegion. Default: 0.0</param>
        /// <param name="angleEnd">Angle of the ray to be mapped to column coordinate $Width-1$ of PolarTransRegion. Default: 6.2831853</param>
        /// <param name="radiusStart">Radius of the circle to be mapped to row coordinate 0 of PolarTransRegion. Default: 0</param>
        /// <param name="radiusEnd">Radius of the circle to be mapped to row coordinate $Height-1$ of PolarTransRegion. Default: 100</param>
        /// <param name="width">Width of the virtual output image. Default: 512</param>
        /// <param name="height">Height of the virtual output image. Default: 512</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "nearest_neighbor"</param>
        public static void PolarTransRegion(
          HObject region,
          out HObject polarTransRegion,
          HTuple row,
          HTuple column,
          HTuple angleStart,
          HTuple angleEnd,
          HTuple radiusStart,
          HTuple radiusEnd,
          HTuple width,
          HTuple height,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(476);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, angleStart);
            HalconAPI.Store(proc, 3, angleEnd);
            HalconAPI.Store(proc, 4, radiusStart);
            HalconAPI.Store(proc, 5, radiusEnd);
            HalconAPI.Store(proc, 6, width);
            HalconAPI.Store(proc, 7, height);
            HalconAPI.Store(proc, 8, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleEnd);
            HalconAPI.UnpinTuple(radiusStart);
            HalconAPI.UnpinTuple(radiusEnd);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HObject.LoadNew(proc, 1, err, out polarTransRegion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Merge regions from line scan images.</summary>
        /// <param name="currRegions">Current input regions.</param>
        /// <param name="prevRegions">Merged regions from the previous iteration.</param>
        /// <param name="currMergedRegions">Current regions, merged with old ones where applicable.</param>
        /// <param name="prevMergedRegions">Regions from the previous iteration which could not be merged with the current ones.</param>
        /// <param name="imageHeight">Height of the line scan images. Default: 512</param>
        /// <param name="mergeBorder">Image line of the current image, which touches the previous image. Default: "top"</param>
        /// <param name="maxImagesRegion">Maximum number of images for a single region. Default: 3</param>
        public static void MergeRegionsLineScan(
          HObject currRegions,
          HObject prevRegions,
          out HObject currMergedRegions,
          out HObject prevMergedRegions,
          HTuple imageHeight,
          HTuple mergeBorder,
          HTuple maxImagesRegion)
        {
            IntPtr proc = HalconAPI.PreCall(477);
            HalconAPI.Store(proc, 1, (HObjectBase)currRegions);
            HalconAPI.Store(proc, 2, (HObjectBase)prevRegions);
            HalconAPI.Store(proc, 0, imageHeight);
            HalconAPI.Store(proc, 1, mergeBorder);
            HalconAPI.Store(proc, 2, maxImagesRegion);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(imageHeight);
            HalconAPI.UnpinTuple(mergeBorder);
            HalconAPI.UnpinTuple(maxImagesRegion);
            int err2 = HObject.LoadNew(proc, 1, err1, out currMergedRegions);
            int procResult = HObject.LoadNew(proc, 2, err2, out prevMergedRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)currRegions);
            GC.KeepAlive((object)prevRegions);
        }

        /// <summary>Partition a region into rectangles of approximately equal size.</summary>
        /// <param name="region">Region to be partitioned.</param>
        /// <param name="partitioned">Partitioned region.</param>
        /// <param name="width">Width of the individual rectangles.</param>
        /// <param name="height">Height of the individual rectangles.</param>
        public static void PartitionRectangle(
          HObject region,
          out HObject partitioned,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(478);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out partitioned);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Partition a region horizontally at positions of small vertical extent.</summary>
        /// <param name="region">Region to be partitioned.</param>
        /// <param name="partitioned">Partitioned region.</param>
        /// <param name="distance">Approximate width of the resulting region parts.</param>
        /// <param name="percent">Maximum percental shift of the split position. Default: 20</param>
        public static void PartitionDynamic(
          HObject region,
          out HObject partitioned,
          HTuple distance,
          HTuple percent)
        {
            IntPtr proc = HalconAPI.PreCall(479);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, distance);
            HalconAPI.Store(proc, 1, percent);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distance);
            HalconAPI.UnpinTuple(percent);
            int procResult = HObject.LoadNew(proc, 1, err, out partitioned);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Convert regions to a label image.</summary>
        /// <param name="region">Regions to be converted.</param>
        /// <param name="imageLabel">Result image of dimension Width * Height containing the converted regions.</param>
        /// <param name="type">Pixel type of the result image. Default: "int2"</param>
        /// <param name="width">Width of the image to be generated. Default: 512</param>
        /// <param name="height">Height of the image to be generated. Default: 512</param>
        public static void RegionToLabel(
          HObject region,
          out HObject imageLabel,
          HTuple type,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(480);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, width);
            HalconAPI.Store(proc, 2, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageLabel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Convert a region into a binary byte-image.</summary>
        /// <param name="region">Regions to be converted.</param>
        /// <param name="binImage">Result image of dimension Width * Height containing the converted regions.</param>
        /// <param name="foregroundGray">Gray value in which the regions are displayed. Default: 255</param>
        /// <param name="backgroundGray">Gray value in which the background is displayed. Default: 0</param>
        /// <param name="width">Width of the image to be generated. Default: 512</param>
        /// <param name="height">Height of the image to be generated. Default: 512</param>
        public static void RegionToBin(
          HObject region,
          out HObject binImage,
          HTuple foregroundGray,
          HTuple backgroundGray,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(481);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, foregroundGray);
            HalconAPI.Store(proc, 1, backgroundGray);
            HalconAPI.Store(proc, 2, width);
            HalconAPI.Store(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(foregroundGray);
            HalconAPI.UnpinTuple(backgroundGray);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out binImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Return the union of two regions.</summary>
        /// <param name="region1">Region for which the union with all regions in Region2 is to be computed.</param>
        /// <param name="region2">Regions which should be added to Region1.</param>
        /// <param name="regionUnion">Resulting regions.</param>
        public static void Union2(HObject region1, HObject region2, out HObject regionUnion)
        {
            IntPtr proc = HalconAPI.PreCall(482);
            HalconAPI.Store(proc, 1, (HObjectBase)region1);
            HalconAPI.Store(proc, 2, (HObjectBase)region2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionUnion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region1);
            GC.KeepAlive((object)region2);
        }

        /// <summary>Return the union of all input regions.</summary>
        /// <param name="region">Regions of which the union is to be computed.</param>
        /// <param name="regionUnion">Union of all input regions.</param>
        public static void Union1(HObject region, out HObject regionUnion)
        {
            IntPtr proc = HalconAPI.PreCall(483);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionUnion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Compute the closest-point transformation of a region.</summary>
        /// <param name="region">Region for which the distance to the border is computed.</param>
        /// <param name="distances">Image containing the distance information.</param>
        /// <param name="closestPoints">Image containing the coordinates of the closest points.</param>
        /// <param name="metric">Type of metric to be used for the closest-point transformation. Default: "city-block"</param>
        /// <param name="foreground">Compute the distance for pixels inside (true) or outside (false) the input region. Default: "true"</param>
        /// <param name="closestPointMode">Mode in which the coordinates of the closest points are returned. Default: "absolute"</param>
        /// <param name="width">Width of the output images. Default: 640</param>
        /// <param name="height">Height of the output images. Default: 480</param>
        public static void ClosestPointTransform(
          HObject region,
          out HObject distances,
          out HObject closestPoints,
          HTuple metric,
          HTuple foreground,
          HTuple closestPointMode,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(484);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, metric);
            HalconAPI.Store(proc, 1, foreground);
            HalconAPI.Store(proc, 2, closestPointMode);
            HalconAPI.Store(proc, 3, width);
            HalconAPI.Store(proc, 4, height);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(foreground);
            HalconAPI.UnpinTuple(closestPointMode);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int err2 = HObject.LoadNew(proc, 1, err1, out distances);
            int procResult = HObject.LoadNew(proc, 2, err2, out closestPoints);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Compute the distance transformation of a region.</summary>
        /// <param name="region">Region for which the distance to the border is computed.</param>
        /// <param name="distanceImage">Image containing the distance information.</param>
        /// <param name="metric">Type of metric to be used for the distance transformation. Default: "city-block"</param>
        /// <param name="foreground">Compute the distance for pixels inside (true) or outside (false) the input region. Default: "true"</param>
        /// <param name="width">Width of the output image. Default: 640</param>
        /// <param name="height">Height of the output image. Default: 480</param>
        public static void DistanceTransform(
          HObject region,
          out HObject distanceImage,
          HTuple metric,
          HTuple foreground,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(485);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, metric);
            HalconAPI.Store(proc, 1, foreground);
            HalconAPI.Store(proc, 2, width);
            HalconAPI.Store(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(foreground);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out distanceImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Compute the skeleton of a region.</summary>
        /// <param name="region">Region to be thinned.</param>
        /// <param name="skeleton">Resulting skeleton.</param>
        public static void Skeleton(HObject region, out HObject skeleton)
        {
            IntPtr proc = HalconAPI.PreCall(486);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out skeleton);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Apply a projective transformation to a region.</summary>
        /// <param name="regions">Input regions.</param>
        /// <param name="transRegions">Output regions.</param>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "bilinear"</param>
        public static void ProjectiveTransRegion(
          HObject regions,
          out HObject transRegions,
          HTuple homMat2D,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(487);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HObject.LoadNew(proc, 1, err, out transRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Apply an arbitrary affine 2D transformation to regions.</summary>
        /// <param name="region">Region(s) to be rotated and scaled.</param>
        /// <param name="regionAffineTrans">Transformed output region(s).</param>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="interpolate">Should the transformation be done using interpolation? Default: "nearest_neighbor"</param>
        public static void AffineTransRegion(
          HObject region,
          out HObject regionAffineTrans,
          HTuple homMat2D,
          HTuple interpolate)
        {
            IntPtr proc = HalconAPI.PreCall(488);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, interpolate);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(interpolate);
            int procResult = HObject.LoadNew(proc, 1, err, out regionAffineTrans);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Reflect a region about an axis.</summary>
        /// <param name="region">Region(s) to be reflected.</param>
        /// <param name="regionMirror">Reflected region(s).</param>
        /// <param name="mode">Axis of symmetry. Default: "row"</param>
        /// <param name="widthHeight">Twice the coordinate of the axis of symmetry. Default: 512</param>
        public static void MirrorRegion(
          HObject region,
          out HObject regionMirror,
          HTuple mode,
          HTuple widthHeight)
        {
            IntPtr proc = HalconAPI.PreCall(489);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, widthHeight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(widthHeight);
            int procResult = HObject.LoadNew(proc, 1, err, out regionMirror);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Zoom a region.</summary>
        /// <param name="region">Region(s) to be zoomed.</param>
        /// <param name="regionZoom">Zoomed region(s).</param>
        /// <param name="scaleWidth">Scale factor in x-direction. Default: 2.0</param>
        /// <param name="scaleHeight">Scale factor in y-direction. Default: 2.0</param>
        public static void ZoomRegion(
          HObject region,
          out HObject regionZoom,
          HTuple scaleWidth,
          HTuple scaleHeight)
        {
            IntPtr proc = HalconAPI.PreCall(490);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, scaleWidth);
            HalconAPI.Store(proc, 1, scaleHeight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scaleWidth);
            HalconAPI.UnpinTuple(scaleHeight);
            int procResult = HObject.LoadNew(proc, 1, err, out regionZoom);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Translate a region.</summary>
        /// <param name="region">Region(s) to be moved.</param>
        /// <param name="regionMoved">Translated region(s).</param>
        /// <param name="row">Row coordinate of the vector by which the region is to be moved. Default: 30</param>
        /// <param name="column">Row coordinate of the vector by which the region is to be moved. Default: 30</param>
        public static void MoveRegion(
          HObject region,
          out HObject regionMoved,
          HTuple row,
          HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(491);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HObject.LoadNew(proc, 1, err, out regionMoved);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Find junctions and end points in a skeleton.</summary>
        /// <param name="region">Input skeletons.</param>
        /// <param name="endPoints">Extracted end points.</param>
        /// <param name="juncPoints">Extracted junctions.</param>
        public static void JunctionsSkeleton(
          HObject region,
          out HObject endPoints,
          out HObject juncPoints)
        {
            IntPtr proc = HalconAPI.PreCall(492);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out endPoints);
            int procResult = HObject.LoadNew(proc, 2, err2, out juncPoints);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Calculate the intersection of two regions.</summary>
        /// <param name="region1">Regions to be intersected with all regions in Region2.</param>
        /// <param name="region2">Regions with which Region1 is intersected.</param>
        /// <param name="regionIntersection">Result of the intersection.</param>
        public static void Intersection(
          HObject region1,
          HObject region2,
          out HObject regionIntersection)
        {
            IntPtr proc = HalconAPI.PreCall(493);
            HalconAPI.Store(proc, 1, (HObjectBase)region1);
            HalconAPI.Store(proc, 2, (HObjectBase)region2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionIntersection);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region1);
            GC.KeepAlive((object)region2);
        }

        /// <summary>Partition the image plane using given regions.</summary>
        /// <param name="region">Regions for which the separating lines are to be determined.</param>
        /// <param name="regionInterjacent">Output region containing the separating lines.</param>
        /// <param name="mode">Mode of operation. Default: "mixed"</param>
        public static void Interjacent(HObject region, out HObject regionInterjacent, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(494);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out regionInterjacent);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Fill up holes in regions.</summary>
        /// <param name="region">Input regions containing holes.</param>
        /// <param name="regionFillUp">Regions without holes.</param>
        public static void FillUp(HObject region, out HObject regionFillUp)
        {
            IntPtr proc = HalconAPI.PreCall(495);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionFillUp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Fill up holes in regions having given shape features.</summary>
        /// <param name="region">Input region(s).</param>
        /// <param name="regionFillUp">Output region(s) with filled holes.</param>
        /// <param name="feature">Shape feature used. Default: "area"</param>
        /// <param name="min">Minimum value for Feature. Default: 1.0</param>
        /// <param name="max">Maximum value for Feature. Default: 100.0</param>
        public static void FillUpShape(
          HObject region,
          out HObject regionFillUp,
          HTuple feature,
          HTuple min,
          HTuple max)
        {
            IntPtr proc = HalconAPI.PreCall(496);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, feature);
            HalconAPI.Store(proc, 1, min);
            HalconAPI.Store(proc, 2, max);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(feature);
            HalconAPI.UnpinTuple(min);
            HalconAPI.UnpinTuple(max);
            int procResult = HObject.LoadNew(proc, 1, err, out regionFillUp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Fill gaps between regions or split overlapping regions.</summary>
        /// <param name="regions">Regions for which the gaps are to be closed, or which are to be separated.</param>
        /// <param name="forbiddenArea">Regions in which no expansion takes place.</param>
        /// <param name="regionExpanded">Expanded or separated regions.</param>
        /// <param name="iterations">Number of iterations. Default: "maximal"</param>
        /// <param name="mode">Expansion mode. Default: "image"</param>
        public static void ExpandRegion(
          HObject regions,
          HObject forbiddenArea,
          out HObject regionExpanded,
          HTuple iterations,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(497);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)forbiddenArea);
            HalconAPI.Store(proc, 0, iterations);
            HalconAPI.Store(proc, 1, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out regionExpanded);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)forbiddenArea);
        }

        /// <summary>Clip a region relative to its smallest surrounding rectangle.</summary>
        /// <param name="region">Regions to be clipped.</param>
        /// <param name="regionClipped">Clipped regions.</param>
        /// <param name="top">Number of rows clipped at the top. Default: 1</param>
        /// <param name="bottom">Number of rows clipped at the bottom. Default: 1</param>
        /// <param name="left">Number of columns clipped at the left. Default: 1</param>
        /// <param name="right">Number of columns clipped at the right. Default: 1</param>
        public static void ClipRegionRel(
          HObject region,
          out HObject regionClipped,
          HTuple top,
          HTuple bottom,
          HTuple left,
          HTuple right)
        {
            IntPtr proc = HalconAPI.PreCall(498);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, top);
            HalconAPI.Store(proc, 1, bottom);
            HalconAPI.Store(proc, 2, left);
            HalconAPI.Store(proc, 3, right);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(top);
            HalconAPI.UnpinTuple(bottom);
            HalconAPI.UnpinTuple(left);
            HalconAPI.UnpinTuple(right);
            int procResult = HObject.LoadNew(proc, 1, err, out regionClipped);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Clip a region to a rectangle.</summary>
        /// <param name="region">Region to be clipped.</param>
        /// <param name="regionClipped">Clipped regions.</param>
        /// <param name="row1">Row coordinate of the upper left corner of the rectangle. Default: 0</param>
        /// <param name="column1">Column coordinate of the upper left corner of the rectangle. Default: 0</param>
        /// <param name="row2">Row coordinate of the lower right corner of the rectangle. Default: 256</param>
        /// <param name="column2">Column coordinate of the lower right corner of the rectangle. Default: 256</param>
        public static void ClipRegion(
          HObject region,
          out HObject regionClipped,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(499);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int procResult = HObject.LoadNew(proc, 1, err, out regionClipped);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Rank operator for regions.</summary>
        /// <param name="region">Region(s) to be transformed.</param>
        /// <param name="regionCount">Resulting region(s).</param>
        /// <param name="width">Width of the filter mask. Default: 15</param>
        /// <param name="height">Height of the filter mask. Default: 15</param>
        /// <param name="number">Minimum number of points lying within the filter mask. Default: 70</param>
        public static void RankRegion(
          HObject region,
          out HObject regionCount,
          HTuple width,
          HTuple height,
          HTuple number)
        {
            IntPtr proc = HalconAPI.PreCall(500);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.Store(proc, 2, number);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(number);
            int procResult = HObject.LoadNew(proc, 1, err, out regionCount);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Compute connected components of a region.</summary>
        /// <param name="region">Input region.</param>
        /// <param name="connectedRegions">Connected components.</param>
        public static void Connection(HObject region, out HObject connectedRegions)
        {
            IntPtr proc = HalconAPI.PreCall(501);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out connectedRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Calculate the symmetric difference of two regions.</summary>
        /// <param name="region1">Input region 1.</param>
        /// <param name="region2">Input region 2.</param>
        /// <param name="regionDifference">Resulting region.</param>
        public static void SymmDifference(
          HObject region1,
          HObject region2,
          out HObject regionDifference)
        {
            IntPtr proc = HalconAPI.PreCall(502);
            HalconAPI.Store(proc, 1, (HObjectBase)region1);
            HalconAPI.Store(proc, 2, (HObjectBase)region2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionDifference);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region1);
            GC.KeepAlive((object)region2);
        }

        /// <summary>Calculate the difference of two regions.</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="sub">The union of these regions is subtracted from Region.</param>
        /// <param name="regionDifference">Resulting region.</param>
        public static void Difference(HObject region, HObject sub, out HObject regionDifference)
        {
            IntPtr proc = HalconAPI.PreCall(503);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)sub);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionDifference);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)sub);
        }

        /// <summary>Return the complement of a region.</summary>
        /// <param name="region">Input region(s).</param>
        /// <param name="regionComplement">Complemented regions.</param>
        public static void Complement(HObject region, out HObject regionComplement)
        {
            IntPtr proc = HalconAPI.PreCall(504);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionComplement);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Determine the connected components of the background of given regions.</summary>
        /// <param name="foreground">Input regions.</param>
        /// <param name="backgroundRegions">Connected components of the background.</param>
        public static void BackgroundSeg(HObject foreground, out HObject backgroundRegions)
        {
            IntPtr proc = HalconAPI.PreCall(505);
            HalconAPI.Store(proc, 1, (HObjectBase)foreground);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out backgroundRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)foreground);
        }

        /// <summary>Generate a region having a given Hamming distance.</summary>
        /// <param name="inputRegion">Region to be modified.</param>
        /// <param name="outputRegion">Regions having the required Hamming distance.</param>
        /// <param name="width">Width of the region to be changed. Default: 100</param>
        /// <param name="height">Height of the region to be changed. Default: 100</param>
        /// <param name="distance">Hamming distance between the old and new regions. Default: 1000</param>
        public static void HammingChangeRegion(
          HObject inputRegion,
          out HObject outputRegion,
          HTuple width,
          HTuple height,
          HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(506);
            HalconAPI.Store(proc, 1, (HObjectBase)inputRegion);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.Store(proc, 2, distance);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(distance);
            int procResult = HObject.LoadNew(proc, 1, err, out outputRegion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)inputRegion);
        }

        /// <summary>Remove noise from a region.</summary>
        /// <param name="inputRegion">Regions to be modified.</param>
        /// <param name="outputRegion">Less noisy regions.</param>
        /// <param name="type">Mode of noise removal. Default: "n_4"</param>
        public static void RemoveNoiseRegion(
          HObject inputRegion,
          out HObject outputRegion,
          HTuple type)
        {
            IntPtr proc = HalconAPI.PreCall(507);
            HalconAPI.Store(proc, 1, (HObjectBase)inputRegion);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            int procResult = HObject.LoadNew(proc, 1, err, out outputRegion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)inputRegion);
        }

        /// <summary>Transform the shape of a region.</summary>
        /// <param name="region">Regions to be transformed.</param>
        /// <param name="regionTrans">Transformed regions.</param>
        /// <param name="type">Type of transformation. Default: "convex"</param>
        public static void ShapeTrans(HObject region, out HObject regionTrans, HTuple type)
        {
            IntPtr proc = HalconAPI.PreCall(508);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            int procResult = HObject.LoadNew(proc, 1, err, out regionTrans);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Fill gaps between regions (depending on gray value or color) or split overlapping regions.</summary>
        /// <param name="regions">Regions for which the gaps are to be closed, or which are to be separated.</param>
        /// <param name="image">Image (possibly multi-channel) for gray value or color comparison.</param>
        /// <param name="forbiddenArea">Regions in which no expansion takes place.</param>
        /// <param name="regionExpand">Expanded or separated regions.</param>
        /// <param name="iterations">Number of iterations. Default: "maximal"</param>
        /// <param name="mode">Expansion mode. Default: "image"</param>
        /// <param name="threshold">Maximum difference between the gray value or color at the region's border and a candidate for expansion. Default: 32</param>
        public static void ExpandGray(
          HObject regions,
          HObject image,
          HObject forbiddenArea,
          out HObject regionExpand,
          HTuple iterations,
          HTuple mode,
          HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(509);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 3, (HObjectBase)forbiddenArea);
            HalconAPI.Store(proc, 0, iterations);
            HalconAPI.Store(proc, 1, mode);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(threshold);
            int procResult = HObject.LoadNew(proc, 1, err, out regionExpand);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)forbiddenArea);
        }

        /// <summary>Fill gaps between regions (depending on gray value or color) or split overlapping regions.</summary>
        /// <param name="regions">Regions for which the gaps are to be closed, or which are to be separated.</param>
        /// <param name="image">Image (possibly multi-channel) for gray value or color comparison.</param>
        /// <param name="forbiddenArea">Regions in which no expansion takes place.</param>
        /// <param name="regionExpand">Expanded or separated regions.</param>
        /// <param name="iterations">Number of iterations. Default: "maximal"</param>
        /// <param name="mode">Expansion mode. Default: "image"</param>
        /// <param name="refGray">Reference gray value or color for comparison. Default: 128</param>
        /// <param name="threshold">Maximum difference between the reference gray value or color and a candidate for expansion. Default: 32</param>
        public static void ExpandGrayRef(
          HObject regions,
          HObject image,
          HObject forbiddenArea,
          out HObject regionExpand,
          HTuple iterations,
          HTuple mode,
          HTuple refGray,
          HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(510);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 3, (HObjectBase)forbiddenArea);
            HalconAPI.Store(proc, 0, iterations);
            HalconAPI.Store(proc, 1, mode);
            HalconAPI.Store(proc, 2, refGray);
            HalconAPI.Store(proc, 3, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(refGray);
            HalconAPI.UnpinTuple(threshold);
            int procResult = HObject.LoadNew(proc, 1, err, out regionExpand);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)forbiddenArea);
        }

        /// <summary>Split lines represented by one pixel wide, non-branching lines.</summary>
        /// <param name="skeletonRegion">Input lines (represented by 1 pixel wide, non-branching regions).</param>
        /// <param name="maxDistance">Maximum distance of the line points to the line segment connecting both end points. Default: 3</param>
        /// <param name="beginRow">Row coordinates of the start points of the output lines.</param>
        /// <param name="beginCol">Column coordinates of the start points of the output lines.</param>
        /// <param name="endRow">Row coordinates of the end points of the output lines.</param>
        /// <param name="endCol">Column coordinates of the end points of the output lines.</param>
        public static void SplitSkeletonLines(
          HObject skeletonRegion,
          HTuple maxDistance,
          out HTuple beginRow,
          out HTuple beginCol,
          out HTuple endRow,
          out HTuple endCol)
        {
            IntPtr proc = HalconAPI.PreCall(511);
            HalconAPI.Store(proc, 1, (HObjectBase)skeletonRegion);
            HalconAPI.Store(proc, 0, maxDistance);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maxDistance);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out beginRow);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out beginCol);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out endRow);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out endCol);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)skeletonRegion);
        }

        /// <summary>Split lines represented by one pixel wide, non-branching regions.</summary>
        /// <param name="skeletonRegion">Input lines (represented by 1 pixel wide, non-branching regions).</param>
        /// <param name="regionLines">Split lines.</param>
        /// <param name="maxDistance">Maximum distance of the line points to the line segment connecting both end points. Default: 3</param>
        public static void SplitSkeletonRegion(
          HObject skeletonRegion,
          out HObject regionLines,
          HTuple maxDistance)
        {
            IntPtr proc = HalconAPI.PreCall(512);
            HalconAPI.Store(proc, 1, (HObjectBase)skeletonRegion);
            HalconAPI.Store(proc, 0, maxDistance);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maxDistance);
            int procResult = HObject.LoadNew(proc, 1, err, out regionLines);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)skeletonRegion);
        }

        /// <summary>Convert a histogram into a region.</summary>
        /// <param name="region">Region containing the histogram.</param>
        /// <param name="histogram">Input histogram.</param>
        /// <param name="row">Row coordinate of the center of the histogram. Default: 255</param>
        /// <param name="column">Column coordinate of the center of the histogram. Default: 255</param>
        /// <param name="scale">Scale factor for the histogram. Default: 1</param>
        public static void GenRegionHisto(
          out HObject region,
          HTuple histogram,
          HTuple row,
          HTuple column,
          HTuple scale)
        {
            IntPtr proc = HalconAPI.PreCall(513);
            HalconAPI.Store(proc, 0, histogram);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, scale);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(histogram);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(scale);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Eliminate runs of a given length.</summary>
        /// <param name="region">Region to be clipped.</param>
        /// <param name="regionClipped">Clipped regions.</param>
        /// <param name="elimShorter">All runs which are shorter are eliminated. Default: 3</param>
        /// <param name="elimLonger">All runs which are longer are eliminated. Default: 1000</param>
        public static void EliminateRuns(
          HObject region,
          out HObject regionClipped,
          HTuple elimShorter,
          HTuple elimLonger)
        {
            IntPtr proc = HalconAPI.PreCall(514);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, elimShorter);
            HalconAPI.Store(proc, 1, elimLonger);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(elimShorter);
            HalconAPI.UnpinTuple(elimLonger);
            int procResult = HObject.LoadNew(proc, 1, err, out regionClipped);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Calculate the 3D surface normals of a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model containing 3D point data.</param>
        /// <param name="method">Normals calculation method. Default: "mls"</param>
        /// <param name="genParamName">Names of generic smoothing parameters. Default: []</param>
        /// <param name="genParamValue">Values of generic smoothing parameters. Default: []</param>
        /// <param name="objectModel3DNormals">Handle of the 3D object model with calculated 3D normals.</param>
        public static void SurfaceNormalsObjectModel3d(
          HTuple objectModel3D,
          HTuple method,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple objectModel3DNormals)
        {
            IntPtr proc = HalconAPI.PreCall(515);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, method);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DNormals);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Smooth the 3D points of a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model containing 3D point data.</param>
        /// <param name="method">Smoothing method. Default: "mls"</param>
        /// <param name="genParamName">Names of generic smoothing parameters. Default: []</param>
        /// <param name="genParamValue">Values of generic smoothing parameters. Default: []</param>
        /// <param name="smoothObjectModel3D">Handle of the 3D object model with the smoothed 3D point data.</param>
        public static void SmoothObjectModel3d(
          HTuple objectModel3D,
          HTuple method,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple smoothObjectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(516);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, method);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out smoothObjectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a surface triangulation for a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model containing 3D point data.</param>
        /// <param name="method">Triangulation method. Default: "greedy"</param>
        /// <param name="genParamName">Names of the generic triangulation parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic triangulation parameters. Default: []</param>
        /// <param name="triangulatedObjectModel3D">Handle of the 3D object model with the triangulated surface.</param>
        /// <param name="information">Additional information about the triangulation process.</param>
        public static void TriangulateObjectModel3d(
          HTuple objectModel3D,
          HTuple method,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple triangulatedObjectModel3D,
          out HTuple information)
        {
            IntPtr proc = HalconAPI.PreCall(517);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, method);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out triangulatedObjectModel3D);
            int procResult = HTuple.LoadNew(proc, 1, err2, out information);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of all stereo models.</summary>
        public static void ClearAllStereoModels()
        {
            IntPtr proc = HalconAPI.PreCall(518);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a stereo model.</summary>
        /// <param name="stereoModelID">Handle of the stereo model.</param>
        public static void ClearStereoModel(HTuple stereoModelID)
        {
            IntPtr proc = HalconAPI.PreCall(519);
            HalconAPI.Store(proc, 0, stereoModelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stereoModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Reconstruct 3D points from calibrated multi-view stereo images.</summary>
        /// <param name="stereoModelID">Handle of the stereo model.</param>
        /// <param name="row">Row coordinates of the detected points.</param>
        /// <param name="column">Column coordinates of the detected points.</param>
        /// <param name="covIP">Covariance matrices of the detected points. Default: []</param>
        /// <param name="cameraIdx">Indices of the observing cameras.</param>
        /// <param name="pointIdx">Indices of the observed world points.</param>
        /// <param name="x">X coordinates of the reconstructed 3D points.</param>
        /// <param name="y">Y coordinates of the reconstructed 3D points.</param>
        /// <param name="z">Z coordinates of the reconstructed 3D points.</param>
        /// <param name="covWP">Covariance matrices of the reconstructed 3D points.</param>
        /// <param name="pointIdxOut">Indices of the reconstructed 3D points.</param>
        public static void ReconstructPointsStereo(
          HTuple stereoModelID,
          HTuple row,
          HTuple column,
          HTuple covIP,
          HTuple cameraIdx,
          HTuple pointIdx,
          out HTuple x,
          out HTuple y,
          out HTuple z,
          out HTuple covWP,
          out HTuple pointIdxOut)
        {
            IntPtr proc = HalconAPI.PreCall(520);
            HalconAPI.Store(proc, 0, stereoModelID);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, covIP);
            HalconAPI.Store(proc, 4, cameraIdx);
            HalconAPI.Store(proc, 5, pointIdx);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stereoModelID);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(covIP);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(pointIdx);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out x);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out y);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out z);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out covWP);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out pointIdxOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Reconstruct surface from calibrated multi-view stereo images.</summary>
        /// <param name="images">An image array acquired by the camera setup associated with the stereo model.</param>
        /// <param name="stereoModelID">Handle of the stereo model.</param>
        /// <param name="objectModel3D">Handle to the resulting surface.</param>
        public static void ReconstructSurfaceStereo(
          HObject images,
          HTuple stereoModelID,
          out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(521);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, stereoModelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stereoModelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Get intermediate iconic results of a stereo reconstruction.</summary>
        /// <param name="objectVal">Iconic result.</param>
        /// <param name="stereoModelID">Handle of the stereo model.</param>
        /// <param name="pairIndex">Camera indices of the pair ([From, To]).</param>
        /// <param name="objectName">Name of the iconic result to be returned.</param>
        public static void GetStereoModelObject(
          out HObject objectVal,
          HTuple stereoModelID,
          HTuple pairIndex,
          HTuple objectName)
        {
            IntPtr proc = HalconAPI.PreCall(522);
            HalconAPI.Store(proc, 0, stereoModelID);
            HalconAPI.Store(proc, 1, pairIndex);
            HalconAPI.Store(proc, 2, objectName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stereoModelID);
            HalconAPI.UnpinTuple(pairIndex);
            HalconAPI.UnpinTuple(objectName);
            int procResult = HObject.LoadNew(proc, 1, err, out objectVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the list of image pairs set in a stereo model.</summary>
        /// <param name="stereoModelID">Handle of the stereo model.</param>
        /// <param name="from">Camera indices for the from cameras in the image pairs.</param>
        /// <param name="to">Camera indices for the to cameras in the image pairs.</param>
        public static void GetStereoModelImagePairs(
          HTuple stereoModelID,
          out HTuple from,
          out HTuple to)
        {
            IntPtr proc = HalconAPI.PreCall(523);
            HalconAPI.Store(proc, 0, stereoModelID);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stereoModelID);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out from);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out to);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Specify image pairs to be used for surface stereo reconstruction.</summary>
        /// <param name="stereoModelID">Handle of the stereo model.</param>
        /// <param name="from">Camera indices for the from cameras in the image pairs.</param>
        /// <param name="to">Camera indices for the to cameras in the  image pairs.</param>
        public static void SetStereoModelImagePairs(HTuple stereoModelID, HTuple from, HTuple to)
        {
            IntPtr proc = HalconAPI.PreCall(524);
            HalconAPI.Store(proc, 0, stereoModelID);
            HalconAPI.Store(proc, 1, from);
            HalconAPI.Store(proc, 2, to);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stereoModelID);
            HalconAPI.UnpinTuple(from);
            HalconAPI.UnpinTuple(to);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get stereo model parameters.</summary>
        /// <param name="stereoModelID">Handle of the stereo model.</param>
        /// <param name="genParamName">Names of the parameters to be set.</param>
        /// <param name="genParamValue">Values of the parameters to be set.</param>
        public static void GetStereoModelParam(
          HTuple stereoModelID,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(525);
            HalconAPI.Store(proc, 0, stereoModelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stereoModelID);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set stereo model parameters.</summary>
        /// <param name="stereoModelID">Handle of the stereo model.</param>
        /// <param name="genParamName">Names of the parameters to be set.</param>
        /// <param name="genParamValue">Values of the parameters to be set.</param>
        public static void SetStereoModelParam(
          HTuple stereoModelID,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(526);
            HalconAPI.Store(proc, 0, stereoModelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stereoModelID);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a HALCON stereo model.</summary>
        /// <param name="cameraSetupModelID">Handle to the camera setup model.</param>
        /// <param name="method">Reconstruction method. Default: "surface_pairwise"</param>
        /// <param name="genParamName">Name of the model parameter to be set. Default: []</param>
        /// <param name="genParamValue">Value of the model parameter to be set. Default: []</param>
        /// <param name="stereoModelID">Handle of the stereo model.</param>
        public static void CreateStereoModel(
          HTuple cameraSetupModelID,
          HTuple method,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple stereoModelID)
        {
            IntPtr proc = HalconAPI.PreCall(527);
            HalconAPI.Store(proc, 0, cameraSetupModelID);
            HalconAPI.Store(proc, 1, method);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraSetupModelID);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out stereoModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query message queue parameters or information about the queue.</summary>
        /// <param name="queueHandle">Message queue handle.</param>
        /// <param name="genParamName">Names of the queue parameters or info queries. Default: "max_message_num"</param>
        /// <param name="genParamValue">Values of the queue parameters or info queries.</param>
        public static void GetMessageQueueParam(
          HTuple queueHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(528);
            HalconAPI.Store(proc, 0, queueHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(queueHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set message queue parameters or invoke commands on the queue.</summary>
        /// <param name="queueHandle">Message queue handle.</param>
        /// <param name="genParamName">Names of the queue parameters or action commands. Default: "max_message_num"</param>
        /// <param name="genParamValue">Values of the queue parameters or action commands. Default: 1</param>
        public static void SetMessageQueueParam(
          HTuple queueHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(529);
            HalconAPI.Store(proc, 0, queueHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(queueHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Receive one or more messages from the message queue.</summary>
        /// <param name="queueHandle">Message queue handle.</param>
        /// <param name="genParamName">Names of optional generic parameters Default: "timeout"</param>
        /// <param name="genParamValue">Values of optional generic parameters Default: "infinite"</param>
        /// <param name="messageHandle">Handle(s) of the dequeued message(s).</param>
        public static void DequeueMessage(
          HTuple queueHandle,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple messageHandle)
        {
            IntPtr proc = HalconAPI.PreCall(530);
            HalconAPI.Store(proc, 0, queueHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(queueHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out messageHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Enqueue one or more messages to the message queue.</summary>
        /// <param name="queueHandle">Message queue handle.</param>
        /// <param name="messageHandle">Handle(s) of message(s) to be enqueued.</param>
        /// <param name="genParamName">Names of optional generic parameters.</param>
        /// <param name="genParamValue">Values of optional generic parameters.</param>
        public static void EnqueueMessage(
          HTuple queueHandle,
          HTuple messageHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(531);
            HalconAPI.Store(proc, 0, queueHandle);
            HalconAPI.Store(proc, 1, messageHandle);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(queueHandle);
            HalconAPI.UnpinTuple(messageHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close a message queue handle and release all associated resources.</summary>
        /// <param name="queueHandle">Message queue handle(s) to be closed.</param>
        public static void ClearMessageQueue(HTuple queueHandle)
        {
            IntPtr proc = HalconAPI.PreCall(532);
            HalconAPI.Store(proc, 0, queueHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(queueHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a new empty message queue.</summary>
        /// <param name="queueHandle">Handle of the newly created message queue.</param>
        public static void CreateMessageQueue(out HTuple queueHandle)
        {
            IntPtr proc = HalconAPI.PreCall(533);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out queueHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query message parameters or information about the message.</summary>
        /// <param name="messageHandle">Message handle.</param>
        /// <param name="genParamName">Names of the message parameters or info queries. Default: "message_keys"</param>
        /// <param name="key">Message keys the parameter/query should be applied to.</param>
        /// <param name="genParamValue">Values of the message parameters or info queries.</param>
        public static void GetMessageParam(
          HTuple messageHandle,
          HTuple genParamName,
          HTuple key,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(534);
            HalconAPI.Store(proc, 0, messageHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, key);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(messageHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(key);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set message parameter or invoke commands on the message.</summary>
        /// <param name="messageHandle">Message handle.</param>
        /// <param name="genParamName">Names of the message parameters or action commands. Default: "remove_key"</param>
        /// <param name="key">Message keys the parameter/command should be applied to.</param>
        /// <param name="genParamValue">Values of the message parameters or action commands.</param>
        public static void SetMessageParam(
          HTuple messageHandle,
          HTuple genParamName,
          HTuple key,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(535);
            HalconAPI.Store(proc, 0, messageHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, key);
            HalconAPI.Store(proc, 3, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(messageHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(key);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Retrieve an object associated with the key from the message.</summary>
        /// <param name="objectData">Tuple value retrieved from the message.</param>
        /// <param name="messageHandle">Message handle.</param>
        /// <param name="key">Key string.</param>
        public static void GetMessageObj(out HObject objectData, HTuple messageHandle, HTuple key)
        {
            IntPtr proc = HalconAPI.PreCall(536);
            HalconAPI.Store(proc, 0, messageHandle);
            HalconAPI.Store(proc, 1, key);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(messageHandle);
            HalconAPI.UnpinTuple(key);
            int procResult = HObject.LoadNew(proc, 1, err, out objectData);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a key/object pair to the message.</summary>
        /// <param name="objectData">Object to be associated with the key.</param>
        /// <param name="messageHandle">Message handle.</param>
        /// <param name="key">Key string.</param>
        public static void SetMessageObj(HObject objectData, HTuple messageHandle, HTuple key)
        {
            IntPtr proc = HalconAPI.PreCall(537);
            HalconAPI.Store(proc, 1, (HObjectBase)objectData);
            HalconAPI.Store(proc, 0, messageHandle);
            HalconAPI.Store(proc, 1, key);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(messageHandle);
            HalconAPI.UnpinTuple(key);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objectData);
        }

        /// <summary>Retrieve a tuple associated with the key from the message.</summary>
        /// <param name="messageHandle">Message handle.</param>
        /// <param name="key">Key string.</param>
        /// <param name="tupleData">Tuple value retrieved from the message.</param>
        public static void GetMessageTuple(HTuple messageHandle, HTuple key, out HTuple tupleData)
        {
            IntPtr proc = HalconAPI.PreCall(538);
            HalconAPI.Store(proc, 0, messageHandle);
            HalconAPI.Store(proc, 1, key);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(messageHandle);
            HalconAPI.UnpinTuple(key);
            int procResult = HTuple.LoadNew(proc, 0, err, out tupleData);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a key/tuple pair to the message.</summary>
        /// <param name="messageHandle">Message handle.</param>
        /// <param name="key">Key string.</param>
        /// <param name="tupleData">Tuple value to be associated with the key.</param>
        public static void SetMessageTuple(HTuple messageHandle, HTuple key, HTuple tupleData)
        {
            IntPtr proc = HalconAPI.PreCall(539);
            HalconAPI.Store(proc, 0, messageHandle);
            HalconAPI.Store(proc, 1, key);
            HalconAPI.Store(proc, 2, tupleData);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(messageHandle);
            HalconAPI.UnpinTuple(key);
            HalconAPI.UnpinTuple(tupleData);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close a message handle and release all associated resources.</summary>
        /// <param name="messageHandle">Message handle(s) to be closed.</param>
        public static void ClearMessage(HTuple messageHandle)
        {
            IntPtr proc = HalconAPI.PreCall(540);
            HalconAPI.Store(proc, 0, messageHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(messageHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a new empty message.</summary>
        /// <param name="messageHandle">Handle of the newly created message.</param>
        public static void CreateMessage(out HTuple messageHandle)
        {
            IntPtr proc = HalconAPI.PreCall(541);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out messageHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Destroy all condition synchronization objects.</summary>
        public static void ClearAllConditions()
        {
            IntPtr proc = HalconAPI.PreCall(542);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Destroy a condition synchronization object.</summary>
        /// <param name="conditionHandle">Condition synchronization object.</param>
        public static void ClearCondition(HTuple conditionHandle)
        {
            IntPtr proc = HalconAPI.PreCall(543);
            HalconAPI.Store(proc, 0, conditionHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(conditionHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Signal a condition synchronization object.</summary>
        /// <param name="conditionHandle">Condition synchronization object.</param>
        public static void BroadcastCondition(HTuple conditionHandle)
        {
            IntPtr proc = HalconAPI.PreCall(544);
            HalconAPI.Store(proc, 0, conditionHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(conditionHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Signal a condition synchronization object.</summary>
        /// <param name="conditionHandle">Condition synchronization object.</param>
        public static void SignalCondition(HTuple conditionHandle)
        {
            IntPtr proc = HalconAPI.PreCall(545);
            HalconAPI.Store(proc, 0, conditionHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(conditionHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Bounded wait on the signal of a condition synchronization object.</summary>
        /// <param name="conditionHandle">Condition synchronization object.</param>
        /// <param name="mutexHandle">Mutex synchronization object.</param>
        /// <param name="timeout">Timeout in micro seconds.</param>
        public static void TimedWaitCondition(
          HTuple conditionHandle,
          HTuple mutexHandle,
          HTuple timeout)
        {
            IntPtr proc = HalconAPI.PreCall(546);
            HalconAPI.Store(proc, 0, conditionHandle);
            HalconAPI.Store(proc, 1, mutexHandle);
            HalconAPI.Store(proc, 2, timeout);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(conditionHandle);
            HalconAPI.UnpinTuple(mutexHandle);
            HalconAPI.UnpinTuple(timeout);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>wait on the signal of a condition synchronization object.</summary>
        /// <param name="conditionHandle">Condition synchronization object.</param>
        /// <param name="mutexHandle">Mutex synchronization object.</param>
        public static void WaitCondition(HTuple conditionHandle, HTuple mutexHandle)
        {
            IntPtr proc = HalconAPI.PreCall(547);
            HalconAPI.Store(proc, 0, conditionHandle);
            HalconAPI.Store(proc, 1, mutexHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(conditionHandle);
            HalconAPI.UnpinTuple(mutexHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a condition variable synchronization object.</summary>
        /// <param name="attribName">Mutex attribute. Default: []</param>
        /// <param name="attribValue">Mutex attribute value. Default: []</param>
        /// <param name="conditionHandle">Condition synchronization object.</param>
        public static void CreateCondition(
          HTuple attribName,
          HTuple attribValue,
          out HTuple conditionHandle)
        {
            IntPtr proc = HalconAPI.PreCall(548);
            HalconAPI.Store(proc, 0, attribName);
            HalconAPI.Store(proc, 1, attribValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(attribName);
            HalconAPI.UnpinTuple(attribValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out conditionHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Destroy all barrier synchronization objects.</summary>
        public static void ClearAllBarriers()
        {
            IntPtr proc = HalconAPI.PreCall(549);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Destroy a barrier synchronization object.</summary>
        /// <param name="barrierHandle">Barrier synchronization object.</param>
        public static void ClearBarrier(HTuple barrierHandle)
        {
            IntPtr proc = HalconAPI.PreCall(550);
            HalconAPI.Store(proc, 0, barrierHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barrierHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Wait on the release of a barrier synchronization object.</summary>
        /// <param name="barrierHandle">Barrier synchronization object.</param>
        public static void WaitBarrier(HTuple barrierHandle)
        {
            IntPtr proc = HalconAPI.PreCall(551);
            HalconAPI.Store(proc, 0, barrierHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barrierHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a barrier synchronization object.</summary>
        /// <param name="attribName">Barrier attribute. Default: []</param>
        /// <param name="attribValue">Barrier attribute value. Default: []</param>
        /// <param name="teamSize">Barrier team size. Default: 1</param>
        /// <param name="barrierHandle">Barrier synchronization object.</param>
        public static void CreateBarrier(
          HTuple attribName,
          HTuple attribValue,
          HTuple teamSize,
          out HTuple barrierHandle)
        {
            IntPtr proc = HalconAPI.PreCall(552);
            HalconAPI.Store(proc, 0, attribName);
            HalconAPI.Store(proc, 1, attribValue);
            HalconAPI.Store(proc, 2, teamSize);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(attribName);
            HalconAPI.UnpinTuple(attribValue);
            HalconAPI.UnpinTuple(teamSize);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out barrierHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all event synchronization objects.</summary>
        public static void ClearAllEvents()
        {
            IntPtr proc = HalconAPI.PreCall(553);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear the event synchronization object.</summary>
        /// <param name="eventHandle">Event synchronization object.</param>
        public static void ClearEvent(HTuple eventHandle)
        {
            IntPtr proc = HalconAPI.PreCall(554);
            HalconAPI.Store(proc, 0, eventHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(eventHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Unlock an event synchronization object. </summary>
        /// <param name="eventHandle">Event synchronization object.</param>
        public static void SignalEvent(HTuple eventHandle)
        {
            IntPtr proc = HalconAPI.PreCall(555);
            HalconAPI.Store(proc, 0, eventHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(eventHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Lock an event synchronization object only if it is unlocked.</summary>
        /// <param name="eventHandle">Event synchronization object.</param>
        /// <param name="busy">Object already locked?</param>
        public static void TryWaitEvent(HTuple eventHandle, out HTuple busy)
        {
            IntPtr proc = HalconAPI.PreCall(556);
            HalconAPI.Store(proc, 0, eventHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(eventHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out busy);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Lock an event synchronization object.</summary>
        /// <param name="eventHandle">Event synchronization object.</param>
        public static void WaitEvent(HTuple eventHandle)
        {
            IntPtr proc = HalconAPI.PreCall(557);
            HalconAPI.Store(proc, 0, eventHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(eventHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an event synchronization object.</summary>
        /// <param name="attribName">Mutex attribute. Default: []</param>
        /// <param name="attribValue">Mutex attribute value. Default: []</param>
        /// <param name="eventHandle">Event synchronization object.</param>
        public static void CreateEvent(HTuple attribName, HTuple attribValue, out HTuple eventHandle)
        {
            IntPtr proc = HalconAPI.PreCall(558);
            HalconAPI.Store(proc, 0, attribName);
            HalconAPI.Store(proc, 1, attribValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(attribName);
            HalconAPI.UnpinTuple(attribValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out eventHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all mutex synchronization objects.</summary>
        public static void ClearAllMutexes()
        {
            IntPtr proc = HalconAPI.PreCall(559);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear the mutex synchronization object.</summary>
        /// <param name="mutexHandle">Mutex synchronization object.</param>
        public static void ClearMutex(HTuple mutexHandle)
        {
            IntPtr proc = HalconAPI.PreCall(560);
            HalconAPI.Store(proc, 0, mutexHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mutexHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Unlock a mutex synchronization object.</summary>
        /// <param name="mutexHandle">Mutex synchronization object.</param>
        public static void UnlockMutex(HTuple mutexHandle)
        {
            IntPtr proc = HalconAPI.PreCall(561);
            HalconAPI.Store(proc, 0, mutexHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mutexHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Lock a mutex synchronization object.</summary>
        /// <param name="mutexHandle">Mutex synchronization object.</param>
        /// <param name="busy">Mutex already locked?</param>
        public static void TryLockMutex(HTuple mutexHandle, out HTuple busy)
        {
            IntPtr proc = HalconAPI.PreCall(562);
            HalconAPI.Store(proc, 0, mutexHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mutexHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out busy);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Lock a mutex synchronization object.</summary>
        /// <param name="mutexHandle">Mutex synchronization object.</param>
        public static void LockMutex(HTuple mutexHandle)
        {
            IntPtr proc = HalconAPI.PreCall(563);
            HalconAPI.Store(proc, 0, mutexHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mutexHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a mutual exclusion synchronization object.</summary>
        /// <param name="attribName">Mutex attribute class. Default: []</param>
        /// <param name="attribValue">Mutex attribute kind. Default: []</param>
        /// <param name="mutexHandle">Mutex synchronization object.</param>
        public static void CreateMutex(HTuple attribName, HTuple attribValue, out HTuple mutexHandle)
        {
            IntPtr proc = HalconAPI.PreCall(564);
            HalconAPI.Store(proc, 0, attribName);
            HalconAPI.Store(proc, 1, attribValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(attribName);
            HalconAPI.UnpinTuple(attribValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out mutexHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the attributes of a threading / synchronization object.</summary>
        /// <param name="threadingHandle">Threading object.</param>
        /// <param name="threadingClass">Class name of threading object.</param>
        /// <param name="attribName">Name of an attribute.</param>
        /// <param name="attribValue">Value of the attribute.</param>
        public static void GetThreadingAttrib(
          HTuple threadingHandle,
          out HTuple threadingClass,
          out HTuple attribName,
          out HTuple attribValue)
        {
            IntPtr proc = HalconAPI.PreCall(565);
            HalconAPI.Store(proc, 0, threadingHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(threadingHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out threadingClass);
            int err3 = HTuple.LoadNew(proc, 1, err2, out attribName);
            int procResult = HTuple.LoadNew(proc, 2, err3, out attribValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set AOP information for operators.</summary>
        /// <param name="operatorName">Operator to set information to Default: ""</param>
        /// <param name="indexName">Further specific index Default: ""</param>
        /// <param name="indexValue">Further specific address Default: ""</param>
        /// <param name="infoName">Scope of information Default: "max_threads"</param>
        /// <param name="infoValue">AOP information value</param>
        public static void SetAopInfo(
          HTuple operatorName,
          HTuple indexName,
          HTuple indexValue,
          HTuple infoName,
          HTuple infoValue)
        {
            IntPtr proc = HalconAPI.PreCall(566);
            HalconAPI.Store(proc, 0, operatorName);
            HalconAPI.Store(proc, 1, indexName);
            HalconAPI.Store(proc, 2, indexValue);
            HalconAPI.Store(proc, 3, infoName);
            HalconAPI.Store(proc, 4, infoValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(operatorName);
            HalconAPI.UnpinTuple(indexName);
            HalconAPI.UnpinTuple(indexValue);
            HalconAPI.UnpinTuple(infoName);
            HalconAPI.UnpinTuple(infoValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return AOP information for operators. </summary>
        /// <param name="operatorName">Operator to get information for</param>
        /// <param name="indexName">Further index stages Default: ["iconic_type","parameter:0"]</param>
        /// <param name="indexValue">Further index values Default: ["byte",""]</param>
        /// <param name="infoName">Scope of information Default: "max_threads"</param>
        /// <param name="infoValue">Value of information</param>
        public static void GetAopInfo(
          HTuple operatorName,
          HTuple indexName,
          HTuple indexValue,
          HTuple infoName,
          out HTuple infoValue)
        {
            IntPtr proc = HalconAPI.PreCall(567);
            HalconAPI.Store(proc, 0, operatorName);
            HalconAPI.Store(proc, 1, indexName);
            HalconAPI.Store(proc, 2, indexValue);
            HalconAPI.Store(proc, 3, infoName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(operatorName);
            HalconAPI.UnpinTuple(indexName);
            HalconAPI.UnpinTuple(indexValue);
            HalconAPI.UnpinTuple(infoName);
            int procResult = HTuple.LoadNew(proc, 0, err, out infoValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query indexing structure of AOP information for operators. </summary>
        /// <param name="operatorName">Operator to get information for Default: ""</param>
        /// <param name="indexName">Further specific index Default: ""</param>
        /// <param name="indexValue">Further specific address Default: ""</param>
        /// <param name="name">Name of next index stage</param>
        /// <param name="value">Values of next index stage</param>
        public static void QueryAopInfo(
          HTuple operatorName,
          HTuple indexName,
          HTuple indexValue,
          out HTuple name,
          out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(568);
            HalconAPI.Store(proc, 0, operatorName);
            HalconAPI.Store(proc, 1, indexName);
            HalconAPI.Store(proc, 2, indexValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(operatorName);
            HalconAPI.UnpinTuple(indexName);
            HalconAPI.UnpinTuple(indexValue);
            int err2 = HTuple.LoadNew(proc, 0, err1, out name);
            int procResult = HTuple.LoadNew(proc, 1, err2, out value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Check hardware regarding its potential for automatic operator parallelization.</summary>
        /// <param name="operatorName">Operators to check Default: ""</param>
        /// <param name="iconicType">Iconic object types to check Default: ""</param>
        /// <param name="fileName">Knowledge file name Default: ""</param>
        /// <param name="genParamName">Parameter name Default: "none"</param>
        /// <param name="genParamValue">Parameter value Default: "none"</param>
        public static void OptimizeAop(
          HTuple operatorName,
          HTuple iconicType,
          HTuple fileName,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(569);
            HalconAPI.Store(proc, 0, operatorName);
            HalconAPI.Store(proc, 1, iconicType);
            HalconAPI.Store(proc, 2, fileName);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(operatorName);
            HalconAPI.UnpinTuple(iconicType);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write knowledge about hardware dependent behavior of automatic operator parallelization to file.</summary>
        /// <param name="fileName">Name of knowledge file Default: ""</param>
        /// <param name="genParamName">Parameter name Default: "none"</param>
        /// <param name="genParamValue">Parameter value Default: "none"</param>
        public static void WriteAopKnowledge(
          HTuple fileName,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(570);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Load knowledge about hardware dependent behavior of automatic operator parallelization.</summary>
        /// <param name="fileName">Name of knowledge file Default: ""</param>
        /// <param name="genParamName">Parameter name Default: "none"</param>
        /// <param name="genParamValue">Parameter value Default: "none"</param>
        /// <param name="attributes">Knowledge attributes</param>
        /// <param name="operatorNames">Updated Operators</param>
        public static void ReadAopKnowledge(
          HTuple fileName,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple attributes,
          out HTuple operatorNames)
        {
            IntPtr proc = HalconAPI.PreCall(571);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, err1, out attributes);
            int procResult = HTuple.LoadNew(proc, 1, err2, out operatorNames);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary></summary>
        /// <param name="objectVal"></param>
        /// <param name="dummy"></param>
        /// <param name="numReadChord"></param>
        /// <param name="numCopyObj"></param>
        /// <param name="writeChord"></param>
        public static void TestAccess(
          HObject objectVal,
          out HObject dummy,
          HTuple numReadChord,
          HTuple numCopyObj,
          HTuple writeChord)
        {
            IntPtr proc = HalconAPI.PreCall(572);
            HalconAPI.Store(proc, 1, (HObjectBase)objectVal);
            HalconAPI.Store(proc, 0, numReadChord);
            HalconAPI.Store(proc, 1, numCopyObj);
            HalconAPI.Store(proc, 2, writeChord);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numReadChord);
            HalconAPI.UnpinTuple(numCopyObj);
            HalconAPI.UnpinTuple(writeChord);
            int procResult = HObject.LoadNew(proc, 1, err, out dummy);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objectVal);
        }

        /// <summary>Calculate the difference of two object tuples.</summary>
        /// <param name="objects">Object tuple 1.</param>
        /// <param name="objectsSub">Object tuple 2.</param>
        /// <param name="objectsDiff">Objects from Objects that are not part of ObjectsSub.</param>
        public static void ObjDiff(HObject objects, HObject objectsSub, out HObject objectsDiff)
        {
            IntPtr proc = HalconAPI.PreCall(573);
            HalconAPI.Store(proc, 1, (HObjectBase)objects);
            HalconAPI.Store(proc, 2, (HObjectBase)objectsSub);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out objectsDiff);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects);
            GC.KeepAlive((object)objectsSub);
        }

        /// <summary>Set single gray values in an image.</summary>
        /// <param name="image">Image to be modified.</param>
        /// <param name="row">Row coordinates of the pixels to be modified. Default: 0</param>
        /// <param name="column">Column coordinates of the pixels to be modified. Default: 0</param>
        /// <param name="grayval">Gray values to be used. Default: 255.0</param>
        public static void SetGrayval(HObject image, HTuple row, HTuple column, HTuple grayval)
        {
            IntPtr proc = HalconAPI.PreCall(574);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, grayval);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(grayval);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Paint XLD objects into an image.</summary>
        /// <param name="XLD">XLD objects to be painted into the input image.</param>
        /// <param name="image">Image in which the xld objects are to be painted.</param>
        /// <param name="imageResult">Image containing the result.</param>
        /// <param name="grayval">Desired gray value of the xld object. Default: 255.0</param>
        public static void PaintXld(
          HObject XLD,
          HObject image,
          out HObject imageResult,
          HTuple grayval)
        {
            IntPtr proc = HalconAPI.PreCall(575);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, grayval);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(grayval);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
            GC.KeepAlive((object)image);
        }

        /// <summary>Paint regions into an image.</summary>
        /// <param name="region">Regions to be painted into the input image.</param>
        /// <param name="image">Image in which the regions are to be painted.</param>
        /// <param name="imageResult">Image containing the result.</param>
        /// <param name="grayval">Desired gray values of the regions. Default: 255.0</param>
        /// <param name="type">Paint regions filled or as boundaries. Default: "fill"</param>
        public static void PaintRegion(
          HObject region,
          HObject image,
          out HObject imageResult,
          HTuple grayval,
          HTuple type)
        {
            IntPtr proc = HalconAPI.PreCall(576);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, grayval);
            HalconAPI.Store(proc, 1, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(grayval);
            HalconAPI.UnpinTuple(type);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)image);
        }

        /// <summary>Overpaint regions in an image.</summary>
        /// <param name="image">Image in which the regions are to be painted.</param>
        /// <param name="region">Regions to be painted into the input image.</param>
        /// <param name="grayval">Desired gray values of the regions. Default: 255.0</param>
        /// <param name="type">Paint regions filled or as boundaries. Default: "fill"</param>
        public static void OverpaintRegion(HObject image, HObject region, HTuple grayval, HTuple type)
        {
            IntPtr proc = HalconAPI.PreCall(577);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.Store(proc, 0, grayval);
            HalconAPI.Store(proc, 1, type);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(grayval);
            HalconAPI.UnpinTuple(type);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)region);
        }

        /// <summary>Create an image with a specified constant gray value.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageCleared">Image with constant gray value.</param>
        /// <param name="grayval">Gray value to be used for the output image. Default: 0</param>
        public static void GenImageProto(HObject image, out HObject imageCleared, HTuple grayval)
        {
            IntPtr proc = HalconAPI.PreCall(578);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, grayval);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(grayval);
            int procResult = HObject.LoadNew(proc, 1, err, out imageCleared);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Paint the gray values of an image into another image.</summary>
        /// <param name="imageSource">Input image containing the desired gray values.</param>
        /// <param name="imageDestination">Input image to be painted over.</param>
        /// <param name="mixedImage">Result image.</param>
        public static void PaintGray(
          HObject imageSource,
          HObject imageDestination,
          out HObject mixedImage)
        {
            IntPtr proc = HalconAPI.PreCall(579);
            HalconAPI.Store(proc, 1, (HObjectBase)imageSource);
            HalconAPI.Store(proc, 2, (HObjectBase)imageDestination);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out mixedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageSource);
            GC.KeepAlive((object)imageDestination);
        }

        /// <summary>Overpaint the gray values of an image.</summary>
        /// <param name="imageDestination">Input image to be painted over.</param>
        /// <param name="imageSource">Input image containing the desired gray values.</param>
        public static void OverpaintGray(HObject imageDestination, HObject imageSource)
        {
            IntPtr proc = HalconAPI.PreCall(580);
            HalconAPI.Store(proc, 1, (HObjectBase)imageDestination);
            HalconAPI.Store(proc, 2, (HObjectBase)imageSource);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageDestination);
            GC.KeepAlive((object)imageSource);
        }

        /// <summary>Convert an "integer number" into an iconic object.</summary>
        /// <param name="objects">Created objects.</param>
        /// <param name="surrogateTuple">Tuple of object surrogates.</param>
        public static void IntegerToObj(out HObject objects, HTuple surrogateTuple)
        {
            IntPtr proc = HalconAPI.PreCall(581);
            HalconAPI.Store(proc, 0, surrogateTuple);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surrogateTuple);
            int procResult = HObject.LoadNew(proc, 1, err, out objects);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert an iconic object into an "integer number."</summary>
        /// <param name="objects">Objects for which the surrogates are to be returned.</param>
        /// <param name="index">Starting index of the surrogates to be returned. Default: 1</param>
        /// <param name="number">Number of surrogates to be returned. Default: -1</param>
        /// <param name="surrogateTuple">Tuple containing the surrogates.</param>
        public static void ObjToInteger(
          HObject objects,
          HTuple index,
          HTuple number,
          out HTuple surrogateTuple)
        {
            IntPtr proc = HalconAPI.PreCall(582);
            HalconAPI.Store(proc, 1, (HObjectBase)objects);
            HalconAPI.Store(proc, 0, index);
            HalconAPI.Store(proc, 1, number);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(number);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out surrogateTuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects);
        }

        /// <summary>Copy an iconic object in the HALCON database.</summary>
        /// <param name="objects">Objects to be copied.</param>
        /// <param name="objectsSelected">Copied objects.</param>
        /// <param name="index">Starting index of the objects to be copied. Default: 1</param>
        /// <param name="numObj">Number of objects to be copied or -1. Default: 1</param>
        public static void CopyObj(
          HObject objects,
          out HObject objectsSelected,
          HTuple index,
          HTuple numObj)
        {
            IntPtr proc = HalconAPI.PreCall(583);
            HalconAPI.Store(proc, 1, (HObjectBase)objects);
            HalconAPI.Store(proc, 0, index);
            HalconAPI.Store(proc, 1, numObj);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(numObj);
            int procResult = HObject.LoadNew(proc, 1, err, out objectsSelected);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects);
        }

        /// <summary>Concatenate two iconic object tuples.</summary>
        /// <param name="objects1">Object tuple 1.</param>
        /// <param name="objects2">Object tuple 2.</param>
        /// <param name="objectsConcat">Concatenated objects.</param>
        public static void ConcatObj(HObject objects1, HObject objects2, out HObject objectsConcat)
        {
            IntPtr proc = HalconAPI.PreCall(584);
            HalconAPI.Store(proc, 1, (HObjectBase)objects1);
            HalconAPI.Store(proc, 2, (HObjectBase)objects2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out objectsConcat);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects1);
            GC.KeepAlive((object)objects2);
        }

        /// <summary>Delete an iconic object from the HALCON database.</summary>
        /// <param name="objects">Objects to be deleted.</param>
        public static void ClearObj(HObject objects)
        {
            IntPtr proc = HalconAPI.PreCall(585);
            HalconAPI.Store(proc, 1, (HObjectBase)objects);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects);
        }

        /// <summary>Copy an image and allocate new memory for it.</summary>
        /// <param name="image">Image to be copied.</param>
        /// <param name="dupImage">Copied image.</param>
        public static void CopyImage(HObject image, out HObject dupImage)
        {
            IntPtr proc = HalconAPI.PreCall(586);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out dupImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Select objects from an object tuple.</summary>
        /// <param name="objects">Input objects.</param>
        /// <param name="objectSelected">Selected objects.</param>
        /// <param name="index">Indices of the objects to be selected. Default: 1</param>
        public static void SelectObj(HObject objects, out HObject objectSelected, HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(587);
            HalconAPI.Store(proc, 1, (HObjectBase)objects);
            HalconAPI.Store(proc, 0, index);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(index);
            int procResult = HObject.LoadNew(proc, 1, err, out objectSelected);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects);
        }

        /// <summary>Compare iconic objects regarding equality.</summary>
        /// <param name="objects1">Reference objects.</param>
        /// <param name="objects2">Test objects.</param>
        /// <param name="epsilon">Maximum allowed difference between two gray values or  coordinates etc. Default: 0.0</param>
        /// <param name="isEqual">Boolean result value.</param>
        public static void CompareObj(
          HObject objects1,
          HObject objects2,
          HTuple epsilon,
          out HTuple isEqual)
        {
            IntPtr proc = HalconAPI.PreCall(588);
            HalconAPI.Store(proc, 1, (HObjectBase)objects1);
            HalconAPI.Store(proc, 2, (HObjectBase)objects2);
            HalconAPI.Store(proc, 0, epsilon);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(epsilon);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isEqual);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects1);
            GC.KeepAlive((object)objects2);
        }

        /// <summary>Test whether a region is contained in another region.</summary>
        /// <param name="region1">Test region.</param>
        /// <param name="region2">Region for comparison.</param>
        /// <param name="isSubset">Is Region1 contained in Region2?</param>
        public static void TestSubsetRegion(HObject region1, HObject region2, out HTuple isSubset)
        {
            IntPtr proc = HalconAPI.PreCall(589);
            HalconAPI.Store(proc, 1, (HObjectBase)region1);
            HalconAPI.Store(proc, 2, (HObjectBase)region2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isSubset);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region1);
            GC.KeepAlive((object)region2);
        }

        /// <summary>Test whether the regions of two objects are identical.</summary>
        /// <param name="regions1">Test regions.</param>
        /// <param name="regions2">Comparative regions.</param>
        /// <param name="isEqual">boolean result value.</param>
        public static void TestEqualRegion(HObject regions1, HObject regions2, out HTuple isEqual)
        {
            IntPtr proc = HalconAPI.PreCall(590);
            HalconAPI.Store(proc, 1, (HObjectBase)regions1);
            HalconAPI.Store(proc, 2, (HObjectBase)regions2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isEqual);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions1);
            GC.KeepAlive((object)regions2);
        }

        /// <summary>Compare image objects regarding equality.</summary>
        /// <param name="objects1">Test objects.</param>
        /// <param name="objects2">Comparative objects.</param>
        /// <param name="isEqual">boolean result value.</param>
        public static void TestEqualObj(HObject objects1, HObject objects2, out HTuple isEqual)
        {
            IntPtr proc = HalconAPI.PreCall(591);
            HalconAPI.Store(proc, 1, (HObjectBase)objects1);
            HalconAPI.Store(proc, 2, (HObjectBase)objects2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isEqual);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects1);
            GC.KeepAlive((object)objects2);
        }

        /// <summary>Number of objects in a tuple.</summary>
        /// <param name="objects">Objects to be examined.</param>
        /// <param name="number">Number of objects in the tuple Objects.</param>
        public static void CountObj(HObject objects, out HTuple number)
        {
            IntPtr proc = HalconAPI.PreCall(592);
            HalconAPI.Store(proc, 1, (HObjectBase)objects);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out number);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects);
        }

        /// <summary>Informations about the components of an image object.</summary>
        /// <param name="objectVal">Image object to be examined.</param>
        /// <param name="request">Required information about object components. Default: "creator"</param>
        /// <param name="channel">Components to be examined (0 for region/XLD). Default: 0</param>
        /// <param name="information">Requested information.</param>
        public static void GetChannelInfo(
          HObject objectVal,
          HTuple request,
          HTuple channel,
          out HTuple information)
        {
            IntPtr proc = HalconAPI.PreCall(593);
            HalconAPI.Store(proc, 1, (HObjectBase)objectVal);
            HalconAPI.Store(proc, 0, request);
            HalconAPI.Store(proc, 1, channel);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(request);
            HalconAPI.UnpinTuple(channel);
            int procResult = HTuple.LoadNew(proc, 0, err, out information);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objectVal);
        }

        /// <summary>Name of the class of an image object.</summary>
        /// <param name="objectVal">Image objects to be examined.</param>
        /// <param name="classVal">Name of class.</param>
        public static void GetObjClass(HObject objectVal, out HTuple classVal)
        {
            IntPtr proc = HalconAPI.PreCall(594);
            HalconAPI.Store(proc, 1, (HObjectBase)objectVal);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, err, out classVal);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objectVal);
        }

        /// <summary>Create a three-channel image from a pointer to the interleaved pixels.</summary>
        /// <param name="imageRGB">Created image with new image matrix.</param>
        /// <param name="pixelPointer">Pointer to interleaved pixels.</param>
        /// <param name="colorFormat">Format of the input pixels. Default: "rgb"</param>
        /// <param name="originalWidth">Width of input image. Default: 512</param>
        /// <param name="originalHeight">Height of input image. Default: 512</param>
        /// <param name="alignment">Reserved.</param>
        /// <param name="type">Pixel type of output image. Default: "byte"</param>
        /// <param name="imageWidth">Width of output image. Default: 0</param>
        /// <param name="imageHeight">Height of output image. Default: 0</param>
        /// <param name="startRow">Line number of upper left corner of desired image part. Default: 0</param>
        /// <param name="startColumn">Column number of upper left corner of desired image part. Default: 0</param>
        /// <param name="bitsPerChannel">Number of used bits per pixel and channel of the output image (-1: All bits are used). Default: -1</param>
        /// <param name="bitShift">Number of bits that the color values of the input pixels are shifted to the right (only uint2 images). Default: 0</param>
        public static void GenImageInterleaved(
          out HObject imageRGB,
          HTuple pixelPointer,
          HTuple colorFormat,
          HTuple originalWidth,
          HTuple originalHeight,
          HTuple alignment,
          HTuple type,
          HTuple imageWidth,
          HTuple imageHeight,
          HTuple startRow,
          HTuple startColumn,
          HTuple bitsPerChannel,
          HTuple bitShift)
        {
            IntPtr proc = HalconAPI.PreCall(595);
            HalconAPI.Store(proc, 0, pixelPointer);
            HalconAPI.Store(proc, 1, colorFormat);
            HalconAPI.Store(proc, 2, originalWidth);
            HalconAPI.Store(proc, 3, originalHeight);
            HalconAPI.Store(proc, 4, alignment);
            HalconAPI.Store(proc, 5, type);
            HalconAPI.Store(proc, 6, imageWidth);
            HalconAPI.Store(proc, 7, imageHeight);
            HalconAPI.Store(proc, 8, startRow);
            HalconAPI.Store(proc, 9, startColumn);
            HalconAPI.Store(proc, 10, bitsPerChannel);
            HalconAPI.Store(proc, 11, bitShift);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pixelPointer);
            HalconAPI.UnpinTuple(colorFormat);
            HalconAPI.UnpinTuple(originalWidth);
            HalconAPI.UnpinTuple(originalHeight);
            HalconAPI.UnpinTuple(alignment);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(imageWidth);
            HalconAPI.UnpinTuple(imageHeight);
            HalconAPI.UnpinTuple(startRow);
            HalconAPI.UnpinTuple(startColumn);
            HalconAPI.UnpinTuple(bitsPerChannel);
            HalconAPI.UnpinTuple(bitShift);
            int procResult = HObject.LoadNew(proc, 1, err, out imageRGB);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a region from an XLD polygon.</summary>
        /// <param name="polygon">Input polygon(s).</param>
        /// <param name="region">Created region(s).</param>
        /// <param name="mode">Fill mode of the region(s). Default: "filled"</param>
        public static void GenRegionPolygonXld(HObject polygon, out HObject region, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(596);
            HalconAPI.Store(proc, 1, (HObjectBase)polygon);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygon);
        }

        /// <summary>Create a region from an XLD contour.</summary>
        /// <param name="contour">Input contour(s).</param>
        /// <param name="region">Created region(s).</param>
        /// <param name="mode">Fill mode of the region(s). Default: "filled"</param>
        public static void GenRegionContourXld(HObject contour, out HObject region, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(597);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Store a polygon as a "filled" region.</summary>
        /// <param name="region">Created region.</param>
        /// <param name="rows">Line indices of the base points of the region contour. Default: 100</param>
        /// <param name="columns">Column indices of the base points of the region contour. Default: 100</param>
        public static void GenRegionPolygonFilled(out HObject region, HTuple rows, HTuple columns)
        {
            IntPtr proc = HalconAPI.PreCall(598);
            HalconAPI.Store(proc, 0, rows);
            HalconAPI.Store(proc, 1, columns);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows);
            HalconAPI.UnpinTuple(columns);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Store a polygon as a region.</summary>
        /// <param name="region">Created region.</param>
        /// <param name="rows">Line indices of the base points of the region contour. Default: 100</param>
        /// <param name="columns">Colum indices of the base points of the region contour. Default: 100</param>
        public static void GenRegionPolygon(out HObject region, HTuple rows, HTuple columns)
        {
            IntPtr proc = HalconAPI.PreCall(599);
            HalconAPI.Store(proc, 0, rows);
            HalconAPI.Store(proc, 1, columns);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows);
            HalconAPI.UnpinTuple(columns);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Store individual pixels as image region.</summary>
        /// <param name="region">Created region.</param>
        /// <param name="rows">Lines of the pixels in the region. Default: 100</param>
        /// <param name="columns">Columns of the pixels in the region. Default: 100</param>
        public static void GenRegionPoints(out HObject region, HTuple rows, HTuple columns)
        {
            IntPtr proc = HalconAPI.PreCall(600);
            HalconAPI.Store(proc, 0, rows);
            HalconAPI.Store(proc, 1, columns);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows);
            HalconAPI.UnpinTuple(columns);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a region from a runlength coding.</summary>
        /// <param name="region">Created region.</param>
        /// <param name="row">Lines of the runs. Default: 100</param>
        /// <param name="columnBegin">Columns of the starting points of the runs. Default: 50</param>
        /// <param name="columnEnd">Columns of the ending points of the runs. Default: 200</param>
        public static void GenRegionRuns(
          out HObject region,
          HTuple row,
          HTuple columnBegin,
          HTuple columnEnd)
        {
            IntPtr proc = HalconAPI.PreCall(601);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, columnBegin);
            HalconAPI.Store(proc, 2, columnEnd);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(columnBegin);
            HalconAPI.UnpinTuple(columnEnd);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a rectangle of any orientation.</summary>
        /// <param name="rectangle">Created rectangle.</param>
        /// <param name="row">Line index of the center. Default: 300.0</param>
        /// <param name="column">Column index of the center. Default: 200.0</param>
        /// <param name="phi">Angle of longitudinal axis to the horizontal (in radians). Default: 0.0</param>
        /// <param name="length1">Half width. Default: 100.0</param>
        /// <param name="length2">Half height. Default: 20.0</param>
        public static void GenRectangle2(
          out HObject rectangle,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple length1,
          HTuple length2)
        {
            IntPtr proc = HalconAPI.PreCall(602);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, phi);
            HalconAPI.Store(proc, 3, length1);
            HalconAPI.Store(proc, 4, length2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(length1);
            HalconAPI.UnpinTuple(length2);
            int procResult = HObject.LoadNew(proc, 1, err, out rectangle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a rectangle parallel to the coordinate axes.</summary>
        /// <param name="rectangle">Created rectangle.</param>
        /// <param name="row1">Line of upper left corner point. Default: 30.0</param>
        /// <param name="column1">Column of upper left corner point. Default: 20.0</param>
        /// <param name="row2">Line of lower right corner point. Default: 100.0</param>
        /// <param name="column2">Column of lower right corner point. Default: 200.0</param>
        public static void GenRectangle1(
          out HObject rectangle,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(603);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int procResult = HObject.LoadNew(proc, 1, err, out rectangle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a random region.</summary>
        /// <param name="regionRandom">Created random region with expansion Width x Height.</param>
        /// <param name="width">Maximum horizontal expansion of random region. Default: 128</param>
        /// <param name="height">Maximum vertical expansion of random region. Default: 128</param>
        public static void GenRandomRegion(out HObject regionRandom, HTuple width, HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(604);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out regionRandom);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an image from three pointers to the pixels (red/green/blue).</summary>
        /// <param name="imageRGB">Created image with new image matrix.</param>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        /// <param name="pixelPointerRed">Pointer to first red value (channel 1).</param>
        /// <param name="pixelPointerGreen">Pointer to first green value (channel 2).</param>
        /// <param name="pixelPointerBlue">Pointer to first blue value (channel 3).</param>
        public static void GenImage3(
          out HObject imageRGB,
          HTuple type,
          HTuple width,
          HTuple height,
          HTuple pixelPointerRed,
          HTuple pixelPointerGreen,
          HTuple pixelPointerBlue)
        {
            IntPtr proc = HalconAPI.PreCall(605);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, width);
            HalconAPI.Store(proc, 2, height);
            HalconAPI.Store(proc, 3, pixelPointerRed);
            HalconAPI.Store(proc, 4, pixelPointerGreen);
            HalconAPI.Store(proc, 5, pixelPointerBlue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(pixelPointerRed);
            HalconAPI.UnpinTuple(pixelPointerGreen);
            HalconAPI.UnpinTuple(pixelPointerBlue);
            int procResult = HObject.LoadNew(proc, 1, err, out imageRGB);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an image from a pointer to the pixels.</summary>
        /// <param name="image">Created image with new image matrix.</param>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        /// <param name="pixelPointer">Pointer to first gray value.</param>
        public static void GenImage1(
          out HObject image,
          HTuple type,
          HTuple width,
          HTuple height,
          HTuple pixelPointer)
        {
            IntPtr proc = HalconAPI.PreCall(606);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, width);
            HalconAPI.Store(proc, 2, height);
            HalconAPI.Store(proc, 3, pixelPointer);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(pixelPointer);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an image with constant gray value.</summary>
        /// <param name="image">Created image with new image matrix.</param>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        public static void GenImageConst(out HObject image, HTuple type, HTuple width, HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(607);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, width);
            HalconAPI.Store(proc, 2, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an ellipse sector.</summary>
        /// <param name="ellipseSector">Created ellipse(s).</param>
        /// <param name="row">Line index of center. Default: 200.0</param>
        /// <param name="column">Column index of center. Default: 200.0</param>
        /// <param name="phi">Orientation of the longer radius (Radius1). Default: 0.0</param>
        /// <param name="radius1">Longer radius. Default: 100.0</param>
        /// <param name="radius2">Shorter radius. Default: 60.0</param>
        /// <param name="startAngle">Start angle of the sector. Default: 0.0</param>
        /// <param name="endAngle">End angle of the sector. Default: 3.14159</param>
        public static void GenEllipseSector(
          out HObject ellipseSector,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple radius1,
          HTuple radius2,
          HTuple startAngle,
          HTuple endAngle)
        {
            IntPtr proc = HalconAPI.PreCall(608);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, phi);
            HalconAPI.Store(proc, 3, radius1);
            HalconAPI.Store(proc, 4, radius2);
            HalconAPI.Store(proc, 5, startAngle);
            HalconAPI.Store(proc, 6, endAngle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(radius1);
            HalconAPI.UnpinTuple(radius2);
            HalconAPI.UnpinTuple(startAngle);
            HalconAPI.UnpinTuple(endAngle);
            int procResult = HObject.LoadNew(proc, 1, err, out ellipseSector);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an ellipse.</summary>
        /// <param name="ellipse">Created ellipse(s).</param>
        /// <param name="row">Line index of center. Default: 200.0</param>
        /// <param name="column">Column index of center. Default: 200.0</param>
        /// <param name="phi">Orientation of the longer radius (Radius1). Default: 0.0</param>
        /// <param name="radius1">Longer radius. Default: 100.0</param>
        /// <param name="radius2">Shorter radius. Default: 60.0</param>
        public static void GenEllipse(
          out HObject ellipse,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple radius1,
          HTuple radius2)
        {
            IntPtr proc = HalconAPI.PreCall(609);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, phi);
            HalconAPI.Store(proc, 3, radius1);
            HalconAPI.Store(proc, 4, radius2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(radius1);
            HalconAPI.UnpinTuple(radius2);
            int procResult = HObject.LoadNew(proc, 1, err, out ellipse);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a circle sector.</summary>
        /// <param name="circleSector">Generated circle sector.</param>
        /// <param name="row">Line index of center. Default: 200.0</param>
        /// <param name="column">Column index of center. Default: 200.0</param>
        /// <param name="radius">Radius of circle. Default: 100.5</param>
        /// <param name="startAngle">Start angle of the circle sector. Default: 0.0</param>
        /// <param name="endAngle">End angle of the circle sector. Default: 3.14159</param>
        public static void GenCircleSector(
          out HObject circleSector,
          HTuple row,
          HTuple column,
          HTuple radius,
          HTuple startAngle,
          HTuple endAngle)
        {
            IntPtr proc = HalconAPI.PreCall(610);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, radius);
            HalconAPI.Store(proc, 3, startAngle);
            HalconAPI.Store(proc, 4, endAngle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(startAngle);
            HalconAPI.UnpinTuple(endAngle);
            int procResult = HObject.LoadNew(proc, 1, err, out circleSector);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a circle.</summary>
        /// <param name="circle">Generated circle.</param>
        /// <param name="row">Line index of center. Default: 200.0</param>
        /// <param name="column">Column index of center. Default: 200.0</param>
        /// <param name="radius">Radius of circle. Default: 100.5</param>
        public static void GenCircle(out HObject circle, HTuple row, HTuple column, HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(611);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, radius);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(radius);
            int procResult = HObject.LoadNew(proc, 1, err, out circle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a checkered region.</summary>
        /// <param name="regionChecker">Created checkerboard region.</param>
        /// <param name="widthRegion">Largest occurring $x$ value of the region. Default: 511</param>
        /// <param name="heightRegion">Largest occurring $y$ value of the region. Default: 511</param>
        /// <param name="widthPattern">Width of a field of the checkerboard. Default: 64</param>
        /// <param name="heightPattern">Height of a field of the checkerboard. Default: 64</param>
        public static void GenCheckerRegion(
          out HObject regionChecker,
          HTuple widthRegion,
          HTuple heightRegion,
          HTuple widthPattern,
          HTuple heightPattern)
        {
            IntPtr proc = HalconAPI.PreCall(612);
            HalconAPI.Store(proc, 0, widthRegion);
            HalconAPI.Store(proc, 1, heightRegion);
            HalconAPI.Store(proc, 2, widthPattern);
            HalconAPI.Store(proc, 3, heightPattern);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(widthRegion);
            HalconAPI.UnpinTuple(heightRegion);
            HalconAPI.UnpinTuple(widthPattern);
            HalconAPI.UnpinTuple(heightPattern);
            int procResult = HObject.LoadNew(proc, 1, err, out regionChecker);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a region from lines or pixels.</summary>
        /// <param name="regionGrid">Created lines/pixel region.</param>
        /// <param name="rowSteps">Step width in line direction or zero. Default: 10</param>
        /// <param name="columnSteps">Step width in column direction or zero. Default: 10</param>
        /// <param name="type">Type of created pattern. Default: "lines"</param>
        /// <param name="width">Maximum width of pattern. Default: 512</param>
        /// <param name="height">Maximum height of pattern. Default: 512</param>
        public static void GenGridRegion(
          out HObject regionGrid,
          HTuple rowSteps,
          HTuple columnSteps,
          HTuple type,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(613);
            HalconAPI.Store(proc, 0, rowSteps);
            HalconAPI.Store(proc, 1, columnSteps);
            HalconAPI.Store(proc, 2, type);
            HalconAPI.Store(proc, 3, width);
            HalconAPI.Store(proc, 4, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rowSteps);
            HalconAPI.UnpinTuple(columnSteps);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out regionGrid);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create random regions like circles, rectangles and ellipses.</summary>
        /// <param name="regions">Created regions.</param>
        /// <param name="type">Type of regions to be created. Default: "circle"</param>
        /// <param name="widthMin">Minimum width of the region. Default: 10.0</param>
        /// <param name="widthMax">Maximum width of the region. Default: 20.0</param>
        /// <param name="heightMin">Minimum height of the region. Default: 10.0</param>
        /// <param name="heightMax">Maximum height of the region. Default: 30.0</param>
        /// <param name="phiMin">Minimum rotation angle of the region. Default: -0.7854</param>
        /// <param name="phiMax">Maximum rotation angle of the region. Default: 0.7854</param>
        /// <param name="numRegions">Number of regions. Default: 100</param>
        /// <param name="width">Maximum horizontal expansion. Default: 512</param>
        /// <param name="height">Maximum vertical expansion. Default: 512</param>
        public static void GenRandomRegions(
          out HObject regions,
          HTuple type,
          HTuple widthMin,
          HTuple widthMax,
          HTuple heightMin,
          HTuple heightMax,
          HTuple phiMin,
          HTuple phiMax,
          HTuple numRegions,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(614);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, widthMin);
            HalconAPI.Store(proc, 2, widthMax);
            HalconAPI.Store(proc, 3, heightMin);
            HalconAPI.Store(proc, 4, heightMax);
            HalconAPI.Store(proc, 5, phiMin);
            HalconAPI.Store(proc, 6, phiMax);
            HalconAPI.Store(proc, 7, numRegions);
            HalconAPI.Store(proc, 8, width);
            HalconAPI.Store(proc, 9, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(widthMin);
            HalconAPI.UnpinTuple(widthMax);
            HalconAPI.UnpinTuple(heightMin);
            HalconAPI.UnpinTuple(heightMax);
            HalconAPI.UnpinTuple(phiMin);
            HalconAPI.UnpinTuple(phiMax);
            HalconAPI.UnpinTuple(numRegions);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out regions);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Store input lines described in Hesse normal form as regions.</summary>
        /// <param name="regions">Created regions (one for every line), clipped to maximum image format.</param>
        /// <param name="orientation">Orientation of the normal vector in radians. Default: 0.0</param>
        /// <param name="distance">Distance from the line to the coordinate origin (0.0). Default: 200</param>
        public static void GenRegionHline(out HObject regions, HTuple orientation, HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(615);
            HalconAPI.Store(proc, 0, orientation);
            HalconAPI.Store(proc, 1, distance);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(orientation);
            HalconAPI.UnpinTuple(distance);
            int procResult = HObject.LoadNew(proc, 1, err, out regions);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Store input lines as regions.</summary>
        /// <param name="regionLines">Created regions.</param>
        /// <param name="beginRow">Line coordinates of the starting points of the input lines. Default: 100</param>
        /// <param name="beginCol">Column coordinates of the starting points of the input lines. Default: 50</param>
        /// <param name="endRow">Line coordinates of the ending points of the input lines. Default: 150</param>
        /// <param name="endCol">Column coordinates of the ending points of the input lines. Default: 250</param>
        public static void GenRegionLine(
          out HObject regionLines,
          HTuple beginRow,
          HTuple beginCol,
          HTuple endRow,
          HTuple endCol)
        {
            IntPtr proc = HalconAPI.PreCall(616);
            HalconAPI.Store(proc, 0, beginRow);
            HalconAPI.Store(proc, 1, beginCol);
            HalconAPI.Store(proc, 2, endRow);
            HalconAPI.Store(proc, 3, endCol);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(beginRow);
            HalconAPI.UnpinTuple(beginCol);
            HalconAPI.UnpinTuple(endRow);
            HalconAPI.UnpinTuple(endCol);
            int procResult = HObject.LoadNew(proc, 1, err, out regionLines);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an empty object tuple.</summary>
        /// <param name="emptyObject">No objects.</param>
        public static void GenEmptyObj(out HObject emptyObject)
        {
            IntPtr proc = HalconAPI.PreCall(617);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out emptyObject);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an empty region.</summary>
        /// <param name="emptyRegion">Empty region (no pixels).</param>
        public static void GenEmptyRegion(out HObject emptyRegion)
        {
            IntPtr proc = HalconAPI.PreCall(618);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out emptyRegion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a gray value ramp.</summary>
        /// <param name="imageGrayRamp">Created image with new image matrix.</param>
        /// <param name="alpha">Gradient in line direction. Default: 1.0</param>
        /// <param name="beta">Gradient in column direction. Default: 1.0</param>
        /// <param name="mean">Mean gray value. Default: 128</param>
        /// <param name="row">Line index of reference point. Default: 256</param>
        /// <param name="column">Column index of reference point. Default: 256</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        public static void GenImageGrayRamp(
          out HObject imageGrayRamp,
          HTuple alpha,
          HTuple beta,
          HTuple mean,
          HTuple row,
          HTuple column,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(619);
            HalconAPI.Store(proc, 0, alpha);
            HalconAPI.Store(proc, 1, beta);
            HalconAPI.Store(proc, 2, mean);
            HalconAPI.Store(proc, 3, row);
            HalconAPI.Store(proc, 4, column);
            HalconAPI.Store(proc, 5, width);
            HalconAPI.Store(proc, 6, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.UnpinTuple(beta);
            HalconAPI.UnpinTuple(mean);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageGrayRamp);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a three-channel image from three pointers on the pixels with storage management.</summary>
        /// <param name="image">Created HALCON image.</param>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        /// <param name="pointerRed">Pointer to the first gray value of the first channel.</param>
        /// <param name="pointerGreen">Pointer to the first gray value of the second channel.</param>
        /// <param name="pointerBlue">Pointer to the first gray value of the third channel.</param>
        /// <param name="clearProc">Pointer to the procedure re-releasing the memory of the image when deleting the object. Default: 0</param>
        public static void GenImage3Extern(
          out HObject image,
          HTuple type,
          HTuple width,
          HTuple height,
          HTuple pointerRed,
          HTuple pointerGreen,
          HTuple pointerBlue,
          HTuple clearProc)
        {
            IntPtr proc = HalconAPI.PreCall(620);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, width);
            HalconAPI.Store(proc, 2, height);
            HalconAPI.Store(proc, 3, pointerRed);
            HalconAPI.Store(proc, 4, pointerGreen);
            HalconAPI.Store(proc, 5, pointerBlue);
            HalconAPI.Store(proc, 6, clearProc);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(pointerRed);
            HalconAPI.UnpinTuple(pointerGreen);
            HalconAPI.UnpinTuple(pointerBlue);
            HalconAPI.UnpinTuple(clearProc);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an image from a pointer on the pixels with storage management.</summary>
        /// <param name="image">Created HALCON image.</param>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        /// <param name="pixelPointer">Pointer to the first gray value.</param>
        /// <param name="clearProc">Pointer to the procedure re-releasing the memory of the image when deleting the object. Default: 0</param>
        public static void GenImage1Extern(
          out HObject image,
          HTuple type,
          HTuple width,
          HTuple height,
          HTuple pixelPointer,
          HTuple clearProc)
        {
            IntPtr proc = HalconAPI.PreCall(621);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, width);
            HalconAPI.Store(proc, 2, height);
            HalconAPI.Store(proc, 3, pixelPointer);
            HalconAPI.Store(proc, 4, clearProc);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(pixelPointer);
            HalconAPI.UnpinTuple(clearProc);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an image with a rectangular domain from a pointer on the pixels (with storage management).</summary>
        /// <param name="image">Created HALCON image.</param>
        /// <param name="pixelPointer">Pointer to the first pixel.</param>
        /// <param name="width">Width of the image. Default: 512</param>
        /// <param name="height">Height of the image. Default: 512</param>
        /// <param name="verticalPitch">Distance (in bytes) between pixel m in row n and pixel m in row n+1 of the 'input image'.</param>
        /// <param name="horizontalBitPitch">Distance between two neighboring pixels in bits . Default: 8</param>
        /// <param name="bitsPerPixel">Number of used bits per pixel. Default: 8</param>
        /// <param name="doCopy">Copy image data. Default: "false"</param>
        /// <param name="clearProc">Pointer to the procedure releasing the memory of the image when deleting the object. Default: 0</param>
        public static void GenImage1Rect(
          out HObject image,
          HTuple pixelPointer,
          HTuple width,
          HTuple height,
          HTuple verticalPitch,
          HTuple horizontalBitPitch,
          HTuple bitsPerPixel,
          HTuple doCopy,
          HTuple clearProc)
        {
            IntPtr proc = HalconAPI.PreCall(622);
            HalconAPI.Store(proc, 0, pixelPointer);
            HalconAPI.Store(proc, 1, width);
            HalconAPI.Store(proc, 2, height);
            HalconAPI.Store(proc, 3, verticalPitch);
            HalconAPI.Store(proc, 4, horizontalBitPitch);
            HalconAPI.Store(proc, 5, bitsPerPixel);
            HalconAPI.Store(proc, 6, doCopy);
            HalconAPI.Store(proc, 7, clearProc);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pixelPointer);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(verticalPitch);
            HalconAPI.UnpinTuple(horizontalBitPitch);
            HalconAPI.UnpinTuple(bitsPerPixel);
            HalconAPI.UnpinTuple(doCopy);
            HalconAPI.UnpinTuple(clearProc);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Access to the image data pointer and the image data inside the smallest rectangle of the domain of the input image.</summary>
        /// <param name="image">Input image (Himage).</param>
        /// <param name="pixelPointer">Pointer to the image data.</param>
        /// <param name="width">Width of the output image.</param>
        /// <param name="height">Height of the output image.</param>
        /// <param name="verticalPitch">Width(input image)*(HorizontalBitPitch/8).</param>
        /// <param name="horizontalBitPitch">Distance between two neighboring pixels in bits .</param>
        /// <param name="bitsPerPixel">Number of used bits per pixel.</param>
        public static void GetImagePointer1Rect(
          HObject image,
          out HTuple pixelPointer,
          out HTuple width,
          out HTuple height,
          out HTuple verticalPitch,
          out HTuple horizontalBitPitch,
          out HTuple bitsPerPixel)
        {
            IntPtr proc = HalconAPI.PreCall(623);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out pixelPointer);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out width);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out height);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out verticalPitch);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out horizontalBitPitch);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out bitsPerPixel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Access the pointers of a colored image.</summary>
        /// <param name="imageRGB">Input image.</param>
        /// <param name="pointerRed">Pointer to the pixels of the first channel.</param>
        /// <param name="pointerGreen">Pointer to the pixels of the second channel.</param>
        /// <param name="pointerBlue">Pointer to the pixels of the third channel.</param>
        /// <param name="type">Type of image.</param>
        /// <param name="width">Width of image.</param>
        /// <param name="height">Height of image.</param>
        public static void GetImagePointer3(
          HObject imageRGB,
          out HTuple pointerRed,
          out HTuple pointerGreen,
          out HTuple pointerBlue,
          out HTuple type,
          out HTuple width,
          out HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(624);
            HalconAPI.Store(proc, 1, (HObjectBase)imageRGB);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out pointerRed);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out pointerGreen);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out pointerBlue);
            int err5 = HTuple.LoadNew(proc, 3, err4, out type);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out width);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageRGB);
        }

        /// <summary>Access the pointer of a channel.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="pointer">Pointer to the image data in the HALCON database.</param>
        /// <param name="type">Type of image.</param>
        /// <param name="width">Width of image.</param>
        /// <param name="height">Height of image.</param>
        public static void GetImagePointer1(
          HObject image,
          out HTuple pointer,
          out HTuple type,
          out HTuple width,
          out HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(625);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out pointer);
            int err3 = HTuple.LoadNew(proc, 1, err2, out type);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out width);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Return the type of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="type">Type of image.</param>
        public static void GetImageType(HObject image, out HTuple type)
        {
            IntPtr proc = HalconAPI.PreCall(626);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, err, out type);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Return the size of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="width">Width of image.</param>
        /// <param name="height">Height of image.</param>
        public static void GetImageSize(HObject image, out HTuple width, out HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(627);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out width);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Request time at which the image was created.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="MSecond">Milliseconds (0..999).</param>
        /// <param name="second">Seconds (0..59).</param>
        /// <param name="minute">Minutes (0..59).</param>
        /// <param name="hour">Hours (0..23).</param>
        /// <param name="day">Day of the month (1..31).</param>
        /// <param name="YDay">Day of the year (1..366).</param>
        /// <param name="month">Month (1..12).</param>
        /// <param name="year">Year (xxxx).</param>
        public static void GetImageTime(
          HObject image,
          out HTuple MSecond,
          out HTuple second,
          out HTuple minute,
          out HTuple hour,
          out HTuple day,
          out HTuple YDay,
          out HTuple month,
          out HTuple year)
        {
            IntPtr proc = HalconAPI.PreCall(628);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out MSecond);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out second);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out minute);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out hour);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out day);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out YDay);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.INTEGER, err7, out month);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.INTEGER, err8, out year);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Return gray values of an image at the positions given by tuples of rows and columns.</summary>
        /// <param name="image">Image whose gray values are to be accessed.</param>
        /// <param name="row">Row coordinates of positions. Default: 0</param>
        /// <param name="column">Column coordinates of positions. Default: 0</param>
        /// <param name="interpolation">Interpolation method. Default: "bilinear"</param>
        /// <param name="grayval">Gray values of the selected image coordinates.</param>
        public static void GetGrayvalInterpolated(
          HObject image,
          HTuple row,
          HTuple column,
          HTuple interpolation,
          out HTuple grayval)
        {
            IntPtr proc = HalconAPI.PreCall(629);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, interpolation);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out grayval);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Access the gray values of an image object.</summary>
        /// <param name="image">Image whose gray value is to be accessed.</param>
        /// <param name="row">Row coordinates of pixels to be viewed. Default: 0</param>
        /// <param name="column">Column coordinates of pixels to be viewed. Default: 0</param>
        /// <param name="grayval">Gray values of indicated pixels.</param>
        public static void GetGrayval(HObject image, HTuple row, HTuple column, out HTuple grayval)
        {
            IntPtr proc = HalconAPI.PreCall(630);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HTuple.LoadNew(proc, 0, err, out grayval);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Access the thickness of a region along the main axis.</summary>
        /// <param name="region">Region to be analysed.</param>
        /// <param name="thickness">Thickness of the region along its main axis.</param>
        /// <param name="histogramm">Histogram of the thickness of the region along its main axis.</param>
        public static void GetRegionThickness(
          HObject region,
          out HTuple thickness,
          out HTuple histogramm)
        {
            IntPtr proc = HalconAPI.PreCall(631);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out thickness);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out histogramm);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Polygon approximation of a region.</summary>
        /// <param name="region">Region to be approximated.</param>
        /// <param name="tolerance">Maximum distance between the polygon and the edge of the region. Default: 5.0</param>
        /// <param name="rows">Line numbers of the base points of the contour.</param>
        /// <param name="columns">Column numbers of the base points of the contour.</param>
        public static void GetRegionPolygon(
          HObject region,
          HTuple tolerance,
          out HTuple rows,
          out HTuple columns)
        {
            IntPtr proc = HalconAPI.PreCall(632);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, tolerance);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tolerance);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out rows);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out columns);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Access the pixels of a region.</summary>
        /// <param name="region">This region is accessed.</param>
        /// <param name="rows">Line numbers of the pixels in the region</param>
        /// <param name="columns">Column numbers of the pixels in the region.</param>
        public static void GetRegionPoints(HObject region, out HTuple rows, out HTuple columns)
        {
            IntPtr proc = HalconAPI.PreCall(633);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out rows);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out columns);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Access the contour of an object.</summary>
        /// <param name="region">Output region.</param>
        /// <param name="rows">Line numbers of the contour pixels.</param>
        /// <param name="columns">Column numbers of the contour pixels.</param>
        public static void GetRegionContour(HObject region, out HTuple rows, out HTuple columns)
        {
            IntPtr proc = HalconAPI.PreCall(634);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out rows);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out columns);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Access the runlength coding of a region.</summary>
        /// <param name="region">Output region.</param>
        /// <param name="row">Line numbers of the chords.</param>
        /// <param name="columnBegin">Column numbers of the starting points of the chords.</param>
        /// <param name="columnEnd">Column numbers of the ending points of the chords.</param>
        public static void GetRegionRuns(
          HObject region,
          out HTuple row,
          out HTuple columnBegin,
          out HTuple columnEnd)
        {
            IntPtr proc = HalconAPI.PreCall(635);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out columnBegin);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out columnEnd);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Contour of an object as chain code.</summary>
        /// <param name="region">Region to be transformed.</param>
        /// <param name="row">Line of starting point.</param>
        /// <param name="column">Column of starting point.</param>
        /// <param name="chain">Direction code of the contour (from starting point).</param>
        public static void GetRegionChain(
          HObject region,
          out HTuple row,
          out HTuple column,
          out HTuple chain)
        {
            IntPtr proc = HalconAPI.PreCall(636);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out chain);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Access convex hull as contour.</summary>
        /// <param name="region">Output region.</param>
        /// <param name="rows">Line numbers of contour pixels.</param>
        /// <param name="columns">Column numbers of the contour pixels.</param>
        public static void GetRegionConvex(HObject region, out HTuple rows, out HTuple columns)
        {
            IntPtr proc = HalconAPI.PreCall(637);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out rows);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out columns);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Verification of a pattern using an OCV tool.</summary>
        /// <param name="pattern">Characters to be verified.</param>
        /// <param name="OCVHandle">Handle of the OCV tool.</param>
        /// <param name="patternName">Name of the character. Default: "a"</param>
        /// <param name="adaptPos">Adaption to vertical and horizontal translation. Default: "true"</param>
        /// <param name="adaptSize">Adaption to vertical and horizontal scaling of the size. Default: "true"</param>
        /// <param name="adaptAngle">Adaption to changes of the orientation (not implemented). Default: "false"</param>
        /// <param name="adaptGray">Adaption to additive and scaling gray value changes. Default: "true"</param>
        /// <param name="threshold">Minimum difference between objects. Default: 10</param>
        /// <param name="quality">Evaluation of the character.</param>
        public static void DoOcvSimple(
          HObject pattern,
          HTuple OCVHandle,
          HTuple patternName,
          HTuple adaptPos,
          HTuple adaptSize,
          HTuple adaptAngle,
          HTuple adaptGray,
          HTuple threshold,
          out HTuple quality)
        {
            IntPtr proc = HalconAPI.PreCall(638);
            HalconAPI.Store(proc, 1, (HObjectBase)pattern);
            HalconAPI.Store(proc, 0, OCVHandle);
            HalconAPI.Store(proc, 1, patternName);
            HalconAPI.Store(proc, 2, adaptPos);
            HalconAPI.Store(proc, 3, adaptSize);
            HalconAPI.Store(proc, 4, adaptAngle);
            HalconAPI.Store(proc, 5, adaptGray);
            HalconAPI.Store(proc, 6, threshold);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCVHandle);
            HalconAPI.UnpinTuple(patternName);
            HalconAPI.UnpinTuple(adaptPos);
            HalconAPI.UnpinTuple(adaptSize);
            HalconAPI.UnpinTuple(adaptAngle);
            HalconAPI.UnpinTuple(adaptGray);
            HalconAPI.UnpinTuple(threshold);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out quality);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)pattern);
        }

        /// <summary>Training of an OCV tool.</summary>
        /// <param name="pattern">Pattern to be trained.</param>
        /// <param name="OCVHandle">Handle of the OCV tool to be trained.</param>
        /// <param name="name">Name(s) of the object(s) to analyse. Default: "a"</param>
        /// <param name="mode">Mode for training (only one mode implemented). Default: "single"</param>
        public static void TraindOcvProj(HObject pattern, HTuple OCVHandle, HTuple name, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(639);
            HalconAPI.Store(proc, 1, (HObjectBase)pattern);
            HalconAPI.Store(proc, 0, OCVHandle);
            HalconAPI.Store(proc, 1, name);
            HalconAPI.Store(proc, 2, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCVHandle);
            HalconAPI.UnpinTuple(name);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)pattern);
        }

        /// <summary>Deserialize a serialized OCV tool.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="OCVHandle">Handle of the OCV tool.</param>
        public static void DeserializeOcv(HTuple serializedItemHandle, out HTuple OCVHandle)
        {
            IntPtr proc = HalconAPI.PreCall(640);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCVHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize an OCV tool.</summary>
        /// <param name="OCVHandle">Handle of the OCV tool.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeOcv(HTuple OCVHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(641);
            HalconAPI.Store(proc, 0, OCVHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCVHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Reading an OCV tool from file.</summary>
        /// <param name="fileName">Name of the file which has to be read. Default: "test_ocv"</param>
        /// <param name="OCVHandle">Handle of read OCV tool.</param>
        public static void ReadOcv(HTuple fileName, out HTuple OCVHandle)
        {
            IntPtr proc = HalconAPI.PreCall(642);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCVHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Saving an OCV tool to file.</summary>
        /// <param name="OCVHandle">Handle of the OCV tool to be written.</param>
        /// <param name="fileName">Name of the file where the tool has to be saved. Default: "test_ocv"</param>
        public static void WriteOcv(HTuple OCVHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(643);
            HalconAPI.Store(proc, 0, OCVHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCVHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all OCV tools.</summary>
        public static void CloseAllOcvs()
        {
            IntPtr proc = HalconAPI.PreCall(644);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear an OCV tool.</summary>
        /// <param name="OCVHandle">Handle of the OCV tool which has to be freed.</param>
        public static void CloseOcv(HTuple OCVHandle)
        {
            IntPtr proc = HalconAPI.PreCall(645);
            HalconAPI.Store(proc, 0, OCVHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCVHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a new OCV tool based on gray value projections.</summary>
        /// <param name="patternNames">List of names for patterns to be trained. Default: "a"</param>
        /// <param name="OCVHandle">Handle of the created OCV tool.</param>
        public static void CreateOcvProj(HTuple patternNames, out HTuple OCVHandle)
        {
            IntPtr proc = HalconAPI.PreCall(646);
            HalconAPI.Store(proc, 0, patternNames);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(patternNames);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCVHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Classify a related group of characters with an OCR classifier.</summary>
        /// <param name="character">Characters to be recognized.</param>
        /// <param name="image">Gray values of the characters.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="expression">Expression describing the allowed word structure.</param>
        /// <param name="numAlternatives">Number of classes per character considered for the internal word correction. Default: 3</param>
        /// <param name="numCorrections">Maximum number of corrected characters. Default: 2</param>
        /// <param name="classVal">Result of classifying the characters with the k-NN.</param>
        /// <param name="confidence">Confidence of the class of the characters.</param>
        /// <param name="word">Word text after classification and correction.</param>
        /// <param name="score">Measure of similarity between corrected word and uncorrected classification results.</param>
        public static void DoOcrWordKnn(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          HTuple expression,
          HTuple numAlternatives,
          HTuple numCorrections,
          out HTuple classVal,
          out HTuple confidence,
          out HTuple word,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(647);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, expression);
            HalconAPI.Store(proc, 2, numAlternatives);
            HalconAPI.Store(proc, 3, numCorrections);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(expression);
            HalconAPI.UnpinTuple(numAlternatives);
            HalconAPI.UnpinTuple(numCorrections);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classVal);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidence);
            int err4 = HTuple.LoadNew(proc, 2, err3, out word);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Deserialize a serialized k-NN-based OCR classifier.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void DeserializeOcrClassKnn(HTuple serializedItemHandle, out HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(648);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a k-NN-based OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeOcrClassKnn(HTuple OCRHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(649);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read an OCR classifier from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void ReadOcrClassKnn(HTuple fileName, out HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(650);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a k-NN classifier for an OCR task to a file.</summary>
        /// <param name="OCRHandle">Handle of the k-NN classifier for an OCR task.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteOcrClassKnn(HTuple OCRHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(651);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all OCR classifiers.</summary>
        public static void ClearAllOcrClassKnn()
        {
            IntPtr proc = HalconAPI.PreCall(652);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void ClearOcrClassKnn(HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(653);
            HalconAPI.Store(proc, 0, OCRHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an OCR classifier using a k-Nearest Neighbor (k-NN) classifier.</summary>
        /// <param name="widthCharacter">Width of the rectangle to which the gray values of the segmented character are zoomed. Default: 8</param>
        /// <param name="heightCharacter">Height of the rectangle to which the gray values of the segmented character are zoomed. Default: 10</param>
        /// <param name="interpolation">Interpolation mode for the zooming of the characters. Default: "constant"</param>
        /// <param name="features">Features to be used for classification. Default: "default"</param>
        /// <param name="characters">All characters of the character set to be read. Default: ["0","1","2","3","4","5","6","7","8","9"]</param>
        /// <param name="genParamName">This parameter is not yet supported. Default: []</param>
        /// <param name="genParamValue">This parameter is not yet supported. Default: []</param>
        /// <param name="OCRHandle">Handle of the k-NN classifier.</param>
        public static void CreateOcrClassKnn(
          HTuple widthCharacter,
          HTuple heightCharacter,
          HTuple interpolation,
          HTuple features,
          HTuple characters,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(654);
            HalconAPI.Store(proc, 0, widthCharacter);
            HalconAPI.Store(proc, 1, heightCharacter);
            HalconAPI.Store(proc, 2, interpolation);
            HalconAPI.Store(proc, 3, features);
            HalconAPI.Store(proc, 4, characters);
            HalconAPI.Store(proc, 5, genParamName);
            HalconAPI.Store(proc, 6, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(widthCharacter);
            HalconAPI.UnpinTuple(heightCharacter);
            HalconAPI.UnpinTuple(interpolation);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(characters);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Trains an k-NN classifier for an OCR task.</summary>
        /// <param name="OCRHandle">Handle of the k-NN classifier.</param>
        /// <param name="trainingFile">Names of the training files. Default: "ocr.trf"</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the k-NN classifier creation. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the k-NN classifier creation. Default: []</param>
        public static void TrainfOcrClassKnn(
          HTuple OCRHandle,
          HTuple trainingFile,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(655);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, trainingFile);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the features of a character.</summary>
        /// <param name="character">Input character.</param>
        /// <param name="OCRHandle">Handle of the k-NN classifier.</param>
        /// <param name="transform">Should the feature vector be transformed with the preprocessing? Default: "true"</param>
        /// <param name="features">Feature vector of the character.</param>
        public static void GetFeaturesOcrClassKnn(
          HObject character,
          HTuple OCRHandle,
          HTuple transform,
          out HTuple features)
        {
            IntPtr proc = HalconAPI.PreCall(656);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, transform);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(transform);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out features);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
        }

        /// <summary>Return the parameters of an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="widthCharacter">Width of the rectangle to which the gray values of the segmented character are zoomed.</param>
        /// <param name="heightCharacter">Height of the rectangle to which the gray values of the segmented character are zoomed.</param>
        /// <param name="interpolation">Interpolation mode for the zooming of the characters.</param>
        /// <param name="features">Features to be used for classification.</param>
        /// <param name="characters">Characters of the character set to be read.</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors.</param>
        /// <param name="numTrees">Number of different trees used during the classifcation.</param>
        public static void GetParamsOcrClassKnn(
          HTuple OCRHandle,
          out HTuple widthCharacter,
          out HTuple heightCharacter,
          out HTuple interpolation,
          out HTuple features,
          out HTuple characters,
          out HTuple preprocessing,
          out HTuple numTrees)
        {
            IntPtr proc = HalconAPI.PreCall(657);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out widthCharacter);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out heightCharacter);
            int err4 = HTuple.LoadNew(proc, 2, err3, out interpolation);
            int err5 = HTuple.LoadNew(proc, 3, err4, out features);
            int err6 = HTuple.LoadNew(proc, 4, err5, out characters);
            int err7 = HTuple.LoadNew(proc, 5, err6, out preprocessing);
            int procResult = HTuple.LoadNew(proc, 6, HTupleType.INTEGER, err7, out numTrees);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Classify multiple characters with an k-NN classifier.</summary>
        /// <param name="character">Characters to be recognized.</param>
        /// <param name="image">Gray values of the characters.</param>
        /// <param name="OCRHandle">Handle of the k-NN classifier.</param>
        /// <param name="classVal">Result of classifying the characters with the k-NN.</param>
        /// <param name="confidence">Confidence of the class of the characters.</param>
        public static void DoOcrMultiClassKnn(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          out HTuple classVal,
          out HTuple confidence)
        {
            IntPtr proc = HalconAPI.PreCall(658);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classVal);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Classify a single character with an OCR classifier.</summary>
        /// <param name="character">Character to be recognized.</param>
        /// <param name="image">Gray values of the character.</param>
        /// <param name="OCRHandle">Handle of the k-NN classifier.</param>
        /// <param name="numClasses">Number of maximal classes to determine. Default: 1</param>
        /// <param name="numNeighbors">Number of neighbors to consider. Default: 1</param>
        /// <param name="classVal">Results of classifying the character with the k-NN.</param>
        /// <param name="confidence">Confidence(s) of the class(es) of the character.</param>
        public static void DoOcrSingleClassKnn(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          HTuple numClasses,
          HTuple numNeighbors,
          out HTuple classVal,
          out HTuple confidence)
        {
            IntPtr proc = HalconAPI.PreCall(659);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, numClasses);
            HalconAPI.Store(proc, 2, numNeighbors);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(numClasses);
            HalconAPI.UnpinTuple(numNeighbors);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classVal);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Select an optimal combination of features to classify OCR data.</summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="featureList">List of features that should be considered for selection. Default: ["zoom_factor","ratio","width","height","foreground","foreground_grid_9","foreground_grid_16","anisometry","compactness","convexity","moments_region_2nd_invar","moments_region_2nd_rel_invar","moments_region_3rd_invar","moments_central","phi","num_connect","num_holes","projection_horizontal","projection_vertical","projection_horizontal_invar","projection_vertical_invar","chord_histo","num_runs","pixel","pixel_invar","pixel_binary","gradient_8dir","cooc","moments_gray_plane"]</param>
        /// <param name="selectionMethod">Method to perform the selection. Default: "greedy"</param>
        /// <param name="width">Width of the rectangle to which the gray values of the segmented character are zoomed. Default: 15</param>
        /// <param name="height">Height of the rectangle to which the gray values of the segmented character are zoomed. Default: 16</param>
        /// <param name="genParamName">Names of generic parameters to configure the selection process and the classifier. Default: []</param>
        /// <param name="genParamValue">Values of generic parameters to configure the selection process and the classifier. Default: []</param>
        /// <param name="OCRHandle">Trained OCR-k-NN classifier.</param>
        /// <param name="featureSet">Selected feature set, contains only entries from FeatureList.</param>
        /// <param name="score">Achieved score using tow-fold cross-validation.</param>
        public static void SelectFeatureSetTrainfKnn(
          HTuple trainingFile,
          HTuple featureList,
          HTuple selectionMethod,
          HTuple width,
          HTuple height,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple OCRHandle,
          out HTuple featureSet,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(660);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.Store(proc, 1, featureList);
            HalconAPI.Store(proc, 2, selectionMethod);
            HalconAPI.Store(proc, 3, width);
            HalconAPI.Store(proc, 4, height);
            HalconAPI.Store(proc, 5, genParamName);
            HalconAPI.Store(proc, 6, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(featureList);
            HalconAPI.UnpinTuple(selectionMethod);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out OCRHandle);
            int err3 = HTuple.LoadNew(proc, 1, err2, out featureSet);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select an optimal combination of features to classify OCR data from a (protected) training file.</summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="password">Passwords for protected training files.</param>
        /// <param name="featureList">List of features that should be considered for selection. Default: ["zoom_factor","ratio","width","height","foreground","foreground_grid_9","foreground_grid_16","anisometry","compactness","convexity","moments_region_2nd_invar","moments_region_2nd_rel_invar","moments_region_3rd_invar","moments_central","phi","num_connect","num_holes","projection_horizontal","projection_vertical","projection_horizontal_invar","projection_vertical_invar","chord_histo","num_runs","pixel","pixel_invar","pixel_binary","gradient_8dir","cooc","moments_gray_plane"]</param>
        /// <param name="selectionMethod">Method to perform the selection. Default: "greedy"</param>
        /// <param name="width">Width of the rectangle to which the gray values of the segmented character are zoomed. Default: 15</param>
        /// <param name="height">Height of the rectangle to which the gray values of the segmented character are zoomed. Default: 16</param>
        /// <param name="genParamName">Names of generic parameters to configure the selection process and the classifier. Default: []</param>
        /// <param name="genParamValue">Values of generic parameters to configure the selection process and the classifier. Default: []</param>
        /// <param name="OCRHandle">Trained OCR-MLP classifier.</param>
        /// <param name="featureSet">Selected feature set, contains only entries from FeatureList.</param>
        /// <param name="score">Achieved score using tow-fold cross-validation.</param>
        public static void SelectFeatureSetTrainfMlpProtected(
          HTuple trainingFile,
          HTuple password,
          HTuple featureList,
          HTuple selectionMethod,
          HTuple width,
          HTuple height,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple OCRHandle,
          out HTuple featureSet,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(661);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.Store(proc, 1, password);
            HalconAPI.Store(proc, 2, featureList);
            HalconAPI.Store(proc, 3, selectionMethod);
            HalconAPI.Store(proc, 4, width);
            HalconAPI.Store(proc, 5, height);
            HalconAPI.Store(proc, 6, genParamName);
            HalconAPI.Store(proc, 7, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(password);
            HalconAPI.UnpinTuple(featureList);
            HalconAPI.UnpinTuple(selectionMethod);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out OCRHandle);
            int err3 = HTuple.LoadNew(proc, 1, err2, out featureSet);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Selects an optimal combination of features to classify OCR data.</summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="featureList">List of features that should be considered for selection. Default: ["zoom_factor","ratio","width","height","foreground","foreground_grid_9","foreground_grid_16","anisometry","compactness","convexity","moments_region_2nd_invar","moments_region_2nd_rel_invar","moments_region_3rd_invar","moments_central","phi","num_connect","num_holes","projection_horizontal","projection_vertical","projection_horizontal_invar","projection_vertical_invar","chord_histo","num_runs","pixel","pixel_invar","pixel_binary","gradient_8dir","cooc","moments_gray_plane"]</param>
        /// <param name="selectionMethod">Method to perform the selection. Default: "greedy"</param>
        /// <param name="width">Width of the rectangle to which the gray values of the segmented character are zoomed. Default: 15</param>
        /// <param name="height">Height of the rectangle to which the gray values of the segmented character are zoomed. Default: 16</param>
        /// <param name="genParamName">Names of generic parameters to configure the selection process and the classifier. Default: []</param>
        /// <param name="genParamValue">Values of generic parameters to configure the selection process and the classifier. Default: []</param>
        /// <param name="OCRHandle">Trained OCR-MLP classifier.</param>
        /// <param name="featureSet">Selected feature set, contains only entries from FeatureList.</param>
        /// <param name="score">Achieved score using tow-fold cross-validation.</param>
        public static void SelectFeatureSetTrainfMlp(
          HTuple trainingFile,
          HTuple featureList,
          HTuple selectionMethod,
          HTuple width,
          HTuple height,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple OCRHandle,
          out HTuple featureSet,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(662);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.Store(proc, 1, featureList);
            HalconAPI.Store(proc, 2, selectionMethod);
            HalconAPI.Store(proc, 3, width);
            HalconAPI.Store(proc, 4, height);
            HalconAPI.Store(proc, 5, genParamName);
            HalconAPI.Store(proc, 6, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(featureList);
            HalconAPI.UnpinTuple(selectionMethod);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out OCRHandle);
            int err3 = HTuple.LoadNew(proc, 1, err2, out featureSet);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select an optimal combination of features to classify OCR data from a (protected) training file.</summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="password">Passwords for protected training files.</param>
        /// <param name="featureList">List of features that should be considered for selection. Default: ["zoom_factor","ratio","width","height","foreground","foreground_grid_9","foreground_grid_16","anisometry","compactness","convexity","moments_region_2nd_invar","moments_region_2nd_rel_invar","moments_region_3rd_invar","moments_central","phi","num_connect","num_holes","projection_horizontal","projection_vertical","projection_horizontal_invar","projection_vertical_invar","chord_histo","num_runs","pixel","pixel_invar","pixel_binary","gradient_8dir","cooc","moments_gray_plane"]</param>
        /// <param name="selectionMethod">Method to perform the selection. Default: "greedy"</param>
        /// <param name="width">Width of the rectangle to which the gray values of the segmented character are zoomed. Default: 15</param>
        /// <param name="height">Height of the rectangle to which the gray values of the segmented character are zoomed. Default: 16</param>
        /// <param name="genParamName">Names of generic parameters to configure the selection process and the classifier. Default: []</param>
        /// <param name="genParamValue">Values of generic parameters to configure the selection process and the classifier. Default: []</param>
        /// <param name="OCRHandle">Trained OCR-SVM Classifier.</param>
        /// <param name="featureSet">Selected feature set, contains only entries from FeatureList.</param>
        /// <param name="score">Achieved score using tow-fold cross-validation.</param>
        public static void SelectFeatureSetTrainfSvmProtected(
          HTuple trainingFile,
          HTuple password,
          HTuple featureList,
          HTuple selectionMethod,
          HTuple width,
          HTuple height,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple OCRHandle,
          out HTuple featureSet,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(663);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.Store(proc, 1, password);
            HalconAPI.Store(proc, 2, featureList);
            HalconAPI.Store(proc, 3, selectionMethod);
            HalconAPI.Store(proc, 4, width);
            HalconAPI.Store(proc, 5, height);
            HalconAPI.Store(proc, 6, genParamName);
            HalconAPI.Store(proc, 7, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(password);
            HalconAPI.UnpinTuple(featureList);
            HalconAPI.UnpinTuple(selectionMethod);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out OCRHandle);
            int err3 = HTuple.LoadNew(proc, 1, err2, out featureSet);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Selects an optimal combination of features to classify OCR  data.</summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="featureList">List of features that should be considered for selection. Default: ["zoom_factor","ratio","width","height","foreground","foreground_grid_9","foreground_grid_16","anisometry","compactness","convexity","moments_region_2nd_invar","moments_region_2nd_rel_invar","moments_region_3rd_invar","moments_central","phi","num_connect","num_holes","projection_horizontal","projection_vertical","projection_horizontal_invar","projection_vertical_invar","chord_histo","num_runs","pixel","pixel_invar","pixel_binary","gradient_8dir","cooc","moments_gray_plane"]</param>
        /// <param name="selectionMethod">Method to perform the selection. Default: "greedy"</param>
        /// <param name="width">Width of the rectangle to which the gray values of the segmented character are zoomed. Default: 15</param>
        /// <param name="height">Height of the rectangle to which the gray values of the segmented character are zoomed. Default: 16</param>
        /// <param name="genParamName">Names of generic parameters to configure the selection process and the classifier. Default: []</param>
        /// <param name="genParamValue">Values of generic parameters to configure the selection process and the classifier. Default: []</param>
        /// <param name="OCRHandle">Trained OCR-SVM Classifier.</param>
        /// <param name="featureSet">Selected feature set, contains only entries from FeatureList.</param>
        /// <param name="score">Achieved score using tow-fold cross-validation.</param>
        public static void SelectFeatureSetTrainfSvm(
          HTuple trainingFile,
          HTuple featureList,
          HTuple selectionMethod,
          HTuple width,
          HTuple height,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple OCRHandle,
          out HTuple featureSet,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(664);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.Store(proc, 1, featureList);
            HalconAPI.Store(proc, 2, selectionMethod);
            HalconAPI.Store(proc, 3, width);
            HalconAPI.Store(proc, 4, height);
            HalconAPI.Store(proc, 5, genParamName);
            HalconAPI.Store(proc, 6, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(featureList);
            HalconAPI.UnpinTuple(selectionMethod);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out OCRHandle);
            int err3 = HTuple.LoadNew(proc, 1, err2, out featureSet);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all lexica.</summary>
        public static void ClearAllLexica()
        {
            IntPtr proc = HalconAPI.PreCall(665);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a lexicon.</summary>
        /// <param name="lexiconHandle">Handle of the lexicon.</param>
        public static void ClearLexicon(HTuple lexiconHandle)
        {
            IntPtr proc = HalconAPI.PreCall(666);
            HalconAPI.Store(proc, 0, lexiconHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(lexiconHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find a similar word in a lexicon.</summary>
        /// <param name="lexiconHandle">Handle of the lexicon.</param>
        /// <param name="word">Word to be looked up. Default: "word"</param>
        /// <param name="suggestion">Most similar word found in the lexicon.</param>
        /// <param name="numCorrections">Difference between the words in edit operations.</param>
        public static void SuggestLexicon(
          HTuple lexiconHandle,
          HTuple word,
          out HTuple suggestion,
          out HTuple numCorrections)
        {
            IntPtr proc = HalconAPI.PreCall(667);
            HalconAPI.Store(proc, 0, lexiconHandle);
            HalconAPI.Store(proc, 1, word);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(lexiconHandle);
            HalconAPI.UnpinTuple(word);
            int err2 = HTuple.LoadNew(proc, 0, err1, out suggestion);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out numCorrections);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Check if a word is contained in a lexicon.</summary>
        /// <param name="lexiconHandle">Handle of the lexicon.</param>
        /// <param name="word">Word to be looked up. Default: "word"</param>
        /// <param name="found">Result of the search.</param>
        public static void LookupLexicon(HTuple lexiconHandle, HTuple word, out HTuple found)
        {
            IntPtr proc = HalconAPI.PreCall(668);
            HalconAPI.Store(proc, 0, lexiconHandle);
            HalconAPI.Store(proc, 1, word);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(lexiconHandle);
            HalconAPI.UnpinTuple(word);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out found);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query all words from a lexicon.</summary>
        /// <param name="lexiconHandle">Handle of the lexicon.</param>
        /// <param name="words">List of all words.</param>
        public static void InspectLexicon(HTuple lexiconHandle, out HTuple words)
        {
            IntPtr proc = HalconAPI.PreCall(669);
            HalconAPI.Store(proc, 0, lexiconHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(lexiconHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out words);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a lexicon from a text file.</summary>
        /// <param name="name">Unique name for the new lexicon. Default: "lex1"</param>
        /// <param name="fileName">Name of a text file containing words for the new lexicon. Default: "words.txt"</param>
        /// <param name="lexiconHandle">Handle of the lexicon.</param>
        public static void ImportLexicon(HTuple name, HTuple fileName, out HTuple lexiconHandle)
        {
            IntPtr proc = HalconAPI.PreCall(670);
            HalconAPI.Store(proc, 0, name);
            HalconAPI.Store(proc, 1, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(name);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out lexiconHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a lexicon from a tuple of words.</summary>
        /// <param name="name">Unique name for the new lexicon. Default: "lex1"</param>
        /// <param name="words">Word list for the new lexicon. Default: ["word1","word2","word3"]</param>
        /// <param name="lexiconHandle">Handle of the lexicon.</param>
        public static void CreateLexicon(HTuple name, HTuple words, out HTuple lexiconHandle)
        {
            IntPtr proc = HalconAPI.PreCall(671);
            HalconAPI.Store(proc, 0, name);
            HalconAPI.Store(proc, 1, words);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(name);
            HalconAPI.UnpinTuple(words);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out lexiconHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all SVM based OCR classifiers.</summary>
        public static void ClearAllOcrClassSvm()
        {
            IntPtr proc = HalconAPI.PreCall(672);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear an SVM-based OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void ClearOcrClassSvm(HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(673);
            HalconAPI.Store(proc, 0, OCRHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized SVM-based OCR classifier.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void DeserializeOcrClassSvm(HTuple serializedItemHandle, out HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(674);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a SVM-based OCR classifier</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeOcrClassSvm(HTuple OCRHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(675);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a SVM-based OCR classifier from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void ReadOcrClassSvm(HTuple fileName, out HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(676);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write an OCR classifier to a file.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteOcrClassSvm(HTuple OCRHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(677);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the features of a character.</summary>
        /// <param name="character">Input character.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="transform">Should the feature vector be transformed with the preprocessing? Default: "true"</param>
        /// <param name="features">Feature vector of the character.</param>
        public static void GetFeaturesOcrClassSvm(
          HObject character,
          HTuple OCRHandle,
          HTuple transform,
          out HTuple features)
        {
            IntPtr proc = HalconAPI.PreCall(678);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, transform);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(transform);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out features);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
        }

        /// <summary>Classify a related group of characters with an OCR classifier.</summary>
        /// <param name="character">Characters to be recognized.</param>
        /// <param name="image">Gray values of the characters.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="expression">Expression describing the allowed word structure.</param>
        /// <param name="numAlternatives">Number of classes per character considered for the internal word correction. Default: 3</param>
        /// <param name="numCorrections">Maximum number of corrected characters. Default: 2</param>
        /// <param name="classVal">Result of classifying the characters with the SVM.</param>
        /// <param name="word">Word text after classification and correction.</param>
        /// <param name="score">Measure of similarity between corrected word and uncorrected classification results.</param>
        public static void DoOcrWordSvm(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          HTuple expression,
          HTuple numAlternatives,
          HTuple numCorrections,
          out HTuple classVal,
          out HTuple word,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(679);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, expression);
            HalconAPI.Store(proc, 2, numAlternatives);
            HalconAPI.Store(proc, 3, numCorrections);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(expression);
            HalconAPI.UnpinTuple(numAlternatives);
            HalconAPI.UnpinTuple(numCorrections);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classVal);
            int err3 = HTuple.LoadNew(proc, 1, err2, out word);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Classify multiple characters with an SVM-based OCR classifier.</summary>
        /// <param name="character">Characters to be recognized.</param>
        /// <param name="image">Gray values of the characters.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="classVal">Result of classifying the characters with the SVM.</param>
        public static void DoOcrMultiClassSvm(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          out HTuple classVal)
        {
            IntPtr proc = HalconAPI.PreCall(680);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out classVal);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Classify a single character with an SVM-based OCR classifier.</summary>
        /// <param name="character">Character to be recognized.</param>
        /// <param name="image">Gray values of the character.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="num">Number of best classes to determine. Default: 1</param>
        /// <param name="classVal">Result of classifying the character with the SVM.</param>
        public static void DoOcrSingleClassSvm(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          HTuple num,
          out HTuple classVal)
        {
            IntPtr proc = HalconAPI.PreCall(681);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, num);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(num);
            int procResult = HTuple.LoadNew(proc, 0, err, out classVal);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Approximate a trained SVM-based OCR classifier by a reduced SVM.</summary>
        /// <param name="OCRHandle">Original handle of SVM-based OCR-classifier.</param>
        /// <param name="method">Type of postprocessing to reduce number of SVs. Default: "bottom_up"</param>
        /// <param name="minRemainingSV">Minimum number of remaining SVs. Default: 2</param>
        /// <param name="maxError">Maximum allowed error of reduction. Default: 0.001</param>
        /// <param name="OCRHandleReduced">SVMHandle of reduced OCR classifier.</param>
        public static void ReduceOcrClassSvm(
          HTuple OCRHandle,
          HTuple method,
          HTuple minRemainingSV,
          HTuple maxError,
          out HTuple OCRHandleReduced)
        {
            IntPtr proc = HalconAPI.PreCall(682);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, method);
            HalconAPI.Store(proc, 2, minRemainingSV);
            HalconAPI.Store(proc, 3, maxError);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(minRemainingSV);
            HalconAPI.UnpinTuple(maxError);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandleReduced);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train an OCR classifier with data from a (protected) training file.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="trainingFile">Names of the training files. Default: "ocr.trf"</param>
        /// <param name="password">Passwords for protected training files.</param>
        /// <param name="epsilon">Stop parameter for training. Default: 0.001</param>
        /// <param name="trainMode">Mode of training. Default: "default"</param>
        public static void TrainfOcrClassSvmProtected(
          HTuple OCRHandle,
          HTuple trainingFile,
          HTuple password,
          HTuple epsilon,
          HTuple trainMode)
        {
            IntPtr proc = HalconAPI.PreCall(683);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, trainingFile);
            HalconAPI.Store(proc, 2, password);
            HalconAPI.Store(proc, 3, epsilon);
            HalconAPI.Store(proc, 4, trainMode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(password);
            HalconAPI.UnpinTuple(epsilon);
            HalconAPI.UnpinTuple(trainMode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="trainingFile">Names of the training files. Default: "ocr.trf"</param>
        /// <param name="epsilon">Stop parameter for training. Default: 0.001</param>
        /// <param name="trainMode">Mode of training. Default: "default"</param>
        public static void TrainfOcrClassSvm(
          HTuple OCRHandle,
          HTuple trainingFile,
          HTuple epsilon,
          HTuple trainMode)
        {
            IntPtr proc = HalconAPI.PreCall(684);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, trainingFile);
            HalconAPI.Store(proc, 2, epsilon);
            HalconAPI.Store(proc, 3, trainMode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(epsilon);
            HalconAPI.UnpinTuple(trainMode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the information content of the preprocessed feature vectors of an SVM-based OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="trainingFile">Names of the training files. Default: "ocr.trf"</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors. Default: "principal_components"</param>
        /// <param name="informationCont">Relative information content of the transformed feature vectors.</param>
        /// <param name="cumInformationCont">Cumulative information content of the transformed feature vectors.</param>
        public static void GetPrepInfoOcrClassSvm(
          HTuple OCRHandle,
          HTuple trainingFile,
          HTuple preprocessing,
          out HTuple informationCont,
          out HTuple cumInformationCont)
        {
            IntPtr proc = HalconAPI.PreCall(685);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, trainingFile);
            HalconAPI.Store(proc, 2, preprocessing);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(preprocessing);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out informationCont);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out cumInformationCont);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the number of support vectors of an OCR classifier.</summary>
        /// <param name="OCRHandle">OCR handle.</param>
        /// <param name="numSupportVectors">Total number of support vectors.</param>
        /// <param name="numSVPerSVM">Number of SV of each sub-SVM.</param>
        public static void GetSupportVectorNumOcrClassSvm(
          HTuple OCRHandle,
          out HTuple numSupportVectors,
          out HTuple numSVPerSVM)
        {
            IntPtr proc = HalconAPI.PreCall(686);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out numSupportVectors);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out numSVPerSVM);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the index of a support vector from a trained OCR classifier that is based on support vector machines.</summary>
        /// <param name="OCRHandle">OCR handle.</param>
        /// <param name="indexSupportVector">Number of stored support vectors.</param>
        /// <param name="index">Index of the support vector in the training set.</param>
        public static void GetSupportVectorOcrClassSvm(
          HTuple OCRHandle,
          HTuple indexSupportVector,
          out HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(687);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, indexSupportVector);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(indexSupportVector);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters of an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="widthCharacter">Width of the rectangle to which the gray values of the segmented character are zoomed.</param>
        /// <param name="heightCharacter">Height of the rectangle to which the gray values of the segmented character are zoomed.</param>
        /// <param name="interpolation">Interpolation mode for the zooming of the characters.</param>
        /// <param name="features">Features to be used for classification.</param>
        /// <param name="characters">Characters of the character set to be read.</param>
        /// <param name="kernelType">The kernel type.</param>
        /// <param name="kernelParam">Additional parameters for the kernel function.</param>
        /// <param name="nu">Regularization constant of the SVM.</param>
        /// <param name="mode">The mode of the SVM.</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors.</param>
        /// <param name="numComponents">Preprocessing parameter: Number of transformed features (ignored for Preprocessing $=$ 'none' and Preprocessing $=$ 'normalization').</param>
        public static void GetParamsOcrClassSvm(
          HTuple OCRHandle,
          out HTuple widthCharacter,
          out HTuple heightCharacter,
          out HTuple interpolation,
          out HTuple features,
          out HTuple characters,
          out HTuple kernelType,
          out HTuple kernelParam,
          out HTuple nu,
          out HTuple mode,
          out HTuple preprocessing,
          out HTuple numComponents)
        {
            IntPtr proc = HalconAPI.PreCall(688);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            HalconAPI.InitOCT(proc, 10);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out widthCharacter);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out heightCharacter);
            int err4 = HTuple.LoadNew(proc, 2, err3, out interpolation);
            int err5 = HTuple.LoadNew(proc, 3, err4, out features);
            int err6 = HTuple.LoadNew(proc, 4, err5, out characters);
            int err7 = HTuple.LoadNew(proc, 5, err6, out kernelType);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out kernelParam);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out nu);
            int err10 = HTuple.LoadNew(proc, 8, err9, out mode);
            int err11 = HTuple.LoadNew(proc, 9, err10, out preprocessing);
            int procResult = HTuple.LoadNew(proc, 10, HTupleType.INTEGER, err11, out numComponents);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an OCR classifier using a support vector machine.</summary>
        /// <param name="widthCharacter">Width of the rectangle to which the gray values of the segmented character are zoomed. Default: 8</param>
        /// <param name="heightCharacter">Height of the rectangle to which the gray values of the segmented character are zoomed. Default: 10</param>
        /// <param name="interpolation">Interpolation mode for the zooming of the characters. Default: "constant"</param>
        /// <param name="features">Features to be used for classification. Default: "default"</param>
        /// <param name="characters">All characters of the character set to be read. Default: ["0","1","2","3","4","5","6","7","8","9"]</param>
        /// <param name="kernelType">The kernel type. Default: "rbf"</param>
        /// <param name="kernelParam">Additional parameter for the kernel function. Default: 0.02</param>
        /// <param name="nu">Regularization constant of the SVM. Default: 0.05</param>
        /// <param name="mode">The mode of the SVM. Default: "one-versus-one"</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors. Default: "normalization"</param>
        /// <param name="numComponents">Preprocessing parameter: Number of transformed features (ignored for Preprocessing $=$ 'none' and Preprocessing $=$ 'normalization'). Default: 10</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void CreateOcrClassSvm(
          HTuple widthCharacter,
          HTuple heightCharacter,
          HTuple interpolation,
          HTuple features,
          HTuple characters,
          HTuple kernelType,
          HTuple kernelParam,
          HTuple nu,
          HTuple mode,
          HTuple preprocessing,
          HTuple numComponents,
          out HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(689);
            HalconAPI.Store(proc, 0, widthCharacter);
            HalconAPI.Store(proc, 1, heightCharacter);
            HalconAPI.Store(proc, 2, interpolation);
            HalconAPI.Store(proc, 3, features);
            HalconAPI.Store(proc, 4, characters);
            HalconAPI.Store(proc, 5, kernelType);
            HalconAPI.Store(proc, 6, kernelParam);
            HalconAPI.Store(proc, 7, nu);
            HalconAPI.Store(proc, 8, mode);
            HalconAPI.Store(proc, 9, preprocessing);
            HalconAPI.Store(proc, 10, numComponents);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(widthCharacter);
            HalconAPI.UnpinTuple(heightCharacter);
            HalconAPI.UnpinTuple(interpolation);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(characters);
            HalconAPI.UnpinTuple(kernelType);
            HalconAPI.UnpinTuple(kernelParam);
            HalconAPI.UnpinTuple(nu);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(preprocessing);
            HalconAPI.UnpinTuple(numComponents);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all OCR classifiers.</summary>
        public static void ClearAllOcrClassMlp()
        {
            IntPtr proc = HalconAPI.PreCall(690);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void ClearOcrClassMlp(HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(691);
            HalconAPI.Store(proc, 0, OCRHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized MLP-based OCR classifier.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void DeserializeOcrClassMlp(HTuple serializedItemHandle, out HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(692);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a MLP-based OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeOcrClassMlp(HTuple OCRHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(693);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read an OCR classifier from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void ReadOcrClassMlp(HTuple fileName, out HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(694);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write an OCR classifier to a file.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteOcrClassMlp(HTuple OCRHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(695);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the features of a character.</summary>
        /// <param name="character">Input character.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="transform">Should the feature vector be transformed with the preprocessing? Default: "true"</param>
        /// <param name="features">Feature vector of the character.</param>
        public static void GetFeaturesOcrClassMlp(
          HObject character,
          HTuple OCRHandle,
          HTuple transform,
          out HTuple features)
        {
            IntPtr proc = HalconAPI.PreCall(696);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, transform);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(transform);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out features);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
        }

        /// <summary>Classify a related group of characters with an OCR classifier.</summary>
        /// <param name="character">Characters to be recognized.</param>
        /// <param name="image">Gray values of the characters.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="expression">Expression describing the allowed word structure.</param>
        /// <param name="numAlternatives">Number of classes per character considered for the internal word correction. Default: 3</param>
        /// <param name="numCorrections">Maximum number of corrected characters. Default: 2</param>
        /// <param name="classVal">Result of classifying the characters with the MLP.</param>
        /// <param name="confidence">Confidence of the class of the characters.</param>
        /// <param name="word">Word text after classification and correction.</param>
        /// <param name="score">Measure of similarity between corrected word and uncorrected classification results.</param>
        public static void DoOcrWordMlp(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          HTuple expression,
          HTuple numAlternatives,
          HTuple numCorrections,
          out HTuple classVal,
          out HTuple confidence,
          out HTuple word,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(697);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, expression);
            HalconAPI.Store(proc, 2, numAlternatives);
            HalconAPI.Store(proc, 3, numCorrections);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(expression);
            HalconAPI.UnpinTuple(numAlternatives);
            HalconAPI.UnpinTuple(numCorrections);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classVal);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidence);
            int err4 = HTuple.LoadNew(proc, 2, err3, out word);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Classify multiple characters with an OCR classifier.</summary>
        /// <param name="character">Characters to be recognized.</param>
        /// <param name="image">Gray values of the characters.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="classVal">Result of classifying the characters with the MLP.</param>
        /// <param name="confidence">Confidence of the class of the characters.</param>
        public static void DoOcrMultiClassMlp(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          out HTuple classVal,
          out HTuple confidence)
        {
            IntPtr proc = HalconAPI.PreCall(698);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classVal);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Classify a single character with an OCR classifier.</summary>
        /// <param name="character">Character to be recognized.</param>
        /// <param name="image">Gray values of the character.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="num">Number of best classes to determine. Default: 1</param>
        /// <param name="classVal">Result of classifying the character with the MLP.</param>
        /// <param name="confidence">Confidence(s) of the class(es) of the character.</param>
        public static void DoOcrSingleClassMlp(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          HTuple num,
          out HTuple classVal,
          out HTuple confidence)
        {
            IntPtr proc = HalconAPI.PreCall(699);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, num);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(num);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classVal);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Train an OCR classifier with data from a (protected) training file.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="trainingFile">Names of the training files. Default: "ocr.trf"</param>
        /// <param name="password">Passwords for protected training files.</param>
        /// <param name="maxIterations">Maximum number of iterations of the optimization algorithm. Default: 200</param>
        /// <param name="weightTolerance">Threshold for the difference of the weights of the MLP between two iterations of the optimization algorithm. Default: 1.0</param>
        /// <param name="errorTolerance">Threshold for the difference of the mean error of the MLP on the training data between two iterations of the optimization algorithm. Default: 0.01</param>
        /// <param name="error">Mean error of the MLP on the training data.</param>
        /// <param name="errorLog">Mean error of the MLP on the training data as a function of the number of iterations of the optimization algorithm.</param>
        public static void TrainfOcrClassMlpProtected(
          HTuple OCRHandle,
          HTuple trainingFile,
          HTuple password,
          HTuple maxIterations,
          HTuple weightTolerance,
          HTuple errorTolerance,
          out HTuple error,
          out HTuple errorLog)
        {
            IntPtr proc = HalconAPI.PreCall(700);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, trainingFile);
            HalconAPI.Store(proc, 2, password);
            HalconAPI.Store(proc, 3, maxIterations);
            HalconAPI.Store(proc, 4, weightTolerance);
            HalconAPI.Store(proc, 5, errorTolerance);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(password);
            HalconAPI.UnpinTuple(maxIterations);
            HalconAPI.UnpinTuple(weightTolerance);
            HalconAPI.UnpinTuple(errorTolerance);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out error);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out errorLog);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="trainingFile">Names of the training files. Default: "ocr.trf"</param>
        /// <param name="maxIterations">Maximum number of iterations of the optimization algorithm. Default: 200</param>
        /// <param name="weightTolerance">Threshold for the difference of the weights of the MLP between two iterations of the optimization algorithm. Default: 1.0</param>
        /// <param name="errorTolerance">Threshold for the difference of the mean error of the MLP on the training data between two iterations of the optimization algorithm. Default: 0.01</param>
        /// <param name="error">Mean error of the MLP on the training data.</param>
        /// <param name="errorLog">Mean error of the MLP on the training data as a function of the number of iterations of the optimization algorithm.</param>
        public static void TrainfOcrClassMlp(
          HTuple OCRHandle,
          HTuple trainingFile,
          HTuple maxIterations,
          HTuple weightTolerance,
          HTuple errorTolerance,
          out HTuple error,
          out HTuple errorLog)
        {
            IntPtr proc = HalconAPI.PreCall(701);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, trainingFile);
            HalconAPI.Store(proc, 2, maxIterations);
            HalconAPI.Store(proc, 3, weightTolerance);
            HalconAPI.Store(proc, 4, errorTolerance);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(maxIterations);
            HalconAPI.UnpinTuple(weightTolerance);
            HalconAPI.UnpinTuple(errorTolerance);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out error);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out errorLog);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the information content of the preprocessed feature vectors of an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="trainingFile">Names of the training files. Default: "ocr.trf"</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors. Default: "principal_components"</param>
        /// <param name="informationCont">Relative information content of the transformed feature vectors.</param>
        /// <param name="cumInformationCont">Cumulative information content of the transformed feature vectors.</param>
        public static void GetPrepInfoOcrClassMlp(
          HTuple OCRHandle,
          HTuple trainingFile,
          HTuple preprocessing,
          out HTuple informationCont,
          out HTuple cumInformationCont)
        {
            IntPtr proc = HalconAPI.PreCall(702);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, trainingFile);
            HalconAPI.Store(proc, 2, preprocessing);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(preprocessing);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out informationCont);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out cumInformationCont);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the rejection class parameters of an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="genParamName">Name of the general parameter. Default: "sampling_strategy"</param>
        /// <param name="genParamValue">Value of the general parameter.</param>
        public static void GetRejectionParamsOcrClassMlp(
          HTuple OCRHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(703);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the rejection class parameters of an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="genParamName">Name of the general parameter. Default: "sampling_strategy"</param>
        /// <param name="genParamValue">Value of the general parameter. Default: "hyperbox_around_all_classes"</param>
        public static void SetRejectionParamsOcrClassMlp(
          HTuple OCRHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(704);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the regularization parameters of an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="genParamName">Name of the regularization parameter to return. Default: "weight_prior"</param>
        /// <param name="genParamValue">Value of the regularization parameter.</param>
        public static void GetRegularizationParamsOcrClassMlp(
          HTuple OCRHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(705);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the regularization parameters of an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="genParamName">Name of the regularization parameter to return. Default: "weight_prior"</param>
        /// <param name="genParamValue">Value of the regularization parameter. Default: 1.0</param>
        public static void SetRegularizationParamsOcrClassMlp(
          HTuple OCRHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(706);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters of an OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="widthCharacter">Width of the rectangle to which the gray values of the segmented character are zoomed.</param>
        /// <param name="heightCharacter">Height of the rectangle to which the gray values of the segmented character are zoomed.</param>
        /// <param name="interpolation">Interpolation mode for the zooming of the characters.</param>
        /// <param name="features">Features to be used for classification.</param>
        /// <param name="characters">Characters of the character set to be read.</param>
        /// <param name="numHidden">Number of hidden units of the MLP.</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors.</param>
        /// <param name="numComponents">Preprocessing parameter: Number of transformed features.</param>
        public static void GetParamsOcrClassMlp(
          HTuple OCRHandle,
          out HTuple widthCharacter,
          out HTuple heightCharacter,
          out HTuple interpolation,
          out HTuple features,
          out HTuple characters,
          out HTuple numHidden,
          out HTuple preprocessing,
          out HTuple numComponents)
        {
            IntPtr proc = HalconAPI.PreCall(707);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out widthCharacter);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out heightCharacter);
            int err4 = HTuple.LoadNew(proc, 2, err3, out interpolation);
            int err5 = HTuple.LoadNew(proc, 3, err4, out features);
            int err6 = HTuple.LoadNew(proc, 4, err5, out characters);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out numHidden);
            int err8 = HTuple.LoadNew(proc, 6, err7, out preprocessing);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.INTEGER, err8, out numComponents);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an OCR classifier using a multilayer perceptron.</summary>
        /// <param name="widthCharacter">Width of the rectangle to which the gray values of the segmented character are zoomed. Default: 8</param>
        /// <param name="heightCharacter">Height of the rectangle to which the gray values of the segmented character are zoomed. Default: 10</param>
        /// <param name="interpolation">Interpolation mode for the zooming of the characters. Default: "constant"</param>
        /// <param name="features">Features to be used for classification. Default: "default"</param>
        /// <param name="characters">All characters of the character set to be read. Default: ["0","1","2","3","4","5","6","7","8","9"]</param>
        /// <param name="numHidden">Number of hidden units of the MLP. Default: 80</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors. Default: "none"</param>
        /// <param name="numComponents">Preprocessing parameter: Number of transformed features (ignored for Preprocessing $=$ 'none' and Preprocessing $=$ 'normalization'). Default: 10</param>
        /// <param name="randSeed">Seed value of the random number generator that is used to initialize the MLP with random values. Default: 42</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void CreateOcrClassMlp(
          HTuple widthCharacter,
          HTuple heightCharacter,
          HTuple interpolation,
          HTuple features,
          HTuple characters,
          HTuple numHidden,
          HTuple preprocessing,
          HTuple numComponents,
          HTuple randSeed,
          out HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(708);
            HalconAPI.Store(proc, 0, widthCharacter);
            HalconAPI.Store(proc, 1, heightCharacter);
            HalconAPI.Store(proc, 2, interpolation);
            HalconAPI.Store(proc, 3, features);
            HalconAPI.Store(proc, 4, characters);
            HalconAPI.Store(proc, 5, numHidden);
            HalconAPI.Store(proc, 6, preprocessing);
            HalconAPI.Store(proc, 7, numComponents);
            HalconAPI.Store(proc, 8, randSeed);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(widthCharacter);
            HalconAPI.UnpinTuple(heightCharacter);
            HalconAPI.UnpinTuple(interpolation);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(characters);
            HalconAPI.UnpinTuple(numHidden);
            HalconAPI.UnpinTuple(preprocessing);
            HalconAPI.UnpinTuple(numComponents);
            HalconAPI.UnpinTuple(randSeed);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize an OCR classifier.</summary>
        /// <param name="ocrHandle">ID of the OCR classifier.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeOcr(HTuple ocrHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(709);
            HalconAPI.Store(proc, 0, ocrHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ocrHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized OCR classifier.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="ocrHandle">ID of the OCR classifier.</param>
        public static void DeserializeOcr(HTuple serializedItemHandle, out HTuple ocrHandle)
        {
            IntPtr proc = HalconAPI.PreCall(710);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out ocrHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Writing an OCR classifier into a file.</summary>
        /// <param name="ocrHandle">ID of the OCR classifier.</param>
        /// <param name="fileName">Name of the file for the OCR classifier (without extension). Default: "my_ocr"</param>
        public static void WriteOcr(HTuple ocrHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(711);
            HalconAPI.Store(proc, 0, ocrHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ocrHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read an OCR classifier from a file.</summary>
        /// <param name="fileName">Name of the OCR classifier file. Default: "testnet"</param>
        /// <param name="ocrHandle">ID of the read OCR classifier.</param>
        public static void ReadOcr(HTuple fileName, out HTuple ocrHandle)
        {
            IntPtr proc = HalconAPI.PreCall(712);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out ocrHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Classify one character.</summary>
        /// <param name="character">Character to be recognized.</param>
        /// <param name="image">Gray values of the characters.</param>
        /// <param name="ocrHandle">ID of the OCR classifier.</param>
        /// <param name="classes">Classes (names) of the characters.</param>
        /// <param name="confidences">Confidence values of the characters.</param>
        public static void DoOcrSingle(
          HObject character,
          HObject image,
          HTuple ocrHandle,
          out HTuple classes,
          out HTuple confidences)
        {
            IntPtr proc = HalconAPI.PreCall(713);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, ocrHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ocrHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classes);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidences);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Classify characters.</summary>
        /// <param name="character">Characters to be recognized.</param>
        /// <param name="image">Gray values for the characters.</param>
        /// <param name="ocrHandle">ID of the OCR classifier.</param>
        /// <param name="classVal">Class (name) of the characters.</param>
        /// <param name="confidence">Confidence values of the characters.</param>
        public static void DoOcrMulti(
          HObject character,
          HObject image,
          HTuple ocrHandle,
          out HTuple classVal,
          out HTuple confidence)
        {
            IntPtr proc = HalconAPI.PreCall(714);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, ocrHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ocrHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classVal);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Get information about an OCR classifier.</summary>
        /// <param name="ocrHandle">ID of the OCR classifier.</param>
        /// <param name="widthPattern">Width of the scaled characters.</param>
        /// <param name="heightPattern">Height of the scaled characters.</param>
        /// <param name="interpolation">Interpolation mode for scaling the characters.</param>
        /// <param name="widthMaxChar">Width of the largest trained character.</param>
        /// <param name="heightMaxChar">Height of the largest trained character.</param>
        /// <param name="features">Used features.</param>
        /// <param name="characters">All characters of the set.</param>
        public static void InfoOcrClassBox(
          HTuple ocrHandle,
          out HTuple widthPattern,
          out HTuple heightPattern,
          out HTuple interpolation,
          out HTuple widthMaxChar,
          out HTuple heightMaxChar,
          out HTuple features,
          out HTuple characters)
        {
            IntPtr proc = HalconAPI.PreCall(715);
            HalconAPI.Store(proc, 0, ocrHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ocrHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out widthPattern);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out heightPattern);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out interpolation);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out widthMaxChar);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out heightMaxChar);
            int err7 = HTuple.LoadNew(proc, 5, err6, out features);
            int procResult = HTuple.LoadNew(proc, 6, err7, out characters);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a new OCR-classifier.</summary>
        /// <param name="widthPattern">Width of the input layer of the network. Default: 8</param>
        /// <param name="heightPattern">Height of the input layer of the network. Default: 10</param>
        /// <param name="interpolation">Interpolation mode concerning scaling of characters. Default: 1</param>
        /// <param name="features">Additional features. Default: "default"</param>
        /// <param name="character">All characters of a set. Default: ["a","b","c"]</param>
        /// <param name="ocrHandle">ID of the created OCR classifier.</param>
        public static void CreateOcrClassBox(
          HTuple widthPattern,
          HTuple heightPattern,
          HTuple interpolation,
          HTuple features,
          HTuple character,
          out HTuple ocrHandle)
        {
            IntPtr proc = HalconAPI.PreCall(716);
            HalconAPI.Store(proc, 0, widthPattern);
            HalconAPI.Store(proc, 1, heightPattern);
            HalconAPI.Store(proc, 2, interpolation);
            HalconAPI.Store(proc, 3, features);
            HalconAPI.Store(proc, 4, character);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(widthPattern);
            HalconAPI.UnpinTuple(heightPattern);
            HalconAPI.UnpinTuple(interpolation);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(character);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out ocrHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train an OCR classifier by the input of regions.</summary>
        /// <param name="character">Characters to be trained.</param>
        /// <param name="image">Gray values for the characters.</param>
        /// <param name="ocrHandle">ID of the desired OCR-classifier.</param>
        /// <param name="classVal">Class (name) of the characters. Default: "a"</param>
        /// <param name="avgConfidence">Average confidence during a re-classification of the trained characters.</param>
        public static void TraindOcrClassBox(
          HObject character,
          HObject image,
          HTuple ocrHandle,
          HTuple classVal,
          out HTuple avgConfidence)
        {
            IntPtr proc = HalconAPI.PreCall(717);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, ocrHandle);
            HalconAPI.Store(proc, 1, classVal);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ocrHandle);
            HalconAPI.UnpinTuple(classVal);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out avgConfidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Train an OCR classifier with the help of a training file.</summary>
        /// <param name="ocrHandle">ID of the desired OCR-network.</param>
        /// <param name="trainingFile">Names of the training files. Default: "train_ocr"</param>
        /// <param name="avgConfidence">Average confidence during a re-classification of the trained characters.</param>
        public static void TrainfOcrClassBox(
          HTuple ocrHandle,
          HTuple trainingFile,
          out HTuple avgConfidence)
        {
            IntPtr proc = HalconAPI.PreCall(718);
            HalconAPI.Store(proc, 0, ocrHandle);
            HalconAPI.Store(proc, 1, trainingFile);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ocrHandle);
            HalconAPI.UnpinTuple(trainingFile);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out avgConfidence);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Protection of training data.</summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="password">Passwords for protecting the training files.</param>
        /// <param name="trainingFileProtected">Names of the protected training files.</param>
        public static void ProtectOcrTrainf(
          HTuple trainingFile,
          HTuple password,
          HTuple trainingFileProtected)
        {
            IntPtr proc = HalconAPI.PreCall(719);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.Store(proc, 1, password);
            HalconAPI.Store(proc, 2, trainingFileProtected);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(password);
            HalconAPI.UnpinTuple(trainingFileProtected);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Storing of training characters into a file.</summary>
        /// <param name="character">Characters to be trained.</param>
        /// <param name="image">Gray values of the characters.</param>
        /// <param name="classVal">Class (name) of the characters.</param>
        /// <param name="trainingFile">Name of the training file. Default: "train_ocr"</param>
        public static void WriteOcrTrainf(
          HObject character,
          HObject image,
          HTuple classVal,
          HTuple trainingFile)
        {
            IntPtr proc = HalconAPI.PreCall(720);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, classVal);
            HalconAPI.Store(proc, 1, trainingFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classVal);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Define a new conversion table for the characters.</summary>
        /// <param name="ocrHandle">ID of the OCR-network to be changed.</param>
        /// <param name="character">New assign of characters. Default: ["a","b","c"]</param>
        public static void OcrChangeChar(HTuple ocrHandle, HTuple character)
        {
            IntPtr proc = HalconAPI.PreCall(721);
            HalconAPI.Store(proc, 0, ocrHandle);
            HalconAPI.Store(proc, 1, character);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ocrHandle);
            HalconAPI.UnpinTuple(character);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deallocation of the memory of an OCR classifier.</summary>
        /// <param name="ocrHandle">ID of the OCR classifier to be deleted.</param>
        public static void CloseOcr(HTuple ocrHandle)
        {
            IntPtr proc = HalconAPI.PreCall(722);
            HalconAPI.Store(proc, 0, ocrHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ocrHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Sorting of regions with respect to their relative position.</summary>
        /// <param name="regions">Regions to be sorted.</param>
        /// <param name="sortedRegions">Sorted regions.</param>
        /// <param name="sortMode">Kind of sorting. Default: "first_point"</param>
        /// <param name="order">Increasing or decreasing sorting order. Default: "true"</param>
        /// <param name="rowOrCol">Sorting first with respect to row, then to column. Default: "row"</param>
        public static void SortRegion(
          HObject regions,
          out HObject sortedRegions,
          HTuple sortMode,
          HTuple order,
          HTuple rowOrCol)
        {
            IntPtr proc = HalconAPI.PreCall(723);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, sortMode);
            HalconAPI.Store(proc, 1, order);
            HalconAPI.Store(proc, 2, rowOrCol);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sortMode);
            HalconAPI.UnpinTuple(order);
            HalconAPI.UnpinTuple(rowOrCol);
            int procResult = HObject.LoadNew(proc, 1, err, out sortedRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Destroy all OCR classifiers.</summary>
        public static void CloseAllOcrs()
        {
            IntPtr proc = HalconAPI.PreCall(724);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test an OCR classifier.</summary>
        /// <param name="character">Characters to be tested.</param>
        /// <param name="image">Gray values for the characters.</param>
        /// <param name="ocrHandle">ID of the desired OCR-classifier.</param>
        /// <param name="classVal">Class (name) of the characters. Default: "a"</param>
        /// <param name="confidence">Confidence for the character to belong to the class.</param>
        public static void TestdOcrClassBox(
          HObject character,
          HObject image,
          HTuple ocrHandle,
          HTuple classVal,
          out HTuple confidence)
        {
            IntPtr proc = HalconAPI.PreCall(725);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, ocrHandle);
            HalconAPI.Store(proc, 1, classVal);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ocrHandle);
            HalconAPI.UnpinTuple(classVal);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out confidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Cut out an image area relative to the domain.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imagePart">Image area.</param>
        /// <param name="top">Number of rows clipped at the top. Default: -1</param>
        /// <param name="left">Number of columns clipped at the left. Default: -1</param>
        /// <param name="bottom">Number of rows clipped at the bottom. Default: -1</param>
        /// <param name="right">Number of columns clipped at the right. Default: -1</param>
        public static void CropDomainRel(
          HObject image,
          out HObject imagePart,
          HTuple top,
          HTuple left,
          HTuple bottom,
          HTuple right)
        {
            IntPtr proc = HalconAPI.PreCall(726);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, top);
            HalconAPI.Store(proc, 1, left);
            HalconAPI.Store(proc, 2, bottom);
            HalconAPI.Store(proc, 3, right);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(top);
            HalconAPI.UnpinTuple(left);
            HalconAPI.UnpinTuple(bottom);
            HalconAPI.UnpinTuple(right);
            int procResult = HObject.LoadNew(proc, 1, err, out imagePart);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Access the features which correspond to a character.</summary>
        /// <param name="character">Characters to be trained.</param>
        /// <param name="ocrHandle">ID of the desired OCR-classifier.</param>
        /// <param name="featureVector">Feature vector.</param>
        public static void OcrGetFeatures(
          HObject character,
          HTuple ocrHandle,
          out HTuple featureVector)
        {
            IntPtr proc = HalconAPI.PreCall(727);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 0, ocrHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ocrHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out featureVector);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
        }

        /// <summary>Concat training files.</summary>
        /// <param name="singleFiles">Names of the single training files. Default: ""</param>
        /// <param name="composedFile">Name of the composed training file. Default: "all_characters"</param>
        public static void ConcatOcrTrainf(HTuple singleFiles, HTuple composedFile)
        {
            IntPtr proc = HalconAPI.PreCall(728);
            HalconAPI.Store(proc, 0, singleFiles);
            HalconAPI.Store(proc, 1, composedFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(singleFiles);
            HalconAPI.UnpinTuple(composedFile);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write characters into a training file.</summary>
        /// <param name="character">Characters to be trained.</param>
        /// <param name="classVal">Class (name) of the characters.</param>
        /// <param name="trainingFile">Name of the training file. Default: "train_ocr"</param>
        public static void WriteOcrTrainfImage(HObject character, HTuple classVal, HTuple trainingFile)
        {
            IntPtr proc = HalconAPI.PreCall(729);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 0, classVal);
            HalconAPI.Store(proc, 1, trainingFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classVal);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
        }

        /// <summary>Add characters to a training file.</summary>
        /// <param name="character">Characters to be trained.</param>
        /// <param name="image">Gray values of the characters.</param>
        /// <param name="classVal">Class (name) of the characters.</param>
        /// <param name="trainingFile">Name of the training file. Default: "train_ocr"</param>
        public static void AppendOcrTrainf(
          HObject character,
          HObject image,
          HTuple classVal,
          HTuple trainingFile)
        {
            IntPtr proc = HalconAPI.PreCall(730);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, classVal);
            HalconAPI.Store(proc, 1, trainingFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classVal);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Query which characters are stored in a (protected) training file.</summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="password">Passwords for protected training files.</param>
        /// <param name="characterNames">Names of the read characters.</param>
        /// <param name="characterCount">Number of characters.</param>
        public static void ReadOcrTrainfNamesProtected(
          HTuple trainingFile,
          HTuple password,
          out HTuple characterNames,
          out HTuple characterCount)
        {
            IntPtr proc = HalconAPI.PreCall(731);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.Store(proc, 1, password);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(password);
            int err2 = HTuple.LoadNew(proc, 0, err1, out characterNames);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out characterCount);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query which characters are stored in a training file.</summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="characterNames">Names of the read characters.</param>
        /// <param name="characterCount">Number of characters.</param>
        public static void ReadOcrTrainfNames(
          HTuple trainingFile,
          out HTuple characterNames,
          out HTuple characterCount)
        {
            IntPtr proc = HalconAPI.PreCall(732);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            int err2 = HTuple.LoadNew(proc, 0, err1, out characterNames);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out characterCount);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read training specific characters from files and convert to images.</summary>
        /// <param name="characters">Images read from file.</param>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="searchNames">Names of the characters to be extracted. Default: "0"</param>
        /// <param name="foundNames">Names of the read characters.</param>
        public static void ReadOcrTrainfSelect(
          out HObject characters,
          HTuple trainingFile,
          HTuple searchNames,
          out HTuple foundNames)
        {
            IntPtr proc = HalconAPI.PreCall(733);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.Store(proc, 1, searchNames);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(searchNames);
            int err2 = HObject.LoadNew(proc, 1, err1, out characters);
            int procResult = HTuple.LoadNew(proc, 0, err2, out foundNames);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read training characters from files and convert to images.</summary>
        /// <param name="characters">Images read from file.</param>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="characterNames">Names of the read characters.</param>
        public static void ReadOcrTrainf(
          out HObject characters,
          HTuple trainingFile,
          out HTuple characterNames)
        {
            IntPtr proc = HalconAPI.PreCall(734);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            int err2 = HObject.LoadNew(proc, 1, err1, out characters);
            int procResult = HTuple.LoadNew(proc, 0, err2, out characterNames);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Prune the branches of a region.</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="regionPrune">Result of the pruning operation.</param>
        /// <param name="length">Length of the branches to be removed. Default: 2</param>
        public static void Pruning(HObject region, out HObject regionPrune, HTuple length)
        {
            IntPtr proc = HalconAPI.PreCall(735);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, length);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(length);
            int procResult = HObject.LoadNew(proc, 1, err, out regionPrune);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Reduce a region to its boundary.</summary>
        /// <param name="region">Regions for which the boundary is to be computed.</param>
        /// <param name="regionBorder">Resulting boundaries.</param>
        /// <param name="boundaryType">Boundary type. Default: "inner"</param>
        public static void Boundary(HObject region, out HObject regionBorder, HTuple boundaryType)
        {
            IntPtr proc = HalconAPI.PreCall(736);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, boundaryType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(boundaryType);
            int procResult = HObject.LoadNew(proc, 1, err, out regionBorder);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Perform a closing after an opening with multiple structuring elements.</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="structElements">Structuring elements.</param>
        /// <param name="regionFitted">Fitted regions.</param>
        public static void Fitting(HObject region, HObject structElements, out HObject regionFitted)
        {
            IntPtr proc = HalconAPI.PreCall(737);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElements);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionFitted);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElements);
        }

        /// <summary>Generate standard structuring elements.</summary>
        /// <param name="structElements">Generated structuring elements.</param>
        /// <param name="type">Type of structuring element to generate. Default: "noise"</param>
        /// <param name="row">Row coordinate of the reference point. Default: 1</param>
        /// <param name="column">Column coordinate of the reference point. Default: 1</param>
        public static void GenStructElements(
          out HObject structElements,
          HTuple type,
          HTuple row,
          HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(738);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HObject.LoadNew(proc, 1, err, out structElements);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Reflect a region about a point.</summary>
        /// <param name="region">Region to be reflected.</param>
        /// <param name="transposed">Transposed region.</param>
        /// <param name="row">Row coordinate of the reference point. Default: 0</param>
        /// <param name="column">Column coordinate of the reference point. Default: 0</param>
        public static void TransposeRegion(
          HObject region,
          out HObject transposed,
          HTuple row,
          HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(739);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HObject.LoadNew(proc, 1, err, out transposed);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Remove the result of a hit-or-miss operation from a region (sequential).</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="regionThin">Result of the thinning operator.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "l"</param>
        /// <param name="iterations">Number of iterations. For 'f', 'f2', 'h' and 'i' the only useful value is 1. Default: 20</param>
        public static void ThinningSeq(
          HObject region,
          out HObject regionThin,
          HTuple golayElement,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(740);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionThin);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Remove the result of a hit-or-miss operation from a region (using a Golay structuring element).</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="regionThin">Result of the thinning operator.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "h"</param>
        /// <param name="rotation">Rotation of the Golay element. Depending on the element, not all rotations are valid. Default: 0</param>
        public static void ThinningGolay(
          HObject region,
          out HObject regionThin,
          HTuple golayElement,
          HTuple rotation)
        {
            IntPtr proc = HalconAPI.PreCall(741);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, rotation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(rotation);
            int procResult = HObject.LoadNew(proc, 1, err, out regionThin);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Remove the result of a hit-or-miss operation from a region.</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="structElement1">Structuring element for the foreground.</param>
        /// <param name="structElement2">Structuring element for the background.</param>
        /// <param name="regionThin">Result of the thinning operator.</param>
        /// <param name="row">Row coordinate of the reference point. Default: 0</param>
        /// <param name="column">Column coordinate of the reference point. Default: 0</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void Thinning(
          HObject region,
          HObject structElement1,
          HObject structElement2,
          out HObject regionThin,
          HTuple row,
          HTuple column,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(742);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement1);
            HalconAPI.Store(proc, 3, (HObjectBase)structElement2);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionThin);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement1);
            GC.KeepAlive((object)structElement2);
        }

        /// <summary>Add the result of a hit-or-miss operation to a region (sequential).</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="regionThick">Result of the thickening operator.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "h"</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void ThickeningSeq(
          HObject region,
          out HObject regionThick,
          HTuple golayElement,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(743);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionThick);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Add the result of a hit-or-miss operation to a region (using a Golay structuring element).</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="regionThick">Result of the thickening operator.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "h"</param>
        /// <param name="rotation">Rotation of the Golay element. Depending on the element, not all rotations are valid. Default: 0</param>
        public static void ThickeningGolay(
          HObject region,
          out HObject regionThick,
          HTuple golayElement,
          HTuple rotation)
        {
            IntPtr proc = HalconAPI.PreCall(744);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, rotation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(rotation);
            int procResult = HObject.LoadNew(proc, 1, err, out regionThick);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Add the result of a hit-or-miss operation to a region.</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="structElement1">Structuring element for the foreground.</param>
        /// <param name="structElement2">Structuring element for the background.</param>
        /// <param name="regionThick">Result of the thickening operator.</param>
        /// <param name="row">Row coordinate of the reference point. Default: 16</param>
        /// <param name="column">Column coordinate of the reference point. Default: 16</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void Thickening(
          HObject region,
          HObject structElement1,
          HObject structElement2,
          out HObject regionThick,
          HTuple row,
          HTuple column,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(745);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement1);
            HalconAPI.Store(proc, 3, (HObjectBase)structElement2);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionThick);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement1);
            GC.KeepAlive((object)structElement2);
        }

        /// <summary>Hit-or-miss operation for regions using the Golay alphabet (sequential).</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="regionHitMiss">Result of the hit-or-miss operation.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "h"</param>
        public static void HitOrMissSeq(HObject region, out HObject regionHitMiss, HTuple golayElement)
        {
            IntPtr proc = HalconAPI.PreCall(746);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            int procResult = HObject.LoadNew(proc, 1, err, out regionHitMiss);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Hit-or-miss operation for regions using the Golay alphabet.</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="regionHitMiss">Result of the hit-or-miss operation.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "h"</param>
        /// <param name="rotation">Rotation of the Golay element. Depending on the element, not all rotations are valid. Default: 0</param>
        public static void HitOrMissGolay(
          HObject region,
          out HObject regionHitMiss,
          HTuple golayElement,
          HTuple rotation)
        {
            IntPtr proc = HalconAPI.PreCall(747);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, rotation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(rotation);
            int procResult = HObject.LoadNew(proc, 1, err, out regionHitMiss);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Hit-or-miss operation for regions.</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="structElement1">Erosion mask for the input regions.</param>
        /// <param name="structElement2">Erosion mask for the complements of the input regions.</param>
        /// <param name="regionHitMiss">Result of the hit-or-miss operation.</param>
        /// <param name="row">Row coordinate of the reference point. Default: 16</param>
        /// <param name="column">Column coordinate of the reference point. Default: 16</param>
        public static void HitOrMiss(
          HObject region,
          HObject structElement1,
          HObject structElement2,
          out HObject regionHitMiss,
          HTuple row,
          HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(748);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement1);
            HalconAPI.Store(proc, 3, (HObjectBase)structElement2);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HObject.LoadNew(proc, 1, err, out regionHitMiss);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement1);
            GC.KeepAlive((object)structElement2);
        }

        /// <summary>Generate the structuring elements of the Golay alphabet.</summary>
        /// <param name="structElement1">Structuring element for the foreground.</param>
        /// <param name="structElement2">Structuring element for the background.</param>
        /// <param name="golayElement">Name of the structuring element. Default: "l"</param>
        /// <param name="rotation">Rotation of the Golay element. Depending on the element, not all rotations are valid. Default: 0</param>
        /// <param name="row">Row coordinate of the reference point. Default: 16</param>
        /// <param name="column">Column coordinate of the reference point. Default: 16</param>
        public static void GolayElements(
          out HObject structElement1,
          out HObject structElement2,
          HTuple golayElement,
          HTuple rotation,
          HTuple row,
          HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(749);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, rotation);
            HalconAPI.Store(proc, 2, row);
            HalconAPI.Store(proc, 3, column);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int err2 = HObject.LoadNew(proc, 1, err1, out structElement1);
            int procResult = HObject.LoadNew(proc, 2, err2, out structElement2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Thinning of a region.</summary>
        /// <param name="region">Regions to be thinned.</param>
        /// <param name="regionSkiz">Result of the skiz operator.</param>
        /// <param name="iterations1">Number of iterations for the sequential thinning with the element 'l' of the Golay alphabet. Default: 100</param>
        /// <param name="iterations2">Number of iterations for the sequential thinning with the element 'e' of the Golay alphabet. Default: 1</param>
        public static void MorphSkiz(
          HObject region,
          out HObject regionSkiz,
          HTuple iterations1,
          HTuple iterations2)
        {
            IntPtr proc = HalconAPI.PreCall(750);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, iterations1);
            HalconAPI.Store(proc, 1, iterations2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(iterations1);
            HalconAPI.UnpinTuple(iterations2);
            int procResult = HObject.LoadNew(proc, 1, err, out regionSkiz);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Compute the morphological skeleton of a region.</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="regionSkeleton">Resulting morphological skeleton.</param>
        public static void MorphSkeleton(HObject region, out HObject regionSkeleton)
        {
            IntPtr proc = HalconAPI.PreCall(751);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionSkeleton);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Compute the union of bottom_hat and top_hat.</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="structElement">Structuring element (position-invariant).</param>
        /// <param name="regionMorphHat">Union of top hat and bottom hat.</param>
        public static void MorphHat(HObject region, HObject structElement, out HObject regionMorphHat)
        {
            IntPtr proc = HalconAPI.PreCall(752);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionMorphHat);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Compute the bottom hat of regions.</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="structElement">Structuring element (position independent).</param>
        /// <param name="regionBottomHat">Result of the bottom hat operator.</param>
        public static void BottomHat(
          HObject region,
          HObject structElement,
          out HObject regionBottomHat)
        {
            IntPtr proc = HalconAPI.PreCall(753);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionBottomHat);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Compute the top hat of regions.</summary>
        /// <param name="region">Regions to be processed.</param>
        /// <param name="structElement">Structuring element (position independent).</param>
        /// <param name="regionTopHat">Result of the top hat operator.</param>
        public static void TopHat(HObject region, HObject structElement, out HObject regionTopHat)
        {
            IntPtr proc = HalconAPI.PreCall(754);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionTopHat);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Erode a region (using a reference point).</summary>
        /// <param name="region">Regions to be eroded.</param>
        /// <param name="structElement">Structuring element.</param>
        /// <param name="regionMinkSub">Eroded regions.</param>
        /// <param name="row">Row coordinate of the reference point. Default: 0</param>
        /// <param name="column">Column coordinate of the reference point. Default: 0</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void MinkowskiSub2(
          HObject region,
          HObject structElement,
          out HObject regionMinkSub,
          HTuple row,
          HTuple column,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(755);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionMinkSub);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Erode a region.</summary>
        /// <param name="region">Regions to be eroded.</param>
        /// <param name="structElement">Structuring element.</param>
        /// <param name="regionMinkSub">Eroded regions.</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void MinkowskiSub1(
          HObject region,
          HObject structElement,
          out HObject regionMinkSub,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(756);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.Store(proc, 0, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionMinkSub);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Dilate a region (using a reference point).</summary>
        /// <param name="region">Regions to be dilated.</param>
        /// <param name="structElement">Structuring element.</param>
        /// <param name="regionMinkAdd">Dilated regions.</param>
        /// <param name="row">Row coordinate of the reference point.</param>
        /// <param name="column">Column coordinate of the reference point.</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void MinkowskiAdd2(
          HObject region,
          HObject structElement,
          out HObject regionMinkAdd,
          HTuple row,
          HTuple column,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(757);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionMinkAdd);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Perform a Minkowski addition on a region.</summary>
        /// <param name="region">Regions to be dilated.</param>
        /// <param name="structElement">Structuring element.</param>
        /// <param name="regionMinkAdd">Dilated regions.</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void MinkowskiAdd1(
          HObject region,
          HObject structElement,
          out HObject regionMinkAdd,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(758);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.Store(proc, 0, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionMinkAdd);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Close a region with a rectangular structuring element.</summary>
        /// <param name="region">Regions to be closed.</param>
        /// <param name="regionClosing">Closed regions.</param>
        /// <param name="width">Width of the structuring rectangle. Default: 10</param>
        /// <param name="height">Height of the structuring rectangle. Default: 10</param>
        public static void ClosingRectangle1(
          HObject region,
          out HObject regionClosing,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(759);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out regionClosing);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Close a region with an element from the Golay alphabet.</summary>
        /// <param name="region">Regions to be closed.</param>
        /// <param name="regionClosing">Closed regions.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "h"</param>
        /// <param name="rotation">Rotation of the Golay element. Depending on the element, not all rotations are valid. Default: 0</param>
        public static void ClosingGolay(
          HObject region,
          out HObject regionClosing,
          HTuple golayElement,
          HTuple rotation)
        {
            IntPtr proc = HalconAPI.PreCall(760);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, rotation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(rotation);
            int procResult = HObject.LoadNew(proc, 1, err, out regionClosing);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Close a region with a circular structuring element.</summary>
        /// <param name="region">Regions to be closed.</param>
        /// <param name="regionClosing">Closed regions.</param>
        /// <param name="radius">Radius of the circular structuring element. Default: 3.5</param>
        public static void ClosingCircle(HObject region, out HObject regionClosing, HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(761);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, radius);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(radius);
            int procResult = HObject.LoadNew(proc, 1, err, out regionClosing);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Close a region.</summary>
        /// <param name="region">Regions to be closed.</param>
        /// <param name="structElement">Structuring element (position-invariant).</param>
        /// <param name="regionClosing">Closed regions.</param>
        public static void Closing(HObject region, HObject structElement, out HObject regionClosing)
        {
            IntPtr proc = HalconAPI.PreCall(762);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionClosing);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Separate overlapping regions.</summary>
        /// <param name="region">Regions to be opened.</param>
        /// <param name="structElement">Structuring element (position-invariant).</param>
        /// <param name="regionOpening">Opened regions.</param>
        public static void OpeningSeg(HObject region, HObject structElement, out HObject regionOpening)
        {
            IntPtr proc = HalconAPI.PreCall(763);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionOpening);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Open a region with an element from the Golay alphabet.</summary>
        /// <param name="region">Regions to be opened.</param>
        /// <param name="regionOpening">Opened regions.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "h"</param>
        /// <param name="rotation">Rotation of the Golay element. Depending on the element, not all rotations are valid. Default: 0</param>
        public static void OpeningGolay(
          HObject region,
          out HObject regionOpening,
          HTuple golayElement,
          HTuple rotation)
        {
            IntPtr proc = HalconAPI.PreCall(764);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, rotation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(rotation);
            int procResult = HObject.LoadNew(proc, 1, err, out regionOpening);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Open a region with a rectangular structuring element.</summary>
        /// <param name="region">Regions to be opened.</param>
        /// <param name="regionOpening">Opened regions.</param>
        /// <param name="width">Width of the structuring rectangle. Default: 10</param>
        /// <param name="height">Height of the structuring rectangle. Default: 10</param>
        public static void OpeningRectangle1(
          HObject region,
          out HObject regionOpening,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(765);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out regionOpening);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Open a region with a circular structuring element.</summary>
        /// <param name="region">Regions to be opened.</param>
        /// <param name="regionOpening">Opened regions.</param>
        /// <param name="radius">Radius of the circular structuring element. Default: 3.5</param>
        public static void OpeningCircle(HObject region, out HObject regionOpening, HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(766);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, radius);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(radius);
            int procResult = HObject.LoadNew(proc, 1, err, out regionOpening);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Open a region.</summary>
        /// <param name="region">Regions to be opened.</param>
        /// <param name="structElement">Structuring element (position-invariant).</param>
        /// <param name="regionOpening">Opened regions.</param>
        public static void Opening(HObject region, HObject structElement, out HObject regionOpening)
        {
            IntPtr proc = HalconAPI.PreCall(767);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out regionOpening);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Erode a region sequentially.</summary>
        /// <param name="region">Regions to be eroded.</param>
        /// <param name="regionErosion">Eroded regions.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "h"</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void ErosionSeq(
          HObject region,
          out HObject regionErosion,
          HTuple golayElement,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(768);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionErosion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Erode a region with an element from the Golay alphabet.</summary>
        /// <param name="region">Regions to be eroded.</param>
        /// <param name="regionErosion">Eroded regions.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "h"</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        /// <param name="rotation">Rotation of the Golay element. Depending on the element, not all rotations are valid. Default: 0</param>
        public static void ErosionGolay(
          HObject region,
          out HObject regionErosion,
          HTuple golayElement,
          HTuple iterations,
          HTuple rotation)
        {
            IntPtr proc = HalconAPI.PreCall(769);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, iterations);
            HalconAPI.Store(proc, 2, rotation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(rotation);
            int procResult = HObject.LoadNew(proc, 1, err, out regionErosion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Erode a region with a rectangular structuring element.</summary>
        /// <param name="region">Regions to be eroded.</param>
        /// <param name="regionErosion">Eroded regions.</param>
        /// <param name="width">Width of the structuring rectangle. Default: 11</param>
        /// <param name="height">Height of the structuring rectangle. Default: 11</param>
        public static void ErosionRectangle1(
          HObject region,
          out HObject regionErosion,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(770);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out regionErosion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Erode a region with a circular structuring element.</summary>
        /// <param name="region">Regions to be eroded.</param>
        /// <param name="regionErosion">Eroded regions.</param>
        /// <param name="radius">Radius of the circular structuring element. Default: 3.5</param>
        public static void ErosionCircle(HObject region, out HObject regionErosion, HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(771);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, radius);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(radius);
            int procResult = HObject.LoadNew(proc, 1, err, out regionErosion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Erode a region (using a reference point).</summary>
        /// <param name="region">Regions to be eroded.</param>
        /// <param name="structElement">Structuring element.</param>
        /// <param name="regionErosion">Eroded regions.</param>
        /// <param name="row">Row coordinate of the reference point. Default: 0</param>
        /// <param name="column">Column coordinate of the reference point. Default: 0</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void Erosion2(
          HObject region,
          HObject structElement,
          out HObject regionErosion,
          HTuple row,
          HTuple column,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(772);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionErosion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Erode a region.</summary>
        /// <param name="region">Regions to be eroded.</param>
        /// <param name="structElement">Structuring element.</param>
        /// <param name="regionErosion">Eroded regions.</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void Erosion1(
          HObject region,
          HObject structElement,
          out HObject regionErosion,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(773);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.Store(proc, 0, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionErosion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Dilate a region sequentially.</summary>
        /// <param name="region">Regions to be dilated.</param>
        /// <param name="regionDilation">Dilated regions.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "h"</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void DilationSeq(
          HObject region,
          out HObject regionDilation,
          HTuple golayElement,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(774);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionDilation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Dilate a region with an element from the Golay alphabet.</summary>
        /// <param name="region">Regions to be dilated.</param>
        /// <param name="regionDilation">Dilated regions.</param>
        /// <param name="golayElement">Structuring element from the Golay alphabet. Default: "h"</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        /// <param name="rotation">Rotation of the Golay element. Depending on the element, not all rotations are valid. Default: 0</param>
        public static void DilationGolay(
          HObject region,
          out HObject regionDilation,
          HTuple golayElement,
          HTuple iterations,
          HTuple rotation)
        {
            IntPtr proc = HalconAPI.PreCall(775);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, golayElement);
            HalconAPI.Store(proc, 1, iterations);
            HalconAPI.Store(proc, 2, rotation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(golayElement);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(rotation);
            int procResult = HObject.LoadNew(proc, 1, err, out regionDilation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Dilate a region with a rectangular structuring element.</summary>
        /// <param name="region">Regions to be dilated.</param>
        /// <param name="regionDilation">Dilated regions.</param>
        /// <param name="width">Width of the structuring rectangle. Default: 11</param>
        /// <param name="height">Height of the structuring rectangle. Default: 11</param>
        public static void DilationRectangle1(
          HObject region,
          out HObject regionDilation,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(776);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out regionDilation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Dilate a region with a circular structuring element.</summary>
        /// <param name="region">Regions to be dilated.</param>
        /// <param name="regionDilation">Dilated regions.</param>
        /// <param name="radius">Radius of the circular structuring element. Default: 3.5</param>
        public static void DilationCircle(HObject region, out HObject regionDilation, HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(777);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, radius);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(radius);
            int procResult = HObject.LoadNew(proc, 1, err, out regionDilation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Dilate a region (using a reference point).</summary>
        /// <param name="region">Regions to be dilated.</param>
        /// <param name="structElement">Structuring element.</param>
        /// <param name="regionDilation">Dilated regions.</param>
        /// <param name="row">Row coordinate of the reference point. Default: 0</param>
        /// <param name="column">Column coordinate of the reference point. Default: 0</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void Dilation2(
          HObject region,
          HObject structElement,
          out HObject regionDilation,
          HTuple row,
          HTuple column,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(778);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionDilation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Dilate a region.</summary>
        /// <param name="region">Regions to be dilated.</param>
        /// <param name="structElement">Structuring element.</param>
        /// <param name="regionDilation">Dilated regions.</param>
        /// <param name="iterations">Number of iterations. Default: 1</param>
        public static void Dilation1(
          HObject region,
          HObject structElement,
          out HObject regionDilation,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(779);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)structElement);
            HalconAPI.Store(proc, 0, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out regionDilation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)structElement);
        }

        /// <summary>Perform a gray value bottom hat transformation on an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="SE">Structuring element.</param>
        /// <param name="imageBotHat">Bottom hat image.</param>
        public static void GrayBothat(HObject image, HObject SE, out HObject imageBotHat)
        {
            IntPtr proc = HalconAPI.PreCall(780);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageBotHat);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)SE);
        }

        /// <summary>Perform a gray value top hat transformation on an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="SE">Structuring element.</param>
        /// <param name="imageTopHat">Top hat image.</param>
        public static void GrayTophat(HObject image, HObject SE, out HObject imageTopHat)
        {
            IntPtr proc = HalconAPI.PreCall(781);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageTopHat);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)SE);
        }

        /// <summary>Perform a gray value closing on an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="SE">Structuring element.</param>
        /// <param name="imageClosing">Gray-closed image.</param>
        public static void GrayClosing(HObject image, HObject SE, out HObject imageClosing)
        {
            IntPtr proc = HalconAPI.PreCall(782);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageClosing);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)SE);
        }

        /// <summary>Perform a gray value opening on an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="SE">Structuring element.</param>
        /// <param name="imageOpening">Gray-opened image.</param>
        public static void GrayOpening(HObject image, HObject SE, out HObject imageOpening)
        {
            IntPtr proc = HalconAPI.PreCall(783);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageOpening);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)SE);
        }

        /// <summary>Perform a gray value dilation on an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="SE">Structuring element.</param>
        /// <param name="imageDilation">Gray-dilated image.</param>
        public static void GrayDilation(HObject image, HObject SE, out HObject imageDilation)
        {
            IntPtr proc = HalconAPI.PreCall(784);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageDilation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)SE);
        }

        /// <summary>Perform a gray value erosion on an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="SE">Structuring element.</param>
        /// <param name="imageErosion">Gray-eroded image.</param>
        public static void GrayErosion(HObject image, HObject SE, out HObject imageErosion)
        {
            IntPtr proc = HalconAPI.PreCall(785);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageErosion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)SE);
        }

        /// <summary>Load a structuring element for gray morphology.</summary>
        /// <param name="SE">Generated structuring element.</param>
        /// <param name="fileName">Name of the file containing the structuring element.</param>
        public static void ReadGraySe(out HObject SE, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(786);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HObject.LoadNew(proc, 1, err, out SE);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate ellipsoidal structuring elements for gray morphology.</summary>
        /// <param name="SE">Generated structuring element.</param>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of the structuring element. Default: 5</param>
        /// <param name="height">Height of the structuring element. Default: 5</param>
        /// <param name="smax">Maximum gray value of the structuring element. Default: 0</param>
        public static void GenDiscSe(
          out HObject SE,
          HTuple type,
          HTuple width,
          HTuple height,
          HTuple smax)
        {
            IntPtr proc = HalconAPI.PreCall(787);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, width);
            HalconAPI.Store(proc, 2, height);
            HalconAPI.Store(proc, 3, smax);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(smax);
            int procResult = HObject.LoadNew(proc, 1, err, out SE);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the model contour of a metrology object in image coordinates. </summary>
        /// <param name="contour">Model contour.</param>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology object. Default: "all"</param>
        /// <param name="resolution">Distance between neighboring contour points. Default: 1.5</param>
        public static void GetMetrologyObjectModelContour(
          out HObject contour,
          HTuple metrologyHandle,
          HTuple index,
          HTuple resolution)
        {
            IntPtr proc = HalconAPI.PreCall(788);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, resolution);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(resolution);
            int procResult = HObject.LoadNew(proc, 1, err, out contour);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the result contour of a metrology object. </summary>
        /// <param name="contour">Result contour for the given metrology object.</param>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology object. Default: "all"</param>
        /// <param name="instance">Instance of the metrology object. Default: "all"</param>
        /// <param name="resolution">Distance between neighboring contour points. Default: 1.5</param>
        public static void GetMetrologyObjectResultContour(
          out HObject contour,
          HTuple metrologyHandle,
          HTuple index,
          HTuple instance,
          HTuple resolution)
        {
            IntPtr proc = HalconAPI.PreCall(789);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, instance);
            HalconAPI.Store(proc, 3, resolution);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(instance);
            HalconAPI.UnpinTuple(resolution);
            int procResult = HObject.LoadNew(proc, 1, err, out contour);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Alignment of a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="row">Row coordinate of the alignment. Default: 0</param>
        /// <param name="column">Column coordinate of the alignment. Default: 0</param>
        /// <param name="angle">Rotation angle of the alignment. Default: 0</param>
        public static void AlignMetrologyModel(
          HTuple metrologyHandle,
          HTuple row,
          HTuple column,
          HTuple angle)
        {
            IntPtr proc = HalconAPI.PreCall(790);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, angle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(angle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a metrology object to a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="shape">Type of the metrology object to be added. Default: "circle"</param>
        /// <param name="shapeParam">Parameters of the metrology object to be added.</param>
        /// <param name="measureLength1">Half length of the measure regions perpendicular to the boundary. Default: 20.0</param>
        /// <param name="measureLength2">Half length of the measure regions tangetial to the boundary. Default: 5.0</param>
        /// <param name="measureSigma">Sigma of the Gaussian function for the smoothing. Default: 1.0</param>
        /// <param name="measureThreshold">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="index">Index of the created metrology object.</param>
        public static void AddMetrologyObjectGeneric(
          HTuple metrologyHandle,
          HTuple shape,
          HTuple shapeParam,
          HTuple measureLength1,
          HTuple measureLength2,
          HTuple measureSigma,
          HTuple measureThreshold,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(791);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, shape);
            HalconAPI.Store(proc, 2, shapeParam);
            HalconAPI.Store(proc, 3, measureLength1);
            HalconAPI.Store(proc, 4, measureLength2);
            HalconAPI.Store(proc, 5, measureSigma);
            HalconAPI.Store(proc, 6, measureThreshold);
            HalconAPI.Store(proc, 7, genParamName);
            HalconAPI.Store(proc, 8, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(shape);
            HalconAPI.UnpinTuple(shapeParam);
            HalconAPI.UnpinTuple(measureLength1);
            HalconAPI.UnpinTuple(measureLength2);
            HalconAPI.UnpinTuple(measureSigma);
            HalconAPI.UnpinTuple(measureThreshold);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get parameters that are valid for the entire metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="genParamName">Name of the generic parameter. Default: "camera_param"</param>
        /// <param name="genParamValue">Value of the generic parameter.</param>
        public static void GetMetrologyModelParam(
          HTuple metrologyHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(792);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters that are valid for the entire metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="genParamName">Name of the generic parameter. Default: "camera_param"</param>
        /// <param name="genParamValue">Value of the generic parameter. Default: []</param>
        public static void SetMetrologyModelParam(
          HTuple metrologyHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(793);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized metrology model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        public static void DeserializeMetrologyModel(
          HTuple serializedItemHandle,
          out HTuple metrologyHandle)
        {
            IntPtr proc = HalconAPI.PreCall(794);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out metrologyHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeMetrologyModel(
          HTuple metrologyHandle,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(795);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transform metrology objects of a metrology model, e.g. for alignment.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: "all"</param>
        /// <param name="row">Translation in row direction.</param>
        /// <param name="column">Translation in column direction.</param>
        /// <param name="phi">Rotation angle.</param>
        /// <param name="mode">Mode of the transformation. Default: "absolute"</param>
        public static void TransformMetrologyObject(
          HTuple metrologyHandle,
          HTuple index,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(796);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, row);
            HalconAPI.Store(proc, 3, column);
            HalconAPI.Store(proc, 4, phi);
            HalconAPI.Store(proc, 5, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a metrology model to a file.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteMetrologyModel(HTuple metrologyHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(797);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a metrology model from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        public static void ReadMetrologyModel(HTuple fileName, out HTuple metrologyHandle)
        {
            IntPtr proc = HalconAPI.PreCall(798);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out metrologyHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Copy a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: "all"</param>
        /// <param name="copiedMetrologyHandle">Handle of the copied metrology model.</param>
        public static void CopyMetrologyModel(
          HTuple metrologyHandle,
          HTuple index,
          out HTuple copiedMetrologyHandle)
        {
            IntPtr proc = HalconAPI.PreCall(799);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out copiedMetrologyHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Copy metrology metrology objects of a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: "all"</param>
        /// <param name="copiedIndices">Indices of the copied metrology objects.</param>
        public static void CopyMetrologyObject(
          HTuple metrologyHandle,
          HTuple index,
          out HTuple copiedIndices)
        {
            IntPtr proc = HalconAPI.PreCall(800);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out copiedIndices);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the number of instances of the metrology objects of a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: 0</param>
        /// <param name="numInstances">Number of Instances of the metrology objects.</param>
        public static void GetMetrologyObjectNumInstances(
          HTuple metrologyHandle,
          HTuple index,
          out HTuple numInstances)
        {
            IntPtr proc = HalconAPI.PreCall(801);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out numInstances);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the results of the measurement of a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology object. Default: "all"</param>
        /// <param name="instance">Instance of the metrology object. Default: "all"</param>
        /// <param name="genParamName">Name of the generic parameter. Default: "result_type"</param>
        /// <param name="genParamValue">Value of the generic parameter. Default: "all_param"</param>
        /// <param name="parameter">Result values.</param>
        public static void GetMetrologyObjectResult(
          HTuple metrologyHandle,
          HTuple index,
          HTuple instance,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple parameter)
        {
            IntPtr proc = HalconAPI.PreCall(802);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, instance);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(instance);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, err, out parameter);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the measure regions and the results of the edge location for the metrology objects of a metrology model.</summary>
        /// <param name="contours">Rectangular XLD Contours of measure regions.</param>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: "all"</param>
        /// <param name="transition">Select light/dark or dark/light edges. Default: "all"</param>
        /// <param name="row">Row coordinates of the measured edges.</param>
        /// <param name="column">Column coordinates of the measured edges.</param>
        public static void GetMetrologyObjectMeasures(
          out HObject contours,
          HTuple metrologyHandle,
          HTuple index,
          HTuple transition,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(803);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, transition);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(transition);
            int err2 = HObject.LoadNew(proc, 1, err1, out contours);
            int err3 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err3, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Measure and fit the geometric shapes of all metrology objects of a metrology model.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        public static void ApplyMetrologyModel(HObject image, HTuple metrologyHandle)
        {
            IntPtr proc = HalconAPI.PreCall(804);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, metrologyHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Get the indices of the metrology objects of a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="indices">Indices of the metrology objects.</param>
        public static void GetMetrologyObjectIndices(HTuple metrologyHandle, out HTuple indices)
        {
            IntPtr proc = HalconAPI.PreCall(805);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out indices);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Reset all fuzzy parameters and fuzzy functions of a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: "all"</param>
        public static void ResetMetrologyObjectFuzzyParam(HTuple metrologyHandle, HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(806);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Reset all parameters of a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: "all"</param>
        public static void ResetMetrologyObjectParam(HTuple metrologyHandle, HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(807);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get a fuzzy parameter of a metroloy model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: 0</param>
        /// <param name="genParamName">Names of the generic parameters. Default: "fuzzy_thresh"</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        public static void GetMetrologyObjectFuzzyParam(
          HTuple metrologyHandle,
          HTuple index,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(808);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get one or several parameters of a metroloy model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: "all"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: "num_measures"</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        public static void GetMetrologyObjectParam(
          HTuple metrologyHandle,
          HTuple index,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(809);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set fuzzy parameters or fuzzy functions for a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: "all"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: "fuzzy_thresh"</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: 0.5</param>
        public static void SetMetrologyObjectFuzzyParam(
          HTuple metrologyHandle,
          HTuple index,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(810);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters for the metrology objects of a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: "all"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: "num_instances"</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: 1</param>
        public static void SetMetrologyObjectParam(
          HTuple metrologyHandle,
          HTuple index,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(811);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a rectangle to a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="row">Row (or Y) coordinate of the center of the rectangle.</param>
        /// <param name="column">Column (or X) coordinate of the center of the rectangle.</param>
        /// <param name="phi">Orientation of the main axis [rad].</param>
        /// <param name="length1">Length of the larger half edge of the rectangle.</param>
        /// <param name="length2">Length of the smaller half edge of the rectangle.</param>
        /// <param name="measureLength1">Half length of the measure regions perpendicular to the boundary. Default: 20.0</param>
        /// <param name="measureLength2">Half length of the measure regions tangetial to the boundary. Default: 5.0</param>
        /// <param name="measureSigma">Sigma of the Gaussian function for the smoothing. Default: 1.0</param>
        /// <param name="measureThreshold">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="index">Index of the created metrology object.</param>
        public static void AddMetrologyObjectRectangle2Measure(
          HTuple metrologyHandle,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple length1,
          HTuple length2,
          HTuple measureLength1,
          HTuple measureLength2,
          HTuple measureSigma,
          HTuple measureThreshold,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(812);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, phi);
            HalconAPI.Store(proc, 4, length1);
            HalconAPI.Store(proc, 5, length2);
            HalconAPI.Store(proc, 6, measureLength1);
            HalconAPI.Store(proc, 7, measureLength2);
            HalconAPI.Store(proc, 8, measureSigma);
            HalconAPI.Store(proc, 9, measureThreshold);
            HalconAPI.Store(proc, 10, genParamName);
            HalconAPI.Store(proc, 11, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(length1);
            HalconAPI.UnpinTuple(length2);
            HalconAPI.UnpinTuple(measureLength1);
            HalconAPI.UnpinTuple(measureLength2);
            HalconAPI.UnpinTuple(measureSigma);
            HalconAPI.UnpinTuple(measureThreshold);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a line to a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="rowBegin">Row (or Y) coordinate of the start of the line.</param>
        /// <param name="columnBegin">Column (or X) coordinate of the start of the line.</param>
        /// <param name="rowEnd">Row (or Y) coordinate of the end of the line.</param>
        /// <param name="columnEnd">Column (or X) coordinate of the end of the line.</param>
        /// <param name="measureLength1">Half length of the measure regions perpendicular to the boundary. Default: 20.0</param>
        /// <param name="measureLength2">Half length of the measure regions tangetial to the boundary. Default: 5.0</param>
        /// <param name="measureSigma">Sigma of the Gaussian function for the smoothing. Default: 1.0</param>
        /// <param name="measureThreshold">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="index">Index of the created metrology object.</param>
        public static void AddMetrologyObjectLineMeasure(
          HTuple metrologyHandle,
          HTuple rowBegin,
          HTuple columnBegin,
          HTuple rowEnd,
          HTuple columnEnd,
          HTuple measureLength1,
          HTuple measureLength2,
          HTuple measureSigma,
          HTuple measureThreshold,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(813);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, rowBegin);
            HalconAPI.Store(proc, 2, columnBegin);
            HalconAPI.Store(proc, 3, rowEnd);
            HalconAPI.Store(proc, 4, columnEnd);
            HalconAPI.Store(proc, 5, measureLength1);
            HalconAPI.Store(proc, 6, measureLength2);
            HalconAPI.Store(proc, 7, measureSigma);
            HalconAPI.Store(proc, 8, measureThreshold);
            HalconAPI.Store(proc, 9, genParamName);
            HalconAPI.Store(proc, 10, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(rowBegin);
            HalconAPI.UnpinTuple(columnBegin);
            HalconAPI.UnpinTuple(rowEnd);
            HalconAPI.UnpinTuple(columnEnd);
            HalconAPI.UnpinTuple(measureLength1);
            HalconAPI.UnpinTuple(measureLength2);
            HalconAPI.UnpinTuple(measureSigma);
            HalconAPI.UnpinTuple(measureThreshold);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add an ellipse or an elliptic arc to a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="row">Row (or Y) coordinate of the center of the ellipse.</param>
        /// <param name="column">Column (or X) coordinate of the center of the ellipse.</param>
        /// <param name="phi">Orientation of the main axis [rad].</param>
        /// <param name="radius1">Length of the larger half axis.</param>
        /// <param name="radius2">Length of the smaller half axis.</param>
        /// <param name="measureLength1">Half length of the measure regions perpendicular to the boundary. Default: 20.0</param>
        /// <param name="measureLength2">Half length of the measure regions tangetial to the boundary. Default: 5.0</param>
        /// <param name="measureSigma">Sigma of the Gaussian function for the smoothing. Default: 1.0</param>
        /// <param name="measureThreshold">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="index">Index of the created metrology object.</param>
        public static void AddMetrologyObjectEllipseMeasure(
          HTuple metrologyHandle,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple radius1,
          HTuple radius2,
          HTuple measureLength1,
          HTuple measureLength2,
          HTuple measureSigma,
          HTuple measureThreshold,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(814);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, phi);
            HalconAPI.Store(proc, 4, radius1);
            HalconAPI.Store(proc, 5, radius2);
            HalconAPI.Store(proc, 6, measureLength1);
            HalconAPI.Store(proc, 7, measureLength2);
            HalconAPI.Store(proc, 8, measureSigma);
            HalconAPI.Store(proc, 9, measureThreshold);
            HalconAPI.Store(proc, 10, genParamName);
            HalconAPI.Store(proc, 11, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(radius1);
            HalconAPI.UnpinTuple(radius2);
            HalconAPI.UnpinTuple(measureLength1);
            HalconAPI.UnpinTuple(measureLength2);
            HalconAPI.UnpinTuple(measureSigma);
            HalconAPI.UnpinTuple(measureThreshold);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a circle or a circular arc to a metrology model.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="row">Row coordinate (or Y) of the center of the circle or circular arc.</param>
        /// <param name="column">Column (or X) coordinate of the center of the circle or circular arc.</param>
        /// <param name="radius">Radius of the circle or circular arc.</param>
        /// <param name="measureLength1">Half length of the measure regions perpendicular to the boundary. Default: 20.0</param>
        /// <param name="measureLength2">Half length of the measure regions tangetial to the boundary. Default: 5.0</param>
        /// <param name="measureSigma">Sigma of the Gaussian function for the smoothing. Default: 1.0</param>
        /// <param name="measureThreshold">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="index">Index of the created metrology object.</param>
        public static void AddMetrologyObjectCircleMeasure(
          HTuple metrologyHandle,
          HTuple row,
          HTuple column,
          HTuple radius,
          HTuple measureLength1,
          HTuple measureLength2,
          HTuple measureSigma,
          HTuple measureThreshold,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(815);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, radius);
            HalconAPI.Store(proc, 4, measureLength1);
            HalconAPI.Store(proc, 5, measureLength2);
            HalconAPI.Store(proc, 6, measureSigma);
            HalconAPI.Store(proc, 7, measureThreshold);
            HalconAPI.Store(proc, 8, genParamName);
            HalconAPI.Store(proc, 9, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(measureLength1);
            HalconAPI.UnpinTuple(measureLength2);
            HalconAPI.UnpinTuple(measureSigma);
            HalconAPI.UnpinTuple(measureThreshold);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete all metrology models and free the allocated memory.</summary>
        public static void ClearAllMetrologyModels()
        {
            IntPtr proc = HalconAPI.PreCall(816);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete a metrology model and free the allocated memory.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        public static void ClearMetrologyModel(HTuple metrologyHandle)
        {
            IntPtr proc = HalconAPI.PreCall(817);
            HalconAPI.Store(proc, 0, metrologyHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete metrology objects and free the allocated memory.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="index">Index of the metrology objects. Default: "all"</param>
        public static void ClearMetrologyObject(HTuple metrologyHandle, HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(818);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, index);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the size of the image of metrology objects.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        /// <param name="width">Width of the image to be processed. Default: 640</param>
        /// <param name="height">Height of the image to be processed. Default: 480</param>
        public static void SetMetrologyModelImageSize(
          HTuple metrologyHandle,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(819);
            HalconAPI.Store(proc, 0, metrologyHandle);
            HalconAPI.Store(proc, 1, width);
            HalconAPI.Store(proc, 2, height);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(metrologyHandle);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create the data structure that is needed to measure geometric shapes.</summary>
        /// <param name="metrologyHandle">Handle of the metrology model.</param>
        public static void CreateMetrologyModel(out HTuple metrologyHandle)
        {
            IntPtr proc = HalconAPI.PreCall(820);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out metrologyHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a measure object.</summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeMeasure(HTuple measureHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(821);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized measure object.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="measureHandle">Measure object handle.</param>
        public static void DeserializeMeasure(HTuple serializedItemHandle, out HTuple measureHandle)
        {
            IntPtr proc = HalconAPI.PreCall(822);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out measureHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a measure object to a file.</summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteMeasure(HTuple measureHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(823);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a measure object from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="measureHandle">Measure object handle.</param>
        public static void ReadMeasure(HTuple fileName, out HTuple measureHandle)
        {
            IntPtr proc = HalconAPI.PreCall(824);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out measureHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Extracting points with a particular gray value along a rectangle or an annular arc.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of gaussian smoothing. Default: 1.0</param>
        /// <param name="threshold">Threshold. Default: 128.0</param>
        /// <param name="select">Selection of points. Default: "all"</param>
        /// <param name="rowThresh">Row coordinates of points with threshold value.</param>
        /// <param name="columnThresh">Column coordinates of points with threshold value.</param>
        /// <param name="distance">Distance between consecutive points.</param>
        public static void MeasureThresh(
          HObject image,
          HTuple measureHandle,
          HTuple sigma,
          HTuple threshold,
          HTuple select,
          out HTuple rowThresh,
          out HTuple columnThresh,
          out HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(825);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.Store(proc, 3, select);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(threshold);
            HalconAPI.UnpinTuple(select);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowThresh);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnThresh);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out distance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Delete all measure objects.</summary>
        public static void CloseAllMeasures()
        {
            IntPtr proc = HalconAPI.PreCall(826);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete a measure object.</summary>
        /// <param name="measureHandle">Measure object handle.</param>
        public static void CloseMeasure(HTuple measureHandle)
        {
            IntPtr proc = HalconAPI.PreCall(827);
            HalconAPI.Store(proc, 0, measureHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Extract a gray value profile perpendicular to a rectangle or annular arc.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="grayValues">Gray value profile.</param>
        public static void MeasureProjection(
          HObject image,
          HTuple measureHandle,
          out HTuple grayValues)
        {
            IntPtr proc = HalconAPI.PreCall(828);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out grayValues);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Reset a fuzzy function.</summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="setType">Selection of the fuzzy set. Default: "contrast"</param>
        public static void ResetFuzzyMeasure(HTuple measureHandle, HTuple setType)
        {
            IntPtr proc = HalconAPI.PreCall(829);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.Store(proc, 1, setType);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.UnpinTuple(setType);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Specify a normalized fuzzy function for edge pairs.</summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="pairSize">Favored width of edge pairs. Default: 10.0</param>
        /// <param name="setType">Selection of the fuzzy set. Default: "size_abs_diff"</param>
        /// <param name="function">Fuzzy function.</param>
        public static void SetFuzzyMeasureNormPair(
          HTuple measureHandle,
          HTuple pairSize,
          HTuple setType,
          HTuple function)
        {
            IntPtr proc = HalconAPI.PreCall(830);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.Store(proc, 1, pairSize);
            HalconAPI.Store(proc, 2, setType);
            HalconAPI.Store(proc, 3, function);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.UnpinTuple(pairSize);
            HalconAPI.UnpinTuple(setType);
            HalconAPI.UnpinTuple(function);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Specify a fuzzy function.</summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="setType">Selection of the fuzzy set. Default: "contrast"</param>
        /// <param name="function">Fuzzy function.</param>
        public static void SetFuzzyMeasure(HTuple measureHandle, HTuple setType, HTuple function)
        {
            IntPtr proc = HalconAPI.PreCall(831);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.Store(proc, 1, setType);
            HalconAPI.Store(proc, 2, function);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.UnpinTuple(setType);
            HalconAPI.UnpinTuple(function);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Extract straight edge pairs perpendicular to a rectangle or an annular arc.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of Gaussian smoothing. Default: 1.0</param>
        /// <param name="ampThresh">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="fuzzyThresh">Minimum fuzzy value. Default: 0.5</param>
        /// <param name="transition">Select the first gray value transition of the edge pairs. Default: "all"</param>
        /// <param name="pairing">Constraint of pairing. Default: "no_restriction"</param>
        /// <param name="numPairs">Number of edge pairs. Default: 10</param>
        /// <param name="rowEdgeFirst">Row coordinate of the first edge.</param>
        /// <param name="columnEdgeFirst">Column coordinate of the first edge.</param>
        /// <param name="amplitudeFirst">Edge amplitude of the first edge (with sign).</param>
        /// <param name="rowEdgeSecond">Row coordinate of the second edge.</param>
        /// <param name="columnEdgeSecond">Column coordinate of the second edge.</param>
        /// <param name="amplitudeSecond">Edge amplitude of the second edge (with sign).</param>
        /// <param name="rowPairCenter">Row coordinate of the center of the edge pair.</param>
        /// <param name="columnPairCenter">Column coordinate of the center of the edge pair.</param>
        /// <param name="fuzzyScore">Fuzzy evaluation of the edge pair.</param>
        /// <param name="intraDistance">Distance between the edges of the edge pair.</param>
        public static void FuzzyMeasurePairing(
          HObject image,
          HTuple measureHandle,
          HTuple sigma,
          HTuple ampThresh,
          HTuple fuzzyThresh,
          HTuple transition,
          HTuple pairing,
          HTuple numPairs,
          out HTuple rowEdgeFirst,
          out HTuple columnEdgeFirst,
          out HTuple amplitudeFirst,
          out HTuple rowEdgeSecond,
          out HTuple columnEdgeSecond,
          out HTuple amplitudeSecond,
          out HTuple rowPairCenter,
          out HTuple columnPairCenter,
          out HTuple fuzzyScore,
          out HTuple intraDistance)
        {
            IntPtr proc = HalconAPI.PreCall(832);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.Store(proc, 2, ampThresh);
            HalconAPI.Store(proc, 3, fuzzyThresh);
            HalconAPI.Store(proc, 4, transition);
            HalconAPI.Store(proc, 5, pairing);
            HalconAPI.Store(proc, 6, numPairs);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(ampThresh);
            HalconAPI.UnpinTuple(fuzzyThresh);
            HalconAPI.UnpinTuple(transition);
            HalconAPI.UnpinTuple(pairing);
            HalconAPI.UnpinTuple(numPairs);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowEdgeFirst);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnEdgeFirst);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out amplitudeFirst);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out rowEdgeSecond);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out columnEdgeSecond);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out amplitudeSecond);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out rowPairCenter);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out columnPairCenter);
            int err10 = HTuple.LoadNew(proc, 8, HTupleType.DOUBLE, err9, out fuzzyScore);
            int procResult = HTuple.LoadNew(proc, 9, HTupleType.DOUBLE, err10, out intraDistance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract straight edge pairs perpendicular to a rectangle or an annular arc.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of Gaussian smoothing. Default: 1.0</param>
        /// <param name="ampThresh">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="fuzzyThresh">Minimum fuzzy value. Default: 0.5</param>
        /// <param name="transition">Select the first gray value transition of the edge pairs. Default: "all"</param>
        /// <param name="rowEdgeFirst">Row coordinate of the first edge point.</param>
        /// <param name="columnEdgeFirst">Column coordinate of the first edge point.</param>
        /// <param name="amplitudeFirst">Edge amplitude of the first edge (with sign).</param>
        /// <param name="rowEdgeSecond">Row coordinate of the second edge point.</param>
        /// <param name="columnEdgeSecond">Column coordinate of the second edge point.</param>
        /// <param name="amplitudeSecond">Edge amplitude of the second edge (with sign).</param>
        /// <param name="rowEdgeCenter">Row coordinate of the center of the edge pair.</param>
        /// <param name="columnEdgeCenter">Column coordinate of the center of the edge pair.</param>
        /// <param name="fuzzyScore">Fuzzy evaluation of the edge pair.</param>
        /// <param name="intraDistance">Distance between edges of an edge pair.</param>
        /// <param name="interDistance">Distance between consecutive edge pairs.</param>
        public static void FuzzyMeasurePairs(
          HObject image,
          HTuple measureHandle,
          HTuple sigma,
          HTuple ampThresh,
          HTuple fuzzyThresh,
          HTuple transition,
          out HTuple rowEdgeFirst,
          out HTuple columnEdgeFirst,
          out HTuple amplitudeFirst,
          out HTuple rowEdgeSecond,
          out HTuple columnEdgeSecond,
          out HTuple amplitudeSecond,
          out HTuple rowEdgeCenter,
          out HTuple columnEdgeCenter,
          out HTuple fuzzyScore,
          out HTuple intraDistance,
          out HTuple interDistance)
        {
            IntPtr proc = HalconAPI.PreCall(833);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.Store(proc, 2, ampThresh);
            HalconAPI.Store(proc, 3, fuzzyThresh);
            HalconAPI.Store(proc, 4, transition);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            HalconAPI.InitOCT(proc, 10);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(ampThresh);
            HalconAPI.UnpinTuple(fuzzyThresh);
            HalconAPI.UnpinTuple(transition);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowEdgeFirst);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnEdgeFirst);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out amplitudeFirst);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out rowEdgeSecond);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out columnEdgeSecond);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out amplitudeSecond);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out rowEdgeCenter);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out columnEdgeCenter);
            int err10 = HTuple.LoadNew(proc, 8, HTupleType.DOUBLE, err9, out fuzzyScore);
            int err11 = HTuple.LoadNew(proc, 9, HTupleType.DOUBLE, err10, out intraDistance);
            int procResult = HTuple.LoadNew(proc, 10, HTupleType.DOUBLE, err11, out interDistance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract straight edges perpendicular to a rectangle or an annular arc.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of Gaussian smoothing. Default: 1.0</param>
        /// <param name="ampThresh">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="fuzzyThresh">Minimum fuzzy value. Default: 0.5</param>
        /// <param name="transition">Select light/dark or dark/light edges. Default: "all"</param>
        /// <param name="rowEdge">Row coordinate of the edge point.</param>
        /// <param name="columnEdge">Column coordinate of the edge point.</param>
        /// <param name="amplitude">Edge amplitude of the edge (with sign).</param>
        /// <param name="fuzzyScore">Fuzzy evaluation of the edges.</param>
        /// <param name="distance">Distance between consecutive edges.</param>
        public static void FuzzyMeasurePos(
          HObject image,
          HTuple measureHandle,
          HTuple sigma,
          HTuple ampThresh,
          HTuple fuzzyThresh,
          HTuple transition,
          out HTuple rowEdge,
          out HTuple columnEdge,
          out HTuple amplitude,
          out HTuple fuzzyScore,
          out HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(834);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.Store(proc, 2, ampThresh);
            HalconAPI.Store(proc, 3, fuzzyThresh);
            HalconAPI.Store(proc, 4, transition);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(ampThresh);
            HalconAPI.UnpinTuple(fuzzyThresh);
            HalconAPI.UnpinTuple(transition);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowEdge);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnEdge);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out amplitude);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out fuzzyScore);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out distance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract straight edge pairs perpendicular to a rectangle or annular arc.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of gaussian smoothing. Default: 1.0</param>
        /// <param name="threshold">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="transition">Type of gray value transition that determines how edges are grouped to edge pairs. Default: "all"</param>
        /// <param name="select">Selection of edge pairs. Default: "all"</param>
        /// <param name="rowEdgeFirst">Row coordinate of the center of the first edge.</param>
        /// <param name="columnEdgeFirst">Column coordinate of the center of the first edge.</param>
        /// <param name="amplitudeFirst">Edge amplitude of the first edge (with sign).</param>
        /// <param name="rowEdgeSecond">Row coordinate of the center of the second edge.</param>
        /// <param name="columnEdgeSecond">Column coordinate of the center of the second edge.</param>
        /// <param name="amplitudeSecond">Edge amplitude of the second edge (with sign).</param>
        /// <param name="intraDistance">Distance between edges of an edge pair.</param>
        /// <param name="interDistance">Distance between consecutive edge pairs.</param>
        public static void MeasurePairs(
          HObject image,
          HTuple measureHandle,
          HTuple sigma,
          HTuple threshold,
          HTuple transition,
          HTuple select,
          out HTuple rowEdgeFirst,
          out HTuple columnEdgeFirst,
          out HTuple amplitudeFirst,
          out HTuple rowEdgeSecond,
          out HTuple columnEdgeSecond,
          out HTuple amplitudeSecond,
          out HTuple intraDistance,
          out HTuple interDistance)
        {
            IntPtr proc = HalconAPI.PreCall(835);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.Store(proc, 3, transition);
            HalconAPI.Store(proc, 4, select);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(threshold);
            HalconAPI.UnpinTuple(transition);
            HalconAPI.UnpinTuple(select);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowEdgeFirst);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnEdgeFirst);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out amplitudeFirst);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out rowEdgeSecond);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out columnEdgeSecond);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out amplitudeSecond);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out intraDistance);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out interDistance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract straight edges perpendicular to a rectangle or annular arc.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of gaussian smoothing. Default: 1.0</param>
        /// <param name="threshold">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="transition">Light/dark or dark/light edge. Default: "all"</param>
        /// <param name="select">Selection of end points. Default: "all"</param>
        /// <param name="rowEdge">Row coordinate of the center of the edge.</param>
        /// <param name="columnEdge">Column coordinate of the center of the edge.</param>
        /// <param name="amplitude">Edge amplitude of the edge (with sign).</param>
        /// <param name="distance">Distance between consecutive edges.</param>
        public static void MeasurePos(
          HObject image,
          HTuple measureHandle,
          HTuple sigma,
          HTuple threshold,
          HTuple transition,
          HTuple select,
          out HTuple rowEdge,
          out HTuple columnEdge,
          out HTuple amplitude,
          out HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(836);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.Store(proc, 3, transition);
            HalconAPI.Store(proc, 4, select);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(threshold);
            HalconAPI.UnpinTuple(transition);
            HalconAPI.UnpinTuple(select);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowEdge);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnEdge);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out amplitude);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out distance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Translate a measure object.</summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="row">Row coordinate of the new reference point. Default: 50.0</param>
        /// <param name="column">Column coordinate of the new reference point. Default: 100.0</param>
        public static void TranslateMeasure(HTuple measureHandle, HTuple row, HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(837);
            HalconAPI.Store(proc, 0, measureHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(measureHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Prepare the extraction of straight edges perpendicular to an annular arc.</summary>
        /// <param name="centerRow">Row coordinate of the center of the arc. Default: 100.0</param>
        /// <param name="centerCol">Column coordinate of the center of the arc. Default: 100.0</param>
        /// <param name="radius">Radius of the arc. Default: 50.0</param>
        /// <param name="angleStart">Start angle of the arc in radians. Default: 0.0</param>
        /// <param name="angleExtent">Angular extent of the arc in radians. Default: 6.28318</param>
        /// <param name="annulusRadius">Radius (half width) of the annulus. Default: 10.0</param>
        /// <param name="width">Width of the image to be processed subsequently. Default: 512</param>
        /// <param name="height">Height of the image to be processed subsequently. Default: 512</param>
        /// <param name="interpolation">Type of interpolation to be used. Default: "nearest_neighbor"</param>
        /// <param name="measureHandle">Measure object handle.</param>
        public static void GenMeasureArc(
          HTuple centerRow,
          HTuple centerCol,
          HTuple radius,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple annulusRadius,
          HTuple width,
          HTuple height,
          HTuple interpolation,
          out HTuple measureHandle)
        {
            IntPtr proc = HalconAPI.PreCall(838);
            HalconAPI.Store(proc, 0, centerRow);
            HalconAPI.Store(proc, 1, centerCol);
            HalconAPI.Store(proc, 2, radius);
            HalconAPI.Store(proc, 3, angleStart);
            HalconAPI.Store(proc, 4, angleExtent);
            HalconAPI.Store(proc, 5, annulusRadius);
            HalconAPI.Store(proc, 6, width);
            HalconAPI.Store(proc, 7, height);
            HalconAPI.Store(proc, 8, interpolation);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(centerRow);
            HalconAPI.UnpinTuple(centerCol);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(annulusRadius);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out measureHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Prepare the extraction of straight edges perpendicular to a rectangle.</summary>
        /// <param name="row">Row coordinate of the center of the rectangle. Default: 300.0</param>
        /// <param name="column">Column coordinate of the center of the rectangle. Default: 200.0</param>
        /// <param name="phi">Angle of longitudinal axis of the rectangle to horizontal (radians). Default: 0.0</param>
        /// <param name="length1">Half width of the rectangle. Default: 100.0</param>
        /// <param name="length2">Half height of the rectangle. Default: 20.0</param>
        /// <param name="width">Width of the image to be processed subsequently. Default: 512</param>
        /// <param name="height">Height of the image to be processed subsequently. Default: 512</param>
        /// <param name="interpolation">Type of interpolation to be used. Default: "nearest_neighbor"</param>
        /// <param name="measureHandle">Measure object handle.</param>
        public static void GenMeasureRectangle2(
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple length1,
          HTuple length2,
          HTuple width,
          HTuple height,
          HTuple interpolation,
          out HTuple measureHandle)
        {
            IntPtr proc = HalconAPI.PreCall(839);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, phi);
            HalconAPI.Store(proc, 3, length1);
            HalconAPI.Store(proc, 4, length2);
            HalconAPI.Store(proc, 5, width);
            HalconAPI.Store(proc, 6, height);
            HalconAPI.Store(proc, 7, interpolation);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(length1);
            HalconAPI.UnpinTuple(length2);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out measureHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized matrix.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="matrixID">Matrix handle.</param>
        public static void DeserializeMatrix(HTuple serializedItemHandle, out HTuple matrixID)
        {
            IntPtr proc = HalconAPI.PreCall(840);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a matrix.</summary>
        /// <param name="matrixID">Matrix handle.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeMatrix(HTuple matrixID, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(841);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a matrix from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="matrixID">Matrix handle.</param>
        public static void ReadMatrix(HTuple fileName, out HTuple matrixID)
        {
            IntPtr proc = HalconAPI.PreCall(842);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a matrix to a file.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="fileFormat">Format of the file. Default: "binary"</param>
        /// <param name="fileName">File name.</param>
        public static void WriteMatrix(HTuple matrixID, HTuple fileFormat, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(843);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, fileFormat);
            HalconAPI.Store(proc, 2, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(fileFormat);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Perform an orthogonal decomposition of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="decompositionType">Method of decomposition. Default: "qr"</param>
        /// <param name="outputMatricesType">Type of output matrices. Default: "full"</param>
        /// <param name="computeOrthogonal">Computation of the orthogonal matrix. Default: "true"</param>
        /// <param name="matrixOrthogonalID">Matrix handle with the orthogonal part of the decomposed input matrix.</param>
        /// <param name="matrixTriangularID">Matrix handle with the triangular part of the decomposed input matrix.</param>
        public static void OrthogonalDecomposeMatrix(
          HTuple matrixID,
          HTuple decompositionType,
          HTuple outputMatricesType,
          HTuple computeOrthogonal,
          out HTuple matrixOrthogonalID,
          out HTuple matrixTriangularID)
        {
            IntPtr proc = HalconAPI.PreCall(844);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, decompositionType);
            HalconAPI.Store(proc, 2, outputMatricesType);
            HalconAPI.Store(proc, 3, computeOrthogonal);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(decompositionType);
            HalconAPI.UnpinTuple(outputMatricesType);
            HalconAPI.UnpinTuple(computeOrthogonal);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out matrixOrthogonalID);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out matrixTriangularID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Decompose a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="matrixType">Type of the input matrix. Default: "general"</param>
        /// <param name="matrix1ID">Matrix handle with the output matrix 1.</param>
        /// <param name="matrix2ID">Matrix handle with the output matrix 2.</param>
        public static void DecomposeMatrix(
          HTuple matrixID,
          HTuple matrixType,
          out HTuple matrix1ID,
          out HTuple matrix2ID)
        {
            IntPtr proc = HalconAPI.PreCall(845);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, matrixType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(matrixType);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out matrix1ID);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out matrix2ID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the singular value decomposition of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="SVDType">Type of computation. Default: "full"</param>
        /// <param name="computeSingularVectors">Computation of singular values. Default: "both"</param>
        /// <param name="matrixUID">Matrix handle with the left singular vectors.</param>
        /// <param name="matrixSID">Matrix handle with singular values.</param>
        /// <param name="matrixVID">Matrix handle with the right singular vectors.</param>
        public static void SvdMatrix(
          HTuple matrixID,
          HTuple SVDType,
          HTuple computeSingularVectors,
          out HTuple matrixUID,
          out HTuple matrixSID,
          out HTuple matrixVID)
        {
            IntPtr proc = HalconAPI.PreCall(846);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, SVDType);
            HalconAPI.Store(proc, 2, computeSingularVectors);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(SVDType);
            HalconAPI.UnpinTuple(computeSingularVectors);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out matrixUID);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out matrixSID);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out matrixVID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the generalized eigenvalues and optionally the generalized eigenvectors of general matrices.</summary>
        /// <param name="matrixAID">Matrix handle of the input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the input matrix B.</param>
        /// <param name="computeEigenvectors">Computation of the eigenvectors. Default: "none"</param>
        /// <param name="eigenvaluesRealID">Matrix handle with the real parts of the eigenvalues.</param>
        /// <param name="eigenvaluesImagID">Matrix handle with the imaginary parts of the eigenvalues.</param>
        /// <param name="eigenvectorsRealID">Matrix handle with the real parts of the eigenvectors.</param>
        /// <param name="eigenvectorsImagID">Matrix handle with the imaginary parts of the eigenvectors.</param>
        public static void GeneralizedEigenvaluesGeneralMatrix(
          HTuple matrixAID,
          HTuple matrixBID,
          HTuple computeEigenvectors,
          out HTuple eigenvaluesRealID,
          out HTuple eigenvaluesImagID,
          out HTuple eigenvectorsRealID,
          out HTuple eigenvectorsImagID)
        {
            IntPtr proc = HalconAPI.PreCall(847);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            HalconAPI.Store(proc, 2, computeEigenvectors);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            HalconAPI.UnpinTuple(computeEigenvectors);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out eigenvaluesRealID);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out eigenvaluesImagID);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out eigenvectorsRealID);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out eigenvectorsImagID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the generalized eigenvalues and optionally generalized eigenvectors of symmetric input matrices.</summary>
        /// <param name="matrixAID">Matrix handle of the symmetric input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the symmetric positive definite input matrix B.</param>
        /// <param name="computeEigenvectors">Computation of the eigenvectors. Default: "false"</param>
        /// <param name="eigenvaluesID">Matrix handle with the eigenvalues.</param>
        /// <param name="eigenvectorsID">Matrix handle with the eigenvectors.</param>
        public static void GeneralizedEigenvaluesSymmetricMatrix(
          HTuple matrixAID,
          HTuple matrixBID,
          HTuple computeEigenvectors,
          out HTuple eigenvaluesID,
          out HTuple eigenvectorsID)
        {
            IntPtr proc = HalconAPI.PreCall(848);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            HalconAPI.Store(proc, 2, computeEigenvectors);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            HalconAPI.UnpinTuple(computeEigenvectors);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out eigenvaluesID);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out eigenvectorsID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the eigenvalues and optionally the eigenvectors of a general matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="computeEigenvectors">Computation of the eigenvectors. Default: "none"</param>
        /// <param name="eigenvaluesRealID">Matrix handle with the real parts of the eigenvalues.</param>
        /// <param name="eigenvaluesImagID">Matrix handle with the imaginary parts of the eigenvalues.</param>
        /// <param name="eigenvectorsRealID">Matrix handle with the real parts of the eigenvectors.</param>
        /// <param name="eigenvectorsImagID">Matrix handle with the imaginary parts of the eigenvectors.</param>
        public static void EigenvaluesGeneralMatrix(
          HTuple matrixID,
          HTuple computeEigenvectors,
          out HTuple eigenvaluesRealID,
          out HTuple eigenvaluesImagID,
          out HTuple eigenvectorsRealID,
          out HTuple eigenvectorsImagID)
        {
            IntPtr proc = HalconAPI.PreCall(849);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, computeEigenvectors);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(computeEigenvectors);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out eigenvaluesRealID);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out eigenvaluesImagID);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out eigenvectorsRealID);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out eigenvectorsImagID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the eigenvalues and optionally eigenvectors of a symmetric matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="computeEigenvectors">Computation of the eigenvectors. Default: "false"</param>
        /// <param name="eigenvaluesID">Matrix handle with the eigenvalues.</param>
        /// <param name="eigenvectorsID">Matrix handle with the eigenvectors.</param>
        public static void EigenvaluesSymmetricMatrix(
          HTuple matrixID,
          HTuple computeEigenvectors,
          out HTuple eigenvaluesID,
          out HTuple eigenvectorsID)
        {
            IntPtr proc = HalconAPI.PreCall(850);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, computeEigenvectors);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(computeEigenvectors);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out eigenvaluesID);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out eigenvectorsID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the solution of a system of equations.</summary>
        /// <param name="matrixLHSID">Matrix handle of the input matrix of the left hand side.</param>
        /// <param name="matrixLHSType">The type of the input matrix of the left hand side. Default: "general"</param>
        /// <param name="epsilon">Type of solving and limitation to set singular values to be 0. Default: 0.0</param>
        /// <param name="matrixRHSID">Matrix handle of the input matrix of right hand side.</param>
        /// <param name="matrixResultID">New matrix handle with the solution.</param>
        public static void SolveMatrix(
          HTuple matrixLHSID,
          HTuple matrixLHSType,
          HTuple epsilon,
          HTuple matrixRHSID,
          out HTuple matrixResultID)
        {
            IntPtr proc = HalconAPI.PreCall(851);
            HalconAPI.Store(proc, 0, matrixLHSID);
            HalconAPI.Store(proc, 1, matrixLHSType);
            HalconAPI.Store(proc, 2, epsilon);
            HalconAPI.Store(proc, 3, matrixRHSID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixLHSID);
            HalconAPI.UnpinTuple(matrixLHSType);
            HalconAPI.UnpinTuple(epsilon);
            HalconAPI.UnpinTuple(matrixRHSID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixResultID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the determinant of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="matrixType">The type of the input matrix. Default: "general"</param>
        /// <param name="value">Determinant of the input matrix.</param>
        public static void DeterminantMatrix(HTuple matrixID, HTuple matrixType, out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(852);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, matrixType);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(matrixType);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Invert a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="matrixType">The type of the input matrix. Default: "general"</param>
        /// <param name="epsilon">Type of inversion. Default: 0.0</param>
        public static void InvertMatrixMod(HTuple matrixID, HTuple matrixType, HTuple epsilon)
        {
            IntPtr proc = HalconAPI.PreCall(853);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, matrixType);
            HalconAPI.Store(proc, 2, epsilon);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(matrixType);
            HalconAPI.UnpinTuple(epsilon);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Invert a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="matrixType">The type of the input matrix. Default: "general"</param>
        /// <param name="epsilon">Type of inversion. Default: 0.0</param>
        /// <param name="matrixInvID">Matrix handle with the inverse matrix.</param>
        public static void InvertMatrix(
          HTuple matrixID,
          HTuple matrixType,
          HTuple epsilon,
          out HTuple matrixInvID)
        {
            IntPtr proc = HalconAPI.PreCall(854);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, matrixType);
            HalconAPI.Store(proc, 2, epsilon);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(matrixType);
            HalconAPI.UnpinTuple(epsilon);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixInvID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transpose a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        public static void TransposeMatrixMod(HTuple matrixID)
        {
            IntPtr proc = HalconAPI.PreCall(855);
            HalconAPI.Store(proc, 0, matrixID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transpose a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="matrixTransposedID">Matrix handle with the transpose of the input matrix.</param>
        public static void TransposeMatrix(HTuple matrixID, out HTuple matrixTransposedID)
        {
            IntPtr proc = HalconAPI.PreCall(856);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixTransposedID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Returns the elementwise maximum of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="maxType">Type of maximum determination. Default: "columns"</param>
        /// <param name="matrixMaxID">Matrix handle with the maximum values of the input matrix.</param>
        public static void MaxMatrix(HTuple matrixID, HTuple maxType, out HTuple matrixMaxID)
        {
            IntPtr proc = HalconAPI.PreCall(857);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, maxType);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(maxType);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixMaxID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Returns the elementwise minimum of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="minType">Type of minimum determination. Default: "columns"</param>
        /// <param name="matrixMinID">Matrix handle with the minimum values of the input matrix.</param>
        public static void MinMatrix(HTuple matrixID, HTuple minType, out HTuple matrixMinID)
        {
            IntPtr proc = HalconAPI.PreCall(858);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, minType);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(minType);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixMinID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the power functions of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="matrixType">The type of the input matrix. Default: "general"</param>
        /// <param name="power">The power. Default: 2.0</param>
        public static void PowMatrixMod(HTuple matrixID, HTuple matrixType, HTuple power)
        {
            IntPtr proc = HalconAPI.PreCall(859);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, matrixType);
            HalconAPI.Store(proc, 2, power);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(matrixType);
            HalconAPI.UnpinTuple(power);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the power functions of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="matrixType">The type of the input matrix. Default: "general"</param>
        /// <param name="power">The power. Default: 2.0</param>
        /// <param name="matrixPowID">Matrix handle with the raised powered matrix.</param>
        public static void PowMatrix(
          HTuple matrixID,
          HTuple matrixType,
          HTuple power,
          out HTuple matrixPowID)
        {
            IntPtr proc = HalconAPI.PreCall(860);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, matrixType);
            HalconAPI.Store(proc, 2, power);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(matrixType);
            HalconAPI.UnpinTuple(power);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixPowID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the power functions of the elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix of the base.</param>
        /// <param name="matrixExpID">Matrix handle of the input matrix with exponents.</param>
        public static void PowElementMatrixMod(HTuple matrixID, HTuple matrixExpID)
        {
            IntPtr proc = HalconAPI.PreCall(861);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, matrixExpID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(matrixExpID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the power functions of the elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix of the base.</param>
        /// <param name="matrixExpID">Matrix handle of the input matrix with exponents.</param>
        /// <param name="matrixPowID">Matrix handle with the raised power of the input matrix.</param>
        public static void PowElementMatrix(
          HTuple matrixID,
          HTuple matrixExpID,
          out HTuple matrixPowID)
        {
            IntPtr proc = HalconAPI.PreCall(862);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, matrixExpID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(matrixExpID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixPowID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the power functions of the elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="power">The power. Default: 2.0</param>
        public static void PowScalarElementMatrixMod(HTuple matrixID, HTuple power)
        {
            IntPtr proc = HalconAPI.PreCall(863);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, power);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(power);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the power functions of the elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="power">The power. Default: 2.0</param>
        /// <param name="matrixPowID">Matrix handle with the raised power of the input matrix.</param>
        public static void PowScalarElementMatrix(
          HTuple matrixID,
          HTuple power,
          out HTuple matrixPowID)
        {
            IntPtr proc = HalconAPI.PreCall(864);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, power);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(power);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixPowID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the square root values of the elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        public static void SqrtMatrixMod(HTuple matrixID)
        {
            IntPtr proc = HalconAPI.PreCall(865);
            HalconAPI.Store(proc, 0, matrixID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the square root values of the elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="matrixSqrtID">Matrix handle with the square root values of the input matrix.</param>
        public static void SqrtMatrix(HTuple matrixID, out HTuple matrixSqrtID)
        {
            IntPtr proc = HalconAPI.PreCall(866);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixSqrtID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the absolute values of the elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        public static void AbsMatrixMod(HTuple matrixID)
        {
            IntPtr proc = HalconAPI.PreCall(867);
            HalconAPI.Store(proc, 0, matrixID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the absolute values of the elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="matrixAbsID">Matrix handle with the absolute values of the input matrix.</param>
        public static void AbsMatrix(HTuple matrixID, out HTuple matrixAbsID)
        {
            IntPtr proc = HalconAPI.PreCall(868);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixAbsID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Norm of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="normType">Type of norm. Default: "2-norm"</param>
        /// <param name="value">Norm of the input matrix.</param>
        public static void NormMatrix(HTuple matrixID, HTuple normType, out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(869);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, normType);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(normType);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Returns the elementwise mean of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="meanType">Type of mean determination. Default: "columns"</param>
        /// <param name="matrixMeanID">Matrix handle with the mean values of the input matrix.</param>
        public static void MeanMatrix(HTuple matrixID, HTuple meanType, out HTuple matrixMeanID)
        {
            IntPtr proc = HalconAPI.PreCall(870);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, meanType);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(meanType);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixMeanID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Returns the elementwise sum of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="sumType">Type of summation. Default: "columns"</param>
        /// <param name="matrixSumID">Matrix handle with the sum of the input matrix.</param>
        public static void SumMatrix(HTuple matrixID, HTuple sumType, out HTuple matrixSumID)
        {
            IntPtr proc = HalconAPI.PreCall(871);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, sumType);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(sumType);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixSumID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Divide matrices element-by-element.</summary>
        /// <param name="matrixAID">Matrix handle of the input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the input matrix B.</param>
        public static void DivElementMatrixMod(HTuple matrixAID, HTuple matrixBID)
        {
            IntPtr proc = HalconAPI.PreCall(872);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Divide matrices element-by-element.</summary>
        /// <param name="matrixAID">Matrix handle of the input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the input matrix B.</param>
        /// <param name="matrixDivID">Matrix handle with the divided values of input matrices.</param>
        public static void DivElementMatrix(HTuple matrixAID, HTuple matrixBID, out HTuple matrixDivID)
        {
            IntPtr proc = HalconAPI.PreCall(873);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixDivID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Multiply matrices element-by-element.</summary>
        /// <param name="matrixAID">Matrix handle of the input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the input matrix B.</param>
        public static void MultElementMatrixMod(HTuple matrixAID, HTuple matrixBID)
        {
            IntPtr proc = HalconAPI.PreCall(874);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Multiply matrices element-by-element.</summary>
        /// <param name="matrixAID">Matrix handle of the input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the input matrix B.</param>
        /// <param name="matrixMultID">Matrix handle with the multiplied values of the input matrices.</param>
        public static void MultElementMatrix(
          HTuple matrixAID,
          HTuple matrixBID,
          out HTuple matrixMultID)
        {
            IntPtr proc = HalconAPI.PreCall(875);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixMultID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Scale a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="factor">Scale factor. Default: 2.0</param>
        public static void ScaleMatrixMod(HTuple matrixID, HTuple factor)
        {
            IntPtr proc = HalconAPI.PreCall(876);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, factor);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(factor);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Scale a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="factor">Scale factor. Default: 2.0</param>
        /// <param name="matrixScaledID">Matrix handle with the scaled elements.</param>
        public static void ScaleMatrix(HTuple matrixID, HTuple factor, out HTuple matrixScaledID)
        {
            IntPtr proc = HalconAPI.PreCall(877);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, factor);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(factor);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixScaledID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Subtract two matrices.</summary>
        /// <param name="matrixAID">Matrix handle of the input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the input matrix B.</param>
        public static void SubMatrixMod(HTuple matrixAID, HTuple matrixBID)
        {
            IntPtr proc = HalconAPI.PreCall(878);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Subtract two matrices.</summary>
        /// <param name="matrixAID">Matrix handle of the input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the input matrix B.</param>
        /// <param name="matrixSubID">Matrix handle with the difference of the input matrices.</param>
        public static void SubMatrix(HTuple matrixAID, HTuple matrixBID, out HTuple matrixSubID)
        {
            IntPtr proc = HalconAPI.PreCall(879);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixSubID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add two matrices.</summary>
        /// <param name="matrixAID">Matrix handle of the input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the input matrix B.</param>
        public static void AddMatrixMod(HTuple matrixAID, HTuple matrixBID)
        {
            IntPtr proc = HalconAPI.PreCall(880);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add two matrices.</summary>
        /// <param name="matrixAID">Matrix handle of the input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the input matrix B.</param>
        /// <param name="matrixSumID">Matrix handle with the sum of the input matrices.</param>
        public static void AddMatrix(HTuple matrixAID, HTuple matrixBID, out HTuple matrixSumID)
        {
            IntPtr proc = HalconAPI.PreCall(881);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixSumID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Multiply two matrices.</summary>
        /// <param name="matrixAID">Matrix handle of the input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the input matrix B.</param>
        /// <param name="multType">Type of the input matrices. Default: "AB"</param>
        public static void MultMatrixMod(HTuple matrixAID, HTuple matrixBID, HTuple multType)
        {
            IntPtr proc = HalconAPI.PreCall(882);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            HalconAPI.Store(proc, 2, multType);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            HalconAPI.UnpinTuple(multType);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Multiply two matrices.</summary>
        /// <param name="matrixAID">Matrix handle of the input matrix A.</param>
        /// <param name="matrixBID">Matrix handle of the input matrix B.</param>
        /// <param name="multType">Type of the input matrices. Default: "AB"</param>
        /// <param name="matrixMultID">Matrix handle of the multiplied matrices.</param>
        public static void MultMatrix(
          HTuple matrixAID,
          HTuple matrixBID,
          HTuple multType,
          out HTuple matrixMultID)
        {
            IntPtr proc = HalconAPI.PreCall(883);
            HalconAPI.Store(proc, 0, matrixAID);
            HalconAPI.Store(proc, 1, matrixBID);
            HalconAPI.Store(proc, 2, multType);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixAID);
            HalconAPI.UnpinTuple(matrixBID);
            HalconAPI.UnpinTuple(multType);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixMultID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the size of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="rows">Number of rows of the matrix.</param>
        /// <param name="columns">Number of columns of the matrix.</param>
        public static void GetSizeMatrix(HTuple matrixID, out HTuple rows, out HTuple columns)
        {
            IntPtr proc = HalconAPI.PreCall(884);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out rows);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out columns);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Repeat a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="rows">Number of copies of input matrix in row direction. Default: 2</param>
        /// <param name="columns">Number of copies of input matrix in column direction. Default: 2</param>
        /// <param name="matrixRepeatedID">Matrix handle of the repeated copied matrix.</param>
        public static void RepeatMatrix(
          HTuple matrixID,
          HTuple rows,
          HTuple columns,
          out HTuple matrixRepeatedID)
        {
            IntPtr proc = HalconAPI.PreCall(885);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, rows);
            HalconAPI.Store(proc, 2, columns);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(rows);
            HalconAPI.UnpinTuple(columns);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixRepeatedID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Copy a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="matrixCopyID">Matrix handle of the copied matrix.</param>
        public static void CopyMatrix(HTuple matrixID, out HTuple matrixCopyID)
        {
            IntPtr proc = HalconAPI.PreCall(886);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixCopyID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the diagonal elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="vectorID">Matrix handle containing the diagonal elements to be set.</param>
        /// <param name="diagonal">Position of the diagonal. Default: 0</param>
        public static void SetDiagonalMatrix(HTuple matrixID, HTuple vectorID, HTuple diagonal)
        {
            IntPtr proc = HalconAPI.PreCall(887);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, vectorID);
            HalconAPI.Store(proc, 2, diagonal);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(vectorID);
            HalconAPI.UnpinTuple(diagonal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the diagonal elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="diagonal">Number of the desired diagonal. Default: 0</param>
        /// <param name="vectorID">Matrix handle containing the diagonal elements.</param>
        public static void GetDiagonalMatrix(HTuple matrixID, HTuple diagonal, out HTuple vectorID)
        {
            IntPtr proc = HalconAPI.PreCall(888);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, diagonal);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(diagonal);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out vectorID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set a sub-matrix of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="matrixSubID">Matrix handle of the input sub-matrix.</param>
        /// <param name="row">Upper row position of the sub-matrix in the matrix. Default: 0</param>
        /// <param name="column">Left column position of the sub-matrix in the matrix. Default: 0</param>
        public static void SetSubMatrix(
          HTuple matrixID,
          HTuple matrixSubID,
          HTuple row,
          HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(889);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, matrixSubID);
            HalconAPI.Store(proc, 2, row);
            HalconAPI.Store(proc, 3, column);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(matrixSubID);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get a sub-matrix of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="row">Upper row position of the sub-matrix in the input matrix. Default: 0</param>
        /// <param name="column">Left column position of the sub-matrix in the input matrix. Default: 0</param>
        /// <param name="rowsSub">Number of rows of the sub-matrix. Default: 1</param>
        /// <param name="columnsSub">Number of columns of the sub-matrix. Default: 1</param>
        /// <param name="matrixSubID">Matrix handle of the sub-matrix.</param>
        public static void GetSubMatrix(
          HTuple matrixID,
          HTuple row,
          HTuple column,
          HTuple rowsSub,
          HTuple columnsSub,
          out HTuple matrixSubID)
        {
            IntPtr proc = HalconAPI.PreCall(890);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, rowsSub);
            HalconAPI.Store(proc, 4, columnsSub);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(rowsSub);
            HalconAPI.UnpinTuple(columnsSub);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixSubID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set all values of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="values">Values to be set.</param>
        public static void SetFullMatrix(HTuple matrixID, HTuple values)
        {
            IntPtr proc = HalconAPI.PreCall(891);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, values);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(values);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return all values of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="values">Values of the matrix elements.</param>
        public static void GetFullMatrix(HTuple matrixID, out HTuple values)
        {
            IntPtr proc = HalconAPI.PreCall(892);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out values);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set one or more elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="row">Row numbers of the matrix elements to be modified. Default: 0</param>
        /// <param name="column">Column numbers of the matrix elements to be modified. Default: 0</param>
        /// <param name="value">Values to be set in the indicated matrix elements. Default: 0</param>
        public static void SetValueMatrix(HTuple matrixID, HTuple row, HTuple column, HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(893);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, value);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return one ore more elements of a matrix.</summary>
        /// <param name="matrixID">Matrix handle of the input matrix.</param>
        /// <param name="row">Row numbers of matrix elements to be returned. Default: 0</param>
        /// <param name="column">Column numbers of matrix elements to be returned. Default: 0</param>
        /// <param name="value">Values of indicated matrix elements.</param>
        public static void GetValueMatrix(
          HTuple matrixID,
          HTuple row,
          HTuple column,
          out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(894);
            HalconAPI.Store(proc, 0, matrixID);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all matrices from memory.</summary>
        public static void ClearAllMatrices()
        {
            IntPtr proc = HalconAPI.PreCall(895);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a matrix.</summary>
        /// <param name="matrixID">Matrix handle.</param>
        public static void ClearMatrix(HTuple matrixID)
        {
            IntPtr proc = HalconAPI.PreCall(896);
            HalconAPI.Store(proc, 0, matrixID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(matrixID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a matrix.</summary>
        /// <param name="rows">Number of rows of the matrix. Default: 3</param>
        /// <param name="columns">Number of columns of the matrix. Default: 3</param>
        /// <param name="value">Values for initializing the elements of the matrix. Default: 0</param>
        /// <param name="matrixID">Matrix handle.</param>
        public static void CreateMatrix(
          HTuple rows,
          HTuple columns,
          HTuple value,
          out HTuple matrixID)
        {
            IntPtr proc = HalconAPI.PreCall(897);
            HalconAPI.Store(proc, 0, rows);
            HalconAPI.Store(proc, 1, columns);
            HalconAPI.Store(proc, 2, value);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows);
            HalconAPI.UnpinTuple(columns);
            HalconAPI.UnpinTuple(value);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out matrixID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of all sample identifiers.</summary>
        public static void ClearAllSampleIdentifiers()
        {
            IntPtr proc = HalconAPI.PreCall(898);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a sample identifier.</summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        public static void ClearSampleIdentifier(HTuple sampleIdentifier)
        {
            IntPtr proc = HalconAPI.PreCall(899);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized sample identifier.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        public static void DeserializeSampleIdentifier(
          HTuple serializedItemHandle,
          out HTuple sampleIdentifier)
        {
            IntPtr proc = HalconAPI.PreCall(900);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out sampleIdentifier);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a sample identifier from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        public static void ReadSampleIdentifier(HTuple fileName, out HTuple sampleIdentifier)
        {
            IntPtr proc = HalconAPI.PreCall(901);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out sampleIdentifier);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a sample identifier.</summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeSampleIdentifier(
          HTuple sampleIdentifier,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(902);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a sample identifier to a file.</summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteSampleIdentifier(HTuple sampleIdentifier, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(903);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Identify objects with a sample identifier. </summary>
        /// <param name="image">Image showing the object to be identified.</param>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="numResults">Number of suggested object indices. Default: 1</param>
        /// <param name="ratingThreshold">Rating threshold. Default: 0.0</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        /// <param name="objectIdx">Index of the identified object.</param>
        /// <param name="rating">Rating value of the identified object.</param>
        public static void ApplySampleIdentifier(
          HObject image,
          HTuple sampleIdentifier,
          HTuple numResults,
          HTuple ratingThreshold,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple objectIdx,
          out HTuple rating)
        {
            IntPtr proc = HalconAPI.PreCall(904);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, numResults);
            HalconAPI.Store(proc, 2, ratingThreshold);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(numResults);
            HalconAPI.UnpinTuple(ratingThreshold);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out objectIdx);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out rating);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Get selected parameters of a sample identifier.</summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="genParamName">Parameter name. Default: "rating_method"</param>
        /// <param name="genParamValue">Parameter value.</param>
        public static void GetSampleIdentifierParam(
          HTuple sampleIdentifier,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(905);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set selected parameters of a sample identifier.</summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="genParamName">Parameter name. Default: "rating_method"</param>
        /// <param name="genParamValue">Parameter value. Default: "score_single"</param>
        public static void SetSampleIdentifierParam(
          HTuple sampleIdentifier,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(906);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Retrieve information about an object of a sample identifier.</summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="objectIdx">Index of the object for which information is retrieved.</param>
        /// <param name="infoName">Define, for which kind of object information is retrieved. Default: "num_training_objects"</param>
        /// <param name="infoValue">Information about the object.</param>
        public static void GetSampleIdentifierObjectInfo(
          HTuple sampleIdentifier,
          HTuple objectIdx,
          HTuple infoName,
          out HTuple infoValue)
        {
            IntPtr proc = HalconAPI.PreCall(907);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, objectIdx);
            HalconAPI.Store(proc, 2, infoName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(objectIdx);
            HalconAPI.UnpinTuple(infoName);
            int procResult = HTuple.LoadNew(proc, 0, err, out infoValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define a name or a description for an object of a sample identifier.</summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="objectIdx">Index of the object for which information is set.</param>
        /// <param name="infoName">Define, for which kind of object information is set. Default: "training_object_name"</param>
        /// <param name="infoValue">Information about the object.</param>
        public static void SetSampleIdentifierObjectInfo(
          HTuple sampleIdentifier,
          HTuple objectIdx,
          HTuple infoName,
          HTuple infoValue)
        {
            IntPtr proc = HalconAPI.PreCall(908);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, objectIdx);
            HalconAPI.Store(proc, 2, infoName);
            HalconAPI.Store(proc, 3, infoValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(objectIdx);
            HalconAPI.UnpinTuple(infoName);
            HalconAPI.UnpinTuple(infoValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Remove training data from a sample identifier.  </summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="objectIdx">Index of the training object, from which samples should be removed.</param>
        /// <param name="objectSampleIdx">Index of the training sample that should be removed.</param>
        public static void RemoveSampleIdentifierTrainingData(
          HTuple sampleIdentifier,
          HTuple objectIdx,
          HTuple objectSampleIdx)
        {
            IntPtr proc = HalconAPI.PreCall(909);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, objectIdx);
            HalconAPI.Store(proc, 2, objectSampleIdx);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(objectIdx);
            HalconAPI.UnpinTuple(objectSampleIdx);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Remove preparation data from a sample identifier.  </summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="objectIdx">Index of the preparation object, of which samples should be removed.</param>
        /// <param name="objectSampleIdx">Index of the preparation sample that should be removed.</param>
        public static void RemoveSampleIdentifierPreparationData(
          HTuple sampleIdentifier,
          HTuple objectIdx,
          HTuple objectSampleIdx)
        {
            IntPtr proc = HalconAPI.PreCall(910);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, objectIdx);
            HalconAPI.Store(proc, 2, objectSampleIdx);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(objectIdx);
            HalconAPI.UnpinTuple(objectSampleIdx);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train a sample identifier.  </summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="genParamName">Parameter name. Default: []</param>
        /// <param name="genParamValue">Parameter value. Default: []</param>
        public static void TrainSampleIdentifier(
          HTuple sampleIdentifier,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(911);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add training data to an existing sample identifier. </summary>
        /// <param name="sampleImage">Image that shows an object.</param>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="objectIdx">Index of the object visible in the SampleImage.</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        /// <param name="objectSampleIdx">Index of the object sample.</param>
        public static void AddSampleIdentifierTrainingData(
          HObject sampleImage,
          HTuple sampleIdentifier,
          HTuple objectIdx,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple objectSampleIdx)
        {
            IntPtr proc = HalconAPI.PreCall(912);
            HalconAPI.Store(proc, 1, (HObjectBase)sampleImage);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, objectIdx);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(objectIdx);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectSampleIdx);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)sampleImage);
        }

        /// <summary>Adapt the internal data structure of a sample identifier to the objects to be identified.  </summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="removePreparationData">Indicates if the preparation data should be removed. Default: "true"</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        public static void PrepareSampleIdentifier(
          HTuple sampleIdentifier,
          HTuple removePreparationData,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(913);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, removePreparationData);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(removePreparationData);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add preparation data to an existing sample identifier. </summary>
        /// <param name="sampleImage">Image that shows an object.</param>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="objectIdx">Index of the object visible in the SampleImage. Default: "unknown"</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        /// <param name="objectSampleIdx">Index of the object sample.</param>
        public static void AddSampleIdentifierPreparationData(
          HObject sampleImage,
          HTuple sampleIdentifier,
          HTuple objectIdx,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple objectSampleIdx)
        {
            IntPtr proc = HalconAPI.PreCall(914);
            HalconAPI.Store(proc, 1, (HObjectBase)sampleImage);
            HalconAPI.Store(proc, 0, sampleIdentifier);
            HalconAPI.Store(proc, 1, objectIdx);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampleIdentifier);
            HalconAPI.UnpinTuple(objectIdx);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectSampleIdx);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)sampleImage);
        }

        /// <summary>Create a new sample identifier.</summary>
        /// <param name="genParamName">Parameter name. Default: []</param>
        /// <param name="genParamValue">Parameter value. Default: []</param>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        public static void CreateSampleIdentifier(
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple sampleIdentifier)
        {
            IntPtr proc = HalconAPI.PreCall(915);
            HalconAPI.Store(proc, 0, genParamName);
            HalconAPI.Store(proc, 1, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out sampleIdentifier);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized shape model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void DeserializeShapeModel(HTuple serializedItemHandle, out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(916);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a shape model from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void ReadShapeModel(HTuple fileName, out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(917);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a shape model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeShapeModel(HTuple modelID, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(918);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a shape model to a file.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteShapeModel(HTuple modelID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(919);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of all shape models.</summary>
        public static void ClearAllShapeModels()
        {
            IntPtr proc = HalconAPI.PreCall(920);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a shape model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        public static void ClearShapeModel(HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(921);
            HalconAPI.Store(proc, 0, modelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the contour representation of a shape model.</summary>
        /// <param name="modelContours">Contour representation of the shape model.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="level">Pyramid level for which the contour representation should be returned. Default: 1</param>
        public static void GetShapeModelContours(
          out HObject modelContours,
          HTuple modelID,
          HTuple level)
        {
            IntPtr proc = HalconAPI.PreCall(922);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, level);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(level);
            int procResult = HObject.LoadNew(proc, 1, err, out modelContours);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Determine the parameters of a shape model.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleMin">Minimum scale of the model. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the model. Default: 1.1</param>
        /// <param name="optimization">Kind of optimization. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="parameters">Parameters to be determined automatically. Default: "all"</param>
        /// <param name="parameterName">Name of the automatically determined parameter.</param>
        /// <param name="parameterValue">Value of the automatically determined parameter.</param>
        public static void DetermineShapeModelParams(
          HObject template,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple scaleMin,
          HTuple scaleMax,
          HTuple optimization,
          HTuple metric,
          HTuple contrast,
          HTuple minContrast,
          HTuple parameters,
          out HTuple parameterName,
          out HTuple parameterValue)
        {
            IntPtr proc = HalconAPI.PreCall(923);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleMin);
            HalconAPI.Store(proc, 4, scaleMax);
            HalconAPI.Store(proc, 5, optimization);
            HalconAPI.Store(proc, 6, metric);
            HalconAPI.Store(proc, 7, contrast);
            HalconAPI.Store(proc, 8, minContrast);
            HalconAPI.Store(proc, 9, parameters);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleMin);
            HalconAPI.UnpinTuple(scaleMax);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(parameters);
            int err2 = HTuple.LoadNew(proc, 0, err1, out parameterName);
            int procResult = HTuple.LoadNew(proc, 1, err2, out parameterValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Return the parameters of a shape model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="numLevels">Number of pyramid levels.</param>
        /// <param name="angleStart">Smallest rotation of the pattern.</param>
        /// <param name="angleExtent">Extent of the rotation angles.</param>
        /// <param name="angleStep">Step length of the angles (resolution).</param>
        /// <param name="scaleMin">Minimum scale of the pattern.</param>
        /// <param name="scaleMax">Maximum scale of the pattern.</param>
        /// <param name="scaleStep">Scale step length (resolution).</param>
        /// <param name="metric">Match metric.</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images.</param>
        public static void GetShapeModelParams(
          HTuple modelID,
          out HTuple numLevels,
          out HTuple angleStart,
          out HTuple angleExtent,
          out HTuple angleStep,
          out HTuple scaleMin,
          out HTuple scaleMax,
          out HTuple scaleStep,
          out HTuple metric,
          out HTuple minContrast)
        {
            IntPtr proc = HalconAPI.PreCall(924);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out numLevels);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out angleStart);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angleExtent);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out angleStep);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out scaleMin);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out scaleMax);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out scaleStep);
            int err9 = HTuple.LoadNew(proc, 7, err8, out metric);
            int procResult = HTuple.LoadNew(proc, 8, HTupleType.INTEGER, err9, out minContrast);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the origin (reference point) of a shape model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="row">Row coordinate of the origin of the shape model.</param>
        /// <param name="column">Column coordinate of the origin of the shape model.</param>
        public static void GetShapeModelOrigin(HTuple modelID, out HTuple row, out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(925);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the origin (reference point) of a shape model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="row">Row coordinate of the origin of the shape model.</param>
        /// <param name="column">Column coordinate of the origin of the shape model.</param>
        public static void SetShapeModelOrigin(HTuple modelID, HTuple row, HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(926);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find the best matches of multiple anisotropically scaled shape models.</summary>
        /// <param name="image">Input image in which the models should be found.</param>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleRMin">Minimum scale of the models in the row direction. Default: 0.9</param>
        /// <param name="scaleRMax">Maximum scale of the models in the row direction. Default: 1.1</param>
        /// <param name="scaleCMin">Minimum scale of the models in the column direction. Default: 0.9</param>
        /// <param name="scaleCMax">Maximum scale of the models in the column direction. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="scaleR">Scale of the found instances of the models in the row direction.</param>
        /// <param name="scaleC">Scale of the found instances of the models in the column direction.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public static void FindAnisoShapeModels(
          HObject image,
          HTuple modelIDs,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          HTuple greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scaleR,
          out HTuple scaleC,
          out HTuple score,
          out HTuple model)
        {
            IntPtr proc = HalconAPI.PreCall(927);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelIDs);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleRMin);
            HalconAPI.Store(proc, 4, scaleRMax);
            HalconAPI.Store(proc, 5, scaleCMin);
            HalconAPI.Store(proc, 6, scaleCMax);
            HalconAPI.Store(proc, 7, minScore);
            HalconAPI.Store(proc, 8, numMatches);
            HalconAPI.Store(proc, 9, maxOverlap);
            HalconAPI.Store(proc, 10, subPixel);
            HalconAPI.Store(proc, 11, numLevels);
            HalconAPI.Store(proc, 12, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelIDs);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scaleR);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out scaleC);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out score);
            int procResult = HTuple.LoadNew(proc, 6, HTupleType.INTEGER, err7, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Find the best matches of multiple isotropically scaled shape models.</summary>
        /// <param name="image">Input image in which the models should be found.</param>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleMin">Minimum scale of the models. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the models. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="scale">Scale of the found instances of the models.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public static void FindScaledShapeModels(
          HObject image,
          HTuple modelIDs,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple scaleMin,
          HTuple scaleMax,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          HTuple greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scale,
          out HTuple score,
          out HTuple model)
        {
            IntPtr proc = HalconAPI.PreCall(928);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelIDs);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleMin);
            HalconAPI.Store(proc, 4, scaleMax);
            HalconAPI.Store(proc, 5, minScore);
            HalconAPI.Store(proc, 6, numMatches);
            HalconAPI.Store(proc, 7, maxOverlap);
            HalconAPI.Store(proc, 8, subPixel);
            HalconAPI.Store(proc, 9, numLevels);
            HalconAPI.Store(proc, 10, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelIDs);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleMin);
            HalconAPI.UnpinTuple(scaleMax);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scale);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out score);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Find the best matches of multiple shape models.</summary>
        /// <param name="image">Input image in which the models should be found.</param>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public static void FindShapeModels(
          HObject image,
          HTuple modelIDs,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          HTuple greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score,
          out HTuple model)
        {
            IntPtr proc = HalconAPI.PreCall(929);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelIDs);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, numMatches);
            HalconAPI.Store(proc, 5, maxOverlap);
            HalconAPI.Store(proc, 6, subPixel);
            HalconAPI.Store(proc, 7, numLevels);
            HalconAPI.Store(proc, 8, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelIDs);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Find the best matches of an anisotropically scaled shape model in an image.</summary>
        /// <param name="image">Input image in which the model should be found.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleRMin">Minimum scale of the model in the row direction. Default: 0.9</param>
        /// <param name="scaleRMax">Maximum scale of the model in the row direction. Default: 1.1</param>
        /// <param name="scaleCMin">Minimum scale of the model in the column direction. Default: 0.9</param>
        /// <param name="scaleCMax">Maximum scale of the model in the column direction. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="scaleR">Scale of the found instances of the model in the row direction.</param>
        /// <param name="scaleC">Scale of the found instances of the model in the column direction.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public static void FindAnisoShapeModel(
          HObject image,
          HTuple modelID,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          HTuple greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scaleR,
          out HTuple scaleC,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(930);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleRMin);
            HalconAPI.Store(proc, 4, scaleRMax);
            HalconAPI.Store(proc, 5, scaleCMin);
            HalconAPI.Store(proc, 6, scaleCMax);
            HalconAPI.Store(proc, 7, minScore);
            HalconAPI.Store(proc, 8, numMatches);
            HalconAPI.Store(proc, 9, maxOverlap);
            HalconAPI.Store(proc, 10, subPixel);
            HalconAPI.Store(proc, 11, numLevels);
            HalconAPI.Store(proc, 12, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scaleR);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out scaleC);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Find the best matches of an isotropically scaled shape model in an image.</summary>
        /// <param name="image">Input image in which the model should be found.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleMin">Minimum scale of the model. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the model. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="scale">Scale of the found instances of the model.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public static void FindScaledShapeModel(
          HObject image,
          HTuple modelID,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple scaleMin,
          HTuple scaleMax,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          HTuple greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scale,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(931);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleMin);
            HalconAPI.Store(proc, 4, scaleMax);
            HalconAPI.Store(proc, 5, minScore);
            HalconAPI.Store(proc, 6, numMatches);
            HalconAPI.Store(proc, 7, maxOverlap);
            HalconAPI.Store(proc, 8, subPixel);
            HalconAPI.Store(proc, 9, numLevels);
            HalconAPI.Store(proc, 10, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleMin);
            HalconAPI.UnpinTuple(scaleMax);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scale);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Find the best matches of a shape model in an image.</summary>
        /// <param name="image">Input image in which the model should be found.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public static void FindShapeModel(
          HObject image,
          HTuple modelID,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          HTuple greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(932);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, numMatches);
            HalconAPI.Store(proc, 5, maxOverlap);
            HalconAPI.Store(proc, 6, subPixel);
            HalconAPI.Store(proc, 7, numLevels);
            HalconAPI.Store(proc, 8, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Set the metric of a shape model that was created from XLD contours.</summary>
        /// <param name="image">Input image used for the determination of the polarity.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="homMat2D">Transformation matrix.</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        public static void SetShapeModelMetric(
          HObject image,
          HTuple modelID,
          HTuple homMat2D,
          HTuple metric)
        {
            IntPtr proc = HalconAPI.PreCall(933);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, homMat2D);
            HalconAPI.Store(proc, 2, metric);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Set selected parameters of the shape model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="genParamName">Parameter names.</param>
        /// <param name="genParamValue">Parameter values.</param>
        public static void SetShapeModelParam(
          HTuple modelID,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(934);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Prepare an anisotropically scaled shape model for matching from XLD contours.</summary>
        /// <param name="contours">Input contours that will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in the row direction. Default: 0.9</param>
        /// <param name="scaleRMax">Maximum scale of the pattern in the row direction. Default: 1.1</param>
        /// <param name="scaleRStep">Scale step length (resolution) in the row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in the column direction. Default: 0.9</param>
        /// <param name="scaleCMax">Maximum scale of the pattern in the column direction. Default: 1.1</param>
        /// <param name="scaleCStep">Scale step length (resolution) in the column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "ignore_local_polarity"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: 5</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreateAnisoShapeModelXld(
          HObject contours,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleRStep,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          HTuple metric,
          HTuple minContrast,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(935);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, scaleRMin);
            HalconAPI.Store(proc, 5, scaleRMax);
            HalconAPI.Store(proc, 6, scaleRStep);
            HalconAPI.Store(proc, 7, scaleCMin);
            HalconAPI.Store(proc, 8, scaleCMax);
            HalconAPI.Store(proc, 9, scaleCStep);
            HalconAPI.Store(proc, 10, optimization);
            HalconAPI.Store(proc, 11, metric);
            HalconAPI.Store(proc, 12, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(minContrast);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Prepare an isotropically scaled shape model for matching from XLD contours.</summary>
        /// <param name="contours">Input contours that will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleMin">Minimum scale of the pattern. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the pattern. Default: 1.1</param>
        /// <param name="scaleStep">Scale step length (resolution). Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "ignore_local_polarity"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: 5</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreateScaledShapeModelXld(
          HObject contours,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple scaleMin,
          HTuple scaleMax,
          HTuple scaleStep,
          HTuple optimization,
          HTuple metric,
          HTuple minContrast,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(936);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, scaleMin);
            HalconAPI.Store(proc, 5, scaleMax);
            HalconAPI.Store(proc, 6, scaleStep);
            HalconAPI.Store(proc, 7, optimization);
            HalconAPI.Store(proc, 8, metric);
            HalconAPI.Store(proc, 9, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleMin);
            HalconAPI.UnpinTuple(scaleMax);
            HalconAPI.UnpinTuple(scaleStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(minContrast);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Prepare a shape model for matching from XLD contours.</summary>
        /// <param name="contours">Input contours that will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "ignore_local_polarity"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: 5</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreateShapeModelXld(
          HObject contours,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple optimization,
          HTuple metric,
          HTuple minContrast,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(937);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, optimization);
            HalconAPI.Store(proc, 5, metric);
            HalconAPI.Store(proc, 6, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(minContrast);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Prepare an anisotropically scaled shape model for matching.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in the row direction. Default: 0.9</param>
        /// <param name="scaleRMax">Maximum scale of the pattern in the row direction. Default: 1.1</param>
        /// <param name="scaleRStep">Scale step length (resolution) in the row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in the column direction. Default: 0.9</param>
        /// <param name="scaleCMax">Maximum scale of the pattern in the column direction. Default: 1.1</param>
        /// <param name="scaleCStep">Scale step length (resolution) in the column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreateAnisoShapeModel(
          HObject template,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleRStep,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          HTuple metric,
          HTuple contrast,
          HTuple minContrast,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(938);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, scaleRMin);
            HalconAPI.Store(proc, 5, scaleRMax);
            HalconAPI.Store(proc, 6, scaleRStep);
            HalconAPI.Store(proc, 7, scaleCMin);
            HalconAPI.Store(proc, 8, scaleCMax);
            HalconAPI.Store(proc, 9, scaleCStep);
            HalconAPI.Store(proc, 10, optimization);
            HalconAPI.Store(proc, 11, metric);
            HalconAPI.Store(proc, 12, contrast);
            HalconAPI.Store(proc, 13, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Prepare an isotropically scaled shape model for matching.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleMin">Minimum scale of the pattern. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the pattern. Default: 1.1</param>
        /// <param name="scaleStep">Scale step length (resolution). Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreateScaledShapeModel(
          HObject template,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple scaleMin,
          HTuple scaleMax,
          HTuple scaleStep,
          HTuple optimization,
          HTuple metric,
          HTuple contrast,
          HTuple minContrast,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(939);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, scaleMin);
            HalconAPI.Store(proc, 5, scaleMax);
            HalconAPI.Store(proc, 6, scaleStep);
            HalconAPI.Store(proc, 7, optimization);
            HalconAPI.Store(proc, 8, metric);
            HalconAPI.Store(proc, 9, contrast);
            HalconAPI.Store(proc, 10, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleMin);
            HalconAPI.UnpinTuple(scaleMax);
            HalconAPI.UnpinTuple(scaleStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Prepare a shape model for matching.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreateShapeModel(
          HObject template,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple optimization,
          HTuple metric,
          HTuple contrast,
          HTuple minContrast,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(940);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, optimization);
            HalconAPI.Store(proc, 5, metric);
            HalconAPI.Store(proc, 6, contrast);
            HalconAPI.Store(proc, 7, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Create the representation of a shape model.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="modelImages">Image pyramid of the input image</param>
        /// <param name="modelRegions">Model region pyramid</param>
        /// <param name="numLevels">Number of pyramid levels. Default: 4</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the image and optionally minimum size of the object parts. Default: 30</param>
        public static void InspectShapeModel(
          HObject image,
          out HObject modelImages,
          out HObject modelRegions,
          HTuple numLevels,
          HTuple contrast)
        {
            IntPtr proc = HalconAPI.PreCall(941);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, contrast);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(contrast);
            int err2 = HObject.LoadNew(proc, 1, err1, out modelImages);
            int procResult = HObject.LoadNew(proc, 2, err2, out modelRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Free the memory of all descriptor models in RAM.</summary>
        public static void ClearAllDescriptorModels()
        {
            IntPtr proc = HalconAPI.PreCall(942);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a descriptor model.</summary>
        /// <param name="modelID">Handle of the descriptor model.</param>
        public static void ClearDescriptorModel(HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(943);
            HalconAPI.Store(proc, 0, modelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a descriptor model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void DeserializeDescriptorModel(HTuple serializedItemHandle, out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(944);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a descriptor model.</summary>
        /// <param name="modelID">Handle of a model to be saved.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeDescriptorModel(HTuple modelID, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(945);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a descriptor model from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void ReadDescriptorModel(HTuple fileName, out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(946);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a descriptor model to a file.</summary>
        /// <param name="modelID">Handle of a model to be saved.</param>
        /// <param name="fileName">The path and filename of the model to be saved.</param>
        public static void WriteDescriptorModel(HTuple modelID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(947);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find the best matches of a calibrated descriptor model in an image and return their 3D pose.</summary>
        /// <param name="image">Input image where the model should be found.</param>
        /// <param name="modelID">The handle to the descriptor model.</param>
        /// <param name="detectorParamName">The detector's parameter names. Default: []</param>
        /// <param name="detectorParamValue">Values of the detector's parameters. Default: []</param>
        /// <param name="descriptorParamName">The descriptor's parameter names. Default: []</param>
        /// <param name="descriptorParamValue">Values of the descriptor's parameters. Default: []</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.2</param>
        /// <param name="numMatches">Maximal number of found instances. Default: 1</param>
        /// <param name="camParam">Camera parameter (inner orientation) obtained from camera calibration.</param>
        /// <param name="scoreType">Score type to be evaluated in Score. Default: "num_points"</param>
        /// <param name="pose">3D pose of the object.</param>
        /// <param name="score">Score of the found instances according to the ScoreType input.</param>
        public static void FindCalibDescriptorModel(
          HObject image,
          HTuple modelID,
          HTuple detectorParamName,
          HTuple detectorParamValue,
          HTuple descriptorParamName,
          HTuple descriptorParamValue,
          HTuple minScore,
          HTuple numMatches,
          HTuple camParam,
          HTuple scoreType,
          out HTuple pose,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(948);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, detectorParamName);
            HalconAPI.Store(proc, 2, detectorParamValue);
            HalconAPI.Store(proc, 3, descriptorParamName);
            HalconAPI.Store(proc, 4, descriptorParamValue);
            HalconAPI.Store(proc, 5, minScore);
            HalconAPI.Store(proc, 6, numMatches);
            HalconAPI.Store(proc, 7, camParam);
            HalconAPI.Store(proc, 8, scoreType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(detectorParamName);
            HalconAPI.UnpinTuple(detectorParamValue);
            HalconAPI.UnpinTuple(descriptorParamName);
            HalconAPI.UnpinTuple(descriptorParamValue);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(camParam);
            HalconAPI.UnpinTuple(scoreType);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose);
            int procResult = HTuple.LoadNew(proc, 1, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Find the best matches of a descriptor model in an image.</summary>
        /// <param name="image">Input image where the model should be found.</param>
        /// <param name="modelID">The handle to the descriptor model.</param>
        /// <param name="detectorParamName">The detector's parameter names. Default: []</param>
        /// <param name="detectorParamValue">Values of the detector's parameters. Default: []</param>
        /// <param name="descriptorParamName">The descriptor's parameter names. Default: []</param>
        /// <param name="descriptorParamValue">Values of the descriptor's parameters. Default: []</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.2</param>
        /// <param name="numMatches">Maximal number of found instances. Default: 1</param>
        /// <param name="scoreType">Score type to be evaluated in Score. Default: "num_points"</param>
        /// <param name="homMat2D">Homography between model and found instance.</param>
        /// <param name="score">Score of the found instances according to the ScoreType input.</param>
        public static void FindUncalibDescriptorModel(
          HObject image,
          HTuple modelID,
          HTuple detectorParamName,
          HTuple detectorParamValue,
          HTuple descriptorParamName,
          HTuple descriptorParamValue,
          HTuple minScore,
          HTuple numMatches,
          HTuple scoreType,
          out HTuple homMat2D,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(949);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, detectorParamName);
            HalconAPI.Store(proc, 2, detectorParamValue);
            HalconAPI.Store(proc, 3, descriptorParamName);
            HalconAPI.Store(proc, 4, descriptorParamValue);
            HalconAPI.Store(proc, 5, minScore);
            HalconAPI.Store(proc, 6, numMatches);
            HalconAPI.Store(proc, 7, scoreType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(detectorParamName);
            HalconAPI.UnpinTuple(detectorParamValue);
            HalconAPI.UnpinTuple(descriptorParamName);
            HalconAPI.UnpinTuple(descriptorParamValue);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(scoreType);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out homMat2D);
            int procResult = HTuple.LoadNew(proc, 1, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Query the interest points of the descriptor model or the last processed search image.</summary>
        /// <param name="modelID">The handle to the descriptor model.</param>
        /// <param name="set">Set of interest points. Default: "model"</param>
        /// <param name="subset">Subset of interest points. Default: "all"</param>
        /// <param name="row">Row coordinates of interest points.</param>
        /// <param name="column">Column coordinates of interest points.</param>
        public static void GetDescriptorModelPoints(
          HTuple modelID,
          HTuple set,
          HTuple subset,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(950);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, set);
            HalconAPI.Store(proc, 2, subset);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(set);
            HalconAPI.UnpinTuple(subset);
            int err2 = HTuple.LoadNew(proc, 0, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, err2, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters of a descriptor model.</summary>
        /// <param name="modelID">The object handle to the descriptor model.</param>
        /// <param name="detectorType">The type of the detector.</param>
        /// <param name="detectorParamName">The detectors parameter names.</param>
        /// <param name="detectorParamValue">Values of the detectors parameters.</param>
        /// <param name="descriptorParamName">The descriptors parameter names.</param>
        /// <param name="descriptorParamValue">Values of the descriptors parameters.</param>
        public static void GetDescriptorModelParams(
          HTuple modelID,
          out HTuple detectorType,
          out HTuple detectorParamName,
          out HTuple detectorParamValue,
          out HTuple descriptorParamName,
          out HTuple descriptorParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(951);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int err2 = HTuple.LoadNew(proc, 0, err1, out detectorType);
            int err3 = HTuple.LoadNew(proc, 1, err2, out detectorParamName);
            int err4 = HTuple.LoadNew(proc, 2, err3, out detectorParamValue);
            int err5 = HTuple.LoadNew(proc, 3, err4, out descriptorParamName);
            int procResult = HTuple.LoadNew(proc, 4, err5, out descriptorParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a descriptor model for calibrated perspective matching.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="camParam">The parameters of the internal orientation of the camera.</param>
        /// <param name="referencePose">The reference pose of the object in the reference image.</param>
        /// <param name="detectorType">The type of the detector. Default: "lepetit"</param>
        /// <param name="detectorParamName">The detector's parameter names. Default: []</param>
        /// <param name="detectorParamValue">Values of the detector's parameters. Default: []</param>
        /// <param name="descriptorParamName">The descriptor's parameter names. Default: []</param>
        /// <param name="descriptorParamValue">Values of the descriptor's parameters. Default: []</param>
        /// <param name="seed">The seed for the random number generator. Default: 42</param>
        /// <param name="modelID">The handle to the descriptor model.</param>
        public static void CreateCalibDescriptorModel(
          HObject template,
          HTuple camParam,
          HTuple referencePose,
          HTuple detectorType,
          HTuple detectorParamName,
          HTuple detectorParamValue,
          HTuple descriptorParamName,
          HTuple descriptorParamValue,
          HTuple seed,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(952);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, camParam);
            HalconAPI.Store(proc, 1, referencePose);
            HalconAPI.Store(proc, 2, detectorType);
            HalconAPI.Store(proc, 3, detectorParamName);
            HalconAPI.Store(proc, 4, detectorParamValue);
            HalconAPI.Store(proc, 5, descriptorParamName);
            HalconAPI.Store(proc, 6, descriptorParamValue);
            HalconAPI.Store(proc, 7, seed);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParam);
            HalconAPI.UnpinTuple(referencePose);
            HalconAPI.UnpinTuple(detectorType);
            HalconAPI.UnpinTuple(detectorParamName);
            HalconAPI.UnpinTuple(detectorParamValue);
            HalconAPI.UnpinTuple(descriptorParamName);
            HalconAPI.UnpinTuple(descriptorParamValue);
            HalconAPI.UnpinTuple(seed);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Prepare a descriptor model for interest point matching.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="detectorType">The type of the detector. Default: "lepetit"</param>
        /// <param name="detectorParamName">The detector's parameter names. Default: []</param>
        /// <param name="detectorParamValue">Values of the detector's parameters. Default: []</param>
        /// <param name="descriptorParamName">The descriptor's parameter names. Default: []</param>
        /// <param name="descriptorParamValue">Values of the descriptor's parameters. Default: []</param>
        /// <param name="seed">The seed for the random number generator. Default: 42</param>
        /// <param name="modelID">The handle to the descriptor model.</param>
        public static void CreateUncalibDescriptorModel(
          HObject template,
          HTuple detectorType,
          HTuple detectorParamName,
          HTuple detectorParamValue,
          HTuple descriptorParamName,
          HTuple descriptorParamValue,
          HTuple seed,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(953);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, detectorType);
            HalconAPI.Store(proc, 1, detectorParamName);
            HalconAPI.Store(proc, 2, detectorParamValue);
            HalconAPI.Store(proc, 3, descriptorParamName);
            HalconAPI.Store(proc, 4, descriptorParamValue);
            HalconAPI.Store(proc, 5, seed);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(detectorType);
            HalconAPI.UnpinTuple(detectorParamName);
            HalconAPI.UnpinTuple(detectorParamValue);
            HalconAPI.UnpinTuple(descriptorParamName);
            HalconAPI.UnpinTuple(descriptorParamValue);
            HalconAPI.UnpinTuple(seed);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Query alphanumerical results that were accumulated during descriptor-based matching.</summary>
        /// <param name="modelID">Handle of a descriptor model.</param>
        /// <param name="objectID">Handle of the object for which the results are queried. Default: "all"</param>
        /// <param name="resultNames">Name of the results to be queried. Default: "num_points"</param>
        /// <param name="results">Returned results.</param>
        public static void GetDescriptorModelResults(
          HTuple modelID,
          HTuple objectID,
          HTuple resultNames,
          out HTuple results)
        {
            IntPtr proc = HalconAPI.PreCall(954);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, objectID);
            HalconAPI.Store(proc, 2, resultNames);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(objectID);
            HalconAPI.UnpinTuple(resultNames);
            int procResult = HTuple.LoadNew(proc, 0, err, out results);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the origin of a descriptor model.</summary>
        /// <param name="modelID">Handle of a descriptor model.</param>
        /// <param name="row">Position of origin in row direction.</param>
        /// <param name="column">Position of origin in column direction.</param>
        public static void GetDescriptorModelOrigin(HTuple modelID, out HTuple row, out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(955);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int err2 = HTuple.LoadNew(proc, 0, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, err2, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Sets the origin of a descriptor model.</summary>
        /// <param name="modelID">Handle of a descriptor model.</param>
        /// <param name="row">Translation of origin in row direction. Default: 0</param>
        /// <param name="column">Translation of origin in column direction. Default: 0</param>
        public static void SetDescriptorModelOrigin(HTuple modelID, HTuple row, HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(956);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the origin (reference point) of a deformable model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="row">Row coordinate of the origin of the deformable model.</param>
        /// <param name="column">Column coordinate of the origin of the deformable model.</param>
        public static void GetDeformableModelOrigin(HTuple modelID, out HTuple row, out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(957);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the origin (reference point) of a deformable model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="row">Row coordinate of the origin of the deformable model.</param>
        /// <param name="column">Column coordinate of the origin of the deformable model.</param>
        public static void SetDeformableModelOrigin(HTuple modelID, HTuple row, HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(958);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set selected parameters of the deformable model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="genParamName">Parameter names.</param>
        /// <param name="genParamValue">Parameter values.</param>
        public static void SetDeformableModelParam(
          HTuple modelID,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(959);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters of a deformable model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="genParamName">Names of the generic parameters that are to be queried for the deformable model. Default: "angle_start"</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        public static void GetDeformableModelParams(
          HTuple modelID,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(960);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the contour representation of a deformable model.</summary>
        /// <param name="modelContours">Contour representation of the deformable model.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="level">Pyramid level for which the contour representation should be returned. Default: 1</param>
        public static void GetDeformableModelContours(
          out HObject modelContours,
          HTuple modelID,
          HTuple level)
        {
            IntPtr proc = HalconAPI.PreCall(961);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, level);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(level);
            int procResult = HObject.LoadNew(proc, 1, err, out modelContours);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Determine the parameters of a deformable model.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleMin">Minimum scale of the model. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the model. Default: 1.1</param>
        /// <param name="optimization">Kind of optimization. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The general parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the general parameter. Default: []</param>
        /// <param name="parameters">Parameters to be determined automatically. Default: "all"</param>
        /// <param name="parameterName">Name of the automatically determined parameter.</param>
        /// <param name="parameterValue">Value of the automatically determined parameter.</param>
        public static void DetermineDeformableModelParams(
          HObject template,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple scaleMin,
          HTuple scaleMax,
          HTuple optimization,
          HTuple metric,
          HTuple contrast,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue,
          HTuple parameters,
          out HTuple parameterName,
          out HTuple parameterValue)
        {
            IntPtr proc = HalconAPI.PreCall(962);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleMin);
            HalconAPI.Store(proc, 4, scaleMax);
            HalconAPI.Store(proc, 5, optimization);
            HalconAPI.Store(proc, 6, metric);
            HalconAPI.Store(proc, 7, contrast);
            HalconAPI.Store(proc, 8, minContrast);
            HalconAPI.Store(proc, 9, genParamName);
            HalconAPI.Store(proc, 10, genParamValue);
            HalconAPI.Store(proc, 11, parameters);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleMin);
            HalconAPI.UnpinTuple(scaleMax);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.UnpinTuple(parameters);
            int err2 = HTuple.LoadNew(proc, 0, err1, out parameterName);
            int procResult = HTuple.LoadNew(proc, 1, err2, out parameterValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Deserialize a deformable model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void DeserializeDeformableModel(HTuple serializedItemHandle, out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(963);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a deformable model.</summary>
        /// <param name="modelID">Handle of a model to be saved.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeDeformableModel(HTuple modelID, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(964);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a deformable model from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void ReadDeformableModel(HTuple fileName, out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(965);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a deformable model to a file.</summary>
        /// <param name="modelID">Handle of a model to be saved.</param>
        /// <param name="fileName">The path and filename of the model to be saved.</param>
        public static void WriteDeformableModel(HTuple modelID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(966);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of all deformable models.</summary>
        public static void ClearAllDeformableModels()
        {
            IntPtr proc = HalconAPI.PreCall(967);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a deformable model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        public static void ClearDeformableModel(HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(968);
            HalconAPI.Store(proc, 0, modelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find the best matches of a local deformable model in an image.</summary>
        /// <param name="image">Input image in which the model should be found.</param>
        /// <param name="imageRectified">Rectified image of the found model.</param>
        /// <param name="vectorField">Vector field of the rectification transformation.</param>
        /// <param name="deformedContours">Contours of the found instances of the model.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleRMin">Minimum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">Maximum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleCMin">Minimum scale of the model in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">Maximum scale of the model in column direction. Default: 1.0</param>
        /// <param name="minScore">Minumum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 1.0</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching. Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="resultType">Switch for requested iconic result. Default: []</param>
        /// <param name="genParamName">The general parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the general parameters. Default: []</param>
        /// <param name="score">Scores of the found instances of the model.</param>
        /// <param name="row">Row coordinates of the found instances of the model.</param>
        /// <param name="column">Column coordinates of the found instances of the model.</param>
        public static void FindLocalDeformableModel(
          HObject image,
          out HObject imageRectified,
          out HObject vectorField,
          out HObject deformedContours,
          HTuple modelID,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple numLevels,
          HTuple greediness,
          HTuple resultType,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple score,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(969);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleRMin);
            HalconAPI.Store(proc, 4, scaleRMax);
            HalconAPI.Store(proc, 5, scaleCMin);
            HalconAPI.Store(proc, 6, scaleCMax);
            HalconAPI.Store(proc, 7, minScore);
            HalconAPI.Store(proc, 8, numMatches);
            HalconAPI.Store(proc, 9, maxOverlap);
            HalconAPI.Store(proc, 10, numLevels);
            HalconAPI.Store(proc, 11, greediness);
            HalconAPI.Store(proc, 12, resultType);
            HalconAPI.Store(proc, 13, genParamName);
            HalconAPI.Store(proc, 14, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            HalconAPI.UnpinTuple(resultType);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HObject.LoadNew(proc, 1, err1, out imageRectified);
            int err3 = HObject.LoadNew(proc, 2, err2, out vectorField);
            int err4 = HObject.LoadNew(proc, 3, err3, out deformedContours);
            int err5 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err4, out score);
            int err6 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err5, out row);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err6, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Find the best matches of a calibrated deformable model in an image and return their 3D pose.</summary>
        /// <param name="image">Input image in which the model should be found.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleRMin">Minimum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">Maximum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleCMin">Minimum scale of the model in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">Maximum scale of the model in column direction. Default: 1.0</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 1.0</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="genParamName">The general parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the general parameters. Default: []</param>
        /// <param name="pose">Pose of the object.</param>
        /// <param name="covPose">6 standard deviations or 36 covariances of the pose parameters.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public static void FindPlanarCalibDeformableModel(
          HObject image,
          HTuple modelID,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple numLevels,
          HTuple greediness,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple pose,
          out HTuple covPose,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(970);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleRMin);
            HalconAPI.Store(proc, 4, scaleRMax);
            HalconAPI.Store(proc, 5, scaleCMin);
            HalconAPI.Store(proc, 6, scaleCMax);
            HalconAPI.Store(proc, 7, minScore);
            HalconAPI.Store(proc, 8, numMatches);
            HalconAPI.Store(proc, 9, maxOverlap);
            HalconAPI.Store(proc, 10, numLevels);
            HalconAPI.Store(proc, 11, greediness);
            HalconAPI.Store(proc, 12, genParamName);
            HalconAPI.Store(proc, 13, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covPose);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Find the best matches of a planar projective invariant deformable model in an image.</summary>
        /// <param name="image">Input image in which the model should be found.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleRMin">Minimum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">Maximum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleCMin">Minimum scale of the model in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">Maximum scale of the model in column direction. Default: 1.0</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 1.0</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="genParamName">The general parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the general parameters. Default: []</param>
        /// <param name="homMat2D">Homographies between model and found instances.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public static void FindPlanarUncalibDeformableModel(
          HObject image,
          HTuple modelID,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple numLevels,
          HTuple greediness,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple homMat2D,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(971);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleRMin);
            HalconAPI.Store(proc, 4, scaleRMax);
            HalconAPI.Store(proc, 5, scaleCMin);
            HalconAPI.Store(proc, 6, scaleCMax);
            HalconAPI.Store(proc, 7, minScore);
            HalconAPI.Store(proc, 8, numMatches);
            HalconAPI.Store(proc, 9, maxOverlap);
            HalconAPI.Store(proc, 10, numLevels);
            HalconAPI.Store(proc, 11, greediness);
            HalconAPI.Store(proc, 12, genParamName);
            HalconAPI.Store(proc, 13, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out homMat2D);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Set the metric of a local deformable model that was created from XLD contours.</summary>
        /// <param name="image">Input image used for the determination of the polarity.</param>
        /// <param name="vectorField">Vector field of the local deformation.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        public static void SetLocalDeformableModelMetric(
          HObject image,
          HObject vectorField,
          HTuple modelID,
          HTuple metric)
        {
            IntPtr proc = HalconAPI.PreCall(972);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)vectorField);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, metric);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)vectorField);
        }

        /// <summary>Set the metric of a planar calibrated deformable model that was created from XLD contours.</summary>
        /// <param name="image">Input image used for the determination of the polarity.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="pose">Pose of the model in the image.</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        public static void SetPlanarCalibDeformableModelMetric(
          HObject image,
          HTuple modelID,
          HTuple pose,
          HTuple metric)
        {
            IntPtr proc = HalconAPI.PreCall(973);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, pose);
            HalconAPI.Store(proc, 2, metric);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Set the metric of a planar uncalibrated deformable model that was created from XLD contours.</summary>
        /// <param name="image">Input image used for the determination of the polarity.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="homMat2D">Transformation matrix.</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        public static void SetPlanarUncalibDeformableModelMetric(
          HObject image,
          HTuple modelID,
          HTuple homMat2D,
          HTuple metric)
        {
            IntPtr proc = HalconAPI.PreCall(974);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, homMat2D);
            HalconAPI.Store(proc, 2, metric);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Prepare a deformable model for local deformable matching from XLD contours.</summary>
        /// <param name="contours">Input contours that will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "ignore_local_polarity"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: 5</param>
        /// <param name="genParamName">The generic parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreateLocalDeformableModelXld(
          HObject contours,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleRStep,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          HTuple metric,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(975);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, scaleRMin);
            HalconAPI.Store(proc, 5, scaleRMax);
            HalconAPI.Store(proc, 6, scaleRStep);
            HalconAPI.Store(proc, 7, scaleCMin);
            HalconAPI.Store(proc, 8, scaleCMax);
            HalconAPI.Store(proc, 9, scaleCStep);
            HalconAPI.Store(proc, 10, optimization);
            HalconAPI.Store(proc, 11, metric);
            HalconAPI.Store(proc, 12, minContrast);
            HalconAPI.Store(proc, 13, genParamName);
            HalconAPI.Store(proc, 14, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Prepare a deformable model for planar calibrated matching from XLD contours.</summary>
        /// <param name="contours">Input contours that will be used to create the model.</param>
        /// <param name="camParam">The parameters of the internal orientation of the camera.</param>
        /// <param name="referencePose">The reference pose of the object.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in the column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "ignore_local_polarity"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: 5</param>
        /// <param name="genParamName">The generic parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameter. Default: []</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreatePlanarCalibDeformableModelXld(
          HObject contours,
          HTuple camParam,
          HTuple referencePose,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleRStep,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          HTuple metric,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(976);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, camParam);
            HalconAPI.Store(proc, 1, referencePose);
            HalconAPI.Store(proc, 2, numLevels);
            HalconAPI.Store(proc, 3, angleStart);
            HalconAPI.Store(proc, 4, angleExtent);
            HalconAPI.Store(proc, 5, angleStep);
            HalconAPI.Store(proc, 6, scaleRMin);
            HalconAPI.Store(proc, 7, scaleRMax);
            HalconAPI.Store(proc, 8, scaleRStep);
            HalconAPI.Store(proc, 9, scaleCMin);
            HalconAPI.Store(proc, 10, scaleCMax);
            HalconAPI.Store(proc, 11, scaleCStep);
            HalconAPI.Store(proc, 12, optimization);
            HalconAPI.Store(proc, 13, metric);
            HalconAPI.Store(proc, 14, minContrast);
            HalconAPI.Store(proc, 15, genParamName);
            HalconAPI.Store(proc, 16, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParam);
            HalconAPI.UnpinTuple(referencePose);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Prepare a deformable model for planar uncalibrated matching from XLD contours.</summary>
        /// <param name="contours">Input contours that will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in the column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "ignore_local_polarity"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: 5</param>
        /// <param name="genParamName">The generic parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreatePlanarUncalibDeformableModelXld(
          HObject contours,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleRStep,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          HTuple metric,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(977);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, scaleRMin);
            HalconAPI.Store(proc, 5, scaleRMax);
            HalconAPI.Store(proc, 6, scaleRStep);
            HalconAPI.Store(proc, 7, scaleCMin);
            HalconAPI.Store(proc, 8, scaleCMax);
            HalconAPI.Store(proc, 9, scaleCStep);
            HalconAPI.Store(proc, 10, optimization);
            HalconAPI.Store(proc, 11, metric);
            HalconAPI.Store(proc, 12, minContrast);
            HalconAPI.Store(proc, 13, genParamName);
            HalconAPI.Store(proc, 14, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Creates a deformable model for local, deformable matching.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "none"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Thresholds or hysteresis thresholds for the contrast of the object in the template image. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The generic parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreateLocalDeformableModel(
          HObject template,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleRStep,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          HTuple metric,
          HTuple contrast,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(978);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, scaleRMin);
            HalconAPI.Store(proc, 5, scaleRMax);
            HalconAPI.Store(proc, 6, scaleRStep);
            HalconAPI.Store(proc, 7, scaleCMin);
            HalconAPI.Store(proc, 8, scaleCMax);
            HalconAPI.Store(proc, 9, scaleCStep);
            HalconAPI.Store(proc, 10, optimization);
            HalconAPI.Store(proc, 11, metric);
            HalconAPI.Store(proc, 12, contrast);
            HalconAPI.Store(proc, 13, minContrast);
            HalconAPI.Store(proc, 14, genParamName);
            HalconAPI.Store(proc, 15, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Create a deformable model for calibrated perspective matching.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="camParam">The parameters of the internal orientation of the camera.</param>
        /// <param name="referencePose">The reference pose of the object in the reference image.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in the column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "none"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Thresholds or hysteresis thresholds for the contrast of the object in the template image. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the parameters. Default: []</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreatePlanarCalibDeformableModel(
          HObject template,
          HTuple camParam,
          HTuple referencePose,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleRStep,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          HTuple metric,
          HTuple contrast,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(979);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, camParam);
            HalconAPI.Store(proc, 1, referencePose);
            HalconAPI.Store(proc, 2, numLevels);
            HalconAPI.Store(proc, 3, angleStart);
            HalconAPI.Store(proc, 4, angleExtent);
            HalconAPI.Store(proc, 5, angleStep);
            HalconAPI.Store(proc, 6, scaleRMin);
            HalconAPI.Store(proc, 7, scaleRMax);
            HalconAPI.Store(proc, 8, scaleRStep);
            HalconAPI.Store(proc, 9, scaleCMin);
            HalconAPI.Store(proc, 10, scaleCMax);
            HalconAPI.Store(proc, 11, scaleCStep);
            HalconAPI.Store(proc, 12, optimization);
            HalconAPI.Store(proc, 13, metric);
            HalconAPI.Store(proc, 14, contrast);
            HalconAPI.Store(proc, 15, minContrast);
            HalconAPI.Store(proc, 16, genParamName);
            HalconAPI.Store(proc, 17, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParam);
            HalconAPI.UnpinTuple(referencePose);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Creates a deformable model for uncalibrated, perspective matching.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "none"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Thresholds or hysteresis thresholds for the contrast of the object in the template image. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The generic parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameter. Default: []</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreatePlanarUncalibDeformableModel(
          HObject template,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleRStep,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          HTuple metric,
          HTuple contrast,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(980);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, scaleRMin);
            HalconAPI.Store(proc, 5, scaleRMax);
            HalconAPI.Store(proc, 6, scaleRStep);
            HalconAPI.Store(proc, 7, scaleCMin);
            HalconAPI.Store(proc, 8, scaleCMax);
            HalconAPI.Store(proc, 9, scaleCStep);
            HalconAPI.Store(proc, 10, optimization);
            HalconAPI.Store(proc, 11, metric);
            HalconAPI.Store(proc, 12, contrast);
            HalconAPI.Store(proc, 13, minContrast);
            HalconAPI.Store(proc, 14, genParamName);
            HalconAPI.Store(proc, 15, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Free the memory of all NCC models.</summary>
        public static void ClearAllNccModels()
        {
            IntPtr proc = HalconAPI.PreCall(981);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of an NCC model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        public static void ClearNccModel(HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(982);
            HalconAPI.Store(proc, 0, modelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize an NCC model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void DeserializeNccModel(HTuple serializedItemHandle, out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(983);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize an NCC model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeNccModel(HTuple modelID, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(984);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read an NCC model from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void ReadNccModel(HTuple fileName, out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(985);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write an NCC model to a file.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteNccModel(HTuple modelID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(986);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Determine the parameters of an NCC model.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="parameters">Parameters to be determined automatically. Default: "all"</param>
        /// <param name="parameterName">Name of the automatically determined parameter.</param>
        /// <param name="parameterValue">Value of the automatically determined parameter.</param>
        public static void DetermineNccModelParams(
          HObject template,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple metric,
          HTuple parameters,
          out HTuple parameterName,
          out HTuple parameterValue)
        {
            IntPtr proc = HalconAPI.PreCall(987);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, metric);
            HalconAPI.Store(proc, 4, parameters);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(metric);
            HalconAPI.UnpinTuple(parameters);
            int err2 = HTuple.LoadNew(proc, 0, err1, out parameterName);
            int procResult = HTuple.LoadNew(proc, 1, err2, out parameterValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Return the parameters of an NCC model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="numLevels">Number of pyramid levels.</param>
        /// <param name="angleStart">Smallest rotation of the pattern.</param>
        /// <param name="angleExtent">Extent of the rotation angles.</param>
        /// <param name="angleStep">Step length of the angles (resolution).</param>
        /// <param name="metric">Match metric.</param>
        public static void GetNccModelParams(
          HTuple modelID,
          out HTuple numLevels,
          out HTuple angleStart,
          out HTuple angleExtent,
          out HTuple angleStep,
          out HTuple metric)
        {
            IntPtr proc = HalconAPI.PreCall(988);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out numLevels);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out angleStart);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angleExtent);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out angleStep);
            int procResult = HTuple.LoadNew(proc, 4, err5, out metric);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the origin (reference point) of an NCC model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="row">Row coordinate of the origin of the NCC model.</param>
        /// <param name="column">Column coordinate of the origin of the NCC model.</param>
        public static void GetNccModelOrigin(HTuple modelID, out HTuple row, out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(989);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the origin (reference point) of an NCC model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="row">Row coordinate of the origin of the NCC model.</param>
        /// <param name="column">Column coordinate of the origin of the NCC model.</param>
        public static void SetNccModelOrigin(HTuple modelID, HTuple row, HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(990);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find the best matches of an NCC model in an image.</summary>
        /// <param name="image">Input image in which the model should be found.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.8</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy. Default: "true"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public static void FindNccModel(
          HObject image,
          HTuple modelID,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(991);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, numMatches);
            HalconAPI.Store(proc, 5, maxOverlap);
            HalconAPI.Store(proc, 6, subPixel);
            HalconAPI.Store(proc, 7, numLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Set selected parameters of the NCC model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="genParamName">Parameter names.</param>
        /// <param name="genParamValue">Parameter values.</param>
        public static void SetNccModelParam(HTuple modelID, HTuple genParamName, HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(992);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Prepare an NCC model for matching.</summary>
        /// <param name="template">Input image whose domain will be used to create the model.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void CreateNccModel(
          HObject template,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          HTuple metric,
          out HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(993);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, metric);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(metric);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out modelID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Return the components of a found instance of a component model.</summary>
        /// <param name="foundComponents">Found components of the selected component model instance.</param>
        /// <param name="componentModelID">Handle of the component model.</param>
        /// <param name="modelStart">Start index of each found instance of the component model in the tuples describing the component matches.</param>
        /// <param name="modelEnd">End index of each found instance of the component model to the tuples describing the component matches.</param>
        /// <param name="rowComp">Row coordinate of the found component matches.</param>
        /// <param name="columnComp">Column coordinate of the found component matches.</param>
        /// <param name="angleComp">Rotation angle of the found component matches.</param>
        /// <param name="scoreComp">Score of the found component matches.</param>
        /// <param name="modelComp">Index of the found components.</param>
        /// <param name="modelMatch">Index of the found instance of the component model to be returned.</param>
        /// <param name="markOrientation">Mark the orientation of the components. Default: "false"</param>
        /// <param name="rowCompInst">Row coordinate of all components of the selected model instance.</param>
        /// <param name="columnCompInst">Column coordinate of all components of the selected model instance.</param>
        /// <param name="angleCompInst">Rotation angle of all components of the selected model instance.</param>
        /// <param name="scoreCompInst">Score of all components of the selected model instance.</param>
        public static void GetFoundComponentModel(
          out HObject foundComponents,
          HTuple componentModelID,
          HTuple modelStart,
          HTuple modelEnd,
          HTuple rowComp,
          HTuple columnComp,
          HTuple angleComp,
          HTuple scoreComp,
          HTuple modelComp,
          HTuple modelMatch,
          HTuple markOrientation,
          out HTuple rowCompInst,
          out HTuple columnCompInst,
          out HTuple angleCompInst,
          out HTuple scoreCompInst)
        {
            IntPtr proc = HalconAPI.PreCall(994);
            HalconAPI.Store(proc, 0, componentModelID);
            HalconAPI.Store(proc, 1, modelStart);
            HalconAPI.Store(proc, 2, modelEnd);
            HalconAPI.Store(proc, 3, rowComp);
            HalconAPI.Store(proc, 4, columnComp);
            HalconAPI.Store(proc, 5, angleComp);
            HalconAPI.Store(proc, 6, scoreComp);
            HalconAPI.Store(proc, 7, modelComp);
            HalconAPI.Store(proc, 8, modelMatch);
            HalconAPI.Store(proc, 9, markOrientation);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentModelID);
            HalconAPI.UnpinTuple(modelStart);
            HalconAPI.UnpinTuple(modelEnd);
            HalconAPI.UnpinTuple(rowComp);
            HalconAPI.UnpinTuple(columnComp);
            HalconAPI.UnpinTuple(angleComp);
            HalconAPI.UnpinTuple(scoreComp);
            HalconAPI.UnpinTuple(modelComp);
            HalconAPI.UnpinTuple(modelMatch);
            HalconAPI.UnpinTuple(markOrientation);
            int err2 = HObject.LoadNew(proc, 1, err1, out foundComponents);
            int err3 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out rowCompInst);
            int err4 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err3, out columnCompInst);
            int err5 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err4, out angleCompInst);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err5, out scoreCompInst);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find the best matches of a component model in an image.</summary>
        /// <param name="image">Input image in which the component model should be found.</param>
        /// <param name="componentModelID">Handle of the component model.</param>
        /// <param name="rootComponent">Index of the root component.</param>
        /// <param name="angleStartRoot">Smallest rotation of the root component Default: -0.39</param>
        /// <param name="angleExtentRoot">Extent of the rotation of the root component. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the component model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the component model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the component models to be found. Default: 0.5</param>
        /// <param name="ifRootNotFound">Behavior if the root component is missing. Default: "stop_search"</param>
        /// <param name="ifComponentNotFound">Behavior if a component is missing. Default: "prune_branch"</param>
        /// <param name="posePrediction">Pose prediction of components that are not found. Default: "none"</param>
        /// <param name="minScoreComp">Minimum score of the instances of the components to be found. Default: 0.5</param>
        /// <param name="subPixelComp">Subpixel accuracy of the component poses if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevelsComp">Number of pyramid levels for the components used in the matching (and lowest pyramid level to use if $|NumLevelsComp| = 2n$). Default: 0</param>
        /// <param name="greedinessComp">"Greediness" of the search heuristic for the components (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="modelStart">Start index of each found instance of the component model in the tuples describing the component matches.</param>
        /// <param name="modelEnd">End index of each found instance of the component model in the tuples describing the component matches.</param>
        /// <param name="score">Score of the found instances of the component model.</param>
        /// <param name="rowComp">Row coordinate of the found component matches.</param>
        /// <param name="columnComp">Column coordinate of the found component matches.</param>
        /// <param name="angleComp">Rotation angle of the found component matches.</param>
        /// <param name="scoreComp">Score of the found component matches.</param>
        /// <param name="modelComp">Index of the found components.</param>
        public static void FindComponentModel(
          HObject image,
          HTuple componentModelID,
          HTuple rootComponent,
          HTuple angleStartRoot,
          HTuple angleExtentRoot,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple ifRootNotFound,
          HTuple ifComponentNotFound,
          HTuple posePrediction,
          HTuple minScoreComp,
          HTuple subPixelComp,
          HTuple numLevelsComp,
          HTuple greedinessComp,
          out HTuple modelStart,
          out HTuple modelEnd,
          out HTuple score,
          out HTuple rowComp,
          out HTuple columnComp,
          out HTuple angleComp,
          out HTuple scoreComp,
          out HTuple modelComp)
        {
            IntPtr proc = HalconAPI.PreCall(995);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, componentModelID);
            HalconAPI.Store(proc, 1, rootComponent);
            HalconAPI.Store(proc, 2, angleStartRoot);
            HalconAPI.Store(proc, 3, angleExtentRoot);
            HalconAPI.Store(proc, 4, minScore);
            HalconAPI.Store(proc, 5, numMatches);
            HalconAPI.Store(proc, 6, maxOverlap);
            HalconAPI.Store(proc, 7, ifRootNotFound);
            HalconAPI.Store(proc, 8, ifComponentNotFound);
            HalconAPI.Store(proc, 9, posePrediction);
            HalconAPI.Store(proc, 10, minScoreComp);
            HalconAPI.Store(proc, 11, subPixelComp);
            HalconAPI.Store(proc, 12, numLevelsComp);
            HalconAPI.Store(proc, 13, greedinessComp);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentModelID);
            HalconAPI.UnpinTuple(rootComponent);
            HalconAPI.UnpinTuple(angleStartRoot);
            HalconAPI.UnpinTuple(angleExtentRoot);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(ifRootNotFound);
            HalconAPI.UnpinTuple(ifComponentNotFound);
            HalconAPI.UnpinTuple(posePrediction);
            HalconAPI.UnpinTuple(minScoreComp);
            HalconAPI.UnpinTuple(subPixelComp);
            HalconAPI.UnpinTuple(numLevelsComp);
            HalconAPI.UnpinTuple(greedinessComp);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out modelStart);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out modelEnd);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out rowComp);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out columnComp);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out angleComp);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out scoreComp);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.INTEGER, err8, out modelComp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Free the memory of all component models.</summary>
        public static void ClearAllComponentModels()
        {
            IntPtr proc = HalconAPI.PreCall(996);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a component model.</summary>
        /// <param name="componentModelID">Handle of the component model.</param>
        public static void ClearComponentModel(HTuple componentModelID)
        {
            IntPtr proc = HalconAPI.PreCall(997);
            HalconAPI.Store(proc, 0, componentModelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the search tree of a component model.</summary>
        /// <param name="tree">Search tree.</param>
        /// <param name="relations">Relations of components that are connected in the search tree.</param>
        /// <param name="componentModelID">Handle of the component model.</param>
        /// <param name="rootComponent">Index of the root component.</param>
        /// <param name="image">Image for which the tree is to be returned. Default: "model_image"</param>
        /// <param name="startNode">Component index of the start node of an arc in the search tree.</param>
        /// <param name="endNode">Component index of the end node of an arc in the search tree.</param>
        /// <param name="row">Row coordinate of the center of the rectangle representing the relation.</param>
        /// <param name="column">Column index of the center of the rectangle representing the relation.</param>
        /// <param name="phi">Orientation of the rectangle representing the relation (radians).</param>
        /// <param name="length1">First radius (half length) of the rectangle representing the relation.</param>
        /// <param name="length2">Second radius (half width) of the rectangle representing the relation.</param>
        /// <param name="angleStart">Smallest relative orientation angle.</param>
        /// <param name="angleExtent">Extent of the relative orientation angle.</param>
        public static void GetComponentModelTree(
          out HObject tree,
          out HObject relations,
          HTuple componentModelID,
          HTuple rootComponent,
          HTuple image,
          out HTuple startNode,
          out HTuple endNode,
          out HTuple row,
          out HTuple column,
          out HTuple phi,
          out HTuple length1,
          out HTuple length2,
          out HTuple angleStart,
          out HTuple angleExtent)
        {
            IntPtr proc = HalconAPI.PreCall(998);
            HalconAPI.Store(proc, 0, componentModelID);
            HalconAPI.Store(proc, 1, rootComponent);
            HalconAPI.Store(proc, 2, image);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentModelID);
            HalconAPI.UnpinTuple(rootComponent);
            HalconAPI.UnpinTuple(image);
            int err2 = HObject.LoadNew(proc, 1, err1, out tree);
            int err3 = HObject.LoadNew(proc, 2, err2, out relations);
            int err4 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err3, out startNode);
            int err5 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err4, out endNode);
            int err6 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err5, out row);
            int err7 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err6, out column);
            int err8 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err7, out phi);
            int err9 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err8, out length1);
            int err10 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err9, out length2);
            int err11 = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err10, out angleStart);
            int procResult = HTuple.LoadNew(proc, 8, HTupleType.DOUBLE, err11, out angleExtent);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters of a component model.</summary>
        /// <param name="componentModelID">Handle of the component model.</param>
        /// <param name="minScoreComp">Minimum score of the instances of the components to be found.</param>
        /// <param name="rootRanking">Ranking of the model components expressing their suitability to act as root component.</param>
        /// <param name="shapeModelIDs">Handles of the shape models of the individual model components.</param>
        public static void GetComponentModelParams(
          HTuple componentModelID,
          out HTuple minScoreComp,
          out HTuple rootRanking,
          out HTuple shapeModelIDs)
        {
            IntPtr proc = HalconAPI.PreCall(999);
            HalconAPI.Store(proc, 0, componentModelID);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentModelID);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out minScoreComp);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out rootRanking);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out shapeModelIDs);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized component model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="componentModelID">Handle of the component model.</param>
        public static void DeserializeComponentModel(
          HTuple serializedItemHandle,
          out HTuple componentModelID)
        {
            IntPtr proc = HalconAPI.PreCall(1000);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out componentModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a component model.</summary>
        /// <param name="componentModelID">Handle of the component model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeComponentModel(
          HTuple componentModelID,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1001);
            HalconAPI.Store(proc, 0, componentModelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentModelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a component model from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="componentModelID">Handle of the component model.</param>
        public static void ReadComponentModel(HTuple fileName, out HTuple componentModelID)
        {
            IntPtr proc = HalconAPI.PreCall(1002);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out componentModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a component model to a file.</summary>
        /// <param name="componentModelID">Handle of the component model.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteComponentModel(HTuple componentModelID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1003);
            HalconAPI.Store(proc, 0, componentModelID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentModelID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Prepare a component model for matching based on explicitly specified components and relations.</summary>
        /// <param name="modelImage">Input image from which the shape models of the model components should be created.</param>
        /// <param name="componentRegions">Input regions from which the shape models of the model components should be created.</param>
        /// <param name="variationRow">Variation of the model components in row direction.</param>
        /// <param name="variationColumn">Variation of the model components in column direction.</param>
        /// <param name="variationAngle">Angle variation of the model components.</param>
        /// <param name="angleStart">Smallest rotation of the component model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation of the component model. Default: 0.79</param>
        /// <param name="contrastLowComp">Lower hysteresis threshold for the contrast of the components in the model image. Default: "auto"</param>
        /// <param name="contrastHighComp">Upper hysteresis threshold for the contrast of the components in the model image. Default: "auto"</param>
        /// <param name="minSizeComp">Minimum size of the contour regions in the model. Default: "auto"</param>
        /// <param name="minContrastComp">Minimum contrast of the components in the search images. Default: "auto"</param>
        /// <param name="minScoreComp">Minimum score of the instances of the components to be found. Default: 0.5</param>
        /// <param name="numLevelsComp">Maximum number of pyramid levels for the components. Default: "auto"</param>
        /// <param name="angleStepComp">Step length of the angles (resolution) for the components. Default: "auto"</param>
        /// <param name="optimizationComp">Kind of optimization for the components. Default: "auto"</param>
        /// <param name="metricComp">Match metric used for the components. Default: "use_polarity"</param>
        /// <param name="pregenerationComp">Complete pregeneration of the shape models for the components if equal to 'true'. Default: "false"</param>
        /// <param name="componentModelID">Handle of the component model.</param>
        /// <param name="rootRanking">Ranking of the model components expressing the suitability to act as the root component.</param>
        public static void CreateComponentModel(
          HObject modelImage,
          HObject componentRegions,
          HTuple variationRow,
          HTuple variationColumn,
          HTuple variationAngle,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple contrastLowComp,
          HTuple contrastHighComp,
          HTuple minSizeComp,
          HTuple minContrastComp,
          HTuple minScoreComp,
          HTuple numLevelsComp,
          HTuple angleStepComp,
          HTuple optimizationComp,
          HTuple metricComp,
          HTuple pregenerationComp,
          out HTuple componentModelID,
          out HTuple rootRanking)
        {
            IntPtr proc = HalconAPI.PreCall(1004);
            HalconAPI.Store(proc, 1, (HObjectBase)modelImage);
            HalconAPI.Store(proc, 2, (HObjectBase)componentRegions);
            HalconAPI.Store(proc, 0, variationRow);
            HalconAPI.Store(proc, 1, variationColumn);
            HalconAPI.Store(proc, 2, variationAngle);
            HalconAPI.Store(proc, 3, angleStart);
            HalconAPI.Store(proc, 4, angleExtent);
            HalconAPI.Store(proc, 5, contrastLowComp);
            HalconAPI.Store(proc, 6, contrastHighComp);
            HalconAPI.Store(proc, 7, minSizeComp);
            HalconAPI.Store(proc, 8, minContrastComp);
            HalconAPI.Store(proc, 9, minScoreComp);
            HalconAPI.Store(proc, 10, numLevelsComp);
            HalconAPI.Store(proc, 11, angleStepComp);
            HalconAPI.Store(proc, 12, optimizationComp);
            HalconAPI.Store(proc, 13, metricComp);
            HalconAPI.Store(proc, 14, pregenerationComp);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(variationRow);
            HalconAPI.UnpinTuple(variationColumn);
            HalconAPI.UnpinTuple(variationAngle);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(contrastLowComp);
            HalconAPI.UnpinTuple(contrastHighComp);
            HalconAPI.UnpinTuple(minSizeComp);
            HalconAPI.UnpinTuple(minContrastComp);
            HalconAPI.UnpinTuple(minScoreComp);
            HalconAPI.UnpinTuple(numLevelsComp);
            HalconAPI.UnpinTuple(angleStepComp);
            HalconAPI.UnpinTuple(optimizationComp);
            HalconAPI.UnpinTuple(metricComp);
            HalconAPI.UnpinTuple(pregenerationComp);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out componentModelID);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out rootRanking);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)modelImage);
            GC.KeepAlive((object)componentRegions);
        }

        /// <summary>Prepare a component model for matching based on trained components.</summary>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        /// <param name="angleStart">Smallest rotation of the component model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation of the component model. Default: 0.79</param>
        /// <param name="minContrastComp">Minimum contrast of the components in the search images. Default: "auto"</param>
        /// <param name="minScoreComp">Minimum score of the instances of the components to be found. Default: 0.5</param>
        /// <param name="numLevelsComp">Maximum number of pyramid levels for the components. Default: "auto"</param>
        /// <param name="angleStepComp">Step length of the angles (resolution) for the components. Default: "auto"</param>
        /// <param name="optimizationComp">Kind of optimization for the components. Default: "auto"</param>
        /// <param name="metricComp">Match metric used for the components. Default: "use_polarity"</param>
        /// <param name="pregenerationComp">Complete pregeneration of the shape models for the components if equal to 'true'. Default: "false"</param>
        /// <param name="componentModelID">Handle of the component model.</param>
        /// <param name="rootRanking">Ranking of the model components expressing the suitability to act as the root component.</param>
        public static void CreateTrainedComponentModel(
          HTuple componentTrainingID,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple minContrastComp,
          HTuple minScoreComp,
          HTuple numLevelsComp,
          HTuple angleStepComp,
          HTuple optimizationComp,
          HTuple metricComp,
          HTuple pregenerationComp,
          out HTuple componentModelID,
          out HTuple rootRanking)
        {
            IntPtr proc = HalconAPI.PreCall(1005);
            HalconAPI.Store(proc, 0, componentTrainingID);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, minContrastComp);
            HalconAPI.Store(proc, 4, minScoreComp);
            HalconAPI.Store(proc, 5, numLevelsComp);
            HalconAPI.Store(proc, 6, angleStepComp);
            HalconAPI.Store(proc, 7, optimizationComp);
            HalconAPI.Store(proc, 8, metricComp);
            HalconAPI.Store(proc, 9, pregenerationComp);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentTrainingID);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(minContrastComp);
            HalconAPI.UnpinTuple(minScoreComp);
            HalconAPI.UnpinTuple(numLevelsComp);
            HalconAPI.UnpinTuple(angleStepComp);
            HalconAPI.UnpinTuple(optimizationComp);
            HalconAPI.UnpinTuple(metricComp);
            HalconAPI.UnpinTuple(pregenerationComp);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out componentModelID);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out rootRanking);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of all component training results.</summary>
        public static void ClearAllTrainingComponents()
        {
            IntPtr proc = HalconAPI.PreCall(1006);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a component training result.</summary>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        public static void ClearTrainingComponents(HTuple componentTrainingID)
        {
            IntPtr proc = HalconAPI.PreCall(1007);
            HalconAPI.Store(proc, 0, componentTrainingID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentTrainingID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the relations between the model components that are contained in a training result.</summary>
        /// <param name="relations">Region representation of the relations.</param>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        /// <param name="referenceComponent">Index of reference component.</param>
        /// <param name="image">Image for which the component relations are to be returned. Default: "model_image"</param>
        /// <param name="row">Row coordinate of the center of the rectangle representing the relation.</param>
        /// <param name="column">Column index of the center of the rectangle representing the relation.</param>
        /// <param name="phi">Orientation of the rectangle representing the relation (radians).</param>
        /// <param name="length1">First radius (half length) of the rectangle representing the relation.</param>
        /// <param name="length2">Second radius (half width) of the rectangle representing the relation.</param>
        /// <param name="angleStart">Smallest relative orientation angle.</param>
        /// <param name="angleExtent">Extent of the relative orientation angles.</param>
        public static void GetComponentRelations(
          out HObject relations,
          HTuple componentTrainingID,
          HTuple referenceComponent,
          HTuple image,
          out HTuple row,
          out HTuple column,
          out HTuple phi,
          out HTuple length1,
          out HTuple length2,
          out HTuple angleStart,
          out HTuple angleExtent)
        {
            IntPtr proc = HalconAPI.PreCall(1008);
            HalconAPI.Store(proc, 0, componentTrainingID);
            HalconAPI.Store(proc, 1, referenceComponent);
            HalconAPI.Store(proc, 2, image);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentTrainingID);
            HalconAPI.UnpinTuple(referenceComponent);
            HalconAPI.UnpinTuple(image);
            int err2 = HObject.LoadNew(proc, 1, err1, out relations);
            int err3 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out row);
            int err4 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err3, out column);
            int err5 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err4, out phi);
            int err6 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err5, out length1);
            int err7 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err6, out length2);
            int err8 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err7, out angleStart);
            int procResult = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err8, out angleExtent);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the initial or model components in a certain image.</summary>
        /// <param name="trainingComponents">Contour regions of the initial components or of the model components.</param>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        /// <param name="components">Type of returned components or index of an initial component. Default: "model_components"</param>
        /// <param name="image">Image for which the components are to be returned. Default: "model_image"</param>
        /// <param name="markOrientation">Mark the orientation of the components. Default: "false"</param>
        /// <param name="row">Row coordinate of the found instances of all initial components or model components.</param>
        /// <param name="column">Column coordinate of the found instances of all initial components or model components.</param>
        /// <param name="angle">Rotation angle of the found instances of all components.</param>
        /// <param name="score">Score of the found instances of all components.</param>
        public static void GetTrainingComponents(
          out HObject trainingComponents,
          HTuple componentTrainingID,
          HTuple components,
          HTuple image,
          HTuple markOrientation,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(1009);
            HalconAPI.Store(proc, 0, componentTrainingID);
            HalconAPI.Store(proc, 1, components);
            HalconAPI.Store(proc, 2, image);
            HalconAPI.Store(proc, 3, markOrientation);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentTrainingID);
            HalconAPI.UnpinTuple(components);
            HalconAPI.UnpinTuple(image);
            HalconAPI.UnpinTuple(markOrientation);
            int err2 = HObject.LoadNew(proc, 1, err1, out trainingComponents);
            int err3 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out row);
            int err4 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err3, out column);
            int err5 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err4, out angle);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err5, out score);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Modify the relations within a training result.</summary>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        /// <param name="referenceComponent">Model component(s) relative to which the movement(s) should be modified. Default: "all"</param>
        /// <param name="toleranceComponent">Model component(s) of which the relative movement(s) should be modified. Default: "all"</param>
        /// <param name="positionTolerance">Change of the position relation in pixels.</param>
        /// <param name="angleTolerance">Change of the orientation relation in radians.</param>
        public static void ModifyComponentRelations(
          HTuple componentTrainingID,
          HTuple referenceComponent,
          HTuple toleranceComponent,
          HTuple positionTolerance,
          HTuple angleTolerance)
        {
            IntPtr proc = HalconAPI.PreCall(1010);
            HalconAPI.Store(proc, 0, componentTrainingID);
            HalconAPI.Store(proc, 1, referenceComponent);
            HalconAPI.Store(proc, 2, toleranceComponent);
            HalconAPI.Store(proc, 3, positionTolerance);
            HalconAPI.Store(proc, 4, angleTolerance);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentTrainingID);
            HalconAPI.UnpinTuple(referenceComponent);
            HalconAPI.UnpinTuple(toleranceComponent);
            HalconAPI.UnpinTuple(positionTolerance);
            HalconAPI.UnpinTuple(angleTolerance);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a component training result.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        public static void DeserializeTrainingComponents(
          HTuple serializedItemHandle,
          out HTuple componentTrainingID)
        {
            IntPtr proc = HalconAPI.PreCall(1011);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out componentTrainingID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a component training result.</summary>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeTrainingComponents(
          HTuple componentTrainingID,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1012);
            HalconAPI.Store(proc, 0, componentTrainingID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentTrainingID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a component training result from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        public static void ReadTrainingComponents(HTuple fileName, out HTuple componentTrainingID)
        {
            IntPtr proc = HalconAPI.PreCall(1013);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out componentTrainingID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a component training result to a file.</summary>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteTrainingComponents(HTuple componentTrainingID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1014);
            HalconAPI.Store(proc, 0, componentTrainingID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentTrainingID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Adopt new parameters that are used to create the model components into the training result.</summary>
        /// <param name="trainingImages">Training images that were used for training the model components.</param>
        /// <param name="modelComponents">Contour regions of rigid model components.</param>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        /// <param name="ambiguityCriterion">Criterion for solving the ambiguities. Default: "rigidity"</param>
        /// <param name="maxContourOverlap">Maximum contour overlap of the found initial components. Default: 0.2</param>
        /// <param name="clusterThreshold">Threshold for clustering the initial components. Default: 0.5</param>
        public static void ClusterModelComponents(
          HObject trainingImages,
          out HObject modelComponents,
          HTuple componentTrainingID,
          HTuple ambiguityCriterion,
          HTuple maxContourOverlap,
          HTuple clusterThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(1015);
            HalconAPI.Store(proc, 1, (HObjectBase)trainingImages);
            HalconAPI.Store(proc, 0, componentTrainingID);
            HalconAPI.Store(proc, 1, ambiguityCriterion);
            HalconAPI.Store(proc, 2, maxContourOverlap);
            HalconAPI.Store(proc, 3, clusterThreshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentTrainingID);
            HalconAPI.UnpinTuple(ambiguityCriterion);
            HalconAPI.UnpinTuple(maxContourOverlap);
            HalconAPI.UnpinTuple(clusterThreshold);
            int procResult = HObject.LoadNew(proc, 1, err, out modelComponents);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)trainingImages);
        }

        /// <summary>Inspect the rigid model components obtained from the training.</summary>
        /// <param name="modelComponents">Contour regions of rigid model components.</param>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        /// <param name="ambiguityCriterion">Criterion for solving the ambiguities. Default: "rigidity"</param>
        /// <param name="maxContourOverlap">Maximum contour overlap of the found initial components. Default: 0.2</param>
        /// <param name="clusterThreshold">Threshold for clustering the initial components. Default: 0.5</param>
        public static void InspectClusteredComponents(
          out HObject modelComponents,
          HTuple componentTrainingID,
          HTuple ambiguityCriterion,
          HTuple maxContourOverlap,
          HTuple clusterThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(1016);
            HalconAPI.Store(proc, 0, componentTrainingID);
            HalconAPI.Store(proc, 1, ambiguityCriterion);
            HalconAPI.Store(proc, 2, maxContourOverlap);
            HalconAPI.Store(proc, 3, clusterThreshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(componentTrainingID);
            HalconAPI.UnpinTuple(ambiguityCriterion);
            HalconAPI.UnpinTuple(maxContourOverlap);
            HalconAPI.UnpinTuple(clusterThreshold);
            int procResult = HObject.LoadNew(proc, 1, err, out modelComponents);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train components and relations for the component-based matching.</summary>
        /// <param name="modelImage">Input image from which the shape models of the initial components should be created.</param>
        /// <param name="initialComponents">Contour regions or enclosing regions of the initial components.</param>
        /// <param name="trainingImages">Training images that are used for training the model components.</param>
        /// <param name="modelComponents">Contour regions of rigid model components.</param>
        /// <param name="contrastLow">Lower hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="contrastHigh">Upper hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="minSize">Minimum size of connected contour regions. Default: "auto"</param>
        /// <param name="minScore">Minimum score of the instances of the initial components to be found. Default: 0.5</param>
        /// <param name="searchRowTol">Search tolerance in row direction. Default: -1</param>
        /// <param name="searchColumnTol">Search tolerance in column direction. Default: -1</param>
        /// <param name="searchAngleTol">Angle search tolerance. Default: -1</param>
        /// <param name="trainingEmphasis">Decision whether the training emphasis should lie on a fast computation or on a high robustness. Default: "speed"</param>
        /// <param name="ambiguityCriterion">Criterion for solving ambiguous matches of the initial components in the training images. Default: "rigidity"</param>
        /// <param name="maxContourOverlap">Maximum contour overlap of the found initial components in a training image. Default: 0.2</param>
        /// <param name="clusterThreshold">Threshold for clustering the initial components. Default: 0.5</param>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        public static void TrainModelComponents(
          HObject modelImage,
          HObject initialComponents,
          HObject trainingImages,
          out HObject modelComponents,
          HTuple contrastLow,
          HTuple contrastHigh,
          HTuple minSize,
          HTuple minScore,
          HTuple searchRowTol,
          HTuple searchColumnTol,
          HTuple searchAngleTol,
          HTuple trainingEmphasis,
          HTuple ambiguityCriterion,
          HTuple maxContourOverlap,
          HTuple clusterThreshold,
          out HTuple componentTrainingID)
        {
            IntPtr proc = HalconAPI.PreCall(1017);
            HalconAPI.Store(proc, 1, (HObjectBase)modelImage);
            HalconAPI.Store(proc, 2, (HObjectBase)initialComponents);
            HalconAPI.Store(proc, 3, (HObjectBase)trainingImages);
            HalconAPI.Store(proc, 0, contrastLow);
            HalconAPI.Store(proc, 1, contrastHigh);
            HalconAPI.Store(proc, 2, minSize);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, searchRowTol);
            HalconAPI.Store(proc, 5, searchColumnTol);
            HalconAPI.Store(proc, 6, searchAngleTol);
            HalconAPI.Store(proc, 7, trainingEmphasis);
            HalconAPI.Store(proc, 8, ambiguityCriterion);
            HalconAPI.Store(proc, 9, maxContourOverlap);
            HalconAPI.Store(proc, 10, clusterThreshold);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(contrastLow);
            HalconAPI.UnpinTuple(contrastHigh);
            HalconAPI.UnpinTuple(minSize);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(searchRowTol);
            HalconAPI.UnpinTuple(searchColumnTol);
            HalconAPI.UnpinTuple(searchAngleTol);
            HalconAPI.UnpinTuple(trainingEmphasis);
            HalconAPI.UnpinTuple(ambiguityCriterion);
            HalconAPI.UnpinTuple(maxContourOverlap);
            HalconAPI.UnpinTuple(clusterThreshold);
            int err2 = HObject.LoadNew(proc, 1, err1, out modelComponents);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err2, out componentTrainingID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)modelImage);
            GC.KeepAlive((object)initialComponents);
            GC.KeepAlive((object)trainingImages);
        }

        /// <summary>Extract the initial components of a component model.</summary>
        /// <param name="modelImage">Input image from which the initial components should be extracted.</param>
        /// <param name="initialComponents">Contour regions of initial components.</param>
        /// <param name="contrastLow">Lower hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="contrastHigh">Upper hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="minSize">Minimum size of the initial components. Default: "auto"</param>
        /// <param name="mode">Type of automatic segmentation. Default: "connection"</param>
        /// <param name="genericName">Names of optional control parameters. Default: []</param>
        /// <param name="genericValue">Values of optional control parameters. Default: []</param>
        public static void GenInitialComponents(
          HObject modelImage,
          out HObject initialComponents,
          HTuple contrastLow,
          HTuple contrastHigh,
          HTuple minSize,
          HTuple mode,
          HTuple genericName,
          HTuple genericValue)
        {
            IntPtr proc = HalconAPI.PreCall(1018);
            HalconAPI.Store(proc, 1, (HObjectBase)modelImage);
            HalconAPI.Store(proc, 0, contrastLow);
            HalconAPI.Store(proc, 1, contrastHigh);
            HalconAPI.Store(proc, 2, minSize);
            HalconAPI.Store(proc, 3, mode);
            HalconAPI.Store(proc, 4, genericName);
            HalconAPI.Store(proc, 5, genericValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(contrastLow);
            HalconAPI.UnpinTuple(contrastHigh);
            HalconAPI.UnpinTuple(minSize);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(genericName);
            HalconAPI.UnpinTuple(genericValue);
            int procResult = HObject.LoadNew(proc, 1, err, out initialComponents);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)modelImage);
        }

        /// <summary>Get details of a result from deformable surface based matching.</summary>
        /// <param name="deformableSurfaceMatchingResult">Handle of the deformable surface matching result.</param>
        /// <param name="resultName">Name of the result property. Default: "sampled_scene"</param>
        /// <param name="resultIndex">Index of the result property. Default: 0</param>
        /// <param name="resultValue">Value of the result property.</param>
        public static void GetDeformableSurfaceMatchingResult(
          HTuple deformableSurfaceMatchingResult,
          HTuple resultName,
          HTuple resultIndex,
          out HTuple resultValue)
        {
            IntPtr proc = HalconAPI.PreCall(1019);
            HalconAPI.Store(proc, 0, deformableSurfaceMatchingResult);
            HalconAPI.Store(proc, 1, resultName);
            HalconAPI.Store(proc, 2, resultIndex);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deformableSurfaceMatchingResult);
            HalconAPI.UnpinTuple(resultName);
            HalconAPI.UnpinTuple(resultIndex);
            int procResult = HTuple.LoadNew(proc, 0, err, out resultValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a deformable surface matching result.</summary>
        /// <param name="deformableSurfaceMatchingResult">Handle of the deformable surface matching result.</param>
        public static void ClearDeformableSurfaceMatchingResult(HTuple deformableSurfaceMatchingResult)
        {
            IntPtr proc = HalconAPI.PreCall(1020);
            HalconAPI.Store(proc, 0, deformableSurfaceMatchingResult);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deformableSurfaceMatchingResult);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a deformable surface model.</summary>
        /// <param name="deformableSurfaceModel">Handle of the deformable surface model.</param>
        public static void ClearDeformableSurfaceModel(HTuple deformableSurfaceModel)
        {
            IntPtr proc = HalconAPI.PreCall(1021);
            HalconAPI.Store(proc, 0, deformableSurfaceModel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deformableSurfaceModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a deformable surface model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="deformableSurfaceModel">Handle of the deformable surface model.</param>
        public static void DeserializeDeformableSurfaceModel(
          HTuple serializedItemHandle,
          out HTuple deformableSurfaceModel)
        {
            IntPtr proc = HalconAPI.PreCall(1022);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out deformableSurfaceModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a deformable surface_model.</summary>
        /// <param name="deformableSurfaceModel">Handle of the deformable surface model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeDeformableSurfaceModel(
          HTuple deformableSurfaceModel,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1023);
            HalconAPI.Store(proc, 0, deformableSurfaceModel);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deformableSurfaceModel);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a deformable surface model from a file.</summary>
        /// <param name="fileName">Name of the file to read.</param>
        /// <param name="deformableSurfaceModel">Handle of the read deformable surface model.</param>
        public static void ReadDeformableSurfaceModel(
          HTuple fileName,
          out HTuple deformableSurfaceModel)
        {
            IntPtr proc = HalconAPI.PreCall(1024);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out deformableSurfaceModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a deformable surface model to a file.</summary>
        /// <param name="deformableSurfaceModel">Handle of the deformable surface model to write.</param>
        /// <param name="fileName">File name to write to.</param>
        public static void WriteDeformableSurfaceModel(HTuple deformableSurfaceModel, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1025);
            HalconAPI.Store(proc, 0, deformableSurfaceModel);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deformableSurfaceModel);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Refine the position and deformation of a deformable surface model in a 3D scene.</summary>
        /// <param name="deformableSurfaceModel">Handle of the deformable surface model.</param>
        /// <param name="objectModel3D">Handle of the 3D object model containing the scene.</param>
        /// <param name="relSamplingDistance">Relative sampling distance of the scene. Default: 0.05</param>
        /// <param name="initialDeformationObjectModel3D">Initial deformation of the 3D object model</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="score">Score of the refined model.</param>
        /// <param name="deformableSurfaceMatchingResult">Handle of the matching result.</param>
        public static void RefineDeformableSurfaceModel(
          HTuple deformableSurfaceModel,
          HTuple objectModel3D,
          HTuple relSamplingDistance,
          HTuple initialDeformationObjectModel3D,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple score,
          out HTuple deformableSurfaceMatchingResult)
        {
            IntPtr proc = HalconAPI.PreCall(1026);
            HalconAPI.Store(proc, 0, deformableSurfaceModel);
            HalconAPI.Store(proc, 1, objectModel3D);
            HalconAPI.Store(proc, 2, relSamplingDistance);
            HalconAPI.Store(proc, 3, initialDeformationObjectModel3D);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deformableSurfaceModel);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(relSamplingDistance);
            HalconAPI.UnpinTuple(initialDeformationObjectModel3D);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out score);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out deformableSurfaceMatchingResult);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find the best match of a deformable surface model in a 3D scene.</summary>
        /// <param name="deformableSurfaceModel">Handle of the deformable surface model.</param>
        /// <param name="objectModel3D">Handle of the 3D object model containing the scene.</param>
        /// <param name="relSamplingDistance">Scene sampling distance relative to the diameter of the surface model. Default: 0.05</param>
        /// <param name="minScore">Minimum score of the returned match. Default: 0</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="score">Score of the found instances of the surface model.</param>
        /// <param name="deformableSurfaceMatchingResult">Handle of the matching result.</param>
        public static void FindDeformableSurfaceModel(
          HTuple deformableSurfaceModel,
          HTuple objectModel3D,
          HTuple relSamplingDistance,
          HTuple minScore,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple score,
          out HTuple deformableSurfaceMatchingResult)
        {
            IntPtr proc = HalconAPI.PreCall(1027);
            HalconAPI.Store(proc, 0, deformableSurfaceModel);
            HalconAPI.Store(proc, 1, objectModel3D);
            HalconAPI.Store(proc, 2, relSamplingDistance);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deformableSurfaceModel);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(relSamplingDistance);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out score);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out deformableSurfaceMatchingResult);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters and properties of a deformable surface model.</summary>
        /// <param name="deformableSurfaceModel">Handle of the deformable surface model.</param>
        /// <param name="genParamName">Name of the parameter. Default: "sampled_model"</param>
        /// <param name="genParamValue">Value of the parameter.</param>
        public static void GetDeformableSurfaceModelParam(
          HTuple deformableSurfaceModel,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1028);
            HalconAPI.Store(proc, 0, deformableSurfaceModel);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deformableSurfaceModel);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a reference point to a deformable surface model.</summary>
        /// <param name="deformableSurfaceModel">Handle of the deformable surface model.</param>
        /// <param name="referencePointX">x-coordinates of a reference point.</param>
        /// <param name="referencePointY">x-coordinates of a reference point.</param>
        /// <param name="referencePointZ">x-coordinates of a reference point.</param>
        /// <param name="referencePointIndex">Index of the new reference point.</param>
        public static void AddDeformableSurfaceModelReferencePoint(
          HTuple deformableSurfaceModel,
          HTuple referencePointX,
          HTuple referencePointY,
          HTuple referencePointZ,
          out HTuple referencePointIndex)
        {
            IntPtr proc = HalconAPI.PreCall(1029);
            HalconAPI.Store(proc, 0, deformableSurfaceModel);
            HalconAPI.Store(proc, 1, referencePointX);
            HalconAPI.Store(proc, 2, referencePointY);
            HalconAPI.Store(proc, 3, referencePointZ);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deformableSurfaceModel);
            HalconAPI.UnpinTuple(referencePointX);
            HalconAPI.UnpinTuple(referencePointY);
            HalconAPI.UnpinTuple(referencePointZ);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out referencePointIndex);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a sample deformation to a deformable surface model</summary>
        /// <param name="deformableSurfaceModel">Handle of the deformable surface model.</param>
        /// <param name="objectModel3D">Handle of the deformed 3D object model.</param>
        public static void AddDeformableSurfaceModelSample(
          HTuple deformableSurfaceModel,
          HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1030);
            HalconAPI.Store(proc, 0, deformableSurfaceModel);
            HalconAPI.Store(proc, 1, objectModel3D);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(deformableSurfaceModel);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create the data structure needed to perform deformable surface-based matching.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="relSamplingDistance">Sampling distance relative to the object's diameter Default: 0.05</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="deformableSurfaceModel">Handle of the deformable surface model.</param>
        public static void CreateDeformableSurfaceModel(
          HTuple objectModel3D,
          HTuple relSamplingDistance,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple deformableSurfaceModel)
        {
            IntPtr proc = HalconAPI.PreCall(1031);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, relSamplingDistance);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(relSamplingDistance);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out deformableSurfaceModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get details of a result from surface based matching.</summary>
        /// <param name="surfaceMatchingResultID">Handle of the surface matching result.</param>
        /// <param name="resultName">Name of the result property. Default: "pose"</param>
        /// <param name="resultIndex">Index of the matching result, starting with 0. Default: 0</param>
        /// <param name="resultValue">Value of the result property.</param>
        public static void GetSurfaceMatchingResult(
          HTuple surfaceMatchingResultID,
          HTuple resultName,
          HTuple resultIndex,
          out HTuple resultValue)
        {
            IntPtr proc = HalconAPI.PreCall(1032);
            HalconAPI.Store(proc, 0, surfaceMatchingResultID);
            HalconAPI.Store(proc, 1, resultName);
            HalconAPI.Store(proc, 2, resultIndex);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surfaceMatchingResultID);
            HalconAPI.UnpinTuple(resultName);
            HalconAPI.UnpinTuple(resultIndex);
            int procResult = HTuple.LoadNew(proc, 0, err, out resultValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of all surface matching results.</summary>
        public static void ClearAllSurfaceMatchingResults()
        {
            IntPtr proc = HalconAPI.PreCall(1033);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a surface matching result.</summary>
        /// <param name="surfaceMatchingResultID">Handle of the surface matching result.</param>
        public static void ClearSurfaceMatchingResult(HTuple surfaceMatchingResultID)
        {
            IntPtr proc = HalconAPI.PreCall(1034);
            HalconAPI.Store(proc, 0, surfaceMatchingResultID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surfaceMatchingResultID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of all surface models.</summary>
        public static void ClearAllSurfaceModels()
        {
            IntPtr proc = HalconAPI.PreCall(1035);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a surface model.</summary>
        /// <param name="surfaceModelID">Handle of the surface model.</param>
        public static void ClearSurfaceModel(HTuple surfaceModelID)
        {
            IntPtr proc = HalconAPI.PreCall(1036);
            HalconAPI.Store(proc, 0, surfaceModelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surfaceModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a surface model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="surfaceModelID">Handle of the surface model.</param>
        public static void DeserializeSurfaceModel(
          HTuple serializedItemHandle,
          out HTuple surfaceModelID)
        {
            IntPtr proc = HalconAPI.PreCall(1037);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out surfaceModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a surface_model.</summary>
        /// <param name="surfaceModelID">Handle of the surface model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeSurfaceModel(HTuple surfaceModelID, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1038);
            HalconAPI.Store(proc, 0, surfaceModelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surfaceModelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a surface model from a file.</summary>
        /// <param name="fileName">Name of the SFM file.</param>
        /// <param name="surfaceModelID">Handle of the read surface model.</param>
        public static void ReadSurfaceModel(HTuple fileName, out HTuple surfaceModelID)
        {
            IntPtr proc = HalconAPI.PreCall(1039);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out surfaceModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a surface model to a file.</summary>
        /// <param name="surfaceModelID">Handle of the surface model.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteSurfaceModel(HTuple surfaceModelID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1040);
            HalconAPI.Store(proc, 0, surfaceModelID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surfaceModelID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Refine the pose of a surface model in a 3D scene.</summary>
        /// <param name="surfaceModelID">Handle of the surface model.</param>
        /// <param name="objectModel3D">Handle of the 3D object model containing the scene.</param>
        /// <param name="initialPose">Initial pose of the surface model in the scene.</param>
        /// <param name="minScore">Minimum score of the returned poses. Default: 0</param>
        /// <param name="returnResultHandle">Enable returning a result handle in SurfaceMatchingResultID. Default: "false"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="pose">3D pose of the surface model in the scene.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        /// <param name="surfaceMatchingResultID">Handle of the matching result, if enabled in ReturnResultHandle.</param>
        public static void RefineSurfaceModelPose(
          HTuple surfaceModelID,
          HTuple objectModel3D,
          HTuple initialPose,
          HTuple minScore,
          HTuple returnResultHandle,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple pose,
          out HTuple score,
          out HTuple surfaceMatchingResultID)
        {
            IntPtr proc = HalconAPI.PreCall(1041);
            HalconAPI.Store(proc, 0, surfaceModelID);
            HalconAPI.Store(proc, 1, objectModel3D);
            HalconAPI.Store(proc, 2, initialPose);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, returnResultHandle);
            HalconAPI.Store(proc, 5, genParamName);
            HalconAPI.Store(proc, 6, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surfaceModelID);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(initialPose);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(returnResultHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out score);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out surfaceMatchingResultID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find the best matches of a surface model in a 3D scene.</summary>
        /// <param name="surfaceModelID">Handle of the surface model.</param>
        /// <param name="objectModel3D">Handle of the 3D object model containing the scene.</param>
        /// <param name="relSamplingDistance">Scene sampling distance relative to the diameter of the surface model. Default: 0.05</param>
        /// <param name="keyPointFraction">Fraction of sampled scene points used as key points. Default: 0.2</param>
        /// <param name="minScore">Minimum score of the returned poses. Default: 0</param>
        /// <param name="returnResultHandle">Enable returning a result handle in SurfaceMatchingResultID. Default: "false"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="pose">3D pose of the surface model in the scene.</param>
        /// <param name="score">Score of the found instances of the surface model.</param>
        /// <param name="surfaceMatchingResultID">Handle of the matching result, if enabled in ReturnResultHandle.</param>
        public static void FindSurfaceModel(
          HTuple surfaceModelID,
          HTuple objectModel3D,
          HTuple relSamplingDistance,
          HTuple keyPointFraction,
          HTuple minScore,
          HTuple returnResultHandle,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple pose,
          out HTuple score,
          out HTuple surfaceMatchingResultID)
        {
            IntPtr proc = HalconAPI.PreCall(1042);
            HalconAPI.Store(proc, 0, surfaceModelID);
            HalconAPI.Store(proc, 1, objectModel3D);
            HalconAPI.Store(proc, 2, relSamplingDistance);
            HalconAPI.Store(proc, 3, keyPointFraction);
            HalconAPI.Store(proc, 4, minScore);
            HalconAPI.Store(proc, 5, returnResultHandle);
            HalconAPI.Store(proc, 6, genParamName);
            HalconAPI.Store(proc, 7, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surfaceModelID);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(relSamplingDistance);
            HalconAPI.UnpinTuple(keyPointFraction);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(returnResultHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out score);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out surfaceMatchingResultID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters and properties of a surface model.</summary>
        /// <param name="surfaceModelID">Handle of the surface model.</param>
        /// <param name="genParamName">Name of the parameter. Default: "diameter"</param>
        /// <param name="genParamValue">Value of the parameter.</param>
        public static void GetSurfaceModelParam(
          HTuple surfaceModelID,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1043);
            HalconAPI.Store(proc, 0, surfaceModelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surfaceModelID);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create the data structure needed to perform surface-based matching.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="relSamplingDistance">Sampling distance relative to the object's diameter Default: 0.03</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="surfaceModelID">Handle of the surface model.</param>
        public static void CreateSurfaceModel(
          HTuple objectModel3D,
          HTuple relSamplingDistance,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple surfaceModelID)
        {
            IntPtr proc = HalconAPI.PreCall(1044);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, relSamplingDistance);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(relSamplingDistance);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out surfaceModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a 3D camera pose from camera center and viewing direction.</summary>
        /// <param name="camPosX">X coordinate of the optical center of the camera.</param>
        /// <param name="camPosY">Y coordinate of the optical center of the camera.</param>
        /// <param name="camPosZ">Z coordinate of the optical center of the camera.</param>
        /// <param name="lookAtX">X coordinate of the 3D point to which the camera is directed.</param>
        /// <param name="lookAtY">Y coordinate of the 3D point to which the camera is directed.</param>
        /// <param name="lookAtZ">Z coordinate of the 3D point to which the camera is directed.</param>
        /// <param name="refPlaneNormal">Normal vector of the reference plane (points up). Default: "-y"</param>
        /// <param name="camRoll">Camera roll angle. Default: 0</param>
        /// <param name="camPose">3D camera pose.</param>
        public static void CreateCamPoseLookAtPoint(
          HTuple camPosX,
          HTuple camPosY,
          HTuple camPosZ,
          HTuple lookAtX,
          HTuple lookAtY,
          HTuple lookAtZ,
          HTuple refPlaneNormal,
          HTuple camRoll,
          out HTuple camPose)
        {
            IntPtr proc = HalconAPI.PreCall(1045);
            HalconAPI.Store(proc, 0, camPosX);
            HalconAPI.Store(proc, 1, camPosY);
            HalconAPI.Store(proc, 2, camPosZ);
            HalconAPI.Store(proc, 3, lookAtX);
            HalconAPI.Store(proc, 4, lookAtY);
            HalconAPI.Store(proc, 5, lookAtZ);
            HalconAPI.Store(proc, 6, refPlaneNormal);
            HalconAPI.Store(proc, 7, camRoll);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camPosX);
            HalconAPI.UnpinTuple(camPosY);
            HalconAPI.UnpinTuple(camPosZ);
            HalconAPI.UnpinTuple(lookAtX);
            HalconAPI.UnpinTuple(lookAtY);
            HalconAPI.UnpinTuple(lookAtZ);
            HalconAPI.UnpinTuple(refPlaneNormal);
            HalconAPI.UnpinTuple(camRoll);
            int procResult = HTuple.LoadNew(proc, 0, err, out camPose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert spherical coordinates of a 3D point to Cartesian coordinates.</summary>
        /// <param name="longitude">Longitude of the 3D point.</param>
        /// <param name="latitude">Latitude of the 3D point.</param>
        /// <param name="radius">Radius of the 3D point.</param>
        /// <param name="equatPlaneNormal">Normal vector of the equatorial plane (points to the north pole). Default: "-y"</param>
        /// <param name="zeroMeridian">Coordinate axis in the equatorial plane that points to the zero meridian. Default: "-z"</param>
        /// <param name="x">X coordinate of the 3D point.</param>
        /// <param name="y">Y coordinate of the 3D point.</param>
        /// <param name="z">Z coordinate of the 3D point.</param>
        public static void ConvertPoint3dSpherToCart(
          HTuple longitude,
          HTuple latitude,
          HTuple radius,
          HTuple equatPlaneNormal,
          HTuple zeroMeridian,
          out HTuple x,
          out HTuple y,
          out HTuple z)
        {
            IntPtr proc = HalconAPI.PreCall(1046);
            HalconAPI.Store(proc, 0, longitude);
            HalconAPI.Store(proc, 1, latitude);
            HalconAPI.Store(proc, 2, radius);
            HalconAPI.Store(proc, 3, equatPlaneNormal);
            HalconAPI.Store(proc, 4, zeroMeridian);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(longitude);
            HalconAPI.UnpinTuple(latitude);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(equatPlaneNormal);
            HalconAPI.UnpinTuple(zeroMeridian);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out x);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out y);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out z);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert Cartesian coordinates of a 3D point to spherical coordinates.</summary>
        /// <param name="x">X coordinate of the 3D point.</param>
        /// <param name="y">Y coordinate of the 3D point.</param>
        /// <param name="z">Z coordinate of the 3D point.</param>
        /// <param name="equatPlaneNormal">Normal vector of the equatorial plane (points to the north pole). Default: "-y"</param>
        /// <param name="zeroMeridian">Coordinate axis in the equatorial plane that points to the zero meridian. Default: "-z"</param>
        /// <param name="longitude">Longitude of the 3D point.</param>
        /// <param name="latitude">Latitude of the 3D point.</param>
        /// <param name="radius">Radius of the 3D point.</param>
        public static void ConvertPoint3dCartToSpher(
          HTuple x,
          HTuple y,
          HTuple z,
          HTuple equatPlaneNormal,
          HTuple zeroMeridian,
          out HTuple longitude,
          out HTuple latitude,
          out HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(1047);
            HalconAPI.Store(proc, 0, x);
            HalconAPI.Store(proc, 1, y);
            HalconAPI.Store(proc, 2, z);
            HalconAPI.Store(proc, 3, equatPlaneNormal);
            HalconAPI.Store(proc, 4, zeroMeridian);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(x);
            HalconAPI.UnpinTuple(y);
            HalconAPI.UnpinTuple(z);
            HalconAPI.UnpinTuple(equatPlaneNormal);
            HalconAPI.UnpinTuple(zeroMeridian);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out longitude);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out latitude);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out radius);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of all 3D shape models.</summary>
        public static void ClearAllShapeModel3d()
        {
            IntPtr proc = HalconAPI.PreCall(1048);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a 3D shape model.</summary>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        public static void ClearShapeModel3d(HTuple shapeModel3DID)
        {
            IntPtr proc = HalconAPI.PreCall(1049);
            HalconAPI.Store(proc, 0, shapeModel3DID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(shapeModel3DID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized 3D shape model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        public static void DeserializeShapeModel3d(
          HTuple serializedItemHandle,
          out HTuple shapeModel3DID)
        {
            IntPtr proc = HalconAPI.PreCall(1050);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out shapeModel3DID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a 3D shape model.</summary>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeShapeModel3d(HTuple shapeModel3DID, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1051);
            HalconAPI.Store(proc, 0, shapeModel3DID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(shapeModel3DID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a 3D shape model from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        public static void ReadShapeModel3d(HTuple fileName, out HTuple shapeModel3DID)
        {
            IntPtr proc = HalconAPI.PreCall(1052);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out shapeModel3DID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a 3D shape model to a file.</summary>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteShapeModel3d(HTuple shapeModel3DID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1053);
            HalconAPI.Store(proc, 0, shapeModel3DID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(shapeModel3DID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transform a pose that refers to the coordinate system of a 3D object model to a pose that refers to the reference coordinate system of a 3D shape model and vice versa.</summary>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        /// <param name="poseIn">Pose to be transformed in the source system.</param>
        /// <param name="transformation">Direction of the transformation. Default: "ref_to_model"</param>
        /// <param name="poseOut">Transformed 3D pose in the target system.</param>
        public static void TransPoseShapeModel3d(
          HTuple shapeModel3DID,
          HTuple poseIn,
          HTuple transformation,
          out HTuple poseOut)
        {
            IntPtr proc = HalconAPI.PreCall(1054);
            HalconAPI.Store(proc, 0, shapeModel3DID);
            HalconAPI.Store(proc, 1, poseIn);
            HalconAPI.Store(proc, 2, transformation);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(shapeModel3DID);
            HalconAPI.UnpinTuple(poseIn);
            HalconAPI.UnpinTuple(transformation);
            int procResult = HTuple.LoadNew(proc, 0, err, out poseOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Project the edges of a 3D shape model into image coordinates.</summary>
        /// <param name="modelContours">Contour representation of the model view.</param>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        /// <param name="camParam">Internal camera parameters.</param>
        /// <param name="pose">3D pose of the 3D shape model in the world coordinate system.</param>
        /// <param name="hiddenSurfaceRemoval">Remove hidden surfaces? Default: "true"</param>
        /// <param name="minFaceAngle">Smallest face angle for which the edge is displayed Default: 0.523599</param>
        public static void ProjectShapeModel3d(
          out HObject modelContours,
          HTuple shapeModel3DID,
          HTuple camParam,
          HTuple pose,
          HTuple hiddenSurfaceRemoval,
          HTuple minFaceAngle)
        {
            IntPtr proc = HalconAPI.PreCall(1055);
            HalconAPI.Store(proc, 0, shapeModel3DID);
            HalconAPI.Store(proc, 1, camParam);
            HalconAPI.Store(proc, 2, pose);
            HalconAPI.Store(proc, 3, hiddenSurfaceRemoval);
            HalconAPI.Store(proc, 4, minFaceAngle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(shapeModel3DID);
            HalconAPI.UnpinTuple(camParam);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.UnpinTuple(hiddenSurfaceRemoval);
            HalconAPI.UnpinTuple(minFaceAngle);
            int procResult = HObject.LoadNew(proc, 1, err, out modelContours);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the contour representation of a 3D shape model view.</summary>
        /// <param name="modelContours">Contour representation of the model view.</param>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        /// <param name="level">Pyramid level for which the contour representation should be returned. Default: 1</param>
        /// <param name="view">View for which the contour representation should be returned. Default: 1</param>
        /// <param name="viewPose">3D pose of the 3D shape model at the current view.</param>
        public static void GetShapeModel3dContours(
          out HObject modelContours,
          HTuple shapeModel3DID,
          HTuple level,
          HTuple view,
          out HTuple viewPose)
        {
            IntPtr proc = HalconAPI.PreCall(1056);
            HalconAPI.Store(proc, 0, shapeModel3DID);
            HalconAPI.Store(proc, 1, level);
            HalconAPI.Store(proc, 2, view);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(shapeModel3DID);
            HalconAPI.UnpinTuple(level);
            HalconAPI.UnpinTuple(view);
            int err2 = HObject.LoadNew(proc, 1, err1, out modelContours);
            int procResult = HTuple.LoadNew(proc, 0, err2, out viewPose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters of a 3D shape model.</summary>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        /// <param name="genParamName">Names of the generic parameters that are to be queried for the 3D shape model. Default: "num_levels_max"</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        public static void GetShapeModel3dParams(
          HTuple shapeModel3DID,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1057);
            HalconAPI.Store(proc, 0, shapeModel3DID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(shapeModel3DID);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find the best matches of a 3D shape model in an image.</summary>
        /// <param name="image">Input image in which the model should be found.</param>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.7</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="genParamName">Names of (optional) parameters for controlling the behavior of the operator. Default: []</param>
        /// <param name="genParamValue">Values of the optional generic parameters. Default: []</param>
        /// <param name="pose">3D pose of the 3D shape model.</param>
        /// <param name="covPose">6 standard deviations or 36 covariances of the pose parameters.</param>
        /// <param name="score">Score of the found instances of the 3D shape model.</param>
        public static void FindShapeModel3d(
          HObject image,
          HTuple shapeModel3DID,
          HTuple minScore,
          HTuple greediness,
          HTuple numLevels,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple pose,
          out HTuple covPose,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(1058);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, shapeModel3DID);
            HalconAPI.Store(proc, 1, minScore);
            HalconAPI.Store(proc, 2, greediness);
            HalconAPI.Store(proc, 3, numLevels);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(shapeModel3DID);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(greediness);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covPose);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Prepare a 3D object model for matching.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="camParam">Internal camera parameters.</param>
        /// <param name="refRotX">Reference orientation: Rotation around x-axis or x component of the Rodriguez vector (in radians or without unit). Default: 0</param>
        /// <param name="refRotY">Reference orientation: Rotation around y-axis or y component of the Rodriguez vector (in radians or without unit). Default: 0</param>
        /// <param name="refRotZ">Reference orientation: Rotation around z-axis or z component of the Rodriguez vector (in radians or without unit). Default: 0</param>
        /// <param name="orderOfRotation">Meaning of the rotation values of the reference orientation. Default: "gba"</param>
        /// <param name="longitudeMin">Minimum longitude of the model views. Default: -0.35</param>
        /// <param name="longitudeMax">Maximum longitude of the model views. Default: 0.35</param>
        /// <param name="latitudeMin">Minimum latitude of the model views. Default: -0.35</param>
        /// <param name="latitudeMax">Maximum latitude of the model views. Default: 0.35</param>
        /// <param name="camRollMin">Minimum camera roll angle of the model views. Default: -3.1416</param>
        /// <param name="camRollMax">Maximum camera roll angle of the model views. Default: 3.1416</param>
        /// <param name="distMin">Minimum camera-object-distance of the model views. Default: 0.3</param>
        /// <param name="distMax">Maximum camera-object-distance of the model views. Default: 0.4</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: 10</param>
        /// <param name="genParamName">Names of (optional) parameters for controlling the behavior of the operator. Default: []</param>
        /// <param name="genParamValue">Values of the optional generic parameters. Default: []</param>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        public static void CreateShapeModel3d(
          HTuple objectModel3D,
          HTuple camParam,
          HTuple refRotX,
          HTuple refRotY,
          HTuple refRotZ,
          HTuple orderOfRotation,
          HTuple longitudeMin,
          HTuple longitudeMax,
          HTuple latitudeMin,
          HTuple latitudeMax,
          HTuple camRollMin,
          HTuple camRollMax,
          HTuple distMin,
          HTuple distMax,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple shapeModel3DID)
        {
            IntPtr proc = HalconAPI.PreCall(1059);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, camParam);
            HalconAPI.Store(proc, 2, refRotX);
            HalconAPI.Store(proc, 3, refRotY);
            HalconAPI.Store(proc, 4, refRotZ);
            HalconAPI.Store(proc, 5, orderOfRotation);
            HalconAPI.Store(proc, 6, longitudeMin);
            HalconAPI.Store(proc, 7, longitudeMax);
            HalconAPI.Store(proc, 8, latitudeMin);
            HalconAPI.Store(proc, 9, latitudeMax);
            HalconAPI.Store(proc, 10, camRollMin);
            HalconAPI.Store(proc, 11, camRollMax);
            HalconAPI.Store(proc, 12, distMin);
            HalconAPI.Store(proc, 13, distMax);
            HalconAPI.Store(proc, 14, minContrast);
            HalconAPI.Store(proc, 15, genParamName);
            HalconAPI.Store(proc, 16, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(camParam);
            HalconAPI.UnpinTuple(refRotX);
            HalconAPI.UnpinTuple(refRotY);
            HalconAPI.UnpinTuple(refRotZ);
            HalconAPI.UnpinTuple(orderOfRotation);
            HalconAPI.UnpinTuple(longitudeMin);
            HalconAPI.UnpinTuple(longitudeMax);
            HalconAPI.UnpinTuple(latitudeMin);
            HalconAPI.UnpinTuple(latitudeMax);
            HalconAPI.UnpinTuple(camRollMin);
            HalconAPI.UnpinTuple(camRollMax);
            HalconAPI.UnpinTuple(distMin);
            HalconAPI.UnpinTuple(distMax);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out shapeModel3DID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Simplify a triangulated 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model that should be simplified.</param>
        /// <param name="method">Method that should be used for simplification. Default: "preserve_point_coordinates"</param>
        /// <param name="amount">Degree of simplification (default: percentage of remaining model points).</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="simplifiedObjectModel3D">Handle of the simplified 3D object model.</param>
        public static void SimplifyObjectModel3d(
          HTuple objectModel3D,
          HTuple method,
          HTuple amount,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple simplifiedObjectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1060);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, method);
            HalconAPI.Store(proc, 2, amount);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(amount);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out simplifiedObjectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the distances of the points of one 3D object model to another 3D object model.</summary>
        /// <param name="objectModel3DFrom">Handle of the source 3D object model.</param>
        /// <param name="objectModel3DTo">Handle of the target 3D object model.</param>
        /// <param name="pose">Pose of the source 3D object model in the target 3D object model. Default: []</param>
        /// <param name="maxDistance">Maximum distance of interest. Default: 0</param>
        /// <param name="genParamName">Names of the generic input parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic input parameters. Default: []</param>
        public static void DistanceObjectModel3d(
          HTuple objectModel3DFrom,
          HTuple objectModel3DTo,
          HTuple pose,
          HTuple maxDistance,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1061);
            HalconAPI.Store(proc, 0, objectModel3DFrom);
            HalconAPI.Store(proc, 1, objectModel3DTo);
            HalconAPI.Store(proc, 2, pose);
            HalconAPI.Store(proc, 3, maxDistance);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3DFrom);
            HalconAPI.UnpinTuple(objectModel3DTo);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.UnpinTuple(maxDistance);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Combine several 3D object models to a new 3D object model.</summary>
        /// <param name="objectModels3D">Handle of input 3D object models.</param>
        /// <param name="method">Method used for the union. Default: "points_surface"</param>
        /// <param name="unionObjectModel3D">Handle of the resulting 3D object model.</param>
        public static void UnionObjectModel3d(
          HTuple objectModels3D,
          HTuple method,
          out HTuple unionObjectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1062);
            HalconAPI.Store(proc, 0, objectModels3D);
            HalconAPI.Store(proc, 1, method);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModels3D);
            HalconAPI.UnpinTuple(method);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out unionObjectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set attributes of a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="attribName">Name of the attributes.</param>
        /// <param name="attachExtAttribTo">Defines where extended attributes are attached to. Default: []</param>
        /// <param name="attribValues">Attribute values.</param>
        public static void SetObjectModel3dAttribMod(
          HTuple objectModel3D,
          HTuple attribName,
          HTuple attachExtAttribTo,
          HTuple attribValues)
        {
            IntPtr proc = HalconAPI.PreCall(1063);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, attribName);
            HalconAPI.Store(proc, 2, attachExtAttribTo);
            HalconAPI.Store(proc, 3, attribValues);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(attribName);
            HalconAPI.UnpinTuple(attachExtAttribTo);
            HalconAPI.UnpinTuple(attribValues);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set attributes of a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the input 3D object model.</param>
        /// <param name="attribName">Name of the attributes.</param>
        /// <param name="attachExtAttribTo">Defines where extended attributes are attached to. Default: []</param>
        /// <param name="attribValues">Attribute values.</param>
        /// <param name="objectModel3DOut">Handle of the resulting 3D object model.</param>
        public static void SetObjectModel3dAttrib(
          HTuple objectModel3D,
          HTuple attribName,
          HTuple attachExtAttribTo,
          HTuple attribValues,
          out HTuple objectModel3DOut)
        {
            IntPtr proc = HalconAPI.PreCall(1064);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, attribName);
            HalconAPI.Store(proc, 2, attachExtAttribTo);
            HalconAPI.Store(proc, 3, attribValues);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(attribName);
            HalconAPI.UnpinTuple(attachExtAttribTo);
            HalconAPI.UnpinTuple(attribValues);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an empty 3D object model.</summary>
        /// <param name="emptyObjectModel3D">Handle of the new 3D object model.</param>
        public static void GenEmptyObjectModel3d(out HTuple emptyObjectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1065);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out emptyObjectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Sample a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model to be sampled.</param>
        /// <param name="method">Selects between the different subsampling methods. Default: "fast"</param>
        /// <param name="sampleDistance">Sampling distance. Default: 0.05</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted. Default: []</param>
        /// <param name="sampledObjectModel3D">Handle of the 3D object model that contains the sampled points.</param>
        public static void SampleObjectModel3d(
          HTuple objectModel3D,
          HTuple method,
          HTuple sampleDistance,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple sampledObjectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1066);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, method);
            HalconAPI.Store(proc, 2, sampleDistance);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(sampleDistance);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out sampledObjectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Improve the relative transformations between 3D object models based on their overlaps.</summary>
        /// <param name="objectModels3D">Handles of several 3D object models.</param>
        /// <param name="homMats3D">Approximate relative transformations between the 3D object models.</param>
        /// <param name="from">Type of interpretation for the transformations. Default: "global"</param>
        /// <param name="to">Target indices of the transformations if From specifies the source indices, otherwise the parameter must be empty. Default: []</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the global 3D object model registration. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the global 3D object model registration. Default: []</param>
        /// <param name="homMats3DOut">Resulting Transformations.</param>
        /// <param name="scores">Number of overlapping neighbors for each 3D object model.</param>
        public static void RegisterObjectModel3dGlobal(
          HTuple objectModels3D,
          HTuple homMats3D,
          HTuple from,
          HTuple to,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple homMats3DOut,
          out HTuple scores)
        {
            IntPtr proc = HalconAPI.PreCall(1067);
            HalconAPI.Store(proc, 0, objectModels3D);
            HalconAPI.Store(proc, 1, homMats3D);
            HalconAPI.Store(proc, 2, from);
            HalconAPI.Store(proc, 3, to);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModels3D);
            HalconAPI.UnpinTuple(homMats3D);
            HalconAPI.UnpinTuple(from);
            HalconAPI.UnpinTuple(to);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, err1, out homMats3DOut);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out scores);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Search for a transformation between two 3D object models.</summary>
        /// <param name="objectModel3D1">Handle of the first 3D object model.</param>
        /// <param name="objectModel3D2">Handle of the second 3D object model.</param>
        /// <param name="method">Method for the registration. Default: "matching"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="pose">Pose to transform ObjectModel3D1 in the reference frame of ObjectModel3D2.</param>
        /// <param name="score">Overlapping of the two 3D object models.</param>
        public static void RegisterObjectModel3dPair(
          HTuple objectModel3D1,
          HTuple objectModel3D2,
          HTuple method,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple pose,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(1068);
            HalconAPI.Store(proc, 0, objectModel3D1);
            HalconAPI.Store(proc, 1, objectModel3D2);
            HalconAPI.Store(proc, 2, method);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D1);
            HalconAPI.UnpinTuple(objectModel3D2);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out score);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a 3D object model that represents a point cloud from a set of 3D points.</summary>
        /// <param name="x">The x-coordinates of the points in the 3D point cloud.</param>
        /// <param name="y">The y-coordinates of the points in the 3D point cloud.</param>
        /// <param name="z">The z-coordinates of the points in the 3D point cloud.</param>
        /// <param name="objectModel3D">Handle of the resulting 3D object model.</param>
        public static void GenObjectModel3dFromPoints(
          HTuple x,
          HTuple y,
          HTuple z,
          out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1069);
            HalconAPI.Store(proc, 0, x);
            HalconAPI.Store(proc, 1, y);
            HalconAPI.Store(proc, 2, z);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(x);
            HalconAPI.UnpinTuple(y);
            HalconAPI.UnpinTuple(z);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a 3D object model that represents a box.</summary>
        /// <param name="pose">The pose that describes the position and orientation of the box.  The pose has its origin in the center of the box.</param>
        /// <param name="lengthX">The length of the box along the x-axis.</param>
        /// <param name="lengthY">The length of the box along the y-axis.</param>
        /// <param name="lengthZ">The length of the box along the z-axis.</param>
        /// <param name="objectModel3D">Handle of the resulting 3D object model.</param>
        public static void GenBoxObjectModel3d(
          HTuple pose,
          HTuple lengthX,
          HTuple lengthY,
          HTuple lengthZ,
          out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1070);
            HalconAPI.Store(proc, 0, pose);
            HalconAPI.Store(proc, 1, lengthX);
            HalconAPI.Store(proc, 2, lengthY);
            HalconAPI.Store(proc, 3, lengthZ);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.UnpinTuple(lengthX);
            HalconAPI.UnpinTuple(lengthY);
            HalconAPI.UnpinTuple(lengthZ);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a 3D object model that represents a plane.</summary>
        /// <param name="pose">The center and the rotation of the plane.</param>
        /// <param name="XExtent">x coordinates specifying the extent of the plane.</param>
        /// <param name="YExtent">y coordinates specifying the extent of the plane.</param>
        /// <param name="objectModel3D">Handle of the resulting 3D object model.</param>
        public static void GenPlaneObjectModel3d(
          HTuple pose,
          HTuple XExtent,
          HTuple YExtent,
          out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1071);
            HalconAPI.Store(proc, 0, pose);
            HalconAPI.Store(proc, 1, XExtent);
            HalconAPI.Store(proc, 2, YExtent);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.UnpinTuple(XExtent);
            HalconAPI.UnpinTuple(YExtent);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a 3D object model that represents a sphere from x,y,z coordinates.</summary>
        /// <param name="x">The x-coordinate of the center point of the sphere.</param>
        /// <param name="y">The y-coordinate of the center point of the sphere.</param>
        /// <param name="z">The z-coordinate of the center point of the sphere.</param>
        /// <param name="radius">The radius of the sphere.</param>
        /// <param name="objectModel3D">Handle of the resulting 3D object model.</param>
        public static void GenSphereObjectModel3dCenter(
          HTuple x,
          HTuple y,
          HTuple z,
          HTuple radius,
          out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1072);
            HalconAPI.Store(proc, 0, x);
            HalconAPI.Store(proc, 1, y);
            HalconAPI.Store(proc, 2, z);
            HalconAPI.Store(proc, 3, radius);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(x);
            HalconAPI.UnpinTuple(y);
            HalconAPI.UnpinTuple(z);
            HalconAPI.UnpinTuple(radius);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a 3D object model that represents a sphere.</summary>
        /// <param name="pose">The pose that describes the position of the sphere.</param>
        /// <param name="radius">The radius of the sphere.</param>
        /// <param name="objectModel3D">Handle of the resulting 3D object model.</param>
        public static void GenSphereObjectModel3d(HTuple pose, HTuple radius, out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1073);
            HalconAPI.Store(proc, 0, pose);
            HalconAPI.Store(proc, 1, radius);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.UnpinTuple(radius);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a 3D object model that represents a cylinder.</summary>
        /// <param name="pose">The pose that describes the position and orientation of the cylinder.</param>
        /// <param name="radius">The radius of the cylinder.</param>
        /// <param name="minExtent">The length of the cylinder in negative direction of the rotation axis.</param>
        /// <param name="maxExtent">The length of the cylinder in positive direction of the rotation axis.</param>
        /// <param name="objectModel3D">Handle of the resulting 3D object model.</param>
        public static void GenCylinderObjectModel3d(
          HTuple pose,
          HTuple radius,
          HTuple minExtent,
          HTuple maxExtent,
          out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1074);
            HalconAPI.Store(proc, 0, pose);
            HalconAPI.Store(proc, 1, radius);
            HalconAPI.Store(proc, 2, minExtent);
            HalconAPI.Store(proc, 3, maxExtent);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(minExtent);
            HalconAPI.UnpinTuple(maxExtent);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the smallest bounding box around the points of a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="type">The method that is used to estimate the smallest box. Default: "oriented"</param>
        /// <param name="pose">The pose that describes the position and orientation of the box that is generated. The pose has its origin in the center of the box and is oriented such that the x-axis is aligned with the longest side of the box.</param>
        /// <param name="length1">The length of the longest side of the box.</param>
        /// <param name="length2">The length of the second longest side of the box.</param>
        /// <param name="length3">The length of the third longest side of the box.</param>
        public static void SmallestBoundingBoxObjectModel3d(
          HTuple objectModel3D,
          HTuple type,
          out HTuple pose,
          out HTuple length1,
          out HTuple length2,
          out HTuple length3)
        {
            IntPtr proc = HalconAPI.PreCall(1075);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, type);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(type);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out length1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out length2);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out length3);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the smallest sphere around the points of a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="centerPoint">x-, y-, and z-coordinates describing the center point of the sphere.</param>
        /// <param name="radius">The estimated radius of the sphere.</param>
        public static void SmallestSphereObjectModel3d(
          HTuple objectModel3D,
          out HTuple centerPoint,
          out HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(1076);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out centerPoint);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out radius);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Intersect a 3D object model with a plane.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="plane">Pose of the plane. Default: [0,0,0,0,0,0,0]</param>
        /// <param name="objectModel3DIntersection">Handle of the 3D object model that describes the intersection as a set of lines.</param>
        public static void IntersectPlaneObjectModel3d(
          HTuple objectModel3D,
          HTuple plane,
          out HTuple objectModel3DIntersection)
        {
            IntPtr proc = HalconAPI.PreCall(1077);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, plane);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(plane);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DIntersection);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the convex hull of a 3D object model. </summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="objectModel3DConvexHull">Handle of the 3D object model that describes the convex hull.</param>
        public static void ConvexHullObjectModel3d(
          HTuple objectModel3D,
          out HTuple objectModel3DConvexHull)
        {
            IntPtr proc = HalconAPI.PreCall(1078);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DConvexHull);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select 3D object models from an array of 3D object models according to global features.</summary>
        /// <param name="objectModel3D">Handles of the available 3D object models to select.</param>
        /// <param name="feature">List of features a test is performed on. Default: "has_triangles"</param>
        /// <param name="operation">Logical operation to combine the features given in Feature. Default: "and"</param>
        /// <param name="minValue">Minimum value for the given feature. Default: 1</param>
        /// <param name="maxValue">Maximum value for the given feature. Default: 1</param>
        /// <param name="objectModel3DSelected">A subset of ObjectModel3D fulfilling the given conditions.</param>
        public static void SelectObjectModel3d(
          HTuple objectModel3D,
          HTuple feature,
          HTuple operation,
          HTuple minValue,
          HTuple maxValue,
          out HTuple objectModel3DSelected)
        {
            IntPtr proc = HalconAPI.PreCall(1079);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, feature);
            HalconAPI.Store(proc, 2, operation);
            HalconAPI.Store(proc, 3, minValue);
            HalconAPI.Store(proc, 4, maxValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(feature);
            HalconAPI.UnpinTuple(operation);
            HalconAPI.UnpinTuple(minValue);
            HalconAPI.UnpinTuple(maxValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DSelected);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the area of all faces of a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="area">Calculated area.</param>
        public static void AreaObjectModel3d(HTuple objectModel3D, out HTuple area)
        {
            IntPtr proc = HalconAPI.PreCall(1080);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out area);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the maximal diameter of a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="diameter">Calculated diameter.</param>
        public static void MaxDiameterObjectModel3d(HTuple objectModel3D, out HTuple diameter)
        {
            IntPtr proc = HalconAPI.PreCall(1081);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out diameter);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculates the mean or the central moment of second order for a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="momentsToCalculate">Moment to calculate. Default: "mean_points"</param>
        /// <param name="moments">Calculated moment.</param>
        public static void MomentsObjectModel3d(
          HTuple objectModel3D,
          HTuple momentsToCalculate,
          out HTuple moments)
        {
            IntPtr proc = HalconAPI.PreCall(1082);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, momentsToCalculate);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(momentsToCalculate);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out moments);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the volume of a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="plane">Pose of the plane. Default: [0,0,0,0,0,0,0]</param>
        /// <param name="mode">Method to combine volumes laying above and below the reference plane. Default: "signed"</param>
        /// <param name="useFaceOrientation">Decides whether the orientation of a face should affect the resulting sign of the underlying volume. Default: "true"</param>
        /// <param name="volume">Absolute value of the calculated volume.</param>
        public static void VolumeObjectModel3dRelativeToPlane(
          HTuple objectModel3D,
          HTuple plane,
          HTuple mode,
          HTuple useFaceOrientation,
          out HTuple volume)
        {
            IntPtr proc = HalconAPI.PreCall(1083);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, plane);
            HalconAPI.Store(proc, 2, mode);
            HalconAPI.Store(proc, 3, useFaceOrientation);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(plane);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(useFaceOrientation);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out volume);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Remove points from a 3D object model by projecting it to a virtual view and removing all points outside of a given region.</summary>
        /// <param name="region">Region in the image plane.</param>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="camParam">Internal camera parameters.</param>
        /// <param name="pose">3D pose of the world coordinate system in camera coordinates.</param>
        /// <param name="objectModel3DReduced">Handle of the reduced 3D object model.</param>
        public static void ReduceObjectModel3dByView(
          HObject region,
          HTuple objectModel3D,
          HTuple camParam,
          HTuple pose,
          out HTuple objectModel3DReduced)
        {
            IntPtr proc = HalconAPI.PreCall(1084);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, camParam);
            HalconAPI.Store(proc, 2, pose);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(camParam);
            HalconAPI.UnpinTuple(pose);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DReduced);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Determine the connected components of the 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="feature">Attribute used to calculate the connected components. Default: "distance_3d"</param>
        /// <param name="value">Maximum value for the distance between two connected components. Default: 1.0</param>
        /// <param name="objectModel3DConnected">Handle of the 3D object models that represent the connected components.</param>
        public static void ConnectionObjectModel3d(
          HTuple objectModel3D,
          HTuple feature,
          HTuple value,
          out HTuple objectModel3DConnected)
        {
            IntPtr proc = HalconAPI.PreCall(1085);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, feature);
            HalconAPI.Store(proc, 2, value);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(feature);
            HalconAPI.UnpinTuple(value);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DConnected);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Apply a threshold to an attribute of 3D object models.</summary>
        /// <param name="objectModel3D">Handle of the 3D object models.</param>
        /// <param name="attrib">Attributes the threshold is applied to. Default: "point_coord_z"</param>
        /// <param name="minValue">Minimum value for the attributes specified by Attrib. Default: 0.5</param>
        /// <param name="maxValue">Maximum value for the attributes specified by Attrib. Default: 1.0</param>
        /// <param name="objectModel3DThresholded">Handle of the reduced 3D object models.</param>
        public static void SelectPointsObjectModel3d(
          HTuple objectModel3D,
          HTuple attrib,
          HTuple minValue,
          HTuple maxValue,
          out HTuple objectModel3DThresholded)
        {
            IntPtr proc = HalconAPI.PreCall(1086);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, attrib);
            HalconAPI.Store(proc, 2, minValue);
            HalconAPI.Store(proc, 3, maxValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(attrib);
            HalconAPI.UnpinTuple(minValue);
            HalconAPI.UnpinTuple(maxValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DThresholded);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the depth or the index of a displayed 3D object model.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row coordinates.</param>
        /// <param name="column">Column coordinates.</param>
        /// <param name="information">Information. Default: "depth"</param>
        /// <param name="value">Indices or the depth of the objects at (Row,Column).</param>
        public static void GetDispObjectModel3dInfo(
          HTuple windowHandle,
          HTuple row,
          HTuple column,
          HTuple information,
          out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(1087);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, information);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(information);
            int procResult = HTuple.LoadNew(proc, 0, err, out value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Render 3D object models to get an image.</summary>
        /// <param name="image">Rendered scene.</param>
        /// <param name="objectModel3D">Handles of the 3D object models.</param>
        /// <param name="camParam">Camera parameters of the scene.</param>
        /// <param name="pose">3D poses of the objects.</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        public static void RenderObjectModel3d(
          out HObject image,
          HTuple objectModel3D,
          HTuple camParam,
          HTuple pose,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1088);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, camParam);
            HalconAPI.Store(proc, 2, pose);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(camParam);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Display 3D object models.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="objectModel3D">Handles of the 3D object models.</param>
        /// <param name="camParam">Camera parameters of the scene. Default: []</param>
        /// <param name="pose">3D poses of the objects. Default: []</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        public static void DispObjectModel3d(
          HTuple windowHandle,
          HTuple objectModel3D,
          HTuple camParam,
          HTuple pose,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1089);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, objectModel3D);
            HalconAPI.Store(proc, 2, camParam);
            HalconAPI.Store(proc, 3, pose);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(camParam);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Copy a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the input 3D object model.</param>
        /// <param name="attributes">Attributes to be copied. Default: "all"</param>
        /// <param name="copiedObjectModel3D">Handle of the copied 3D object model.</param>
        public static void CopyObjectModel3d(
          HTuple objectModel3D,
          HTuple attributes,
          out HTuple copiedObjectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1090);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, attributes);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(attributes);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out copiedObjectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Prepare a 3D object model for a certain operation.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="purpose">Purpose of the 3D object model. Default: "shape_based_matching_3d"</param>
        /// <param name="overwriteData">Specify if already existing data should be overwritten. Default: "true"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        public static void PrepareObjectModel3d(
          HTuple objectModel3D,
          HTuple purpose,
          HTuple overwriteData,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1091);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, purpose);
            HalconAPI.Store(proc, 2, overwriteData);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(purpose);
            HalconAPI.UnpinTuple(overwriteData);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transform 3D points from a 3D object model to images.</summary>
        /// <param name="x">Image with the X-Coordinates of the 3D points.</param>
        /// <param name="y">Image with the Y-Coordinates of the 3D points.</param>
        /// <param name="z">Image with the Z-Coordinates of the 3D points.</param>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="type">Type of the conversion. Default: "cartesian"</param>
        /// <param name="camParam">Camera parameters.</param>
        /// <param name="pose">Pose of the 3D object model.</param>
        public static void ObjectModel3dToXyz(
          out HObject x,
          out HObject y,
          out HObject z,
          HTuple objectModel3D,
          HTuple type,
          HTuple camParam,
          HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(1092);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, type);
            HalconAPI.Store(proc, 2, camParam);
            HalconAPI.Store(proc, 3, pose);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(camParam);
            HalconAPI.UnpinTuple(pose);
            int err2 = HObject.LoadNew(proc, 1, err1, out x);
            int err3 = HObject.LoadNew(proc, 2, err2, out y);
            int procResult = HObject.LoadNew(proc, 3, err3, out z);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transform 3D points from images to a 3D object model.</summary>
        /// <param name="x">Image with the X-Coordinates and the ROI of the 3D points.</param>
        /// <param name="y">Image with the Y-Coordinates of the 3D points.</param>
        /// <param name="z">Image with the Z-Coordinates of the 3D points.</param>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        public static void XyzToObjectModel3d(
          HObject x,
          HObject y,
          HObject z,
          out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1093);
            HalconAPI.Store(proc, 1, (HObjectBase)x);
            HalconAPI.Store(proc, 2, (HObjectBase)y);
            HalconAPI.Store(proc, 3, (HObjectBase)z);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)x);
            GC.KeepAlive((object)y);
            GC.KeepAlive((object)z);
        }

        /// <summary>Return attributes of 3D object models.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="genParamName">Names of the generic attributes that are queried for the 3D object model. Default: "num_points"</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        public static void GetObjectModel3dParams(
          HTuple objectModel3D,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1094);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Project a 3D object model into image coordinates.</summary>
        /// <param name="modelContours">Projected model contours.</param>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="camParam">Internal camera parameters.</param>
        /// <param name="pose">3D pose of the world coordinate system in camera coordinates.</param>
        /// <param name="genParamName">Name of the generic parameter. Default: []</param>
        /// <param name="genParamValue">Value of the generic parameter. Default: []</param>
        public static void ProjectObjectModel3d(
          out HObject modelContours,
          HTuple objectModel3D,
          HTuple camParam,
          HTuple pose,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1095);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, camParam);
            HalconAPI.Store(proc, 2, pose);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(camParam);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HObject.LoadNew(proc, 1, err, out modelContours);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Apply a rigid 3D transformation to 3D object models.</summary>
        /// <param name="objectModel3D">Handles of the 3D object models.</param>
        /// <param name="pose">Poses.</param>
        /// <param name="objectModel3DRigidTrans">Handles of the transformed 3D object models.</param>
        public static void RigidTransObjectModel3d(
          HTuple objectModel3D,
          HTuple pose,
          out HTuple objectModel3DRigidTrans)
        {
            IntPtr proc = HalconAPI.PreCall(1096);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, pose);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(pose);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DRigidTrans);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Apply an arbitrary projective 3D transformation to 3D object models.</summary>
        /// <param name="objectModel3D">Handles of the 3D object models.</param>
        /// <param name="homMat3D">Homogeneous projective transformation matrix.</param>
        /// <param name="objectModel3DProjectiveTrans">Handles of the transformed 3D object models.</param>
        public static void ProjectiveTransObjectModel3d(
          HTuple objectModel3D,
          HTuple homMat3D,
          out HTuple objectModel3DProjectiveTrans)
        {
            IntPtr proc = HalconAPI.PreCall(1097);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, homMat3D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(homMat3D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DProjectiveTrans);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Apply an arbitrary affine 3D transformation to 3D object models.</summary>
        /// <param name="objectModel3D">Handles of the 3D object models.</param>
        /// <param name="homMat3D">Transformation matrices.</param>
        /// <param name="objectModel3DAffineTrans">Handles of the transformed 3D object models.</param>
        public static void AffineTransObjectModel3d(
          HTuple objectModel3D,
          HTuple homMat3D,
          out HTuple objectModel3DAffineTrans)
        {
            IntPtr proc = HalconAPI.PreCall(1098);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, homMat3D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(homMat3D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DAffineTrans);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of all 3D object models.</summary>
        public static void ClearAllObjectModel3d()
        {
            IntPtr proc = HalconAPI.PreCall(1099);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        public static void ClearObjectModel3d(HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1100);
            HalconAPI.Store(proc, 0, objectModel3D);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeObjectModel3d(HTuple objectModel3D, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1101);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized 3D object model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        public static void DeserializeObjectModel3d(
          HTuple serializedItemHandle,
          out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1102);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Writes a 3D object model to a file.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="fileType">Type of the file that is written. Default: "om3"</param>
        /// <param name="fileName">Name of the file that is written.</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        public static void WriteObjectModel3d(
          HTuple objectModel3D,
          HTuple fileType,
          HTuple fileName,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1103);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, fileType);
            HalconAPI.Store(proc, 2, fileName);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(fileType);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a 3D object model from a file.</summary>
        /// <param name="fileName">Filename of the file to be read.</param>
        /// <param name="scale">Scale of the data in the file. Default: "m"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="status">Status information.</param>
        public static void ReadObjectModel3d(
          HTuple fileName,
          HTuple scale,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple objectModel3D,
          out HTuple status)
        {
            IntPtr proc = HalconAPI.PreCall(1104);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.Store(proc, 1, scale);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out objectModel3D);
            int procResult = HTuple.LoadNew(proc, 1, err2, out status);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read the description file of a Kalman filter.</summary>
        /// <param name="fileName">Description file for a Kalman filter. Default: "kalman.init"</param>
        /// <param name="dimension">The dimensions of the state vector, the measurement vector and the controller vector.</param>
        /// <param name="model">The lined up matrices A, C, Q, possibly G and u, and if necessary L stored in row-major order.</param>
        /// <param name="measurement">The matrix R stored in row-major order.</param>
        /// <param name="prediction">The matrix P0@f$P_{0}$ (error covariance matrix of the initial state estimate) stored in row-major order and the initial state estimate x0@f$x_{0}$ lined up.</param>
        public static void ReadKalman(
          HTuple fileName,
          out HTuple dimension,
          out HTuple model,
          out HTuple measurement,
          out HTuple prediction)
        {
            IntPtr proc = HalconAPI.PreCall(1105);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out dimension);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out model);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out measurement);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out prediction);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read an update file of a Kalman filter.</summary>
        /// <param name="fileName">Update file for a Kalman filter. Default: "kalman.updt"</param>
        /// <param name="dimensionIn">The dimensions of the state vector, measurement vector and controller vector. Default: [3,1,0]</param>
        /// <param name="modelIn">The lined up matrices A,C,Q, possibly G and u, and if necessary L which all have been stored in row-major order. Default: [1.0,1.0,0.5,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,54.3,37.9,48.0,37.9,34.3,42.5,48.0,42.5,43.7]</param>
        /// <param name="measurementIn">The matrix R stored in row-major order. Default: [1,2]</param>
        /// <param name="dimensionOut">The dimensions of the state vector, measurement vector and controller vector.</param>
        /// <param name="modelOut">The lined up matrices A,C,Q, possibly G and u, and if necessary L which all have been stored in row-major order.</param>
        /// <param name="measurementOut">The matrix R stored in row-major order.</param>
        public static void UpdateKalman(
          HTuple fileName,
          HTuple dimensionIn,
          HTuple modelIn,
          HTuple measurementIn,
          out HTuple dimensionOut,
          out HTuple modelOut,
          out HTuple measurementOut)
        {
            IntPtr proc = HalconAPI.PreCall(1106);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.Store(proc, 1, dimensionIn);
            HalconAPI.Store(proc, 2, modelIn);
            HalconAPI.Store(proc, 3, measurementIn);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.UnpinTuple(dimensionIn);
            HalconAPI.UnpinTuple(modelIn);
            HalconAPI.UnpinTuple(measurementIn);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out dimensionOut);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out modelOut);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out measurementOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Estimate the current state of a system with the help of the Kalman filtering.</summary>
        /// <param name="dimension">The dimensions of the state vector, the measurement and the controller vector. Default: [3,1,0]</param>
        /// <param name="model">The lined up matrices A,C,Q, possibly G and u, and if necessary L which have been stored in row-major order. Default: [1.0,1.0,0.5,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,54.3,37.9,48.0,37.9,34.3,42.5,48.0,42.5,43.7]</param>
        /// <param name="measurement">The matrix R stored in row-major order and the measurement vector y lined up. Default: [1.2,1.0]</param>
        /// <param name="predictionIn">The matrix P*@f$P$ (the extrapolation-error covariances) stored in row-major order and the extrapolation vector x*@f$x$ lined up. Default: [0.0,0.0,0.0,0.0,180.5,0.0,0.0,0.0,100.0,0.0,100.0,0.0]</param>
        /// <param name="predictionOut">The matrix P* (the extrapolation-error covariances)stored in row-major order and the extrapolation vector x*@f$x$ lined up.</param>
        /// <param name="estimate">The matrix P~@f$P$ (the estimation-error covariances) stored in row-major order and the estimated state x~@f$x$ lined up.</param>
        public static void FilterKalman(
          HTuple dimension,
          HTuple model,
          HTuple measurement,
          HTuple predictionIn,
          out HTuple predictionOut,
          out HTuple estimate)
        {
            IntPtr proc = HalconAPI.PreCall(1107);
            HalconAPI.Store(proc, 0, dimension);
            HalconAPI.Store(proc, 1, model);
            HalconAPI.Store(proc, 2, measurement);
            HalconAPI.Store(proc, 3, predictionIn);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dimension);
            HalconAPI.UnpinTuple(model);
            HalconAPI.UnpinTuple(measurement);
            HalconAPI.UnpinTuple(predictionIn);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out predictionOut);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out estimate);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query slots concerning information with relation to the operator get_operator_info.</summary>
        /// <param name="slots">Slotnames of the operator get_operator_info.</param>
        public static void QueryOperatorInfo(out HTuple slots)
        {
            IntPtr proc = HalconAPI.PreCall(1108);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, err, out slots);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query slots of the online-information concerning the operator get_param_info.</summary>
        /// <param name="slots">Slotnames for the operator get_param_info.</param>
        public static void QueryParamInfo(out HTuple slots)
        {
            IntPtr proc = HalconAPI.PreCall(1109);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, err, out slots);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get operators with the given string as a substring of their name.</summary>
        /// <param name="pattern">Substring of the seeked names (empty $ less than = greater than $ all names). Default: "info"</param>
        /// <param name="operatorNames">Detected operator names.</param>
        public static void GetOperatorName(HTuple pattern, out HTuple operatorNames)
        {
            IntPtr proc = HalconAPI.PreCall(1110);
            HalconAPI.Store(proc, 0, pattern);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pattern);
            int procResult = HTuple.LoadNew(proc, 0, err, out operatorNames);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get default data type for the control parameters of a HALCON-operator.</summary>
        /// <param name="operatorName">Name of the operator. Default: "get_param_types"</param>
        /// <param name="inpCtrlParType">Default type of the input control parameters.</param>
        /// <param name="outpCtrlParType">Default type of the output control parameters.</param>
        public static void GetParamTypes(
          HTuple operatorName,
          out HTuple inpCtrlParType,
          out HTuple outpCtrlParType)
        {
            IntPtr proc = HalconAPI.PreCall(1111);
            HalconAPI.Store(proc, 0, operatorName);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(operatorName);
            int err2 = HTuple.LoadNew(proc, 0, err1, out inpCtrlParType);
            int procResult = HTuple.LoadNew(proc, 1, err2, out outpCtrlParType);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get number of the different parameter classes of a HALCON-operator.</summary>
        /// <param name="operatorName">Name of the operator. Default: "get_param_num"</param>
        /// <param name="CName">Name of the called C-function.</param>
        /// <param name="inpObjPar">Number of the input object parameters.</param>
        /// <param name="outpObjPar">Number of the output object parameters.</param>
        /// <param name="inpCtrlPar">Number of the input control parameters.</param>
        /// <param name="outpCtrlPar">Number of the output control parameters.</param>
        /// <param name="type">System operator or user procedure.</param>
        public static void GetParamNum(
          HTuple operatorName,
          out HTuple CName,
          out HTuple inpObjPar,
          out HTuple outpObjPar,
          out HTuple inpCtrlPar,
          out HTuple outpCtrlPar,
          out HTuple type)
        {
            IntPtr proc = HalconAPI.PreCall(1112);
            HalconAPI.Store(proc, 0, operatorName);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(operatorName);
            int err2 = HTuple.LoadNew(proc, 0, err1, out CName);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out inpObjPar);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out outpObjPar);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out inpCtrlPar);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out outpCtrlPar);
            int procResult = HTuple.LoadNew(proc, 5, err6, out type);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the names of the parameters of a HALCON-operator.</summary>
        /// <param name="operatorName">Name of the operator. Default: "get_param_names"</param>
        /// <param name="inpObjPar">Names of the input objects.</param>
        /// <param name="outpObjPar">Names of the output objects.</param>
        /// <param name="inpCtrlPar">Names of the input control parameters.</param>
        /// <param name="outpCtrlPar">Names of the output control parameters.</param>
        public static void GetParamNames(
          HTuple operatorName,
          out HTuple inpObjPar,
          out HTuple outpObjPar,
          out HTuple inpCtrlPar,
          out HTuple outpCtrlPar)
        {
            IntPtr proc = HalconAPI.PreCall(1113);
            HalconAPI.Store(proc, 0, operatorName);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(operatorName);
            int err2 = HTuple.LoadNew(proc, 0, err1, out inpObjPar);
            int err3 = HTuple.LoadNew(proc, 1, err2, out outpObjPar);
            int err4 = HTuple.LoadNew(proc, 2, err3, out inpCtrlPar);
            int procResult = HTuple.LoadNew(proc, 3, err4, out outpCtrlPar);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get information concerning a HALCON-operator.</summary>
        /// <param name="operatorName">Name of the operator on which more information is needed. Default: "get_operator_info"</param>
        /// <param name="slot">Desired information. Default: "abstract"</param>
        /// <param name="information">Information (empty if no information is available)</param>
        public static void GetOperatorInfo(HTuple operatorName, HTuple slot, out HTuple information)
        {
            IntPtr proc = HalconAPI.PreCall(1114);
            HalconAPI.Store(proc, 0, operatorName);
            HalconAPI.Store(proc, 1, slot);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(operatorName);
            HalconAPI.UnpinTuple(slot);
            int procResult = HTuple.LoadNew(proc, 0, err, out information);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get information concerning the operator parameters.</summary>
        /// <param name="operatorName">Name of the operator on whose parameter more information is needed. Default: "get_param_info"</param>
        /// <param name="paramName">Name of the parameter on which more information is needed. Default: "Slot"</param>
        /// <param name="slot">Desired information. Default: "description"</param>
        /// <param name="information">Information (empty in case there is no information available).</param>
        public static void GetParamInfo(
          HTuple operatorName,
          HTuple paramName,
          HTuple slot,
          out HTuple information)
        {
            IntPtr proc = HalconAPI.PreCall(1115);
            HalconAPI.Store(proc, 0, operatorName);
            HalconAPI.Store(proc, 1, paramName);
            HalconAPI.Store(proc, 2, slot);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(operatorName);
            HalconAPI.UnpinTuple(paramName);
            HalconAPI.UnpinTuple(slot);
            int procResult = HTuple.LoadNew(proc, 0, err, out information);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Search names of all operators assigned to one keyword.</summary>
        /// <param name="keyword">Keyword for which corresponding operators are searched. Default: "Information"</param>
        /// <param name="operatorNames">Operators whose slot 'keyword' contains the keyword.</param>
        public static void SearchOperator(HTuple keyword, out HTuple operatorNames)
        {
            IntPtr proc = HalconAPI.PreCall(1116);
            HalconAPI.Store(proc, 0, keyword);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(keyword);
            int procResult = HTuple.LoadNew(proc, 0, err, out operatorNames);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get keywords which are assigned to operators.</summary>
        /// <param name="operatorName">Substring in the names of those operators for which keywords are needed. Default: "get_keywords"</param>
        /// <param name="keywords">Keywords for the operators.</param>
        public static void GetKeywords(HTuple operatorName, out HTuple keywords)
        {
            IntPtr proc = HalconAPI.PreCall(1117);
            HalconAPI.Store(proc, 0, operatorName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(operatorName);
            int procResult = HTuple.LoadNew(proc, 0, err, out keywords);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get information concerning the chapters on operators.</summary>
        /// <param name="chapter">Operator class or subclass of interest. Default: ""</param>
        /// <param name="info">Operator classes (Chapter = ") or operator subclasses respectively operators.</param>
        public static void GetChapterInfo(HTuple chapter, out HTuple info)
        {
            IntPtr proc = HalconAPI.PreCall(1118);
            HalconAPI.Store(proc, 0, chapter);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(chapter);
            int procResult = HTuple.LoadNew(proc, 0, err, out info);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert one-channel images into a multi-channel image</summary>
        /// <param name="images">One-channel images to be combined into a one-channel image.</param>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        public static void ChannelsToImage(HObject images, out HObject multiChannelImage)
        {
            IntPtr proc = HalconAPI.PreCall(1119);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out multiChannelImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Convert a multi-channel image into One-channel images</summary>
        /// <param name="multiChannelImage">Multi-channel image to be decomposed.</param>
        /// <param name="images">Generated one-channel images.</param>
        public static void ImageToChannels(HObject multiChannelImage, out HObject images)
        {
            IntPtr proc = HalconAPI.PreCall(1120);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out images);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Convert 7 images into a seven-channel image.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="image3">Input image 3.</param>
        /// <param name="image4">Input image 4.</param>
        /// <param name="image5">Input image 5.</param>
        /// <param name="image6">Input image 6.</param>
        /// <param name="image7">Input image 7.</param>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        public static void Compose7(
          HObject image1,
          HObject image2,
          HObject image3,
          HObject image4,
          HObject image5,
          HObject image6,
          HObject image7,
          out HObject multiChannelImage)
        {
            IntPtr proc = HalconAPI.PreCall(1121);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.Store(proc, 4, (HObjectBase)image4);
            HalconAPI.Store(proc, 5, (HObjectBase)image5);
            HalconAPI.Store(proc, 6, (HObjectBase)image6);
            HalconAPI.Store(proc, 7, (HObjectBase)image7);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out multiChannelImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
            GC.KeepAlive((object)image4);
            GC.KeepAlive((object)image5);
            GC.KeepAlive((object)image6);
            GC.KeepAlive((object)image7);
        }

        /// <summary>Convert 6 images into a six-channel image.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="image3">Input image 3.</param>
        /// <param name="image4">Input image 4.</param>
        /// <param name="image5">Input image 5.</param>
        /// <param name="image6">Input image 6.</param>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        public static void Compose6(
          HObject image1,
          HObject image2,
          HObject image3,
          HObject image4,
          HObject image5,
          HObject image6,
          out HObject multiChannelImage)
        {
            IntPtr proc = HalconAPI.PreCall(1122);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.Store(proc, 4, (HObjectBase)image4);
            HalconAPI.Store(proc, 5, (HObjectBase)image5);
            HalconAPI.Store(proc, 6, (HObjectBase)image6);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out multiChannelImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
            GC.KeepAlive((object)image4);
            GC.KeepAlive((object)image5);
            GC.KeepAlive((object)image6);
        }

        /// <summary>Convert 5 images into a five-channel image.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="image3">Input image 3.</param>
        /// <param name="image4">Input image 4.</param>
        /// <param name="image5">Input image 5.</param>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        public static void Compose5(
          HObject image1,
          HObject image2,
          HObject image3,
          HObject image4,
          HObject image5,
          out HObject multiChannelImage)
        {
            IntPtr proc = HalconAPI.PreCall(1123);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.Store(proc, 4, (HObjectBase)image4);
            HalconAPI.Store(proc, 5, (HObjectBase)image5);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out multiChannelImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
            GC.KeepAlive((object)image4);
            GC.KeepAlive((object)image5);
        }

        /// <summary>Convert 4 images into a four-channel image.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="image3">Input image 3.</param>
        /// <param name="image4">Input image 4.</param>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        public static void Compose4(
          HObject image1,
          HObject image2,
          HObject image3,
          HObject image4,
          out HObject multiChannelImage)
        {
            IntPtr proc = HalconAPI.PreCall(1124);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.Store(proc, 4, (HObjectBase)image4);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out multiChannelImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
            GC.KeepAlive((object)image4);
        }

        /// <summary>Convert 3 images into a three-channel image.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="image3">Input image 3.</param>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        public static void Compose3(
          HObject image1,
          HObject image2,
          HObject image3,
          out HObject multiChannelImage)
        {
            IntPtr proc = HalconAPI.PreCall(1125);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out multiChannelImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
        }

        /// <summary>Convert two images into a two-channel image.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        public static void Compose2(HObject image1, HObject image2, out HObject multiChannelImage)
        {
            IntPtr proc = HalconAPI.PreCall(1126);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out multiChannelImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Convert a seven-channel image into seven images.</summary>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        /// <param name="image1">Output image 1.</param>
        /// <param name="image2">Output image 2.</param>
        /// <param name="image3">Output image 3.</param>
        /// <param name="image4">Output image 4.</param>
        /// <param name="image5">Output image 5.</param>
        /// <param name="image6">Output image 6.</param>
        /// <param name="image7">Output image 7.</param>
        public static void Decompose7(
          HObject multiChannelImage,
          out HObject image1,
          out HObject image2,
          out HObject image3,
          out HObject image4,
          out HObject image5,
          out HObject image6,
          out HObject image7)
        {
            IntPtr proc = HalconAPI.PreCall(1127);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out image1);
            int err3 = HObject.LoadNew(proc, 2, err2, out image2);
            int err4 = HObject.LoadNew(proc, 3, err3, out image3);
            int err5 = HObject.LoadNew(proc, 4, err4, out image4);
            int err6 = HObject.LoadNew(proc, 5, err5, out image5);
            int err7 = HObject.LoadNew(proc, 6, err6, out image6);
            int procResult = HObject.LoadNew(proc, 7, err7, out image7);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Convert a six-channel image into six images.</summary>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        /// <param name="image1">Output image 1.</param>
        /// <param name="image2">Output image 2.</param>
        /// <param name="image3">Output image 3.</param>
        /// <param name="image4">Output image 4.</param>
        /// <param name="image5">Output image 5.</param>
        /// <param name="image6">Output image 6.</param>
        public static void Decompose6(
          HObject multiChannelImage,
          out HObject image1,
          out HObject image2,
          out HObject image3,
          out HObject image4,
          out HObject image5,
          out HObject image6)
        {
            IntPtr proc = HalconAPI.PreCall(1128);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out image1);
            int err3 = HObject.LoadNew(proc, 2, err2, out image2);
            int err4 = HObject.LoadNew(proc, 3, err3, out image3);
            int err5 = HObject.LoadNew(proc, 4, err4, out image4);
            int err6 = HObject.LoadNew(proc, 5, err5, out image5);
            int procResult = HObject.LoadNew(proc, 6, err6, out image6);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Convert a five-channel image into five images.</summary>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        /// <param name="image1">Output image 1.</param>
        /// <param name="image2">Output image 2.</param>
        /// <param name="image3">Output image 3.</param>
        /// <param name="image4">Output image 4.</param>
        /// <param name="image5">Output image 5.</param>
        public static void Decompose5(
          HObject multiChannelImage,
          out HObject image1,
          out HObject image2,
          out HObject image3,
          out HObject image4,
          out HObject image5)
        {
            IntPtr proc = HalconAPI.PreCall(1129);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out image1);
            int err3 = HObject.LoadNew(proc, 2, err2, out image2);
            int err4 = HObject.LoadNew(proc, 3, err3, out image3);
            int err5 = HObject.LoadNew(proc, 4, err4, out image4);
            int procResult = HObject.LoadNew(proc, 5, err5, out image5);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Convert a four-channel image into four images.</summary>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        /// <param name="image1">Output image 1.</param>
        /// <param name="image2">Output image 2.</param>
        /// <param name="image3">Output image 3.</param>
        /// <param name="image4">Output image 4.</param>
        public static void Decompose4(
          HObject multiChannelImage,
          out HObject image1,
          out HObject image2,
          out HObject image3,
          out HObject image4)
        {
            IntPtr proc = HalconAPI.PreCall(1130);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out image1);
            int err3 = HObject.LoadNew(proc, 2, err2, out image2);
            int err4 = HObject.LoadNew(proc, 3, err3, out image3);
            int procResult = HObject.LoadNew(proc, 4, err4, out image4);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Convert a three-channel image into three images.</summary>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        /// <param name="image1">Output image 1.</param>
        /// <param name="image2">Output image 2.</param>
        /// <param name="image3">Output image 3.</param>
        public static void Decompose3(
          HObject multiChannelImage,
          out HObject image1,
          out HObject image2,
          out HObject image3)
        {
            IntPtr proc = HalconAPI.PreCall(1131);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out image1);
            int err3 = HObject.LoadNew(proc, 2, err2, out image2);
            int procResult = HObject.LoadNew(proc, 3, err3, out image3);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Convert a two-channel image into two images.</summary>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        /// <param name="image1">Output image 1.</param>
        /// <param name="image2">Output image 2.</param>
        public static void Decompose2(
          HObject multiChannelImage,
          out HObject image1,
          out HObject image2)
        {
            IntPtr proc = HalconAPI.PreCall(1132);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out image1);
            int procResult = HObject.LoadNew(proc, 2, err2, out image2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Count channels of image.</summary>
        /// <param name="multiChannelImage">One- or multi-channel image.</param>
        /// <param name="channels">Number of channels.</param>
        public static void CountChannels(HObject multiChannelImage, out HTuple channels)
        {
            IntPtr proc = HalconAPI.PreCall(1133);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out channels);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Append additional matrices (channels) to the image.</summary>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        /// <param name="image">Image to be appended.</param>
        /// <param name="imageExtended">Image appended by Image.</param>
        public static void AppendChannel(
          HObject multiChannelImage,
          HObject image,
          out HObject imageExtended)
        {
            IntPtr proc = HalconAPI.PreCall(1134);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageExtended);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
            GC.KeepAlive((object)image);
        }

        /// <summary>Access a channel of a multi-channel image.</summary>
        /// <param name="multiChannelImage">Multi-channel image.</param>
        /// <param name="image">One channel of MultiChannelImage.</param>
        /// <param name="channel">Index of channel to be accessed. Default: 1</param>
        public static void AccessChannel(HObject multiChannelImage, out HObject image, HTuple channel)
        {
            IntPtr proc = HalconAPI.PreCall(1135);
            HalconAPI.Store(proc, 1, (HObjectBase)multiChannelImage);
            HalconAPI.Store(proc, 0, channel);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(channel);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiChannelImage);
        }

        /// <summary>Tile multiple image objects into a large image with explicit positioning information.</summary>
        /// <param name="images">Input images.</param>
        /// <param name="tiledImage">Tiled output image.</param>
        /// <param name="offsetRow">Row coordinate of the upper left corner of the input images in the output image. Default: 0</param>
        /// <param name="offsetCol">Column coordinate of the upper left corner of the input images in the output image. Default: 0</param>
        /// <param name="row1">Row coordinate of the upper left corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="col1">Column coordinate of the upper left corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="row2">Row coordinate of the lower right corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="col2">Column coordinate of the lower right corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="width">Width of the output image. Default: 512</param>
        /// <param name="height">Height of the output image. Default: 512</param>
        public static void TileImagesOffset(
          HObject images,
          out HObject tiledImage,
          HTuple offsetRow,
          HTuple offsetCol,
          HTuple row1,
          HTuple col1,
          HTuple row2,
          HTuple col2,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1136);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, offsetRow);
            HalconAPI.Store(proc, 1, offsetCol);
            HalconAPI.Store(proc, 2, row1);
            HalconAPI.Store(proc, 3, col1);
            HalconAPI.Store(proc, 4, row2);
            HalconAPI.Store(proc, 5, col2);
            HalconAPI.Store(proc, 6, width);
            HalconAPI.Store(proc, 7, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(offsetRow);
            HalconAPI.UnpinTuple(offsetCol);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(col1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(col2);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out tiledImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Tile multiple image objects into a large image.</summary>
        /// <param name="images">Input images.</param>
        /// <param name="tiledImage">Tiled output image.</param>
        /// <param name="numColumns">Number of columns to use for the output image. Default: 1</param>
        /// <param name="tileOrder">Order of the input images in the output image. Default: "vertical"</param>
        public static void TileImages(
          HObject images,
          out HObject tiledImage,
          HTuple numColumns,
          HTuple tileOrder)
        {
            IntPtr proc = HalconAPI.PreCall(1137);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, numColumns);
            HalconAPI.Store(proc, 1, tileOrder);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numColumns);
            HalconAPI.UnpinTuple(tileOrder);
            int procResult = HObject.LoadNew(proc, 1, err, out tiledImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Tile multiple images into a large image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="tiledImage">Tiled output image.</param>
        /// <param name="numColumns">Number of columns to use for the output image. Default: 1</param>
        /// <param name="tileOrder">Order of the input images in the output image. Default: "vertical"</param>
        public static void TileChannels(
          HObject image,
          out HObject tiledImage,
          HTuple numColumns,
          HTuple tileOrder)
        {
            IntPtr proc = HalconAPI.PreCall(1138);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, numColumns);
            HalconAPI.Store(proc, 1, tileOrder);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numColumns);
            HalconAPI.UnpinTuple(tileOrder);
            int procResult = HObject.LoadNew(proc, 1, err, out tiledImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Cut out of defined gray values.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imagePart">Image area.</param>
        public static void CropDomain(HObject image, out HObject imagePart)
        {
            IntPtr proc = HalconAPI.PreCall(1139);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imagePart);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Cut out one or more rectangular image areas.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imagePart">Image area.</param>
        /// <param name="row1">Line index of upper left corner of image area. Default: 100</param>
        /// <param name="column1">Column index of upper left corner of image area. Default: 100</param>
        /// <param name="row2">Line index of lower right corner of image area. Default: 200</param>
        /// <param name="column2">Column index of lower right corner of image area. Default: 200</param>
        public static void CropRectangle1(
          HObject image,
          out HObject imagePart,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1140);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int procResult = HObject.LoadNew(proc, 1, err, out imagePart);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Cut out one or more rectangular image areas.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imagePart">Image area.</param>
        /// <param name="row">Line index of upper left corner of image area. Default: 100</param>
        /// <param name="column">Column index of upper left corner of image area. Default: 100</param>
        /// <param name="width">Width of new image. Default: 128</param>
        /// <param name="height">Height of new image. Default: 128</param>
        public static void CropPart(
          HObject image,
          out HObject imagePart,
          HTuple row,
          HTuple column,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1141);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, width);
            HalconAPI.Store(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imagePart);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Change image size.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imagePart">Image with new format.</param>
        /// <param name="width">Width of new image. Default: 512</param>
        /// <param name="height">Height of new image. Default: 512</param>
        public static void ChangeFormat(
          HObject image,
          out HObject imagePart,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1142);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imagePart);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Change definition domain of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="newDomain">New definition domain.</param>
        /// <param name="imageNew">Image with new definition domain.</param>
        public static void ChangeDomain(HObject image, HObject newDomain, out HObject imageNew)
        {
            IntPtr proc = HalconAPI.PreCall(1143);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)newDomain);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageNew);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)newDomain);
        }

        /// <summary>Add gray values to regions.</summary>
        /// <param name="regions">Input regions (without pixel values).</param>
        /// <param name="image">Input image with pixel values for regions.</param>
        /// <param name="grayRegions">Output image(s) with regions and pixel values (one image per input region).</param>
        public static void AddChannels(HObject regions, HObject image, out HObject grayRegions)
        {
            IntPtr proc = HalconAPI.PreCall(1144);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out grayRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Reduce the domain of an image to a rectangle.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageReduced">Image with reduced definition domain.</param>
        /// <param name="row1">Line index of upper left corner of image area. Default: 100</param>
        /// <param name="column1">Column index of upper left corner of image area. Default: 100</param>
        /// <param name="row2">Line index of lower right corner of image area. Default: 200</param>
        /// <param name="column2">Column index of lower right corner of image area. Default: 200</param>
        public static void Rectangle1Domain(
          HObject image,
          out HObject imageReduced,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1145);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int procResult = HObject.LoadNew(proc, 1, err, out imageReduced);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Reduce the domain of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="region">New definition domain.</param>
        /// <param name="imageReduced">Image with reduced definition domain.</param>
        public static void ReduceDomain(HObject image, HObject region, out HObject imageReduced)
        {
            IntPtr proc = HalconAPI.PreCall(1146);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageReduced);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)region);
        }

        /// <summary>Expand the domain of an image to maximum.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageFull">Image with maximum definition domain.</param>
        public static void FullDomain(HObject image, out HObject imageFull)
        {
            IntPtr proc = HalconAPI.PreCall(1147);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFull);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Get the domain of an image.</summary>
        /// <param name="image">Input images.</param>
        /// <param name="domain">Definition domains of input images.</param>
        public static void GetDomain(HObject image, out HObject domain)
        {
            IntPtr proc = HalconAPI.PreCall(1148);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out domain);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Centres of circles for a specific radius.</summary>
        /// <param name="regionIn">Binary edge image in which the circles are to be detected.</param>
        /// <param name="regionOut">Centres of those circles which are included in the edge image by Percent percent.</param>
        /// <param name="radius">Radius of the circle to be searched in the image. Default: 12</param>
        /// <param name="percent">Indicates the percentage (approximately) of the (ideal) circle which must be present in the edge image RegionIn. Default: 60</param>
        /// <param name="mode">The modus defines the position of the circle in question: 0 - the radius is equivalent to the outer border of the set pixels. 1 - the radius is equivalent to the centres of the circle lines´ pixels. 2 - both 0 and 1 (a little more fuzzy, but more reliable in contrast to circles set slightly differently, necessitates 50  </param>
        public static void HoughCircles(
          HObject regionIn,
          out HObject regionOut,
          HTuple radius,
          HTuple percent,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1149);
            HalconAPI.Store(proc, 1, (HObjectBase)regionIn);
            HalconAPI.Store(proc, 0, radius);
            HalconAPI.Store(proc, 1, percent);
            HalconAPI.Store(proc, 2, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(percent);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out regionOut);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regionIn);
        }

        /// <summary>Return the Hough-Transform for circles with a given radius.</summary>
        /// <param name="region">Binary edge image in which the circles are to be detected.</param>
        /// <param name="houghImage">Hough transform for circles with a given radius.</param>
        /// <param name="radius">Radius of the circle to be searched in the image. Default: 12</param>
        public static void HoughCircleTrans(HObject region, out HObject houghImage, HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(1150);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, radius);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(radius);
            int procResult = HObject.LoadNew(proc, 1, err, out houghImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Detect lines in edge images with the help of the Hough transform using local gradient direction and return them in normal form.</summary>
        /// <param name="imageDir">Image containing the edge direction. The edges are described by the image domain.</param>
        /// <param name="houghImage">Hough transform.</param>
        /// <param name="lines">Regions of the input image that contributed to the local maxima.</param>
        /// <param name="directionUncertainty">Uncertainty of edge direction (in degrees). Default: 2</param>
        /// <param name="angleResolution">Resolution in the angle area (in 1/degrees). Default: 4</param>
        /// <param name="smoothing">Smoothing filter for hough image. Default: "mean"</param>
        /// <param name="filterSize">Required smoothing filter size. Default: 5</param>
        /// <param name="threshold">Threshold value in the Hough image. Default: 100</param>
        /// <param name="angleGap">Minimum distance of two maxima in the Hough image (direction: angle). Default: 5</param>
        /// <param name="distGap">Minimum distance of two maxima in the Hough image (direction: distance). Default: 5</param>
        /// <param name="genLines">Create line regions if 'true'. Default: "true"</param>
        /// <param name="angle">Angles (in radians) of the detected lines' normal vectors.</param>
        /// <param name="dist">Distance of the detected lines from the origin.</param>
        public static void HoughLinesDir(
          HObject imageDir,
          out HObject houghImage,
          out HObject lines,
          HTuple directionUncertainty,
          HTuple angleResolution,
          HTuple smoothing,
          HTuple filterSize,
          HTuple threshold,
          HTuple angleGap,
          HTuple distGap,
          HTuple genLines,
          out HTuple angle,
          out HTuple dist)
        {
            IntPtr proc = HalconAPI.PreCall(1151);
            HalconAPI.Store(proc, 1, (HObjectBase)imageDir);
            HalconAPI.Store(proc, 0, directionUncertainty);
            HalconAPI.Store(proc, 1, angleResolution);
            HalconAPI.Store(proc, 2, smoothing);
            HalconAPI.Store(proc, 3, filterSize);
            HalconAPI.Store(proc, 4, threshold);
            HalconAPI.Store(proc, 5, angleGap);
            HalconAPI.Store(proc, 6, distGap);
            HalconAPI.Store(proc, 7, genLines);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(directionUncertainty);
            HalconAPI.UnpinTuple(angleResolution);
            HalconAPI.UnpinTuple(smoothing);
            HalconAPI.UnpinTuple(filterSize);
            HalconAPI.UnpinTuple(threshold);
            HalconAPI.UnpinTuple(angleGap);
            HalconAPI.UnpinTuple(distGap);
            HalconAPI.UnpinTuple(genLines);
            int err2 = HObject.LoadNew(proc, 1, err1, out houghImage);
            int err3 = HObject.LoadNew(proc, 2, err2, out lines);
            int err4 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err4, out dist);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageDir);
        }

        /// <summary>Compute the Hough transform for lines using local gradient direction.</summary>
        /// <param name="imageDir">Image containing the edge direction. The edges must be described by the image domain.</param>
        /// <param name="houghImage">Hough transform.</param>
        /// <param name="directionUncertainty">Uncertainty of the edge direction (in degrees). Default: 2</param>
        /// <param name="angleResolution">Resolution in the angle area (in 1/degrees). Default: 4</param>
        public static void HoughLineTransDir(
          HObject imageDir,
          out HObject houghImage,
          HTuple directionUncertainty,
          HTuple angleResolution)
        {
            IntPtr proc = HalconAPI.PreCall(1152);
            HalconAPI.Store(proc, 1, (HObjectBase)imageDir);
            HalconAPI.Store(proc, 0, directionUncertainty);
            HalconAPI.Store(proc, 1, angleResolution);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(directionUncertainty);
            HalconAPI.UnpinTuple(angleResolution);
            int procResult = HObject.LoadNew(proc, 1, err, out houghImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageDir);
        }

        /// <summary>Detect lines in edge images with the help of the Hough transform and returns it in HNF.</summary>
        /// <param name="regionIn">Binary edge image in which the lines are to be detected.</param>
        /// <param name="angleResolution">Adjusting the resolution in the angle area. Default: 4</param>
        /// <param name="threshold">Threshold value in the Hough image. Default: 100</param>
        /// <param name="angleGap">Minimal distance of two maxima in the Hough image (direction: angle). Default: 5</param>
        /// <param name="distGap">Minimal distance of two maxima in the Hough image (direction: distance). Default: 5</param>
        /// <param name="angle">Angles (in radians) of the detected lines' normal vectors.</param>
        /// <param name="dist">Distance of the detected lines from the origin.</param>
        public static void HoughLines(
          HObject regionIn,
          HTuple angleResolution,
          HTuple threshold,
          HTuple angleGap,
          HTuple distGap,
          out HTuple angle,
          out HTuple dist)
        {
            IntPtr proc = HalconAPI.PreCall(1153);
            HalconAPI.Store(proc, 1, (HObjectBase)regionIn);
            HalconAPI.Store(proc, 0, angleResolution);
            HalconAPI.Store(proc, 1, threshold);
            HalconAPI.Store(proc, 2, angleGap);
            HalconAPI.Store(proc, 3, distGap);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(angleResolution);
            HalconAPI.UnpinTuple(threshold);
            HalconAPI.UnpinTuple(angleGap);
            HalconAPI.UnpinTuple(distGap);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out angle);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out dist);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regionIn);
        }

        /// <summary>Produce the Hough transform for lines within regions.</summary>
        /// <param name="region">Binary edge image in which lines are to be detected.</param>
        /// <param name="houghImage">Hough transform for lines.</param>
        /// <param name="angleResolution">Adjusting the resolution in the angle area. Default: 4</param>
        public static void HoughLineTrans(
          HObject region,
          out HObject houghImage,
          HTuple angleResolution)
        {
            IntPtr proc = HalconAPI.PreCall(1154);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, angleResolution);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(angleResolution);
            int procResult = HObject.LoadNew(proc, 1, err, out houghImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Select those lines from a set of lines (in HNF) which fit best into a region.</summary>
        /// <param name="regionIn">Region in which the lines are to be matched.</param>
        /// <param name="regionLines">Region array containing the matched lines.</param>
        /// <param name="angleIn">Angles (in radians) of the normal vectors of the input lines.</param>
        /// <param name="distIn">Distances of the input lines form the origin.</param>
        /// <param name="lineWidth">Widths of the lines. Default: 7</param>
        /// <param name="thresh">Threshold value for the number of line points in the region. Default: 100</param>
        /// <param name="angleOut">Angles (in radians) of the normal vectors of the selected lines.</param>
        /// <param name="distOut">Distances of the selected lines from the origin.</param>
        public static void SelectMatchingLines(
          HObject regionIn,
          out HObject regionLines,
          HTuple angleIn,
          HTuple distIn,
          HTuple lineWidth,
          HTuple thresh,
          out HTuple angleOut,
          out HTuple distOut)
        {
            IntPtr proc = HalconAPI.PreCall(1155);
            HalconAPI.Store(proc, 1, (HObjectBase)regionIn);
            HalconAPI.Store(proc, 0, angleIn);
            HalconAPI.Store(proc, 1, distIn);
            HalconAPI.Store(proc, 2, lineWidth);
            HalconAPI.Store(proc, 3, thresh);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(angleIn);
            HalconAPI.UnpinTuple(distIn);
            HalconAPI.UnpinTuple(lineWidth);
            HalconAPI.UnpinTuple(thresh);
            int err2 = HObject.LoadNew(proc, 1, err1, out regionLines);
            int err3 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out angleOut);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err3, out distOut);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regionIn);
        }

        /// <summary>Segment the rectification grid region in the image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="gridRegion">Output region containing the rectification grid.</param>
        /// <param name="minContrast">Minimum contrast. Default: 8.0</param>
        /// <param name="radius">Radius of the circular structuring element. Default: 7.5</param>
        public static void FindRectificationGrid(
          HObject image,
          out HObject gridRegion,
          HTuple minContrast,
          HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(1156);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, minContrast);
            HalconAPI.Store(proc, 1, radius);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(radius);
            int procResult = HObject.LoadNew(proc, 1, err, out gridRegion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Generate a PostScript file, which describes the rectification grid.</summary>
        /// <param name="width">Width of the checkered pattern in meters (without the two frames). Default: 0.17</param>
        /// <param name="numSquares">Number of squares per row and column. Default: 17</param>
        /// <param name="gridFile">File name of the PostScript file. Default: "rectification_grid.ps"</param>
        public static void CreateRectificationGrid(HTuple width, HTuple numSquares, HTuple gridFile)
        {
            IntPtr proc = HalconAPI.PreCall(1157);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, numSquares);
            HalconAPI.Store(proc, 2, gridFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(numSquares);
            HalconAPI.UnpinTuple(gridFile);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Establish connections between the grid points of the rectification grid.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="connectingLines">Output contours.</param>
        /// <param name="row">Row coordinates of the grid points.</param>
        /// <param name="column">Column coordinates of the grid points.</param>
        /// <param name="sigma">Size of the applied Gaussians. Default: 0.9</param>
        /// <param name="maxDist">Maximum distance of the connecting lines from the grid points. Default: 5.5</param>
        public static void ConnectGridPoints(
          HObject image,
          out HObject connectingLines,
          HTuple row,
          HTuple column,
          HTuple sigma,
          HTuple maxDist)
        {
            IntPtr proc = HalconAPI.PreCall(1158);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, sigma);
            HalconAPI.Store(proc, 3, maxDist);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(maxDist);
            int procResult = HObject.LoadNew(proc, 1, err, out connectingLines);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute the mapping between the distorted image and the rectified image based upon the points of a regular grid.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="connectingLines">Input contours.</param>
        /// <param name="map">Image containing the mapping data.</param>
        /// <param name="meshes">Output contours.</param>
        /// <param name="gridSpacing">Distance of the grid points in the rectified image.</param>
        /// <param name="rotation">Rotation to be applied to the point grid. Default: "auto"</param>
        /// <param name="row">Row coordinates of the grid points.</param>
        /// <param name="column">Column coordinates of the grid points.</param>
        /// <param name="mapType">Type of mapping. Default: "bilinear"</param>
        public static void GenGridRectificationMap(
          HObject image,
          HObject connectingLines,
          out HObject map,
          out HObject meshes,
          HTuple gridSpacing,
          HTuple rotation,
          HTuple row,
          HTuple column,
          HTuple mapType)
        {
            IntPtr proc = HalconAPI.PreCall(1159);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)connectingLines);
            HalconAPI.Store(proc, 0, gridSpacing);
            HalconAPI.Store(proc, 1, rotation);
            HalconAPI.Store(proc, 2, row);
            HalconAPI.Store(proc, 3, column);
            HalconAPI.Store(proc, 4, mapType);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(gridSpacing);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(mapType);
            int err2 = HObject.LoadNew(proc, 1, err1, out map);
            int procResult = HObject.LoadNew(proc, 2, err2, out meshes);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)connectingLines);
        }

        /// <summary>Generate a projection map that describes the mapping between an arbitrarily distorted image and the rectified image.</summary>
        /// <param name="map">Image containing the mapping data.</param>
        /// <param name="gridSpacing">Distance of the grid points in the rectified image.</param>
        /// <param name="row">Row coordinates of the grid points in the distorted image.</param>
        /// <param name="column">Column coordinates of the grid points in the distorted image.</param>
        /// <param name="gridWidth">Width of the point grid (number of grid points).</param>
        /// <param name="imageWidth">Width of the images to be rectified.</param>
        /// <param name="imageHeight">Height of the images to be rectified.</param>
        /// <param name="mapType">Type of mapping. Default: "bilinear"</param>
        public static void GenArbitraryDistortionMap(
          out HObject map,
          HTuple gridSpacing,
          HTuple row,
          HTuple column,
          HTuple gridWidth,
          HTuple imageWidth,
          HTuple imageHeight,
          HTuple mapType)
        {
            IntPtr proc = HalconAPI.PreCall(1160);
            HalconAPI.Store(proc, 0, gridSpacing);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, gridWidth);
            HalconAPI.Store(proc, 4, imageWidth);
            HalconAPI.Store(proc, 5, imageHeight);
            HalconAPI.Store(proc, 6, mapType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(gridSpacing);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(gridWidth);
            HalconAPI.UnpinTuple(imageWidth);
            HalconAPI.UnpinTuple(imageHeight);
            HalconAPI.UnpinTuple(mapType);
            int procResult = HObject.LoadNew(proc, 1, err, out map);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Gets a copy of the background image of the HALCON window.</summary>
        /// <param name="backgroundImage">Copy of the background image.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void GetWindowBackgroundImage(out HObject backgroundImage, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1161);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out backgroundImage);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a callback function to a drawing object.</summary>
        /// <param name="drawID">Handle of the drawing object.</param>
        /// <param name="drawObjectEvent">Events to be captured.</param>
        /// <param name="callbackFunction">Callback functions.</param>
        public static void SetDrawingObjectCallback(
          HTuple drawID,
          HTuple drawObjectEvent,
          HTuple callbackFunction)
        {
            IntPtr proc = HalconAPI.PreCall(1162);
            HalconAPI.Store(proc, 0, drawID);
            HalconAPI.Store(proc, 1, drawObjectEvent);
            HalconAPI.Store(proc, 2, callbackFunction);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(drawID);
            HalconAPI.UnpinTuple(drawObjectEvent);
            HalconAPI.UnpinTuple(callbackFunction);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Detach the background image from a HALCON window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        public static void DetachBackgroundFromWindow(HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1163);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Attach a background image to a HALCON window.</summary>
        /// <param name="image">Background image.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void AttachBackgroundToWindow(HObject image, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1164);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detach an existing drawing object from a HALCON window.</summary>
        /// <param name="windowHandle">Window Handle.</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void DetachDrawingObjectFromWindow(HTuple windowHandle, HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1165);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, drawID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Attach an existing drawing object to a HALCON window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void AttachDrawingObjectToWindow(HTuple windowHandle, HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1166);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, drawID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Modify the pose of a 3D plot.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="lastRow">Row coordinate of the first point.</param>
        /// <param name="lastCol">Column coordinate of the first point.</param>
        /// <param name="currentRow">Row coordinate of the second point.</param>
        /// <param name="currentCol">Column coordinate of the second point.</param>
        /// <param name="mode">Navigation mode. Default: "rotate"</param>
        public static void UpdateWindowPose(
          HTuple windowHandle,
          HTuple lastRow,
          HTuple lastCol,
          HTuple currentRow,
          HTuple currentCol,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1167);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, lastRow);
            HalconAPI.Store(proc, 2, lastCol);
            HalconAPI.Store(proc, 3, currentRow);
            HalconAPI.Store(proc, 4, currentCol);
            HalconAPI.Store(proc, 5, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(lastRow);
            HalconAPI.UnpinTuple(lastCol);
            HalconAPI.UnpinTuple(currentRow);
            HalconAPI.UnpinTuple(currentCol);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculates image coordinates for a point in a 3D plot window.</summary>
        /// <param name="image">Displayed image.</param>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row coordinate in the window.</param>
        /// <param name="column">Column coordinate in the window.</param>
        /// <param name="imageRow">Row coordinate in the image.</param>
        /// <param name="imageColumn">Column coordinate in the image.</param>
        /// <param name="height">Height value.</param>
        public static void UnprojectCoordinates(
          HObject image,
          HTuple windowHandle,
          HTuple row,
          HTuple column,
          out HTuple imageRow,
          out HTuple imageColumn,
          out HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1168);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out imageRow);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out imageColumn);
            int procResult = HTuple.LoadNew(proc, 2, err3, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Get the operating system window handle.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="OSWindowHandle">Operating system window handle.</param>
        /// <param name="OSDisplayHandle">Operating system display handle (under Unix-like systems only).</param>
        public static void GetOsWindowHandle(
          HTuple windowHandle,
          out HTuple OSWindowHandle,
          out HTuple OSDisplayHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1169);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out OSWindowHandle);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out OSDisplayHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the device context of a virtual graphics window (Windows NT).</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="WINHDC">device context of WINHWnd.</param>
        public static void SetWindowDc(HTuple windowHandle, HTuple WINHDC)
        {
            IntPtr proc = HalconAPI.PreCall(1170);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, WINHDC);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(WINHDC);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a virtual graphics window under Windows.</summary>
        /// <param name="WINHWnd">Windows window handle of a previously created window.</param>
        /// <param name="row">Row coordinate of upper left corner. Default: 0</param>
        /// <param name="column">Column coordinate of upper left corner. Default: 0</param>
        /// <param name="width">Width of the window. Default: 512</param>
        /// <param name="height">Height of the window. Default: 512</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void NewExternWindow(
          HTuple WINHWnd,
          HTuple row,
          HTuple column,
          HTuple width,
          HTuple height,
          out HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1171);
            HalconAPI.Store(proc, 0, WINHWnd);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, width);
            HalconAPI.Store(proc, 4, height);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(WINHWnd);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out windowHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive output from two window buffers.</summary>
        /// <param name="windowHandleSource1">Source window handle of the "`upper window"'.</param>
        /// <param name="windowHandleSource2">Source window handle of the "`lower window"'.</param>
        /// <param name="windowHandle">Output window handle.</param>
        public static void SlideImage(
          HTuple windowHandleSource1,
          HTuple windowHandleSource2,
          HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1172);
            HalconAPI.Store(proc, 0, windowHandleSource1);
            HalconAPI.Store(proc, 1, windowHandleSource2);
            HalconAPI.Store(proc, 2, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandleSource1);
            HalconAPI.UnpinTuple(windowHandleSource2);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Specify a window type.</summary>
        /// <param name="windowType">Name of the window type which has to be set. Default: "X-Window"</param>
        public static void SetWindowType(HTuple windowType)
        {
            IntPtr proc = HalconAPI.PreCall(1173);
            HalconAPI.Store(proc, 0, windowType);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowType);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Modify position and size of a window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row index of upper left corner in target position. Default: 0</param>
        /// <param name="column">Column index of upper left corner in target position. Default: 0</param>
        /// <param name="width">Width of the window. Default: 512</param>
        /// <param name="height">Height of the window. Default: 512</param>
        public static void SetWindowExtents(
          HTuple windowHandle,
          HTuple row,
          HTuple column,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1174);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, width);
            HalconAPI.Store(proc, 4, height);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get window characteristics.</summary>
        /// <param name="attributeName">Name of the attribute that should be returned.</param>
        /// <param name="attributeValue">Attribute value.</param>
        public static void GetWindowAttr(HTuple attributeName, out HTuple attributeValue)
        {
            IntPtr proc = HalconAPI.PreCall(1175);
            HalconAPI.Store(proc, 0, attributeName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(attributeName);
            int procResult = HTuple.LoadNew(proc, 0, err, out attributeValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set window characteristics.</summary>
        /// <param name="attributeName">Name of the attribute that should be modified.</param>
        /// <param name="attributeValue">Value of the attribute that should be set.</param>
        public static void SetWindowAttr(HTuple attributeName, HTuple attributeValue)
        {
            IntPtr proc = HalconAPI.PreCall(1176);
            HalconAPI.Store(proc, 0, attributeName);
            HalconAPI.Store(proc, 1, attributeValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(attributeName);
            HalconAPI.UnpinTuple(attributeValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query all available window types.</summary>
        /// <param name="windowTypes">Names of available window types.</param>
        public static void QueryWindowType(out HTuple windowTypes)
        {
            IntPtr proc = HalconAPI.PreCall(1177);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, err, out windowTypes);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open a graphics window.</summary>
        /// <param name="row">Row index of upper left corner. Default: 0</param>
        /// <param name="column">Column index of upper left corner. Default: 0</param>
        /// <param name="width">Width of the window. Default: 256</param>
        /// <param name="height">Height of the window. Default: 256</param>
        /// <param name="fatherWindow">Logical number of the father window. To specify the display as father you may enter 'root' or 0. Default: 0</param>
        /// <param name="mode">Window mode. Default: "visible"</param>
        /// <param name="machine">Name of the computer on which you want to open the window. Otherwise the empty string. Default: ""</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void OpenWindow(
          HTuple row,
          HTuple column,
          HTuple width,
          HTuple height,
          HTuple fatherWindow,
          HTuple mode,
          HTuple machine,
          out HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1178);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, width);
            HalconAPI.Store(proc, 3, height);
            HalconAPI.Store(proc, 4, fatherWindow);
            HalconAPI.Store(proc, 5, mode);
            HalconAPI.Store(proc, 6, machine);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(fatherWindow);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(machine);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out windowHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open a textual window.</summary>
        /// <param name="row">Row index of upper left corner. Default: 0</param>
        /// <param name="column">Column index of upper left corner. Default: 0</param>
        /// <param name="width">Window's width. Default: 256</param>
        /// <param name="height">Window's height. Default: 256</param>
        /// <param name="borderWidth">Window border's width. Default: 2</param>
        /// <param name="borderColor">Window border's color. Default: "white"</param>
        /// <param name="backgroundColor">Background color. Default: "black"</param>
        /// <param name="fatherWindow">Logical number of the father window. For the display as father you may specify 'root' or 0. Default: 0</param>
        /// <param name="mode">Window mode. Default: "visible"</param>
        /// <param name="machine">Computer name, where the window has to be opened or empty string. Default: ""</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void OpenTextwindow(
          HTuple row,
          HTuple column,
          HTuple width,
          HTuple height,
          HTuple borderWidth,
          HTuple borderColor,
          HTuple backgroundColor,
          HTuple fatherWindow,
          HTuple mode,
          HTuple machine,
          out HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1179);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, width);
            HalconAPI.Store(proc, 3, height);
            HalconAPI.Store(proc, 4, borderWidth);
            HalconAPI.Store(proc, 5, borderColor);
            HalconAPI.Store(proc, 6, backgroundColor);
            HalconAPI.Store(proc, 7, fatherWindow);
            HalconAPI.Store(proc, 8, mode);
            HalconAPI.Store(proc, 9, machine);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(borderWidth);
            HalconAPI.UnpinTuple(borderColor);
            HalconAPI.UnpinTuple(backgroundColor);
            HalconAPI.UnpinTuple(fatherWindow);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(machine);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out windowHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Copy inside an output window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row1">Row index of upper left corner of the source rectangle. Default: 0</param>
        /// <param name="column1">Column index of upper left corner of the source rectangle. Default: 0</param>
        /// <param name="row2">Row index of lower right corner of the source rectangle. Default: 64</param>
        /// <param name="column2">Column index of lower right corner of the source rectangle. Default: 64</param>
        /// <param name="destRow">Row index of upper left corner of the target position. Default: 64</param>
        /// <param name="destColumn">Column index of upper left corner of the target position. Default: 64</param>
        public static void MoveRectangle(
          HTuple windowHandle,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          HTuple destRow,
          HTuple destColumn)
        {
            IntPtr proc = HalconAPI.PreCall(1180);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row1);
            HalconAPI.Store(proc, 2, column1);
            HalconAPI.Store(proc, 3, row2);
            HalconAPI.Store(proc, 4, column2);
            HalconAPI.Store(proc, 5, destRow);
            HalconAPI.Store(proc, 6, destColumn);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            HalconAPI.UnpinTuple(destRow);
            HalconAPI.UnpinTuple(destColumn);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the window type.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="windowType">Window type</param>
        public static void GetWindowType(HTuple windowHandle, out HTuple windowType)
        {
            IntPtr proc = HalconAPI.PreCall(1181);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out windowType);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Access to a window's pixel data.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="imageRed">Pointer on red channel of pixel data.</param>
        /// <param name="imageGreen">Pointer on green channel of pixel data.</param>
        /// <param name="imageBlue">Pointer on blue channel of pixel data.</param>
        /// <param name="width">Length of an image line.</param>
        /// <param name="height">Number of image lines.</param>
        public static void GetWindowPointer3(
          HTuple windowHandle,
          out HTuple imageRed,
          out HTuple imageGreen,
          out HTuple imageBlue,
          out HTuple width,
          out HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1182);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out imageRed);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out imageGreen);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out imageBlue);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out width);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out height);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Information about a window's size and position.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row index of upper left corner of the window.</param>
        /// <param name="column">Column index of upper left corner of the window.</param>
        /// <param name="width">Window width.</param>
        /// <param name="height">Window height.</param>
        public static void GetWindowExtents(
          HTuple windowHandle,
          out HTuple row,
          out HTuple column,
          out HTuple width,
          out HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1183);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out width);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out height);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write the window content in an image object.</summary>
        /// <param name="image">Saved image.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void DumpWindowImage(out HObject image, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1184);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write the window content to a file.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="device">Name of the target device or of the graphic format. Default: "postscript"</param>
        /// <param name="fileName">File name (without extension). Default: "halcon_dump"</param>
        public static void DumpWindow(HTuple windowHandle, HTuple device, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1185);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, device);
            HalconAPI.Store(proc, 2, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(device);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Copy all pixels within rectangles between output windows.</summary>
        /// <param name="windowHandleSource">Source window handle.</param>
        /// <param name="windowHandleDestination">Destination window handle.</param>
        /// <param name="row1">Row index of upper left corner in the source window. Default: 0</param>
        /// <param name="column1">Column index of upper left corner in the source window. Default: 0</param>
        /// <param name="row2">Row index of lower right corner in the source window. Default: 128</param>
        /// <param name="column2">Column index of lower right corner in the source window. Default: 128</param>
        /// <param name="destRow">Row index of upper left corner in the target window. Default: 0</param>
        /// <param name="destColumn">Column index of upper left corner in the target window. Default: 0</param>
        public static void CopyRectangle(
          HTuple windowHandleSource,
          HTuple windowHandleDestination,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          HTuple destRow,
          HTuple destColumn)
        {
            IntPtr proc = HalconAPI.PreCall(1186);
            HalconAPI.Store(proc, 0, windowHandleSource);
            HalconAPI.Store(proc, 1, windowHandleDestination);
            HalconAPI.Store(proc, 2, row1);
            HalconAPI.Store(proc, 3, column1);
            HalconAPI.Store(proc, 4, row2);
            HalconAPI.Store(proc, 5, column2);
            HalconAPI.Store(proc, 6, destRow);
            HalconAPI.Store(proc, 7, destColumn);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandleSource);
            HalconAPI.UnpinTuple(windowHandleDestination);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            HalconAPI.UnpinTuple(destRow);
            HalconAPI.UnpinTuple(destColumn);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close an output window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        public static void CloseWindow(HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1187);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete the contents of an output window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        public static void ClearWindow(HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1188);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete a rectangle on the output window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row1">Line index of upper left corner. Default: 10</param>
        /// <param name="column1">Column index of upper left corner. Default: 10</param>
        /// <param name="row2">Row index of lower right corner. Default: 118</param>
        /// <param name="column2">Column index of lower right corner. Default: 118</param>
        public static void ClearRectangle(
          HTuple windowHandle,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1189);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row1);
            HalconAPI.Store(proc, 2, column1);
            HalconAPI.Store(proc, 3, row2);
            HalconAPI.Store(proc, 4, column2);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Print text in a window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="stringVal">Tuple of output values (all types). Default: "hello"</param>
        public static void WriteString(HTuple windowHandle, HTuple stringVal)
        {
            IntPtr proc = HalconAPI.PreCall(1190);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, stringVal);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(stringVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the shape of the text cursor.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="textCursor">Name of cursor shape. Default: "invisible"</param>
        public static void SetTshape(HTuple windowHandle, HTuple textCursor)
        {
            IntPtr proc = HalconAPI.PreCall(1191);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, textCursor);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(textCursor);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the position of the text cursor.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row index of text cursor position. Default: 24</param>
        /// <param name="column">Column index of text cursor position. Default: 12</param>
        public static void SetTposition(HTuple windowHandle, HTuple row, HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1192);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a string in a text window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="inString">Default string (visible before input). Default: ""</param>
        /// <param name="length">Maximum number of characters. Default: 32</param>
        /// <param name="outString">Read string.</param>
        public static void ReadString(
          HTuple windowHandle,
          HTuple inString,
          HTuple length,
          out HTuple outString)
        {
            IntPtr proc = HalconAPI.PreCall(1193);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, inString);
            HalconAPI.Store(proc, 2, length);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(inString);
            HalconAPI.UnpinTuple(length);
            int procResult = HTuple.LoadNew(proc, 0, err, out outString);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a character from a text window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="charVal">Input character (if it is not a control character).</param>
        /// <param name="code">Code for input character.</param>
        public static void ReadChar(HTuple windowHandle, out HTuple charVal, out HTuple code)
        {
            IntPtr proc = HalconAPI.PreCall(1194);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out charVal);
            int procResult = HTuple.LoadNew(proc, 1, err2, out code);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the position of the text cursor to the beginning of the next line.</summary>
        /// <param name="windowHandle">Window handle.</param>
        public static void NewLine(HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1195);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the shape of the text cursor.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="textCursor">Name of the current text cursor.</param>
        public static void GetTshape(HTuple windowHandle, out HTuple textCursor)
        {
            IntPtr proc = HalconAPI.PreCall(1196);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out textCursor);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get cursor position.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row index of text cursor position.</param>
        /// <param name="column">Column index of text cursor position.</param>
        public static void GetTposition(HTuple windowHandle, out HTuple row, out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1197);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the maximum size of all characters of a font.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="maxAscent">Maximum height above baseline.</param>
        /// <param name="maxDescent">Maximum extension below baseline.</param>
        /// <param name="maxWidth">Maximum character width.</param>
        /// <param name="maxHeight">Maximum character height.</param>
        public static void GetFontExtents(
          HTuple windowHandle,
          out HTuple maxAscent,
          out HTuple maxDescent,
          out HTuple maxWidth,
          out HTuple maxHeight)
        {
            IntPtr proc = HalconAPI.PreCall(1198);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out maxAscent);
            int err3 = HTuple.LoadNew(proc, 1, err2, out maxDescent);
            int err4 = HTuple.LoadNew(proc, 2, err3, out maxWidth);
            int procResult = HTuple.LoadNew(proc, 3, err4, out maxHeight);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the spatial size of a string.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="values">Values to consider. Default: "test_string"</param>
        /// <param name="ascent">Maximum height above baseline.</param>
        /// <param name="descent">Maximum extension below baseline.</param>
        /// <param name="width">Text width.</param>
        /// <param name="height">Text height.</param>
        public static void GetStringExtents(
          HTuple windowHandle,
          HTuple values,
          out HTuple ascent,
          out HTuple descent,
          out HTuple width,
          out HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1199);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, values);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(values);
            int err2 = HTuple.LoadNew(proc, 0, err1, out ascent);
            int err3 = HTuple.LoadNew(proc, 1, err2, out descent);
            int err4 = HTuple.LoadNew(proc, 2, err3, out width);
            int procResult = HTuple.LoadNew(proc, 3, err4, out height);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the available fonts.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="font">Tuple with available font names.</param>
        public static void QueryFont(HTuple windowHandle, out HTuple font)
        {
            IntPtr proc = HalconAPI.PreCall(1200);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out font);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query all shapes available for text cursors.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="textCursor">Names of the available text cursors.</param>
        public static void QueryTshape(HTuple windowHandle, out HTuple textCursor)
        {
            IntPtr proc = HalconAPI.PreCall(1201);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out textCursor);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the font used for text output.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="font">Name of new font.</param>
        public static void SetFont(HTuple windowHandle, HTuple font)
        {
            IntPtr proc = HalconAPI.PreCall(1202);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, font);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(font);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current font.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="font">Name of the current font.</param>
        public static void GetFont(HTuple windowHandle, out HTuple font)
        {
            IntPtr proc = HalconAPI.PreCall(1203);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out font);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the depth or the index of instances in a displayed 3D scene.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="row">Row coordinates.</param>
        /// <param name="column">Column coordinates.</param>
        /// <param name="information">Information. Default: "depth"</param>
        /// <param name="value">Indices or the depth of the objects at (Row,Column).</param>
        public static void GetDisplayScene3dInfo(
          HTuple windowHandle,
          HTuple scene3D,
          HTuple row,
          HTuple column,
          HTuple information,
          out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(1204);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, scene3D);
            HalconAPI.Store(proc, 2, row);
            HalconAPI.Store(proc, 3, column);
            HalconAPI.Store(proc, 4, information);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(information);
            int procResult = HTuple.LoadNew(proc, 0, err, out value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the pose of a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="toWorldPose">New pose of the 3D scene.</param>
        public static void SetScene3dToWorldPose(HTuple scene3D, HTuple toWorldPose)
        {
            IntPtr proc = HalconAPI.PreCall(1205);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, toWorldPose);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(toWorldPose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters of a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="genParamName">Names of the generic parameters. Default: "quality"</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: "high"</param>
        public static void SetScene3dParam(HTuple scene3D, HTuple genParamName, HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1206);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters of a light in a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="lightIndex">Index of the light source.</param>
        /// <param name="genParamName">Names of the generic parameters. Default: "ambient"</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: [0.2,0.2,0.2]</param>
        public static void SetScene3dLightParam(
          HTuple scene3D,
          HTuple lightIndex,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1207);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, lightIndex);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(lightIndex);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the pose of an instance in a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="instanceIndex">Index of the instance.</param>
        /// <param name="pose">New pose of the instance.</param>
        public static void SetScene3dInstancePose(HTuple scene3D, HTuple instanceIndex, HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(1208);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, instanceIndex);
            HalconAPI.Store(proc, 2, pose);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(instanceIndex);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters of an instance in a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="instanceIndex">Index of the instance.</param>
        /// <param name="genParamName">Names of the generic parameters. Default: "color"</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: "green"</param>
        public static void SetScene3dInstanceParam(
          HTuple scene3D,
          HTuple instanceIndex,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1209);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, instanceIndex);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(instanceIndex);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the pose of a camera in a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="cameraIndex">Index of the camera.</param>
        /// <param name="pose">New pose of the camera.</param>
        public static void SetScene3dCameraPose(HTuple scene3D, HTuple cameraIndex, HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(1210);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, cameraIndex);
            HalconAPI.Store(proc, 2, pose);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(cameraIndex);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Render an image of a 3D scene.</summary>
        /// <param name="image">Rendered 3D scene.</param>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="cameraIndex">Index of the camera used to display the scene.</param>
        public static void RenderScene3d(out HObject image, HTuple scene3D, HTuple cameraIndex)
        {
            IntPtr proc = HalconAPI.PreCall(1211);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, cameraIndex);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(cameraIndex);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Remove a light from a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="lightIndex">Light to remove.</param>
        public static void RemoveScene3dLight(HTuple scene3D, HTuple lightIndex)
        {
            IntPtr proc = HalconAPI.PreCall(1212);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, lightIndex);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(lightIndex);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Remove an object instance from a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="instanceIndex">Index of the instance to remove.</param>
        public static void RemoveScene3dInstance(HTuple scene3D, HTuple instanceIndex)
        {
            IntPtr proc = HalconAPI.PreCall(1213);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, instanceIndex);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(instanceIndex);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Remove a camera from a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="cameraIndex">Index of the camera to remove.</param>
        public static void RemoveScene3dCamera(HTuple scene3D, HTuple cameraIndex)
        {
            IntPtr proc = HalconAPI.PreCall(1214);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, cameraIndex);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(cameraIndex);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Display a 3D scene.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="cameraIndex">Index of the camera used to display the scene.</param>
        public static void DisplayScene3d(HTuple windowHandle, HTuple scene3D, HTuple cameraIndex)
        {
            IntPtr proc = HalconAPI.PreCall(1215);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, scene3D);
            HalconAPI.Store(proc, 2, cameraIndex);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(cameraIndex);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a light source to a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="lightPosition">Position of the new light source. Default: [-100.0,-100.0,0.0]</param>
        /// <param name="lightKind">Type of the new light source. Default: "point_light"</param>
        /// <param name="lightIndex">Index of the new light source in the 3D scene.</param>
        public static void AddScene3dLight(
          HTuple scene3D,
          HTuple lightPosition,
          HTuple lightKind,
          out HTuple lightIndex)
        {
            IntPtr proc = HalconAPI.PreCall(1216);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, lightPosition);
            HalconAPI.Store(proc, 2, lightKind);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(lightPosition);
            HalconAPI.UnpinTuple(lightKind);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out lightIndex);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add an instance of a 3D object model to a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        /// <param name="pose">Pose of the 3D object model.</param>
        /// <param name="instanceIndex">Index of the new instance in the 3D scene.</param>
        public static void AddScene3dInstance(
          HTuple scene3D,
          HTuple objectModel3D,
          HTuple pose,
          out HTuple instanceIndex)
        {
            IntPtr proc = HalconAPI.PreCall(1217);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, objectModel3D);
            HalconAPI.Store(proc, 2, pose);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(pose);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out instanceIndex);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a camera to a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="cameraParam">Parameters of the new camera.</param>
        /// <param name="cameraIndex">Index of the new camera in the 3D scene.</param>
        public static void AddScene3dCamera(HTuple scene3D, HTuple cameraParam, out HTuple cameraIndex)
        {
            IntPtr proc = HalconAPI.PreCall(1218);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, cameraParam);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(cameraParam);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out cameraIndex);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete a 3D scene and free all allocated memory.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        public static void ClearScene3d(HTuple scene3D)
        {
            IntPtr proc = HalconAPI.PreCall(1219);
            HalconAPI.Store(proc, 0, scene3D);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create the data structure that is needed to visualize collections of 3D objects.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        public static void CreateScene3d(out HTuple scene3D)
        {
            IntPtr proc = HalconAPI.PreCall(1220);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out scene3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get window parameters.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="param">Name of the parameter. Default: "flush"</param>
        /// <param name="value">Value of the parameter.</param>
        public static void GetWindowParam(HTuple windowHandle, HTuple param, out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(1221);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, param);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(param);
            int procResult = HTuple.LoadNew(proc, 0, err, out value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set window parameters.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="param">Name of the parameter. Default: "flush"</param>
        /// <param name="value">Value to be set. Default: "false"</param>
        public static void SetWindowParam(HTuple windowHandle, HTuple param, HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(1222);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, param);
            HalconAPI.Store(proc, 2, value);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(param);
            HalconAPI.UnpinTuple(value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define the region output shape.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="shape">Region output mode. Default: "original"</param>
        public static void SetShape(HTuple windowHandle, HTuple shape)
        {
            IntPtr proc = HalconAPI.PreCall(1223);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, shape);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(shape);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the color definition via RGB values.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="red">Red component of the color. Default: 255</param>
        /// <param name="green">Green component of the color. Default: 0</param>
        /// <param name="blue">Blue component of the color. Default: 0</param>
        public static void SetRgb(HTuple windowHandle, HTuple red, HTuple green, HTuple blue)
        {
            IntPtr proc = HalconAPI.PreCall(1224);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, red);
            HalconAPI.Store(proc, 2, green);
            HalconAPI.Store(proc, 3, blue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(red);
            HalconAPI.UnpinTuple(green);
            HalconAPI.UnpinTuple(blue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define a color lookup table index.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="pixel">Color lookup table index. Default: 128</param>
        public static void SetPixel(HTuple windowHandle, HTuple pixel)
        {
            IntPtr proc = HalconAPI.PreCall(1225);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, pixel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(pixel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define an interpolation method for gray value output. </summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="style">Interpolation method for image output: 0 (fast, low quality) to 2 (slow, high quality). Default: 0</param>
        public static void SetPartStyle(HTuple windowHandle, HTuple style)
        {
            IntPtr proc = HalconAPI.PreCall(1226);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, style);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(style);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Modify the displayed image part.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row1">Row of the upper left corner of the chosen image part. Default: 0</param>
        /// <param name="column1">Column of the upper left corner of the chosen image part. Default: 0</param>
        /// <param name="row2">Row of the lower right corner of the chosen image part. Default: -1</param>
        /// <param name="column2">Column of the lower right corner of the chosen image part. Default: -1</param>
        public static void SetPart(
          HTuple windowHandle,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1227);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row1);
            HalconAPI.Store(proc, 2, column1);
            HalconAPI.Store(proc, 3, row2);
            HalconAPI.Store(proc, 4, column2);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define the gray value output mode.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Output mode. Additional parameters possible. Default: "default"</param>
        public static void SetPaint(HTuple windowHandle, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1228);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define the line width for region contour output.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="width">Line width for region output in contour mode. Default: 1.0</param>
        public static void SetLineWidth(HTuple windowHandle, HTuple width)
        {
            IntPtr proc = HalconAPI.PreCall(1229);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, width);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(width);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define a contour output pattern.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="style">Contour pattern. Default: []</param>
        public static void SetLineStyle(HTuple windowHandle, HTuple style)
        {
            IntPtr proc = HalconAPI.PreCall(1230);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, style);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(style);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define the approximation error for contour display.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="approximation">Maximum deviation from the original contour. Default: 0</param>
        public static void SetLineApprox(HTuple windowHandle, HTuple approximation)
        {
            IntPtr proc = HalconAPI.PreCall(1231);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, approximation);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(approximation);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define the pixel output function.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Name of the display function. Default: "copy"</param>
        public static void SetInsert(HTuple windowHandle, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1232);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define output colors (HSI-coded).</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="hue">Hue for region output. Default: 30</param>
        /// <param name="saturation">Saturation for region output. Default: 255</param>
        /// <param name="intensity">Intensity for region output. Default: 84</param>
        public static void SetHsi(
          HTuple windowHandle,
          HTuple hue,
          HTuple saturation,
          HTuple intensity)
        {
            IntPtr proc = HalconAPI.PreCall(1233);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, hue);
            HalconAPI.Store(proc, 2, saturation);
            HalconAPI.Store(proc, 3, intensity);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(hue);
            HalconAPI.UnpinTuple(saturation);
            HalconAPI.UnpinTuple(intensity);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define gray values for region output.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="grayValues">Gray values for region output. Default: 255</param>
        public static void SetGray(HTuple windowHandle, HTuple grayValues)
        {
            IntPtr proc = HalconAPI.PreCall(1234);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, grayValues);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(grayValues);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define the region fill mode.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Fill mode for region output. Default: "fill"</param>
        public static void SetDraw(HTuple windowHandle, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1235);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define the image matrix output clipping.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Clipping mode for gray value output. Default: "object"</param>
        public static void SetComprise(HTuple windowHandle, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1236);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set multiple output colors.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="numberOfColors">Number of output colors. Default: 12</param>
        public static void SetColored(HTuple windowHandle, HTuple numberOfColors)
        {
            IntPtr proc = HalconAPI.PreCall(1237);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, numberOfColors);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(numberOfColors);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set output color.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="color">Output color names. Default: "white"</param>
        public static void SetColor(HTuple windowHandle, HTuple color)
        {
            IntPtr proc = HalconAPI.PreCall(1238);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, color);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(color);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current region output shape.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="displayShape">Current region output shape.</param>
        public static void GetShape(HTuple windowHandle, out HTuple displayShape)
        {
            IntPtr proc = HalconAPI.PreCall(1239);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out displayShape);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current color in RGB-coding.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="red">The current color's red value.</param>
        /// <param name="green">The current color's green value.</param>
        /// <param name="blue">The current color's blue value.</param>
        public static void GetRgb(
          HTuple windowHandle,
          out HTuple red,
          out HTuple green,
          out HTuple blue)
        {
            IntPtr proc = HalconAPI.PreCall(1240);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out red);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out green);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out blue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current color lookup table index.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="pixel">Index of the current color look-up table.</param>
        public static void GetPixel(HTuple windowHandle, out HTuple pixel)
        {
            IntPtr proc = HalconAPI.PreCall(1241);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out pixel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current interpolation mode for gray value display.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="style">Interpolation mode for image display: 0 (fast, low quality) to 2 (slow, high quality).</param>
        public static void GetPartStyle(HTuple windowHandle, out HTuple style)
        {
            IntPtr proc = HalconAPI.PreCall(1242);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out style);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the image part.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row1">Row index of the image part's upper left corner.</param>
        /// <param name="column1">Column index of the image part's upper left corner.</param>
        /// <param name="row2">Row index of the image part's lower right corner.</param>
        /// <param name="column2">Column index of the image part's lower right corner.</param>
        public static void GetPart(
          HTuple windowHandle,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1243);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out row1);
            int err3 = HTuple.LoadNew(proc, 1, err2, out column1);
            int err4 = HTuple.LoadNew(proc, 2, err3, out row2);
            int procResult = HTuple.LoadNew(proc, 3, err4, out column2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current display mode for gray values.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Name and parameter values of the current display mode.</param>
        public static void GetPaint(HTuple windowHandle, out HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1244);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current line width for contour display.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="width">Current line width for contour display.</param>
        public static void GetLineWidth(HTuple windowHandle, out HTuple width)
        {
            IntPtr proc = HalconAPI.PreCall(1245);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out width);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current graphic mode for contours.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="style">Template for contour display.</param>
        public static void GetLineStyle(HTuple windowHandle, out HTuple style)
        {
            IntPtr proc = HalconAPI.PreCall(1246);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out style);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current approximation error for contour display.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="approximation">Current approximation error for contour display.</param>
        public static void GetLineApprox(HTuple windowHandle, out HTuple approximation)
        {
            IntPtr proc = HalconAPI.PreCall(1247);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out approximation);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current display mode.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Display mode.</param>
        public static void GetInsert(HTuple windowHandle, out HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1248);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the HSI coding of the current color.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="hue">Hue (color value) of the current color.</param>
        /// <param name="saturation">Saturation of the current color.</param>
        /// <param name="intensity">Intensity of the current color.</param>
        public static void GetHsi(
          HTuple windowHandle,
          out HTuple hue,
          out HTuple saturation,
          out HTuple intensity)
        {
            IntPtr proc = HalconAPI.PreCall(1249);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out hue);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out saturation);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out intensity);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current region fill mode.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Current region fill mode.</param>
        public static void GetDraw(HTuple windowHandle, out HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1250);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the output treatment of an image matrix.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Display mode for images.</param>
        public static void GetComprise(HTuple windowHandle, out HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1251);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the region display modes.</summary>
        /// <param name="displayShape">region display mode names.</param>
        public static void QueryShape(out HTuple displayShape)
        {
            IntPtr proc = HalconAPI.PreCall(1252);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, err, out displayShape);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the gray value display modes.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Gray value display mode names.</param>
        public static void QueryPaint(HTuple windowHandle, out HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1253);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the possible line widths.</summary>
        /// <param name="min">Displayable minimum width.</param>
        /// <param name="max">Displayable maximum width.</param>
        public static void QueryLineWidth(out HTuple min, out HTuple max)
        {
            IntPtr proc = HalconAPI.PreCall(1254);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out min);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out max);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the possible graphic modes.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Display function name.</param>
        public static void QueryInsert(HTuple windowHandle, out HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1255);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the displayable gray values.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="grayval">Tuple of all displayable gray values.</param>
        public static void QueryGray(HTuple windowHandle, out HTuple grayval)
        {
            IntPtr proc = HalconAPI.PreCall(1256);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out grayval);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the number of colors for color output.</summary>
        /// <param name="possibleNumberOfColors">Tuple of the possible numbers of colors.</param>
        public static void QueryColored(out HTuple possibleNumberOfColors)
        {
            IntPtr proc = HalconAPI.PreCall(1257);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out possibleNumberOfColors);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query all color names.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="colors">Color names.</param>
        public static void QueryAllColors(HTuple windowHandle, out HTuple colors)
        {
            IntPtr proc = HalconAPI.PreCall(1258);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out colors);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query all color names displayable in the window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="colors">Color names.</param>
        public static void QueryColor(HTuple windowHandle, out HTuple colors)
        {
            IntPtr proc = HalconAPI.PreCall(1259);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out colors);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the icon for region output</summary>
        /// <param name="icon">Icon for the regions center of gravity.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void GetIcon(out HObject icon, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1260);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out icon);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Icon definition for region output.</summary>
        /// <param name="icon">Icon for center of gravity.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void SetIcon(HObject icon, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1261);
            HalconAPI.Store(proc, 1, (HObjectBase)icon);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)icon);
        }

        /// <summary>Displays regions in a window.</summary>
        /// <param name="dispRegions">Regions to display.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void DispRegion(HObject dispRegions, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1262);
            HalconAPI.Store(proc, 1, (HObjectBase)dispRegions);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)dispRegions);
        }

        /// <summary>Displays arbitrarily oriented rectangles.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="centerRow">Row index of the center. Default: 48</param>
        /// <param name="centerCol">Column index of the center. Default: 64</param>
        /// <param name="phi">Orientation of rectangle in radians. Default: 0.0</param>
        /// <param name="length1">Half of the length of the longer side. Default: 48</param>
        /// <param name="length2">Half of the length of the shorter side. Default: 32</param>
        public static void DispRectangle2(
          HTuple windowHandle,
          HTuple centerRow,
          HTuple centerCol,
          HTuple phi,
          HTuple length1,
          HTuple length2)
        {
            IntPtr proc = HalconAPI.PreCall(1263);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, centerRow);
            HalconAPI.Store(proc, 2, centerCol);
            HalconAPI.Store(proc, 3, phi);
            HalconAPI.Store(proc, 4, length1);
            HalconAPI.Store(proc, 5, length2);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(centerRow);
            HalconAPI.UnpinTuple(centerCol);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(length1);
            HalconAPI.UnpinTuple(length2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Display of rectangles aligned to the coordinate axes.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row1">Row index of the upper left corner. Default: 16</param>
        /// <param name="column1">Column index of the upper left corner. Default: 16</param>
        /// <param name="row2">Row index of the lower right corner. Default: 48</param>
        /// <param name="column2">Column index of the lower right corner. Default: 80</param>
        public static void DispRectangle1(
          HTuple windowHandle,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1264);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row1);
            HalconAPI.Store(proc, 2, column1);
            HalconAPI.Store(proc, 3, row2);
            HalconAPI.Store(proc, 4, column2);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Displays a polyline.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row index Default: [16,80,80]</param>
        /// <param name="column">Column index Default: [48,16,80]</param>
        public static void DispPolygon(HTuple windowHandle, HTuple row, HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1265);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Draws lines in a window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row1">Row index of the start. Default: 32.0</param>
        /// <param name="column1">Column index of the start. Default: 32.0</param>
        /// <param name="row2">Row index of end. Default: 64.0</param>
        /// <param name="column2">Column index of end. Default: 64.0</param>
        public static void DispLine(
          HTuple windowHandle,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1266);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row1);
            HalconAPI.Store(proc, 2, column1);
            HalconAPI.Store(proc, 3, row2);
            HalconAPI.Store(proc, 4, column2);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Displays crosses in a window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row coordinate of the center. Default: 32.0</param>
        /// <param name="column">Column coordinate of the center. Default: 32.0</param>
        /// <param name="size">Length of the bars. Default: 6.0</param>
        /// <param name="angle">Orientation. Default: 0.0</param>
        public static void DispCross(
          HTuple windowHandle,
          HTuple row,
          HTuple column,
          HTuple size,
          HTuple angle)
        {
            IntPtr proc = HalconAPI.PreCall(1267);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, size);
            HalconAPI.Store(proc, 4, angle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(size);
            HalconAPI.UnpinTuple(angle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Displays gray value images.</summary>
        /// <param name="image">Gray value image to display.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void DispImage(HObject image, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1268);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Displays images with several channels.</summary>
        /// <param name="multichannelImage">Multichannel images to be displayed.</param>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="channel">Number of channel or the numbers of the RGB-channels Default: 1</param>
        public static void DispChannel(HObject multichannelImage, HTuple windowHandle, HTuple channel)
        {
            IntPtr proc = HalconAPI.PreCall(1269);
            HalconAPI.Store(proc, 1, (HObjectBase)multichannelImage);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, channel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(channel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multichannelImage);
        }

        /// <summary>Displays a color (RGB) image</summary>
        /// <param name="colorImage">Color image to display.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void DispColor(HObject colorImage, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1270);
            HalconAPI.Store(proc, 1, (HObjectBase)colorImage);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)colorImage);
        }

        /// <summary>Displays ellipses.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="centerRow">Row index of center. Default: 64</param>
        /// <param name="centerCol">Column index of center. Default: 64</param>
        /// <param name="phi">Orientation of the ellipse in radians Default: 0.0</param>
        /// <param name="radius1">Radius of major axis. Default: 24.0</param>
        /// <param name="radius2">Radius of minor axis. Default: 14.0</param>
        public static void DispEllipse(
          HTuple windowHandle,
          HTuple centerRow,
          HTuple centerCol,
          HTuple phi,
          HTuple radius1,
          HTuple radius2)
        {
            IntPtr proc = HalconAPI.PreCall(1271);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, centerRow);
            HalconAPI.Store(proc, 2, centerCol);
            HalconAPI.Store(proc, 3, phi);
            HalconAPI.Store(proc, 4, radius1);
            HalconAPI.Store(proc, 5, radius2);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(centerRow);
            HalconAPI.UnpinTuple(centerCol);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(radius1);
            HalconAPI.UnpinTuple(radius2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Displays a noise distribution.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="distribution">Gray value distribution (513 values).</param>
        /// <param name="row">Row index of center. Default: 256</param>
        /// <param name="column">Column index of center. Default: 256</param>
        /// <param name="scale">Size of display. Default: 1</param>
        public static void DispDistribution(
          HTuple windowHandle,
          HTuple distribution,
          HTuple row,
          HTuple column,
          HTuple scale)
        {
            IntPtr proc = HalconAPI.PreCall(1272);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, distribution);
            HalconAPI.Store(proc, 2, row);
            HalconAPI.Store(proc, 3, column);
            HalconAPI.Store(proc, 4, scale);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(distribution);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Displays circles in a window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row index of the center. Default: 64</param>
        /// <param name="column">Column index of the center. Default: 64</param>
        /// <param name="radius">Radius of the circle. Default: 64</param>
        public static void DispCircle(HTuple windowHandle, HTuple row, HTuple column, HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(1273);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, radius);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Displays arrows in a window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row1">Row index of the start. Default: 10.0</param>
        /// <param name="column1">Column index of the start. Default: 10.0</param>
        /// <param name="row2">Row index of the end. Default: 118.0</param>
        /// <param name="column2">Column index of the end. Default: 118.0</param>
        /// <param name="size">Size of the arrowhead. Default: 1.0</param>
        public static void DispArrow(
          HTuple windowHandle,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          HTuple size)
        {
            IntPtr proc = HalconAPI.PreCall(1274);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row1);
            HalconAPI.Store(proc, 2, column1);
            HalconAPI.Store(proc, 3, row2);
            HalconAPI.Store(proc, 4, column2);
            HalconAPI.Store(proc, 5, size);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            HalconAPI.UnpinTuple(size);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Displays circular arcs in a window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="centerRow">Row coordinate of center point. Default: 64</param>
        /// <param name="centerCol">Column coordinate of center point. Default: 64</param>
        /// <param name="angle">Angle between start and end of the arc (in radians). Default: 3.1415926</param>
        /// <param name="beginRow">Row coordinate of the start of the arc. Default: 32</param>
        /// <param name="beginCol">Column coordinate of the start of the arc. Default: 32</param>
        public static void DispArc(
          HTuple windowHandle,
          HTuple centerRow,
          HTuple centerCol,
          HTuple angle,
          HTuple beginRow,
          HTuple beginCol)
        {
            IntPtr proc = HalconAPI.PreCall(1275);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, centerRow);
            HalconAPI.Store(proc, 2, centerCol);
            HalconAPI.Store(proc, 3, angle);
            HalconAPI.Store(proc, 4, beginRow);
            HalconAPI.Store(proc, 5, beginCol);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(centerRow);
            HalconAPI.UnpinTuple(centerCol);
            HalconAPI.UnpinTuple(angle);
            HalconAPI.UnpinTuple(beginRow);
            HalconAPI.UnpinTuple(beginCol);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Displays image objects (image, region, XLD).</summary>
        /// <param name="objectVal">Image object to be displayed.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void DispObj(HObject objectVal, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1276);
            HalconAPI.Store(proc, 1, (HObjectBase)objectVal);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objectVal);
        }

        /// <summary>Set the current mouse pointer shape.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="cursor">Mouse pointer name. Default: "arrow"</param>
        public static void SetMshape(HTuple windowHandle, HTuple cursor)
        {
            IntPtr proc = HalconAPI.PreCall(1277);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, cursor);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(cursor);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the current mouse pointer shape.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="cursor">Mouse pointer name.</param>
        public static void GetMshape(HTuple windowHandle, out HTuple cursor)
        {
            IntPtr proc = HalconAPI.PreCall(1278);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out cursor);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query all available mouse pointer shapes.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="shapeNames">Available mouse pointer names.</param>
        public static void QueryMshape(HTuple windowHandle, out HTuple shapeNames)
        {
            IntPtr proc = HalconAPI.PreCall(1279);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out shapeNames);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the subpixel mouse position.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row coordinate of the mouse position in the window.</param>
        /// <param name="column">Column coordinate of the mouse position in the window.</param>
        /// <param name="button">Mouse button(s) pressed or 0.</param>
        public static void GetMpositionSubPix(
          HTuple windowHandle,
          out HTuple row,
          out HTuple column,
          out HTuple button)
        {
            IntPtr proc = HalconAPI.PreCall(1280);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out button);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query the mouse position.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row coordinate of the mouse position in the window.</param>
        /// <param name="column">Column coordinate of the mouse position in the window.</param>
        /// <param name="button">Mouse button(s) pressed or 0.</param>
        public static void GetMposition(
          HTuple windowHandle,
          out HTuple row,
          out HTuple column,
          out HTuple button)
        {
            IntPtr proc = HalconAPI.PreCall(1281);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out button);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Wait until a mouse button is pressed and get the subpixel mouse position.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row coordinate of the mouse position in the window.</param>
        /// <param name="column">Column coordinate of the mouse position in the window.</param>
        /// <param name="button">Mouse button(s) pressed.</param>
        public static void GetMbuttonSubPix(
          HTuple windowHandle,
          out HTuple row,
          out HTuple column,
          out HTuple button)
        {
            IntPtr proc = HalconAPI.PreCall(1282);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out button);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Wait until a mouse button is pressed.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row coordinate of the mouse position in the window.</param>
        /// <param name="column">Column coordinate of the mouse position in the window.</param>
        /// <param name="button">Mouse button(s) pressed.</param>
        public static void GetMbutton(
          HTuple windowHandle,
          out HTuple row,
          out HTuple column,
          out HTuple button)
        {
            IntPtr proc = HalconAPI.PreCall(1283);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out button);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write look-up-table (lut) as file.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="fileName">File name (of file containing the look-up-table). Default: "/tmp/lut"</param>
        public static void WriteLut(HTuple windowHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1284);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Graphical view of the look-up-table (lut).</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row of centre of the graphic. Default: 128</param>
        /// <param name="column">Column of centre of the graphic. Default: 128</param>
        /// <param name="scale">Scaling of the graphic. Default: 1</param>
        public static void DispLut(HTuple windowHandle, HTuple row, HTuple column, HTuple scale)
        {
            IntPtr proc = HalconAPI.PreCall(1285);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, scale);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query all available look-up-tables (lut).</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="lookUpTable">Names of look-up-tables.</param>
        public static void QueryLut(HTuple windowHandle, out HTuple lookUpTable)
        {
            IntPtr proc = HalconAPI.PreCall(1286);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out lookUpTable);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get modification parameters of look-up-table (lut).</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="hue">Modification of color value.</param>
        /// <param name="saturation">Modification of saturation.</param>
        /// <param name="intensity">Modification of intensity.</param>
        public static void GetLutStyle(
          HTuple windowHandle,
          out HTuple hue,
          out HTuple saturation,
          out HTuple intensity)
        {
            IntPtr proc = HalconAPI.PreCall(1287);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out hue);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out saturation);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out intensity);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Changing the look-up-table (lut).</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="hue">Modification of color value. Default: 0.0</param>
        /// <param name="saturation">Modification of saturation. Default: 1.5</param>
        /// <param name="intensity">Modification of intensity. Default: 1.5</param>
        public static void SetLutStyle(
          HTuple windowHandle,
          HTuple hue,
          HTuple saturation,
          HTuple intensity)
        {
            IntPtr proc = HalconAPI.PreCall(1288);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, hue);
            HalconAPI.Store(proc, 2, saturation);
            HalconAPI.Store(proc, 3, intensity);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(hue);
            HalconAPI.UnpinTuple(saturation);
            HalconAPI.UnpinTuple(intensity);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get current look-up-table (lut).</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="lookUpTable">Name of look-up-table or tuple of RGB-values.</param>
        public static void GetLut(HTuple windowHandle, out HTuple lookUpTable)
        {
            IntPtr proc = HalconAPI.PreCall(1289);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out lookUpTable);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set "`look-up-table"' (lut).</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="lookUpTable">Name of look-up-table, values of look-up-table (RGB) or file name. Default: "default"</param>
        public static void SetLut(HTuple windowHandle, HTuple lookUpTable)
        {
            IntPtr proc = HalconAPI.PreCall(1290);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, lookUpTable);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(lookUpTable);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get mode of fixing of current look-up-table (lut).</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Current Mode of fixing.</param>
        public static void GetFix(HTuple windowHandle, out HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1291);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set fixing of "`look-up-table"' (lut)</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Mode of fixing. Default: "true"</param>
        public static void SetFix(HTuple windowHandle, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1292);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get fixing of "`look-up-table"' (lut) for "`real color images"'</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Mode of fixing.</param>
        public static void GetFixedLut(HTuple windowHandle, out HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1293);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Fix "`look-up-table"' (lut) for "`real color images"'.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="mode">Mode of fixing. Default: "true"</param>
        public static void SetFixedLut(HTuple windowHandle, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1294);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Plot a function using gnuplot.</summary>
        /// <param name="gnuplotFileID">Identifier for the gnuplot output stream.</param>
        /// <param name="function">Function to be plotted.</param>
        public static void GnuplotPlotFunct1d(HTuple gnuplotFileID, HTuple function)
        {
            IntPtr proc = HalconAPI.PreCall(1295);
            HalconAPI.Store(proc, 0, gnuplotFileID);
            HalconAPI.Store(proc, 1, function);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(gnuplotFileID);
            HalconAPI.UnpinTuple(function);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Plot control values using gnuplot.</summary>
        /// <param name="gnuplotFileID">Identifier for the gnuplot output stream.</param>
        /// <param name="values">Control values to be plotted (y-values).</param>
        public static void GnuplotPlotCtrl(HTuple gnuplotFileID, HTuple values)
        {
            IntPtr proc = HalconAPI.PreCall(1296);
            HalconAPI.Store(proc, 0, gnuplotFileID);
            HalconAPI.Store(proc, 1, values);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(gnuplotFileID);
            HalconAPI.UnpinTuple(values);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Visualize images using gnuplot.</summary>
        /// <param name="image">Image to be plotted.</param>
        /// <param name="gnuplotFileID">Identifier for the gnuplot output stream.</param>
        /// <param name="samplesX">Number of samples in the x-direction. Default: 64</param>
        /// <param name="samplesY">Number of samples in the y-direction. Default: 64</param>
        /// <param name="viewRotX">Rotation of the plot about the x-axis. Default: 60</param>
        /// <param name="viewRotZ">Rotation of the plot about the z-axis. Default: 30</param>
        /// <param name="hidden3D">Plot the image with hidden surfaces removed. Default: "hidden3d"</param>
        public static void GnuplotPlotImage(
          HObject image,
          HTuple gnuplotFileID,
          HTuple samplesX,
          HTuple samplesY,
          HTuple viewRotX,
          HTuple viewRotZ,
          HTuple hidden3D)
        {
            IntPtr proc = HalconAPI.PreCall(1297);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, gnuplotFileID);
            HalconAPI.Store(proc, 1, samplesX);
            HalconAPI.Store(proc, 2, samplesY);
            HalconAPI.Store(proc, 3, viewRotX);
            HalconAPI.Store(proc, 4, viewRotZ);
            HalconAPI.Store(proc, 5, hidden3D);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(gnuplotFileID);
            HalconAPI.UnpinTuple(samplesX);
            HalconAPI.UnpinTuple(samplesY);
            HalconAPI.UnpinTuple(viewRotX);
            HalconAPI.UnpinTuple(viewRotZ);
            HalconAPI.UnpinTuple(hidden3D);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Close all open gnuplot files or terminate an active gnuplot sub-process.</summary>
        /// <param name="gnuplotFileID">Identifier for the gnuplot output stream.</param>
        public static void GnuplotClose(HTuple gnuplotFileID)
        {
            IntPtr proc = HalconAPI.PreCall(1298);
            HalconAPI.Store(proc, 0, gnuplotFileID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(gnuplotFileID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open a gnuplot file for visualization of images and control values.</summary>
        /// <param name="fileName">Base name for control and data files.</param>
        /// <param name="gnuplotFileID">Identifier for the gnuplot output stream.</param>
        public static void GnuplotOpenFile(HTuple fileName, out HTuple gnuplotFileID)
        {
            IntPtr proc = HalconAPI.PreCall(1299);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out gnuplotFileID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open a pipe to a gnuplot process for visualization of images and control values.</summary>
        /// <param name="gnuplotFileID">Identifier for the gnuplot output stream.</param>
        public static void GnuplotOpenPipe(out HTuple gnuplotFileID)
        {
            IntPtr proc = HalconAPI.PreCall(1300);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out gnuplotFileID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a text object which can be moved interactively.</summary>
        /// <param name="row">Row coordinate of the text position. Default: 12</param>
        /// <param name="column">Column coordinate of the text position. Default: 12</param>
        /// <param name="stringVal">Character string to be displayed. Default: "Text"</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void CreateDrawingObjectText(
          HTuple row,
          HTuple column,
          HTuple stringVal,
          out HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1301);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, stringVal);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(stringVal);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the iconic object of a drawing object.</summary>
        /// <param name="objectVal">Copy of the iconic object represented by the drawing object.</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void GetDrawingObjectIconic(out HObject objectVal, HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1302);
            HalconAPI.Store(proc, 0, drawID);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(drawID);
            int procResult = HObject.LoadNew(proc, 1, err, out objectVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete drawing object.</summary>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void ClearDrawingObject(HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1303);
            HalconAPI.Store(proc, 0, drawID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the parameters of a drawing object.</summary>
        /// <param name="drawID">Handle of the drawing object.</param>
        /// <param name="genParamName">Parameter names of the drawing object.</param>
        /// <param name="genParamValue">Parameter values.</param>
        public static void SetDrawingObjectParams(
          HTuple drawID,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1304);
            HalconAPI.Store(proc, 0, drawID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(drawID);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the parameters of a drawing object.</summary>
        /// <param name="drawID">Handle of the drawing object.</param>
        /// <param name="genParamName">Parameter names of the drawing object.</param>
        /// <param name="genParamValue">Parameter values.</param>
        public static void GetDrawingObjectParams(
          HTuple drawID,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1305);
            HalconAPI.Store(proc, 0, drawID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(drawID);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the contour of an interactive draw XLD.</summary>
        /// <param name="contour">XLD contour.</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void SetDrawingObjectXld(HObject contour, HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1306);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, drawID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(drawID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Create a XLD contour which can be modified interactively.</summary>
        /// <param name="row">Row coordinates of the polygon. Default: [100,200,200,100]</param>
        /// <param name="column">Column coordinates of the polygon. Default: [100,100,200,200]</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void CreateDrawingObjectXld(HTuple row, HTuple column, out HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1307);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a circle sector which can be modified interactively.</summary>
        /// <param name="row">Row coordinate of the center. Default: 100</param>
        /// <param name="column">Column coordinate of the center. Default: 100</param>
        /// <param name="radius">Radius of the circle. Default: 80</param>
        /// <param name="startAngle">Start angle of the arc. Default: 0</param>
        /// <param name="endAngle">End angle of the arc. Default: 3.14159</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void CreateDrawingObjectCircleSector(
          HTuple row,
          HTuple column,
          HTuple radius,
          HTuple startAngle,
          HTuple endAngle,
          out HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1308);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, radius);
            HalconAPI.Store(proc, 3, startAngle);
            HalconAPI.Store(proc, 4, endAngle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(startAngle);
            HalconAPI.UnpinTuple(endAngle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an elliptic sector which can be modified interactively.</summary>
        /// <param name="row">Row index of the center. Default: 200</param>
        /// <param name="column">Column index of the center. Default: 200</param>
        /// <param name="phi">Orientation of the first half axis in radians. Default: 0</param>
        /// <param name="radius1">First half axis. Default: 100</param>
        /// <param name="radius2">Second half axis. Default: 60</param>
        /// <param name="startAngle">Start angle of the arc. Default: 0</param>
        /// <param name="endAngle">End angle of the arc. Default: 3.14159</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void CreateDrawingObjectEllipseSector(
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple radius1,
          HTuple radius2,
          HTuple startAngle,
          HTuple endAngle,
          out HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1309);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, phi);
            HalconAPI.Store(proc, 3, radius1);
            HalconAPI.Store(proc, 4, radius2);
            HalconAPI.Store(proc, 5, startAngle);
            HalconAPI.Store(proc, 6, endAngle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(radius1);
            HalconAPI.UnpinTuple(radius2);
            HalconAPI.UnpinTuple(startAngle);
            HalconAPI.UnpinTuple(endAngle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a line which can be modified interactively.</summary>
        /// <param name="row1">Row index of the first line point. Default: 100</param>
        /// <param name="column1">Column index of the first line point. Default: 100</param>
        /// <param name="row2">Row index of the second line point. Default: 200</param>
        /// <param name="column2">Column index of the second line point. Default: 200</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void CreateDrawingObjectLine(
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          out HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1310);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a circle which can be modified interactively.</summary>
        /// <param name="row">Row coordinate of the center. Default: 100</param>
        /// <param name="column">Column coordinate of the center. Default: 100</param>
        /// <param name="radius">Radius of the circle. Default: 80</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void CreateDrawingObjectCircle(
          HTuple row,
          HTuple column,
          HTuple radius,
          out HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1311);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, radius);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(radius);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create an ellipse which can be modified interactively.</summary>
        /// <param name="row">Row index of the center. Default: 200</param>
        /// <param name="column">Column index of the center. Default: 200</param>
        /// <param name="phi">Orientation of the first half axis in radians. Default: 0</param>
        /// <param name="radius1">First half axis. Default: 100</param>
        /// <param name="radius2">Second half axis. Default: 60</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void CreateDrawingObjectEllipse(
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple radius1,
          HTuple radius2,
          out HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1312);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, phi);
            HalconAPI.Store(proc, 3, radius1);
            HalconAPI.Store(proc, 4, radius2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(radius1);
            HalconAPI.UnpinTuple(radius2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a rectangle of any orientation which can be modified interactively.</summary>
        /// <param name="row">Row coordinate of the center. Default: 150</param>
        /// <param name="column">Column coordinate of the center. Default: 150</param>
        /// <param name="phi">Orientation of the first half axis in radians. Default: 0</param>
        /// <param name="length1">First half axis. Default: 100</param>
        /// <param name="length2">Second half axis. Default: 100</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void CreateDrawingObjectRectangle2(
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple length1,
          HTuple length2,
          out HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1313);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, phi);
            HalconAPI.Store(proc, 3, length1);
            HalconAPI.Store(proc, 4, length2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(length1);
            HalconAPI.UnpinTuple(length2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a rectangle parallel to the coordinate axis which can be modified interactively.</summary>
        /// <param name="row1">Row coordinate of the upper left corner. Default: 100</param>
        /// <param name="column1">Column coordinate of the upper left corner. Default: 100</param>
        /// <param name="row2">Row coordinate of the lower right corner. Default: 200</param>
        /// <param name="column2">Column coordinate of the lower right corner. Default: 200</param>
        /// <param name="drawID">Handle of the drawing object.</param>
        public static void CreateDrawingObjectRectangle1(
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          out HTuple drawID)
        {
            IntPtr proc = HalconAPI.PreCall(1314);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out drawID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive movement of a region with restriction of positions.</summary>
        /// <param name="sourceRegion">Regions to move.</param>
        /// <param name="maskRegion">Points on which it is allowed for a region to move.</param>
        /// <param name="destinationRegion">Moved regions.</param>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row index of the reference point. Default: 100</param>
        /// <param name="column">Column index of the reference point. Default: 100</param>
        public static void DragRegion3(
          HObject sourceRegion,
          HObject maskRegion,
          out HObject destinationRegion,
          HTuple windowHandle,
          HTuple row,
          HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1315);
            HalconAPI.Store(proc, 1, (HObjectBase)sourceRegion);
            HalconAPI.Store(proc, 2, (HObjectBase)maskRegion);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HObject.LoadNew(proc, 1, err, out destinationRegion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)sourceRegion);
            GC.KeepAlive((object)maskRegion);
        }

        /// <summary>Interactive movement of a region with fixpoint specification.</summary>
        /// <param name="sourceRegion">Regions to move.</param>
        /// <param name="destinationRegion">Moved regions.</param>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row index of the reference point. Default: 100</param>
        /// <param name="column">Column index of the reference point. Default: 100</param>
        public static void DragRegion2(
          HObject sourceRegion,
          out HObject destinationRegion,
          HTuple windowHandle,
          HTuple row,
          HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1316);
            HalconAPI.Store(proc, 1, (HObjectBase)sourceRegion);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HObject.LoadNew(proc, 1, err, out destinationRegion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)sourceRegion);
        }

        /// <summary>Interactive moving of a region.</summary>
        /// <param name="sourceRegion">Regions to move.</param>
        /// <param name="destinationRegion">Moved Regions.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void DragRegion1(
          HObject sourceRegion,
          out HObject destinationRegion,
          HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1317);
            HalconAPI.Store(proc, 1, (HObjectBase)sourceRegion);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out destinationRegion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)sourceRegion);
        }

        /// <summary>Interactive modification of a NURBS curve using interpolation.</summary>
        /// <param name="contOut">Contour of the modified curve.</param>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="rotate">Enable rotation? Default: "true"</param>
        /// <param name="move">Enable moving? Default: "true"</param>
        /// <param name="scale">Enable scaling? Default: "true"</param>
        /// <param name="keepRatio">Keep ratio while scaling? Default: "true"</param>
        /// <param name="edit">Enable editing? Default: "true"</param>
        /// <param name="degree">The degree $p$ of the NURBS curve. Reasonable values are 3 to 5. Default: 3</param>
        /// <param name="rowsIn">Row coordinates of the input interpolation points.</param>
        /// <param name="colsIn">Column coordinates of the input interpolation points.</param>
        /// <param name="tangentsIn">Input tangents.</param>
        /// <param name="controlRows">Row coordinates of the control polygon.</param>
        /// <param name="controlCols">Column coordinates of the control polygon.</param>
        /// <param name="knots">Knot vector.</param>
        /// <param name="rows">Row coordinates of the points specified by the user.</param>
        /// <param name="cols">Column coordinates of the points specified by the user.</param>
        /// <param name="tangents">Tangents specified by the user.</param>
        public static void DrawNurbsInterpMod(
          out HObject contOut,
          HTuple windowHandle,
          HTuple rotate,
          HTuple move,
          HTuple scale,
          HTuple keepRatio,
          HTuple edit,
          HTuple degree,
          HTuple rowsIn,
          HTuple colsIn,
          HTuple tangentsIn,
          out HTuple controlRows,
          out HTuple controlCols,
          out HTuple knots,
          out HTuple rows,
          out HTuple cols,
          out HTuple tangents)
        {
            IntPtr proc = HalconAPI.PreCall(1318);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rotate);
            HalconAPI.Store(proc, 2, move);
            HalconAPI.Store(proc, 3, scale);
            HalconAPI.Store(proc, 4, keepRatio);
            HalconAPI.Store(proc, 5, edit);
            HalconAPI.Store(proc, 6, degree);
            HalconAPI.Store(proc, 7, rowsIn);
            HalconAPI.Store(proc, 8, colsIn);
            HalconAPI.Store(proc, 9, tangentsIn);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rotate);
            HalconAPI.UnpinTuple(move);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.UnpinTuple(keepRatio);
            HalconAPI.UnpinTuple(edit);
            HalconAPI.UnpinTuple(degree);
            HalconAPI.UnpinTuple(rowsIn);
            HalconAPI.UnpinTuple(colsIn);
            HalconAPI.UnpinTuple(tangentsIn);
            int err2 = HObject.LoadNew(proc, 1, err1, out contOut);
            int err3 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out controlRows);
            int err4 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err3, out controlCols);
            int err5 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err4, out knots);
            int err6 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err5, out rows);
            int err7 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err6, out cols);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err7, out tangents);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive drawing of a NURBS curve using interpolation.</summary>
        /// <param name="contOut">Contour of the curve.</param>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="rotate">Enable rotation? Default: "true"</param>
        /// <param name="move">Enable moving? Default: "true"</param>
        /// <param name="scale">Enable scaling? Default: "true"</param>
        /// <param name="keepRatio">Keep ratio while scaling? Default: "true"</param>
        /// <param name="degree">The degree $p$ of the NURBS curve. Reasonable values are 3 to 5. Default: 3</param>
        /// <param name="controlRows">Row coordinates of the control polygon.</param>
        /// <param name="controlCols">Column coordinates of the control polygon.</param>
        /// <param name="knots">Knot vector.</param>
        /// <param name="rows">Row coordinates of the points specified by the user.</param>
        /// <param name="cols">Column coordinates of the points specified by the user.</param>
        /// <param name="tangents">Tangents specified by the user.</param>
        public static void DrawNurbsInterp(
          out HObject contOut,
          HTuple windowHandle,
          HTuple rotate,
          HTuple move,
          HTuple scale,
          HTuple keepRatio,
          HTuple degree,
          out HTuple controlRows,
          out HTuple controlCols,
          out HTuple knots,
          out HTuple rows,
          out HTuple cols,
          out HTuple tangents)
        {
            IntPtr proc = HalconAPI.PreCall(1319);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rotate);
            HalconAPI.Store(proc, 2, move);
            HalconAPI.Store(proc, 3, scale);
            HalconAPI.Store(proc, 4, keepRatio);
            HalconAPI.Store(proc, 5, degree);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rotate);
            HalconAPI.UnpinTuple(move);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.UnpinTuple(keepRatio);
            HalconAPI.UnpinTuple(degree);
            int err2 = HObject.LoadNew(proc, 1, err1, out contOut);
            int err3 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out controlRows);
            int err4 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err3, out controlCols);
            int err5 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err4, out knots);
            int err6 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err5, out rows);
            int err7 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err6, out cols);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err7, out tangents);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive modification of a NURBS curve.</summary>
        /// <param name="contOut">Contour of the modified curve.</param>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="rotate">Enable rotation? Default: "true"</param>
        /// <param name="move">Enable moving? Default: "true"</param>
        /// <param name="scale">Enable scaling? Default: "true"</param>
        /// <param name="keepRatio">Keep ratio while scaling? Default: "true"</param>
        /// <param name="edit">Enable editing? Default: "true"</param>
        /// <param name="degree">The degree $p$ of the NURBS curve. Reasonable values are 3 to 25. Default: 3</param>
        /// <param name="rowsIn">Row coordinates of the input control polygon.</param>
        /// <param name="colsIn">Column coordinates of the input control polygon.</param>
        /// <param name="weightsIn">Input weight vector.</param>
        /// <param name="rows">Row coordinates of the control polygon.</param>
        /// <param name="cols">Columns coordinates of the control polygon.</param>
        /// <param name="weights">Weight vector.</param>
        public static void DrawNurbsMod(
          out HObject contOut,
          HTuple windowHandle,
          HTuple rotate,
          HTuple move,
          HTuple scale,
          HTuple keepRatio,
          HTuple edit,
          HTuple degree,
          HTuple rowsIn,
          HTuple colsIn,
          HTuple weightsIn,
          out HTuple rows,
          out HTuple cols,
          out HTuple weights)
        {
            IntPtr proc = HalconAPI.PreCall(1320);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rotate);
            HalconAPI.Store(proc, 2, move);
            HalconAPI.Store(proc, 3, scale);
            HalconAPI.Store(proc, 4, keepRatio);
            HalconAPI.Store(proc, 5, edit);
            HalconAPI.Store(proc, 6, degree);
            HalconAPI.Store(proc, 7, rowsIn);
            HalconAPI.Store(proc, 8, colsIn);
            HalconAPI.Store(proc, 9, weightsIn);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rotate);
            HalconAPI.UnpinTuple(move);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.UnpinTuple(keepRatio);
            HalconAPI.UnpinTuple(edit);
            HalconAPI.UnpinTuple(degree);
            HalconAPI.UnpinTuple(rowsIn);
            HalconAPI.UnpinTuple(colsIn);
            HalconAPI.UnpinTuple(weightsIn);
            int err2 = HObject.LoadNew(proc, 1, err1, out contOut);
            int err3 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out rows);
            int err4 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err3, out cols);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err4, out weights);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive drawing of a NURBS curve.</summary>
        /// <param name="contOut">Contour approximating the NURBS curve.</param>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="rotate">Enable rotation? Default: "true"</param>
        /// <param name="move">Enable moving? Default: "true"</param>
        /// <param name="scale">Enable scaling? Default: "true"</param>
        /// <param name="keepRatio">Keep ratio while scaling? Default: "true"</param>
        /// <param name="degree">The degree $p$ of the NURBS curve. Reasonable values are 3 to 25. Default: 3</param>
        /// <param name="rows">Row coordinates of the control polygon.</param>
        /// <param name="cols">Columns coordinates of the control polygon.</param>
        /// <param name="weights">Weight vector.</param>
        public static void DrawNurbs(
          out HObject contOut,
          HTuple windowHandle,
          HTuple rotate,
          HTuple move,
          HTuple scale,
          HTuple keepRatio,
          HTuple degree,
          out HTuple rows,
          out HTuple cols,
          out HTuple weights)
        {
            IntPtr proc = HalconAPI.PreCall(1321);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rotate);
            HalconAPI.Store(proc, 2, move);
            HalconAPI.Store(proc, 3, scale);
            HalconAPI.Store(proc, 4, keepRatio);
            HalconAPI.Store(proc, 5, degree);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rotate);
            HalconAPI.UnpinTuple(move);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.UnpinTuple(keepRatio);
            HalconAPI.UnpinTuple(degree);
            int err2 = HObject.LoadNew(proc, 1, err1, out contOut);
            int err3 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out rows);
            int err4 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err3, out cols);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err4, out weights);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive modification of a contour.</summary>
        /// <param name="contIn">Input contour.</param>
        /// <param name="contOut">Modified contour.</param>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="rotate">Enable rotation? Default: "true"</param>
        /// <param name="move">Enable moving? Default: "true"</param>
        /// <param name="scale">Enable scaling? Default: "true"</param>
        /// <param name="keepRatio">Keep ratio while scaling? Default: "true"</param>
        /// <param name="edit">Enable editing? Default: "true"</param>
        public static void DrawXldMod(
          HObject contIn,
          out HObject contOut,
          HTuple windowHandle,
          HTuple rotate,
          HTuple move,
          HTuple scale,
          HTuple keepRatio,
          HTuple edit)
        {
            IntPtr proc = HalconAPI.PreCall(1322);
            HalconAPI.Store(proc, 1, (HObjectBase)contIn);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rotate);
            HalconAPI.Store(proc, 2, move);
            HalconAPI.Store(proc, 3, scale);
            HalconAPI.Store(proc, 4, keepRatio);
            HalconAPI.Store(proc, 5, edit);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rotate);
            HalconAPI.UnpinTuple(move);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.UnpinTuple(keepRatio);
            HalconAPI.UnpinTuple(edit);
            int procResult = HObject.LoadNew(proc, 1, err, out contOut);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contIn);
        }

        /// <summary>Interactive drawing of a contour.</summary>
        /// <param name="contOut">Modified contour.</param>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="rotate">Enable rotation? Default: "true"</param>
        /// <param name="move">Enable moving? Default: "true"</param>
        /// <param name="scale">Enable scaling? Default: "true"</param>
        /// <param name="keepRatio">Keep ratio while scaling? Default: "true"</param>
        public static void DrawXld(
          out HObject contOut,
          HTuple windowHandle,
          HTuple rotate,
          HTuple move,
          HTuple scale,
          HTuple keepRatio)
        {
            IntPtr proc = HalconAPI.PreCall(1323);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rotate);
            HalconAPI.Store(proc, 2, move);
            HalconAPI.Store(proc, 3, scale);
            HalconAPI.Store(proc, 4, keepRatio);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rotate);
            HalconAPI.UnpinTuple(move);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.UnpinTuple(keepRatio);
            int procResult = HObject.LoadNew(proc, 1, err, out contOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive drawing of any orientated rectangle.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="rowIn">Row index of the center.</param>
        /// <param name="columnIn">Column index of the center.</param>
        /// <param name="phiIn">Orientation of the bigger half axis in radians.</param>
        /// <param name="length1In">Bigger half axis.</param>
        /// <param name="length2In">Smaller half axis.</param>
        /// <param name="row">Row index of the center.</param>
        /// <param name="column">Column index of the center.</param>
        /// <param name="phi">Orientation of the bigger half axis in radians.</param>
        /// <param name="length1">Bigger half axis.</param>
        /// <param name="length2">Smaller half axis.</param>
        public static void DrawRectangle2Mod(
          HTuple windowHandle,
          HTuple rowIn,
          HTuple columnIn,
          HTuple phiIn,
          HTuple length1In,
          HTuple length2In,
          out HTuple row,
          out HTuple column,
          out HTuple phi,
          out HTuple length1,
          out HTuple length2)
        {
            IntPtr proc = HalconAPI.PreCall(1324);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rowIn);
            HalconAPI.Store(proc, 2, columnIn);
            HalconAPI.Store(proc, 3, phiIn);
            HalconAPI.Store(proc, 4, length1In);
            HalconAPI.Store(proc, 5, length2In);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rowIn);
            HalconAPI.UnpinTuple(columnIn);
            HalconAPI.UnpinTuple(phiIn);
            HalconAPI.UnpinTuple(length1In);
            HalconAPI.UnpinTuple(length2In);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out length1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out length2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive drawing of any orientated rectangle.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row index of the center.</param>
        /// <param name="column">Column index of the center.</param>
        /// <param name="phi">Orientation of the bigger half axis in radians.</param>
        /// <param name="length1">Bigger half axis.</param>
        /// <param name="length2">Smaller half axis.</param>
        public static void DrawRectangle2(
          HTuple windowHandle,
          out HTuple row,
          out HTuple column,
          out HTuple phi,
          out HTuple length1,
          out HTuple length2)
        {
            IntPtr proc = HalconAPI.PreCall(1325);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out length1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out length2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Draw a rectangle parallel to the coordinate axis.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row1In">Row index of the left upper corner.</param>
        /// <param name="column1In">Column index of the left upper corner.</param>
        /// <param name="row2In">Row index of the right lower corner.</param>
        /// <param name="column2In">Column index of the right lower corner.</param>
        /// <param name="row1">Row index of the left upper corner.</param>
        /// <param name="column1">Column index of the left upper corner.</param>
        /// <param name="row2">Row index of the right lower corner.</param>
        /// <param name="column2">Column index of the right lower corner.</param>
        public static void DrawRectangle1Mod(
          HTuple windowHandle,
          HTuple row1In,
          HTuple column1In,
          HTuple row2In,
          HTuple column2In,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1326);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row1In);
            HalconAPI.Store(proc, 2, column1In);
            HalconAPI.Store(proc, 3, row2In);
            HalconAPI.Store(proc, 4, column2In);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row1In);
            HalconAPI.UnpinTuple(column1In);
            HalconAPI.UnpinTuple(row2In);
            HalconAPI.UnpinTuple(column2In);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out row2);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out column2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Draw a rectangle parallel to the coordinate axis.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row1">Row index of the left upper corner.</param>
        /// <param name="column1">Column index of the left upper corner.</param>
        /// <param name="row2">Row index of the right lower corner.</param>
        /// <param name="column2">Column index of the right lower corner.</param>
        public static void DrawRectangle1(
          HTuple windowHandle,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1327);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out row2);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out column2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Draw a point.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="rowIn">Row index of the point.</param>
        /// <param name="columnIn">Column index of the point.</param>
        /// <param name="row">Row index of the point.</param>
        /// <param name="column">Column index of the point.</param>
        public static void DrawPointMod(
          HTuple windowHandle,
          HTuple rowIn,
          HTuple columnIn,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1328);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rowIn);
            HalconAPI.Store(proc, 2, columnIn);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rowIn);
            HalconAPI.UnpinTuple(columnIn);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Draw a point.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row index of the point.</param>
        /// <param name="column">Column index of the point.</param>
        public static void DrawPoint(HTuple windowHandle, out HTuple row, out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1329);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Draw a line.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row1In">Row index of the first point of the line.</param>
        /// <param name="column1In">Column index of the first point of the line.</param>
        /// <param name="row2In">Row index of the second point of the line.</param>
        /// <param name="column2In">Column index of the second point of the line.</param>
        /// <param name="row1">Row index of the first point of the line.</param>
        /// <param name="column1">Column index of the first point of the line.</param>
        /// <param name="row2">Row index of the second point of the line.</param>
        /// <param name="column2">Column index of the second point of the line.</param>
        public static void DrawLineMod(
          HTuple windowHandle,
          HTuple row1In,
          HTuple column1In,
          HTuple row2In,
          HTuple column2In,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1330);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row1In);
            HalconAPI.Store(proc, 2, column1In);
            HalconAPI.Store(proc, 3, row2In);
            HalconAPI.Store(proc, 4, column2In);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row1In);
            HalconAPI.UnpinTuple(column1In);
            HalconAPI.UnpinTuple(row2In);
            HalconAPI.UnpinTuple(column2In);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out row2);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out column2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Draw a line.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row1">Row index of the first point of the line.</param>
        /// <param name="column1">Column index of the first point of the line.</param>
        /// <param name="row2">Row index of the second point of the line.</param>
        /// <param name="column2">Column index of the second point of the line.</param>
        public static void DrawLine(
          HTuple windowHandle,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1331);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out row2);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out column2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive drawing of an ellipse.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="rowIn">Row index of the center.</param>
        /// <param name="columnIn">Column index of the center.</param>
        /// <param name="phiIn">Orientation of the bigger half axis in radians.</param>
        /// <param name="radius1In">Bigger half axis.</param>
        /// <param name="radius2In">Smaller half axis.</param>
        /// <param name="row">Row index of the center.</param>
        /// <param name="column">Column index of the center.</param>
        /// <param name="phi">Orientation of the first half axis in radians.</param>
        /// <param name="radius1">First half axis.</param>
        /// <param name="radius2">Second half axis.</param>
        public static void DrawEllipseMod(
          HTuple windowHandle,
          HTuple rowIn,
          HTuple columnIn,
          HTuple phiIn,
          HTuple radius1In,
          HTuple radius2In,
          out HTuple row,
          out HTuple column,
          out HTuple phi,
          out HTuple radius1,
          out HTuple radius2)
        {
            IntPtr proc = HalconAPI.PreCall(1332);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rowIn);
            HalconAPI.Store(proc, 2, columnIn);
            HalconAPI.Store(proc, 3, phiIn);
            HalconAPI.Store(proc, 4, radius1In);
            HalconAPI.Store(proc, 5, radius2In);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rowIn);
            HalconAPI.UnpinTuple(columnIn);
            HalconAPI.UnpinTuple(phiIn);
            HalconAPI.UnpinTuple(radius1In);
            HalconAPI.UnpinTuple(radius2In);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out radius1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out radius2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive drawing of an ellipse.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row index of the center.</param>
        /// <param name="column">Column index of the center.</param>
        /// <param name="phi">Orientation of the first half axis in radians.</param>
        /// <param name="radius1">First half axis.</param>
        /// <param name="radius2">Second half axis.</param>
        public static void DrawEllipse(
          HTuple windowHandle,
          out HTuple row,
          out HTuple column,
          out HTuple phi,
          out HTuple radius1,
          out HTuple radius2)
        {
            IntPtr proc = HalconAPI.PreCall(1333);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out radius1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out radius2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive drawing of a circle.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="rowIn">Row index of the center.</param>
        /// <param name="columnIn">Column index of the center.</param>
        /// <param name="radiusIn">Radius of the circle.</param>
        /// <param name="row">Row index of the center.</param>
        /// <param name="column">Column index of the center.</param>
        /// <param name="radius">Circle's radius.</param>
        public static void DrawCircleMod(
          HTuple windowHandle,
          HTuple rowIn,
          HTuple columnIn,
          HTuple radiusIn,
          out HTuple row,
          out HTuple column,
          out HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(1334);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rowIn);
            HalconAPI.Store(proc, 2, columnIn);
            HalconAPI.Store(proc, 3, radiusIn);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rowIn);
            HalconAPI.UnpinTuple(columnIn);
            HalconAPI.UnpinTuple(radiusIn);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out radius);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive drawing of a circle.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Barycenter's row index.</param>
        /// <param name="column">Barycenter's column index.</param>
        /// <param name="radius">Circle's radius.</param>
        public static void DrawCircle(
          HTuple windowHandle,
          out HTuple row,
          out HTuple column,
          out HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(1335);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out radius);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive drawing of a closed region.</summary>
        /// <param name="region">Interactive created region.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void DrawRegion(out HObject region, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1336);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interactive drawing of a polygon row.</summary>
        /// <param name="polygonRegion">Region, which encompasses all painted points.</param>
        /// <param name="windowHandle">Window handle.</param>
        public static void DrawPolygon(out HObject polygonRegion, HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1337);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out polygonRegion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the projection of a point onto a line.</summary>
        /// <param name="row">Row coordinate of the point.</param>
        /// <param name="column">Column coordinate of the point.</param>
        /// <param name="row1">Row coordinate of the first point on the line.</param>
        /// <param name="column1">Column coordinate of the first point on the line.</param>
        /// <param name="row2">Row coordinate of the second point on the line.</param>
        /// <param name="column2">Column coordinate of the second point on the line.</param>
        /// <param name="rowProj">Row coordinate of the projected point.</param>
        /// <param name="colProj">Column coordinate of the projected point</param>
        public static void ProjectionPl(
          HTuple row,
          HTuple column,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          out HTuple rowProj,
          out HTuple colProj)
        {
            IntPtr proc = HalconAPI.PreCall(1338);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, row1);
            HalconAPI.Store(proc, 3, column1);
            HalconAPI.Store(proc, 4, row2);
            HalconAPI.Store(proc, 5, column2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowProj);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out colProj);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate a point of an ellipse corresponding to a specific angle.</summary>
        /// <param name="angle">Angle corresponding to the resulting point [rad]. Default: 0</param>
        /// <param name="row">Row coordinate of the center of the ellipse.</param>
        /// <param name="column">Column coordinate of the center of the ellipse.</param>
        /// <param name="phi">Orientation of the main axis [rad].</param>
        /// <param name="radius1">Length of the larger half axis.</param>
        /// <param name="radius2">Length of the smaller half axis.</param>
        /// <param name="rowPoint">Row coordinate of the point on the ellipse.</param>
        /// <param name="colPoint">Column coordinates of the point on the ellipse.</param>
        public static void GetPointsEllipse(
          HTuple angle,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple radius1,
          HTuple radius2,
          out HTuple rowPoint,
          out HTuple colPoint)
        {
            IntPtr proc = HalconAPI.PreCall(1339);
            HalconAPI.Store(proc, 0, angle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, phi);
            HalconAPI.Store(proc, 4, radius1);
            HalconAPI.Store(proc, 5, radius2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(angle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(radius1);
            HalconAPI.UnpinTuple(radius2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowPoint);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out colPoint);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the intersection point of two lines.</summary>
        /// <param name="rowA1">Row coordinate of the first point of the first line.</param>
        /// <param name="columnA1">Column coordinate of the first point of the first line.</param>
        /// <param name="rowA2">Row coordinate of the second point of the first line.</param>
        /// <param name="columnA2">Column coordinate of the second point of the first line.</param>
        /// <param name="rowB1">Row coordinate of the first point of the second line.</param>
        /// <param name="columnB1">Column coordinate of the first point of the second line.</param>
        /// <param name="rowB2">Row coordinate of the second point of the second line.</param>
        /// <param name="columnB2">Column coordinate of the second point of the second line.</param>
        /// <param name="row">Row coordinate of the intersection point.</param>
        /// <param name="column">Column coordinate of the intersection point.</param>
        /// <param name="isParallel">Are the two lines parallel?</param>
        public static void IntersectionLl(
          HTuple rowA1,
          HTuple columnA1,
          HTuple rowA2,
          HTuple columnA2,
          HTuple rowB1,
          HTuple columnB1,
          HTuple rowB2,
          HTuple columnB2,
          out HTuple row,
          out HTuple column,
          out HTuple isParallel)
        {
            IntPtr proc = HalconAPI.PreCall(1340);
            HalconAPI.Store(proc, 0, rowA1);
            HalconAPI.Store(proc, 1, columnA1);
            HalconAPI.Store(proc, 2, rowA2);
            HalconAPI.Store(proc, 3, columnA2);
            HalconAPI.Store(proc, 4, rowB1);
            HalconAPI.Store(proc, 5, columnB1);
            HalconAPI.Store(proc, 6, rowB2);
            HalconAPI.Store(proc, 7, columnB2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rowA1);
            HalconAPI.UnpinTuple(columnA1);
            HalconAPI.UnpinTuple(rowA2);
            HalconAPI.UnpinTuple(columnA2);
            HalconAPI.UnpinTuple(rowB1);
            HalconAPI.UnpinTuple(columnB1);
            HalconAPI.UnpinTuple(rowB2);
            HalconAPI.UnpinTuple(columnB2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out isParallel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the intersection points of two XLD contours </summary>
        /// <param name="contour1">First XLD contour.</param>
        /// <param name="contour2">Second XLD contour.</param>
        /// <param name="intersectionType">Intersection points to be returned. Default: "all"</param>
        /// <param name="row">Row coordinates of the intersection points.</param>
        /// <param name="column">Column coordinates of the intersection points.</param>
        /// <param name="isOverlapping">Does a part of a contour lies above another contour part?</param>
        public static void IntersectionContoursXld(
          HObject contour1,
          HObject contour2,
          HTuple intersectionType,
          out HTuple row,
          out HTuple column,
          out HTuple isOverlapping)
        {
            IntPtr proc = HalconAPI.PreCall(1341);
            HalconAPI.Store(proc, 1, (HObjectBase)contour1);
            HalconAPI.Store(proc, 2, (HObjectBase)contour2);
            HalconAPI.Store(proc, 0, intersectionType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(intersectionType);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out isOverlapping);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour1);
            GC.KeepAlive((object)contour2);
        }

        /// <summary>Calculate the intersection points of a circle or circular arc and an XLD contour </summary>
        /// <param name="contour">XLD contour.</param>
        /// <param name="circleRow">Row coordinate of the center of the circle or circular arc.</param>
        /// <param name="circleColumn">Column coordinate of the center of the circle or circular arc.</param>
        /// <param name="circleRadius">Radius of the circle or circular arc.</param>
        /// <param name="circleStartPhi">Angle of the start point of the circle or circular arc [rad]. Default: 0.0</param>
        /// <param name="circleEndPhi">Angle of the end point of the circle or  circular arc [rad]. Default: 6.28318</param>
        /// <param name="circlePointOrder">Point order along the circle or circular arc. Default: "positive"</param>
        /// <param name="row">Row coordinates of the intersection points.</param>
        /// <param name="column">Column coordinates of the intersection points.</param>
        public static void IntersectionCircleContourXld(
          HObject contour,
          HTuple circleRow,
          HTuple circleColumn,
          HTuple circleRadius,
          HTuple circleStartPhi,
          HTuple circleEndPhi,
          HTuple circlePointOrder,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1342);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, circleRow);
            HalconAPI.Store(proc, 1, circleColumn);
            HalconAPI.Store(proc, 2, circleRadius);
            HalconAPI.Store(proc, 3, circleStartPhi);
            HalconAPI.Store(proc, 4, circleEndPhi);
            HalconAPI.Store(proc, 5, circlePointOrder);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(circleRow);
            HalconAPI.UnpinTuple(circleColumn);
            HalconAPI.UnpinTuple(circleRadius);
            HalconAPI.UnpinTuple(circleStartPhi);
            HalconAPI.UnpinTuple(circleEndPhi);
            HalconAPI.UnpinTuple(circlePointOrder);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Calculate the intersection points of two circles or circular arcs </summary>
        /// <param name="circle1Row">Row coordinate of the center of the first circle or circular arc.</param>
        /// <param name="circle1Column">Column coordinate of the center of the first circle or circular arc.</param>
        /// <param name="circle1Radius">Radius of the first circle or circular arc.</param>
        /// <param name="circle1StartPhi">Angle of the start point of the first circle or circular arc [rad]. Default: 0.0</param>
        /// <param name="circle1EndPhi">Angle of the end point of the first circle or  circular arc [rad]. Default: 6.28318</param>
        /// <param name="circle1PointOrder">Point order along the first circle or circular arc. Default: "positive"</param>
        /// <param name="circle2Row">Row coordinate of the center of the second circle or circular arc.</param>
        /// <param name="circle2Column">Column coordinate of the center of the second circle or circular arc.</param>
        /// <param name="circle2Radius">Radius of the second circle or circular arc.</param>
        /// <param name="circle2StartPhi">Angle of the start point of the second circle or circular arc [rad]. Default: 0.0</param>
        /// <param name="circle2EndPhi">Angle of the end point of the second circle or  circular arc [rad]. Default: 6.28318</param>
        /// <param name="circle2PointOrder">Point order along the second circle or circular arc. Default: "positive"</param>
        /// <param name="row">Row coordinates of the intersection points.</param>
        /// <param name="column">Column coordinates of the intersection points.</param>
        /// <param name="isOverlapping">Do both circles or circular arcs have a part in common?</param>
        public static void IntersectionCircles(
          HTuple circle1Row,
          HTuple circle1Column,
          HTuple circle1Radius,
          HTuple circle1StartPhi,
          HTuple circle1EndPhi,
          HTuple circle1PointOrder,
          HTuple circle2Row,
          HTuple circle2Column,
          HTuple circle2Radius,
          HTuple circle2StartPhi,
          HTuple circle2EndPhi,
          HTuple circle2PointOrder,
          out HTuple row,
          out HTuple column,
          out HTuple isOverlapping)
        {
            IntPtr proc = HalconAPI.PreCall(1343);
            HalconAPI.Store(proc, 0, circle1Row);
            HalconAPI.Store(proc, 1, circle1Column);
            HalconAPI.Store(proc, 2, circle1Radius);
            HalconAPI.Store(proc, 3, circle1StartPhi);
            HalconAPI.Store(proc, 4, circle1EndPhi);
            HalconAPI.Store(proc, 5, circle1PointOrder);
            HalconAPI.Store(proc, 6, circle2Row);
            HalconAPI.Store(proc, 7, circle2Column);
            HalconAPI.Store(proc, 8, circle2Radius);
            HalconAPI.Store(proc, 9, circle2StartPhi);
            HalconAPI.Store(proc, 10, circle2EndPhi);
            HalconAPI.Store(proc, 11, circle2PointOrder);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(circle1Row);
            HalconAPI.UnpinTuple(circle1Column);
            HalconAPI.UnpinTuple(circle1Radius);
            HalconAPI.UnpinTuple(circle1StartPhi);
            HalconAPI.UnpinTuple(circle1EndPhi);
            HalconAPI.UnpinTuple(circle1PointOrder);
            HalconAPI.UnpinTuple(circle2Row);
            HalconAPI.UnpinTuple(circle2Column);
            HalconAPI.UnpinTuple(circle2Radius);
            HalconAPI.UnpinTuple(circle2StartPhi);
            HalconAPI.UnpinTuple(circle2EndPhi);
            HalconAPI.UnpinTuple(circle2PointOrder);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out isOverlapping);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the intersection points of a line and an XLD contour </summary>
        /// <param name="contour">XLD contour.</param>
        /// <param name="lineRow1">Row coordinate of the first point of the line.</param>
        /// <param name="lineColumn1">Column coordinate of the first point of the line.</param>
        /// <param name="lineRow2">Row coordinate of the second point of the line.</param>
        /// <param name="lineColumn2">Column coordinate of the second point of the line.</param>
        /// <param name="row">Row coordinates of the intersection points.</param>
        /// <param name="column">Column coordinates of the intersection points.</param>
        /// <param name="isOverlapping">Does a part of the XLD contour lies on the line?</param>
        public static void IntersectionLineContourXld(
          HObject contour,
          HTuple lineRow1,
          HTuple lineColumn1,
          HTuple lineRow2,
          HTuple lineColumn2,
          out HTuple row,
          out HTuple column,
          out HTuple isOverlapping)
        {
            IntPtr proc = HalconAPI.PreCall(1344);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, lineRow1);
            HalconAPI.Store(proc, 1, lineColumn1);
            HalconAPI.Store(proc, 2, lineRow2);
            HalconAPI.Store(proc, 3, lineColumn2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(lineRow1);
            HalconAPI.UnpinTuple(lineColumn1);
            HalconAPI.UnpinTuple(lineRow2);
            HalconAPI.UnpinTuple(lineColumn2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out isOverlapping);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Calculate the intersection points of a line and a circle or circular arc </summary>
        /// <param name="lineRow1">Row coordinate of the first point of the line.</param>
        /// <param name="lineColumn1">Column coordinate of the first point of the line.</param>
        /// <param name="lineRow2">Row coordinate of the second point of the line.</param>
        /// <param name="lineColumn2">Column coordinate of the second point of the line.</param>
        /// <param name="circleRow">Row coordinate of the center of the circle or circular arc.</param>
        /// <param name="circleColumn">Column coordinate of the center of the circle or circular arc.</param>
        /// <param name="circleRadius">Radius of the circle or circular arc.</param>
        /// <param name="circleStartPhi">Angle of the start point of the circle or circular arc [rad]. Default: 0.0</param>
        /// <param name="circleEndPhi">Angle of the end point of the circle or  circular arc [rad]. Default: 6.28318</param>
        /// <param name="circlePointOrder">Point order along the circle or circular arc. Default: "positive"</param>
        /// <param name="row">Row coordinates of the intersection points.</param>
        /// <param name="column">Column coordinates of the intersection points.</param>
        public static void IntersectionLineCircle(
          HTuple lineRow1,
          HTuple lineColumn1,
          HTuple lineRow2,
          HTuple lineColumn2,
          HTuple circleRow,
          HTuple circleColumn,
          HTuple circleRadius,
          HTuple circleStartPhi,
          HTuple circleEndPhi,
          HTuple circlePointOrder,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1345);
            HalconAPI.Store(proc, 0, lineRow1);
            HalconAPI.Store(proc, 1, lineColumn1);
            HalconAPI.Store(proc, 2, lineRow2);
            HalconAPI.Store(proc, 3, lineColumn2);
            HalconAPI.Store(proc, 4, circleRow);
            HalconAPI.Store(proc, 5, circleColumn);
            HalconAPI.Store(proc, 6, circleRadius);
            HalconAPI.Store(proc, 7, circleStartPhi);
            HalconAPI.Store(proc, 8, circleEndPhi);
            HalconAPI.Store(proc, 9, circlePointOrder);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(lineRow1);
            HalconAPI.UnpinTuple(lineColumn1);
            HalconAPI.UnpinTuple(lineRow2);
            HalconAPI.UnpinTuple(lineColumn2);
            HalconAPI.UnpinTuple(circleRow);
            HalconAPI.UnpinTuple(circleColumn);
            HalconAPI.UnpinTuple(circleRadius);
            HalconAPI.UnpinTuple(circleStartPhi);
            HalconAPI.UnpinTuple(circleEndPhi);
            HalconAPI.UnpinTuple(circlePointOrder);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the intersection point of two lines </summary>
        /// <param name="line1Row1">Row coordinate of the first point of the first line.</param>
        /// <param name="line1Column1">Column coordinate of the first point of the first line.</param>
        /// <param name="line1Row2">Row coordinate of the second point of the first line.</param>
        /// <param name="line1Column2">Column coordinate of the second point of the first line.</param>
        /// <param name="line2Row1">Row coordinate of the first point of the second line.</param>
        /// <param name="line2Column1">Column coordinate of the first point of the second line.</param>
        /// <param name="line2Row2">Row coordinate of the second point of the second line.</param>
        /// <param name="line2Column2">Column coordinate of the second point of the second line.</param>
        /// <param name="row">Row coordinate of the intersection point.</param>
        /// <param name="column">Column coordinate of the intersection point.</param>
        /// <param name="isOverlapping">Are both lines identical?</param>
        public static void IntersectionLines(
          HTuple line1Row1,
          HTuple line1Column1,
          HTuple line1Row2,
          HTuple line1Column2,
          HTuple line2Row1,
          HTuple line2Column1,
          HTuple line2Row2,
          HTuple line2Column2,
          out HTuple row,
          out HTuple column,
          out HTuple isOverlapping)
        {
            IntPtr proc = HalconAPI.PreCall(1346);
            HalconAPI.Store(proc, 0, line1Row1);
            HalconAPI.Store(proc, 1, line1Column1);
            HalconAPI.Store(proc, 2, line1Row2);
            HalconAPI.Store(proc, 3, line1Column2);
            HalconAPI.Store(proc, 4, line2Row1);
            HalconAPI.Store(proc, 5, line2Column1);
            HalconAPI.Store(proc, 6, line2Row2);
            HalconAPI.Store(proc, 7, line2Column2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(line1Row1);
            HalconAPI.UnpinTuple(line1Column1);
            HalconAPI.UnpinTuple(line1Row2);
            HalconAPI.UnpinTuple(line1Column2);
            HalconAPI.UnpinTuple(line2Row1);
            HalconAPI.UnpinTuple(line2Column1);
            HalconAPI.UnpinTuple(line2Row2);
            HalconAPI.UnpinTuple(line2Column2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out isOverlapping);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the intersection points of a segment and an XLD contour </summary>
        /// <param name="contour">XLD contour.</param>
        /// <param name="segmentRow1">Row coordinate of the first point of the segment.</param>
        /// <param name="segmentColumn1">Column coordinate of the first point of the segment.</param>
        /// <param name="segmentRow2">Row coordinate of the second point of the segment.</param>
        /// <param name="segmentColumn2">Column coordinate of the second point of the segment.</param>
        /// <param name="row">Row coordinates of the intersection points.</param>
        /// <param name="column">Column coordinates of the intersection points.</param>
        /// <param name="isOverlapping">Do the segment and the XLD contour have a part in common?</param>
        public static void IntersectionSegmentContourXld(
          HObject contour,
          HTuple segmentRow1,
          HTuple segmentColumn1,
          HTuple segmentRow2,
          HTuple segmentColumn2,
          out HTuple row,
          out HTuple column,
          out HTuple isOverlapping)
        {
            IntPtr proc = HalconAPI.PreCall(1347);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, segmentRow1);
            HalconAPI.Store(proc, 1, segmentColumn1);
            HalconAPI.Store(proc, 2, segmentRow2);
            HalconAPI.Store(proc, 3, segmentColumn2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(segmentRow1);
            HalconAPI.UnpinTuple(segmentColumn1);
            HalconAPI.UnpinTuple(segmentRow2);
            HalconAPI.UnpinTuple(segmentColumn2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out isOverlapping);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Calculate the intersection points of a segment and a circle or circular arc </summary>
        /// <param name="segmentRow1">Row coordinate of the first point of the segment.</param>
        /// <param name="segmentColumn1">Column coordinate of the first point of the segment.</param>
        /// <param name="segmentRow2">Row coordinate of the second point of the segment.</param>
        /// <param name="segmentColumn2">Column coordinate of the second point of the segment.</param>
        /// <param name="circleRow">Row coordinate of the center of the circle or circular arc.</param>
        /// <param name="circleColumn">Column coordinate of the center of the circle or circular arc.</param>
        /// <param name="circleRadius">Radius of the circle or circular arc.</param>
        /// <param name="circleStartPhi">Angle of the start point of the circle or circular arc [rad]. Default: 0.0</param>
        /// <param name="circleEndPhi">Angle of the end point of the circle or  circular arc [rad]. Default: 6.28318</param>
        /// <param name="circlePointOrder">Point order along the circle or circular arc. Default: "positive"</param>
        /// <param name="row">Row coordinates of the intersection points.</param>
        /// <param name="column">Column coordinates of the intersection points.</param>
        public static void IntersectionSegmentCircle(
          HTuple segmentRow1,
          HTuple segmentColumn1,
          HTuple segmentRow2,
          HTuple segmentColumn2,
          HTuple circleRow,
          HTuple circleColumn,
          HTuple circleRadius,
          HTuple circleStartPhi,
          HTuple circleEndPhi,
          HTuple circlePointOrder,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1348);
            HalconAPI.Store(proc, 0, segmentRow1);
            HalconAPI.Store(proc, 1, segmentColumn1);
            HalconAPI.Store(proc, 2, segmentRow2);
            HalconAPI.Store(proc, 3, segmentColumn2);
            HalconAPI.Store(proc, 4, circleRow);
            HalconAPI.Store(proc, 5, circleColumn);
            HalconAPI.Store(proc, 6, circleRadius);
            HalconAPI.Store(proc, 7, circleStartPhi);
            HalconAPI.Store(proc, 8, circleEndPhi);
            HalconAPI.Store(proc, 9, circlePointOrder);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(segmentRow1);
            HalconAPI.UnpinTuple(segmentColumn1);
            HalconAPI.UnpinTuple(segmentRow2);
            HalconAPI.UnpinTuple(segmentColumn2);
            HalconAPI.UnpinTuple(circleRow);
            HalconAPI.UnpinTuple(circleColumn);
            HalconAPI.UnpinTuple(circleRadius);
            HalconAPI.UnpinTuple(circleStartPhi);
            HalconAPI.UnpinTuple(circleEndPhi);
            HalconAPI.UnpinTuple(circlePointOrder);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the intersection point of a segment and a line </summary>
        /// <param name="segmentRow1">Row coordinate of the first point of the segment.</param>
        /// <param name="segmentColumn1">Column coordinate of the first point of the segment.</param>
        /// <param name="segmentRow2">Row coordinate of the second point of the segment.</param>
        /// <param name="segmentColumn2">Column coordinate of the second point of the segment.</param>
        /// <param name="lineRow1">Row coordinate of the first point of the line.</param>
        /// <param name="lineColumn1">Column coordinate of the first point of the line.</param>
        /// <param name="lineRow2">Row coordinate of the second point of the line.</param>
        /// <param name="lineColumn2">Column coordinate of the second point of the line.</param>
        /// <param name="row">Row coordinate of the intersection point.</param>
        /// <param name="column">Column coordinate of the intersection point.</param>
        /// <param name="isOverlapping">Do the segment and the line have a part in common?</param>
        public static void IntersectionSegmentLine(
          HTuple segmentRow1,
          HTuple segmentColumn1,
          HTuple segmentRow2,
          HTuple segmentColumn2,
          HTuple lineRow1,
          HTuple lineColumn1,
          HTuple lineRow2,
          HTuple lineColumn2,
          out HTuple row,
          out HTuple column,
          out HTuple isOverlapping)
        {
            IntPtr proc = HalconAPI.PreCall(1349);
            HalconAPI.Store(proc, 0, segmentRow1);
            HalconAPI.Store(proc, 1, segmentColumn1);
            HalconAPI.Store(proc, 2, segmentRow2);
            HalconAPI.Store(proc, 3, segmentColumn2);
            HalconAPI.Store(proc, 4, lineRow1);
            HalconAPI.Store(proc, 5, lineColumn1);
            HalconAPI.Store(proc, 6, lineRow2);
            HalconAPI.Store(proc, 7, lineColumn2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(segmentRow1);
            HalconAPI.UnpinTuple(segmentColumn1);
            HalconAPI.UnpinTuple(segmentRow2);
            HalconAPI.UnpinTuple(segmentColumn2);
            HalconAPI.UnpinTuple(lineRow1);
            HalconAPI.UnpinTuple(lineColumn1);
            HalconAPI.UnpinTuple(lineRow2);
            HalconAPI.UnpinTuple(lineColumn2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out isOverlapping);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the intersection point of two line segments </summary>
        /// <param name="segment1Row1">Row coordinate of the first point  of the first segment.</param>
        /// <param name="segment1Column1">Column coordinate of the first point  of the first segment.</param>
        /// <param name="segment1Row2">Row coordinate of the second point  of the first segment.</param>
        /// <param name="segment1Column2">Column coordinate of the second point  of the first segment.</param>
        /// <param name="segment2Row1">Row coordinate of the first point  of the second segment.</param>
        /// <param name="segment2Column1">Column coordinate of the first point  of the second segment.</param>
        /// <param name="segment2Row2">Row coordinate of the second point  of the second segment.</param>
        /// <param name="segment2Column2">Column coordinate of the second point  of the second segment.</param>
        /// <param name="row">Row coordinate of the intersection point.</param>
        /// <param name="column">Column coordinate of the intersection point.</param>
        /// <param name="isOverlapping">Do both segments have a part in common?</param>
        public static void IntersectionSegments(
          HTuple segment1Row1,
          HTuple segment1Column1,
          HTuple segment1Row2,
          HTuple segment1Column2,
          HTuple segment2Row1,
          HTuple segment2Column1,
          HTuple segment2Row2,
          HTuple segment2Column2,
          out HTuple row,
          out HTuple column,
          out HTuple isOverlapping)
        {
            IntPtr proc = HalconAPI.PreCall(1350);
            HalconAPI.Store(proc, 0, segment1Row1);
            HalconAPI.Store(proc, 1, segment1Column1);
            HalconAPI.Store(proc, 2, segment1Row2);
            HalconAPI.Store(proc, 3, segment1Column2);
            HalconAPI.Store(proc, 4, segment2Row1);
            HalconAPI.Store(proc, 5, segment2Column1);
            HalconAPI.Store(proc, 6, segment2Row2);
            HalconAPI.Store(proc, 7, segment2Column2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(segment1Row1);
            HalconAPI.UnpinTuple(segment1Column1);
            HalconAPI.UnpinTuple(segment1Row2);
            HalconAPI.UnpinTuple(segment1Column2);
            HalconAPI.UnpinTuple(segment2Row1);
            HalconAPI.UnpinTuple(segment2Column1);
            HalconAPI.UnpinTuple(segment2Row2);
            HalconAPI.UnpinTuple(segment2Column2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out isOverlapping);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a XLD distance transform.</summary>
        /// <param name="distanceTransformID">Handle of the XLD distance transform.</param>
        public static void ClearDistanceTransformXld(HTuple distanceTransformID)
        {
            IntPtr proc = HalconAPI.PreCall(1351);
            HalconAPI.Store(proc, 0, distanceTransformID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distanceTransformID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Determine the pointwise distance of two contours using an XLD distance transform.</summary>
        /// <param name="contour">Contour(s) for whose points the distances are calculated.</param>
        /// <param name="contourOut">Copy of Contour containing the distances as an attribute.</param>
        /// <param name="distanceTransformID">Handle of the XLD distance transform of the reference contour.</param>
        public static void ApplyDistanceTransformXld(
          HObject contour,
          out HObject contourOut,
          HTuple distanceTransformID)
        {
            IntPtr proc = HalconAPI.PreCall(1352);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, distanceTransformID);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distanceTransformID);
            int procResult = HObject.LoadNew(proc, 1, err, out contourOut);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Read an XLD distance transform from a file.</summary>
        /// <param name="fileName">Name of the file.</param>
        /// <param name="distanceTransformID">Handle of the XLD distance transform.</param>
        public static void ReadDistanceTransformXld(HTuple fileName, out HTuple distanceTransformID)
        {
            IntPtr proc = HalconAPI.PreCall(1353);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out distanceTransformID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize an XLD distance transform.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized XLD distance  transform.</param>
        /// <param name="distanceTransformID">Handle of the deserialized XLD distance  transform.</param>
        public static void DeserializeDistanceTransformXld(
          HTuple serializedItemHandle,
          out HTuple distanceTransformID)
        {
            IntPtr proc = HalconAPI.PreCall(1354);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out distanceTransformID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize an XLD distance transform.</summary>
        /// <param name="distanceTransformID">Handle of the XLD distance transform.</param>
        /// <param name="serializedItemHandle">Handle of the serialized XLD distance  transform.</param>
        public static void SerializeDistanceTransformXld(
          HTuple distanceTransformID,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1355);
            HalconAPI.Store(proc, 0, distanceTransformID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distanceTransformID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write an XLD distance transform into a file.</summary>
        /// <param name="distanceTransformID">Handle of the XLD distance transform.</param>
        /// <param name="fileName">Name of the file.</param>
        public static void WriteDistanceTransformXld(HTuple distanceTransformID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1356);
            HalconAPI.Store(proc, 0, distanceTransformID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distanceTransformID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set new parameters for an XLD distance transform.</summary>
        /// <param name="distanceTransformID">Handle of the XLD distance transform.</param>
        /// <param name="genParamName">Names of the generic parameters. Default: "mode"</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: "point_to_point"</param>
        public static void SetDistanceTransformXldParam(
          HTuple distanceTransformID,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1357);
            HalconAPI.Store(proc, 0, distanceTransformID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distanceTransformID);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the parameters used to build an XLD distance transform.</summary>
        /// <param name="distanceTransformID">Handle of the XLD distance transform.</param>
        /// <param name="genParamName">Names of the generic parameters. Default: "mode"</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        public static void GetDistanceTransformXldParam(
          HTuple distanceTransformID,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1358);
            HalconAPI.Store(proc, 0, distanceTransformID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distanceTransformID);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the reference contour used to build the XLD distance transform.</summary>
        /// <param name="contour">Reference contour.</param>
        /// <param name="distanceTransformID">Handle of the XLD distance transform.</param>
        public static void GetDistanceTransformXldContour(
          out HObject contour,
          HTuple distanceTransformID)
        {
            IntPtr proc = HalconAPI.PreCall(1359);
            HalconAPI.Store(proc, 0, distanceTransformID);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distanceTransformID);
            int procResult = HObject.LoadNew(proc, 1, err, out contour);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create the XLD distance transform.</summary>
        /// <param name="contour">Reference contour(s).</param>
        /// <param name="mode">Compute the distance to points ('point_to_point') or entire segments ('point_to_segment'). Default: "point_to_point"</param>
        /// <param name="maxDistance">Maximum distance of interest. Default: 20.0</param>
        /// <param name="distanceTransformID">Handle of the XLD distance transform.</param>
        public static void CreateDistanceTransformXld(
          HObject contour,
          HTuple mode,
          HTuple maxDistance,
          out HTuple distanceTransformID)
        {
            IntPtr proc = HalconAPI.PreCall(1360);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, maxDistance);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(maxDistance);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out distanceTransformID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Calculate the pointwise distance from one contour to another.</summary>
        /// <param name="contourFrom">Contours for whose points the distances are calculated.</param>
        /// <param name="contourTo">Contours to which the distances are calculated to.</param>
        /// <param name="contourOut">Copy of ContourFrom containing the distances as an attribute.</param>
        /// <param name="mode">Compute the distance to points ('point_to_point') or to entire segments ('point_to_segment'). Default: "point_to_point"</param>
        public static void DistanceContoursXld(
          HObject contourFrom,
          HObject contourTo,
          out HObject contourOut,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1361);
            HalconAPI.Store(proc, 1, (HObjectBase)contourFrom);
            HalconAPI.Store(proc, 2, (HObjectBase)contourTo);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out contourOut);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contourFrom);
            GC.KeepAlive((object)contourTo);
        }

        /// <summary>Calculate the minimum distance between two contours.</summary>
        /// <param name="contour1">First input contour.</param>
        /// <param name="contour2">Second input contour.</param>
        /// <param name="mode">Distance calculation mode. Default: "fast_point_to_segment"</param>
        /// <param name="distanceMin">Minimum distance between the two contours.</param>
        public static void DistanceCcMin(
          HObject contour1,
          HObject contour2,
          HTuple mode,
          out HTuple distanceMin)
        {
            IntPtr proc = HalconAPI.PreCall(1362);
            HalconAPI.Store(proc, 1, (HObjectBase)contour1);
            HalconAPI.Store(proc, 2, (HObjectBase)contour2);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out distanceMin);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour1);
            GC.KeepAlive((object)contour2);
        }

        /// <summary>Calculate the distance between two contours.</summary>
        /// <param name="contour1">First input contour.</param>
        /// <param name="contour2">Second input contour.</param>
        /// <param name="mode">Distance calculation mode. Default: "point_to_point"</param>
        /// <param name="distanceMin">Minimum distance between both contours.</param>
        /// <param name="distanceMax">Maximum distance between both contours.</param>
        public static void DistanceCc(
          HObject contour1,
          HObject contour2,
          HTuple mode,
          out HTuple distanceMin,
          out HTuple distanceMax)
        {
            IntPtr proc = HalconAPI.PreCall(1363);
            HalconAPI.Store(proc, 1, (HObjectBase)contour1);
            HalconAPI.Store(proc, 2, (HObjectBase)contour2);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distanceMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out distanceMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour1);
            GC.KeepAlive((object)contour2);
        }

        /// <summary>Calculate the distance between a line segment and one contour.</summary>
        /// <param name="contour">Input contour.</param>
        /// <param name="row1">Row coordinate of the first point of the line segment.</param>
        /// <param name="column1">Column coordinate of the first point of the line segment.</param>
        /// <param name="row2">Row coordinate of the second point of the line segment.</param>
        /// <param name="column2">Column coordinate of the second point of the line segment.</param>
        /// <param name="distanceMin">Minimum distance between the line segment and the contour.</param>
        /// <param name="distanceMax">Maximum distance between the line segment and the contour.</param>
        public static void DistanceSc(
          HObject contour,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          out HTuple distanceMin,
          out HTuple distanceMax)
        {
            IntPtr proc = HalconAPI.PreCall(1364);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distanceMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out distanceMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Calculate the distance between a line and one contour.</summary>
        /// <param name="contour">Input contour.</param>
        /// <param name="row1">Row coordinate of the first point of the line.</param>
        /// <param name="column1">Column coordinate of the first point of the line.</param>
        /// <param name="row2">Row coordinate of the second point of the line.</param>
        /// <param name="column2">Column coordinate of the second point of the line.</param>
        /// <param name="distanceMin">Minimum distance between the line and the contour.</param>
        /// <param name="distanceMax">Maximum distance between the line and the contour.</param>
        public static void DistanceLc(
          HObject contour,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          out HTuple distanceMin,
          out HTuple distanceMax)
        {
            IntPtr proc = HalconAPI.PreCall(1365);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distanceMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out distanceMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Calculate the distance between a point and one contour.</summary>
        /// <param name="contour">Input contour.</param>
        /// <param name="row">Row coordinate of the point.</param>
        /// <param name="column">Column coordinate of the point.</param>
        /// <param name="distanceMin">Minimum distance between the point and the contour.</param>
        /// <param name="distanceMax">Maximum distance between the point and the contour.</param>
        public static void DistancePc(
          HObject contour,
          HTuple row,
          HTuple column,
          out HTuple distanceMin,
          out HTuple distanceMax)
        {
            IntPtr proc = HalconAPI.PreCall(1366);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distanceMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out distanceMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Calculate the distance between a line segment and one region.</summary>
        /// <param name="region">Input region.</param>
        /// <param name="row1">Row coordinate of the first point of the line segment.</param>
        /// <param name="column1">Column coordinate of the first point of the line segment.</param>
        /// <param name="row2">Row coordinate of the second point of the line segment.</param>
        /// <param name="column2">Column coordinate of the second point of the line segment.</param>
        /// <param name="distanceMin">Minimum distance between the line segment and the region.</param>
        /// <param name="distanceMax">Maximum distance between the line segment and the region.</param>
        public static void DistanceSr(
          HObject region,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          out HTuple distanceMin,
          out HTuple distanceMax)
        {
            IntPtr proc = HalconAPI.PreCall(1367);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distanceMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out distanceMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Calculate the distance between a line and a region.</summary>
        /// <param name="region">Input region.</param>
        /// <param name="row1">Row coordinate of the first point of the line.</param>
        /// <param name="column1">Column coordinate of the first point of the line.</param>
        /// <param name="row2">Row coordinate of the second point of the line.</param>
        /// <param name="column2">Column coordinate of the second point of the line.</param>
        /// <param name="distanceMin">Minimum distance between the line and the region</param>
        /// <param name="distanceMax">Maximum distance between the line and the region</param>
        public static void DistanceLr(
          HObject region,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          out HTuple distanceMin,
          out HTuple distanceMax)
        {
            IntPtr proc = HalconAPI.PreCall(1368);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distanceMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out distanceMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Calculate the distance between a point and a region.</summary>
        /// <param name="region">Input region.</param>
        /// <param name="row">Row coordinate of the point.</param>
        /// <param name="column">Column coordinate of the point.</param>
        /// <param name="distanceMin">Minimum distance between the point and the region.</param>
        /// <param name="distanceMax">Maximum distance between the point and the region.</param>
        public static void DistancePr(
          HObject region,
          HTuple row,
          HTuple column,
          out HTuple distanceMin,
          out HTuple distanceMax)
        {
            IntPtr proc = HalconAPI.PreCall(1369);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distanceMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out distanceMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Calculate the angle between one line and the horizontal axis.</summary>
        /// <param name="row1">Row coordinate the first point of the line.</param>
        /// <param name="column1">Column coordinate of the first point of the line.</param>
        /// <param name="row2">Row coordinate of the second point of the line.</param>
        /// <param name="column2">Column coordinate of the second point of the line.</param>
        /// <param name="angle">Angle between the line and the horizontal axis [rad].</param>
        public static void AngleLx(
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          out HTuple angle)
        {
            IntPtr proc = HalconAPI.PreCall(1370);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out angle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the angle between two lines.</summary>
        /// <param name="rowA1">Row coordinate of the first point of the first line.</param>
        /// <param name="columnA1">Column coordinate of the first point of the first line.</param>
        /// <param name="rowA2">Row coordinate of the second point of the first line.</param>
        /// <param name="columnA2">Column coordinate of the second point of the first line.</param>
        /// <param name="rowB1">Row coordinate of the first point of the second line.</param>
        /// <param name="columnB1">Column coordinate of the first point of the second line.</param>
        /// <param name="rowB2">Row coordinate of the second point of the second line.</param>
        /// <param name="columnB2">Column coordinate of the second point of the second line.</param>
        /// <param name="angle">Angle between the lines [rad].</param>
        public static void AngleLl(
          HTuple rowA1,
          HTuple columnA1,
          HTuple rowA2,
          HTuple columnA2,
          HTuple rowB1,
          HTuple columnB1,
          HTuple rowB2,
          HTuple columnB2,
          out HTuple angle)
        {
            IntPtr proc = HalconAPI.PreCall(1371);
            HalconAPI.Store(proc, 0, rowA1);
            HalconAPI.Store(proc, 1, columnA1);
            HalconAPI.Store(proc, 2, rowA2);
            HalconAPI.Store(proc, 3, columnA2);
            HalconAPI.Store(proc, 4, rowB1);
            HalconAPI.Store(proc, 5, columnB1);
            HalconAPI.Store(proc, 6, rowB2);
            HalconAPI.Store(proc, 7, columnB2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rowA1);
            HalconAPI.UnpinTuple(columnA1);
            HalconAPI.UnpinTuple(rowA2);
            HalconAPI.UnpinTuple(columnA2);
            HalconAPI.UnpinTuple(rowB1);
            HalconAPI.UnpinTuple(columnB1);
            HalconAPI.UnpinTuple(rowB2);
            HalconAPI.UnpinTuple(columnB2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out angle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the distances between a line segment and a line.</summary>
        /// <param name="rowA1">Row coordinate of the first point of the line segment.</param>
        /// <param name="columnA1">Column coordinate of the first point of the line segment.</param>
        /// <param name="rowA2">Row coordinate of the second point of the line segment.</param>
        /// <param name="columnA2">Column coordinate of the second point of the line segment.</param>
        /// <param name="rowB1">Row coordinate of the first point of the line.</param>
        /// <param name="columnB1">Column coordinate of the first point of the line.</param>
        /// <param name="rowB2">Row coordinate of the second point of the line.</param>
        /// <param name="columnB2">Column coordinate of the second point of the line.</param>
        /// <param name="distanceMin">Minimum distance between the line segment and the line.</param>
        /// <param name="distanceMax">Maximum distance between the line segment and the line.</param>
        public static void DistanceSl(
          HTuple rowA1,
          HTuple columnA1,
          HTuple rowA2,
          HTuple columnA2,
          HTuple rowB1,
          HTuple columnB1,
          HTuple rowB2,
          HTuple columnB2,
          out HTuple distanceMin,
          out HTuple distanceMax)
        {
            IntPtr proc = HalconAPI.PreCall(1372);
            HalconAPI.Store(proc, 0, rowA1);
            HalconAPI.Store(proc, 1, columnA1);
            HalconAPI.Store(proc, 2, rowA2);
            HalconAPI.Store(proc, 3, columnA2);
            HalconAPI.Store(proc, 4, rowB1);
            HalconAPI.Store(proc, 5, columnB1);
            HalconAPI.Store(proc, 6, rowB2);
            HalconAPI.Store(proc, 7, columnB2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rowA1);
            HalconAPI.UnpinTuple(columnA1);
            HalconAPI.UnpinTuple(rowA2);
            HalconAPI.UnpinTuple(columnA2);
            HalconAPI.UnpinTuple(rowB1);
            HalconAPI.UnpinTuple(columnB1);
            HalconAPI.UnpinTuple(rowB2);
            HalconAPI.UnpinTuple(columnB2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distanceMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out distanceMax);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the distances between two line segments.</summary>
        /// <param name="rowA1">Row coordinate of the first point of the line segment.</param>
        /// <param name="columnA1">Column coordinate of the first point of the line segment.</param>
        /// <param name="rowA2">Row coordinate of the second point of the line segment.</param>
        /// <param name="columnA2">Column coordinate of the second point of the line segment.</param>
        /// <param name="rowB1">Row coordinate of the first point of the line.</param>
        /// <param name="columnB1">Column of the first point of the line.</param>
        /// <param name="rowB2">Row coordinate of the second point of the line.</param>
        /// <param name="columnB2">Column coordinate of the second point of the line.</param>
        /// <param name="distanceMin">Minimum distance between the line segments.</param>
        /// <param name="distanceMax">Maximum distance between the line segments.</param>
        public static void DistanceSs(
          HTuple rowA1,
          HTuple columnA1,
          HTuple rowA2,
          HTuple columnA2,
          HTuple rowB1,
          HTuple columnB1,
          HTuple rowB2,
          HTuple columnB2,
          out HTuple distanceMin,
          out HTuple distanceMax)
        {
            IntPtr proc = HalconAPI.PreCall(1373);
            HalconAPI.Store(proc, 0, rowA1);
            HalconAPI.Store(proc, 1, columnA1);
            HalconAPI.Store(proc, 2, rowA2);
            HalconAPI.Store(proc, 3, columnA2);
            HalconAPI.Store(proc, 4, rowB1);
            HalconAPI.Store(proc, 5, columnB1);
            HalconAPI.Store(proc, 6, rowB2);
            HalconAPI.Store(proc, 7, columnB2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rowA1);
            HalconAPI.UnpinTuple(columnA1);
            HalconAPI.UnpinTuple(rowA2);
            HalconAPI.UnpinTuple(columnA2);
            HalconAPI.UnpinTuple(rowB1);
            HalconAPI.UnpinTuple(columnB1);
            HalconAPI.UnpinTuple(rowB2);
            HalconAPI.UnpinTuple(columnB2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distanceMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out distanceMax);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the distances between a point and a line segment.</summary>
        /// <param name="row">Row coordinate of the first point.</param>
        /// <param name="column">Column coordinate of the first point.</param>
        /// <param name="row1">Row coordinate of the first point of the line segment.</param>
        /// <param name="column1">Column coordinate of the first point of the line segment.</param>
        /// <param name="row2">Row coordinate of the second point of the line segment.</param>
        /// <param name="column2">Column coordinate of the second point of the line segment.</param>
        /// <param name="distanceMin">Minimum distance between the point and the line segment.</param>
        /// <param name="distanceMax">Maximum distance between the point and the line segment.</param>
        public static void DistancePs(
          HTuple row,
          HTuple column,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          out HTuple distanceMin,
          out HTuple distanceMax)
        {
            IntPtr proc = HalconAPI.PreCall(1374);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, row1);
            HalconAPI.Store(proc, 3, column1);
            HalconAPI.Store(proc, 4, row2);
            HalconAPI.Store(proc, 5, column2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distanceMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out distanceMax);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the distance between one point and one line.</summary>
        /// <param name="row">Row coordinate of the point.</param>
        /// <param name="column">Column of the point.</param>
        /// <param name="row1">Row coordinate of the first point of the line.</param>
        /// <param name="column1">Column coordinate of the first point of the line.</param>
        /// <param name="row2">Row coordinate of the second point of the line.</param>
        /// <param name="column2">Column coordinate of the second point of the line.</param>
        /// <param name="distance">Distance between the points.</param>
        public static void DistancePl(
          HTuple row,
          HTuple column,
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          out HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(1375);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, row1);
            HalconAPI.Store(proc, 3, column1);
            HalconAPI.Store(proc, 4, row2);
            HalconAPI.Store(proc, 5, column2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out distance);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the distance between two points.</summary>
        /// <param name="row1">Row coordinate of the first point.</param>
        /// <param name="column1">Column coordinate of the first point.</param>
        /// <param name="row2">Row coordinate of the second point.</param>
        /// <param name="column2">Column coordinate of the second point.</param>
        /// <param name="distance">Distance between the points.</param>
        public static void DistancePp(
          HTuple row1,
          HTuple column1,
          HTuple row2,
          HTuple column2,
          out HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(1376);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out distance);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compose two functions.</summary>
        /// <param name="function1">Input function 1.</param>
        /// <param name="function2">Input function 2.</param>
        /// <param name="border">Border treatment for the input functions. Default: "constant"</param>
        /// <param name="composedFunction">Composed function.</param>
        public static void ComposeFunct1d(
          HTuple function1,
          HTuple function2,
          HTuple border,
          out HTuple composedFunction)
        {
            IntPtr proc = HalconAPI.PreCall(1377);
            HalconAPI.Store(proc, 0, function1);
            HalconAPI.Store(proc, 1, function2);
            HalconAPI.Store(proc, 2, border);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function1);
            HalconAPI.UnpinTuple(function2);
            HalconAPI.UnpinTuple(border);
            int procResult = HTuple.LoadNew(proc, 0, err, out composedFunction);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the inverse of a function.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="inverseFunction">Inverse of the input function.</param>
        public static void InvertFunct1d(HTuple function, out HTuple inverseFunction)
        {
            IntPtr proc = HalconAPI.PreCall(1378);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            int procResult = HTuple.LoadNew(proc, 0, err, out inverseFunction);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the derivatives of a function.</summary>
        /// <param name="function">Input function</param>
        /// <param name="mode">Type of derivative Default: "first"</param>
        /// <param name="derivative">Derivative of the input function</param>
        public static void DerivateFunct1d(HTuple function, HTuple mode, out HTuple derivative)
        {
            IntPtr proc = HalconAPI.PreCall(1379);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.Store(proc, 1, mode);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            HalconAPI.UnpinTuple(mode);
            int procResult = HTuple.LoadNew(proc, 0, err, out derivative);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the local minimum and maximum points of a function.</summary>
        /// <param name="function">Input function</param>
        /// <param name="mode">Handling of plateaus Default: "strict_min_max"</param>
        /// <param name="interpolation">Interpolation of the input function Default: "true"</param>
        /// <param name="min">Minimum points of the input function</param>
        /// <param name="max">Maximum points of the input function</param>
        public static void LocalMinMaxFunct1d(
          HTuple function,
          HTuple mode,
          HTuple interpolation,
          out HTuple min,
          out HTuple max)
        {
            IntPtr proc = HalconAPI.PreCall(1380);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.Store(proc, 1, mode);
            HalconAPI.Store(proc, 2, interpolation);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(interpolation);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out min);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out max);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the zero crossings of a function.</summary>
        /// <param name="function">Input function</param>
        /// <param name="zeroCrossings">Zero crossings of the input function</param>
        public static void ZeroCrossingsFunct1d(HTuple function, out HTuple zeroCrossings)
        {
            IntPtr proc = HalconAPI.PreCall(1381);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out zeroCrossings);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Multiplication and addition of the y values.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="mult">Factor for scaling of the y values. Default: 2.0</param>
        /// <param name="add">Constant which is added to the y values. Default: 0.0</param>
        /// <param name="functionScaled">Transformed function.</param>
        public static void ScaleYFunct1d(
          HTuple function,
          HTuple mult,
          HTuple add,
          out HTuple functionScaled)
        {
            IntPtr proc = HalconAPI.PreCall(1382);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.Store(proc, 1, mult);
            HalconAPI.Store(proc, 2, add);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            HalconAPI.UnpinTuple(mult);
            HalconAPI.UnpinTuple(add);
            int procResult = HTuple.LoadNew(proc, 0, err, out functionScaled);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Negation of the y values.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="functionInverted">Function with the negated y values.</param>
        public static void NegateFunct1d(HTuple function, out HTuple functionInverted)
        {
            IntPtr proc = HalconAPI.PreCall(1383);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            int procResult = HTuple.LoadNew(proc, 0, err, out functionInverted);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Absolute value of the y values.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="functionAbsolute">Function with the absolute values of the y values.</param>
        public static void AbsFunct1d(HTuple function, out HTuple functionAbsolute)
        {
            IntPtr proc = HalconAPI.PreCall(1384);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            int procResult = HTuple.LoadNew(proc, 0, err, out functionAbsolute);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the value of a function at an arbitrary position.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="x">X coordinate at which the function should be evaluated.</param>
        /// <param name="border">Border treatment for the input function. Default: "constant"</param>
        /// <param name="y">Y value at the given x value.</param>
        public static void GetYValueFunct1d(HTuple function, HTuple x, HTuple border, out HTuple y)
        {
            IntPtr proc = HalconAPI.PreCall(1385);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.Store(proc, 1, x);
            HalconAPI.Store(proc, 2, border);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            HalconAPI.UnpinTuple(x);
            HalconAPI.UnpinTuple(border);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out y);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Access a function value using the index of the control points.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="index">Index of the control points.</param>
        /// <param name="x">X value at the given control points.</param>
        /// <param name="y">Y value at the given control points.</param>
        public static void GetPairFunct1d(HTuple function, HTuple index, out HTuple x, out HTuple y)
        {
            IntPtr proc = HalconAPI.PreCall(1386);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            HalconAPI.UnpinTuple(index);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out x);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out y);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Number of control points of the function.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="length">Number of control points.</param>
        public static void NumPointsFunct1d(HTuple function, out HTuple length)
        {
            IntPtr proc = HalconAPI.PreCall(1387);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out length);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Smallest and largest y value of the function.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="YMin">Smallest y value.</param>
        /// <param name="YMax">Largest y value.</param>
        public static void YRangeFunct1d(HTuple function, out HTuple YMin, out HTuple YMax)
        {
            IntPtr proc = HalconAPI.PreCall(1388);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out YMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out YMax);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Smallest and largest x value of the function.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="XMin">Smallest x value.</param>
        /// <param name="XMax">Largest x value.</param>
        public static void XRangeFunct1d(HTuple function, out HTuple XMin, out HTuple XMax)
        {
            IntPtr proc = HalconAPI.PreCall(1389);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out XMin);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out XMax);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Access to the x/y values of a function.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="XValues">X values of the function.</param>
        /// <param name="YValues">Y values of the function.</param>
        public static void Funct1dToPairs(HTuple function, out HTuple XValues, out HTuple YValues)
        {
            IntPtr proc = HalconAPI.PreCall(1390);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            int err2 = HTuple.LoadNew(proc, 0, err1, out XValues);
            int procResult = HTuple.LoadNew(proc, 1, err2, out YValues);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Sample a function equidistantly in an interval.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="XMin">Minimum x value of the output function.</param>
        /// <param name="XMax">Maximum x value of the output function.</param>
        /// <param name="XDist">Distance of the samples.</param>
        /// <param name="border">Border treatment for the input function. Default: "constant"</param>
        /// <param name="sampledFunction">Sampled function.</param>
        public static void SampleFunct1d(
          HTuple function,
          HTuple XMin,
          HTuple XMax,
          HTuple XDist,
          HTuple border,
          out HTuple sampledFunction)
        {
            IntPtr proc = HalconAPI.PreCall(1391);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.Store(proc, 1, XMin);
            HalconAPI.Store(proc, 2, XMax);
            HalconAPI.Store(proc, 3, XDist);
            HalconAPI.Store(proc, 4, border);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            HalconAPI.UnpinTuple(XMin);
            HalconAPI.UnpinTuple(XMax);
            HalconAPI.UnpinTuple(XDist);
            HalconAPI.UnpinTuple(border);
            int procResult = HTuple.LoadNew(proc, 0, err, out sampledFunction);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transform a function using given transformation parameters.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="paramsVal">Transformation parameters between the functions.</param>
        /// <param name="transformedFunction">Transformed function.</param>
        public static void TransformFunct1d(
          HTuple function,
          HTuple paramsVal,
          out HTuple transformedFunction)
        {
            IntPtr proc = HalconAPI.PreCall(1392);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.Store(proc, 1, paramsVal);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            HalconAPI.UnpinTuple(paramsVal);
            int procResult = HTuple.LoadNew(proc, 0, err, out transformedFunction);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate transformation parameters between two functions.</summary>
        /// <param name="function1">Function 1.</param>
        /// <param name="function2">Function 2.</param>
        /// <param name="border">Border treatment for function 2. Default: "constant"</param>
        /// <param name="paramsConst">Values of the parameters to remain constant. Default: [1.0,0.0,1.0,0.0]</param>
        /// <param name="useParams">Should a parameter be adapted for it? Default: ["true","true","true","true"]</param>
        /// <param name="paramsVal">Transformation parameters between the functions.</param>
        /// <param name="chiSquare">Quadratic error of the output function.</param>
        /// <param name="covar">Covariance Matrix of the transformation parameters.</param>
        public static void MatchFunct1dTrans(
          HTuple function1,
          HTuple function2,
          HTuple border,
          HTuple paramsConst,
          HTuple useParams,
          out HTuple paramsVal,
          out HTuple chiSquare,
          out HTuple covar)
        {
            IntPtr proc = HalconAPI.PreCall(1393);
            HalconAPI.Store(proc, 0, function1);
            HalconAPI.Store(proc, 1, function2);
            HalconAPI.Store(proc, 2, border);
            HalconAPI.Store(proc, 3, paramsConst);
            HalconAPI.Store(proc, 4, useParams);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function1);
            HalconAPI.UnpinTuple(function2);
            HalconAPI.UnpinTuple(border);
            HalconAPI.UnpinTuple(paramsConst);
            HalconAPI.UnpinTuple(useParams);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out paramsVal);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out chiSquare);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out covar);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the distance of two functions.</summary>
        /// <param name="function1">Input function 1.</param>
        /// <param name="function2">Input function 2.</param>
        /// <param name="mode">Modes of invariants. Default: "length"</param>
        /// <param name="sigma">Variance of the optional smoothing with a Gaussian filter. Default: 0.0</param>
        /// <param name="distance">Distance of the functions.</param>
        public static void DistanceFunct1d(
          HTuple function1,
          HTuple function2,
          HTuple mode,
          HTuple sigma,
          out HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(1394);
            HalconAPI.Store(proc, 0, function1);
            HalconAPI.Store(proc, 1, function2);
            HalconAPI.Store(proc, 2, mode);
            HalconAPI.Store(proc, 3, sigma);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function1);
            HalconAPI.UnpinTuple(function2);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(sigma);
            int procResult = HTuple.LoadNew(proc, 0, err, out distance);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Smooth an equidistant 1D function with a Gaussian function.</summary>
        /// <param name="function">Function to be smoothed.</param>
        /// <param name="sigma">Sigma of the Gaussian function for the smoothing. Default: 2.0</param>
        /// <param name="smoothedFunction">Smoothed function.</param>
        public static void SmoothFunct1dGauss(
          HTuple function,
          HTuple sigma,
          out HTuple smoothedFunction)
        {
            IntPtr proc = HalconAPI.PreCall(1395);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            HalconAPI.UnpinTuple(sigma);
            int procResult = HTuple.LoadNew(proc, 0, err, out smoothedFunction);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the positive and negative areas of a function.</summary>
        /// <param name="function">Input function.</param>
        /// <param name="positive">Area under the positive part of the function.</param>
        /// <param name="negative">Area under the negative part of the function.</param>
        public static void IntegrateFunct1d(HTuple function, out HTuple positive, out HTuple negative)
        {
            IntPtr proc = HalconAPI.PreCall(1396);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out positive);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out negative);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a function from a file.</summary>
        /// <param name="fileName">Name of the file to be read.</param>
        /// <param name="function">Function from the file.</param>
        public static void ReadFunct1d(HTuple fileName, out HTuple function)
        {
            IntPtr proc = HalconAPI.PreCall(1397);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, err, out function);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a function to a file.</summary>
        /// <param name="function">Function to be written.</param>
        /// <param name="fileName">Name of the file to be written.</param>
        public static void WriteFunct1d(HTuple function, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1398);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a function from a sequence of y-values.</summary>
        /// <param name="YValues">X value for function points.</param>
        /// <param name="function">Created function.</param>
        public static void CreateFunct1dArray(HTuple YValues, out HTuple function)
        {
            IntPtr proc = HalconAPI.PreCall(1399);
            HalconAPI.Store(proc, 0, YValues);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(YValues);
            int procResult = HTuple.LoadNew(proc, 0, err, out function);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a function from a set of (x,y) pairs.</summary>
        /// <param name="XValues">X value for function points.</param>
        /// <param name="YValues">Y-value for function points.</param>
        /// <param name="function">Created function.</param>
        public static void CreateFunct1dPairs(HTuple XValues, HTuple YValues, out HTuple function)
        {
            IntPtr proc = HalconAPI.PreCall(1400);
            HalconAPI.Store(proc, 0, XValues);
            HalconAPI.Store(proc, 1, YValues);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(XValues);
            HalconAPI.UnpinTuple(YValues);
            int procResult = HTuple.LoadNew(proc, 0, err, out function);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Smooth an equidistant 1D function by averaging its values.</summary>
        /// <param name="function">1D function.</param>
        /// <param name="smoothSize">Size of the averaging mask. Default: 9</param>
        /// <param name="iterations">Number of iterations for the smoothing. Default: 3</param>
        /// <param name="smoothedFunction">Smoothed function.</param>
        public static void SmoothFunct1dMean(
          HTuple function,
          HTuple smoothSize,
          HTuple iterations,
          out HTuple smoothedFunction)
        {
            IntPtr proc = HalconAPI.PreCall(1401);
            HalconAPI.Store(proc, 0, function);
            HalconAPI.Store(proc, 1, smoothSize);
            HalconAPI.Store(proc, 2, iterations);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(function);
            HalconAPI.UnpinTuple(smoothSize);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HTuple.LoadNew(proc, 0, err, out smoothedFunction);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Filter an image using a Laws texture filter.</summary>
        /// <param name="image">Images to which the texture transformation is to be applied.</param>
        /// <param name="imageTexture">Texture images.</param>
        /// <param name="filterTypes">Desired filter. Default: "el"</param>
        /// <param name="shift">Shift to reduce the gray value dynamics. Default: 2</param>
        /// <param name="filterSize">Size of the filter kernel. Default: 5</param>
        public static void TextureLaws(
          HObject image,
          out HObject imageTexture,
          HTuple filterTypes,
          HTuple shift,
          HTuple filterSize)
        {
            IntPtr proc = HalconAPI.PreCall(1402);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filterTypes);
            HalconAPI.Store(proc, 1, shift);
            HalconAPI.Store(proc, 2, filterSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filterTypes);
            HalconAPI.UnpinTuple(shift);
            HalconAPI.UnpinTuple(filterSize);
            int procResult = HObject.LoadNew(proc, 1, err, out imageTexture);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the standard deviation of gray values within rectangular windows.</summary>
        /// <param name="image">Image for which the standard deviation is to be calculated.</param>
        /// <param name="imageDeviation">Image containing the standard deviation.</param>
        /// <param name="width">Width of the mask in which the standard deviation is calculated. Default: 11</param>
        /// <param name="height">Height of the mask in which the standard deviation is calculated. Default: 11</param>
        public static void DeviationImage(
          HObject image,
          out HObject imageDeviation,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1403);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageDeviation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the entropy of gray values within a rectangular window.</summary>
        /// <param name="image">Image for which the entropy is to be calculated.</param>
        /// <param name="imageEntropy">Entropy image.</param>
        /// <param name="width">Width of the mask in which the entropy is calculated. Default: 9</param>
        /// <param name="height">Height of the mask in which the entropy is calculated. Default: 9</param>
        public static void EntropyImage(
          HObject image,
          out HObject imageEntropy,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1404);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageEntropy);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Perform an isotropic diffusion of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="smoothedImage">Output image.</param>
        /// <param name="sigma">Standard deviation of the Gauss distribution. Default: 1.0</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        public static void IsotropicDiffusion(
          HObject image,
          out HObject smoothedImage,
          HTuple sigma,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1405);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out smoothedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Perform an anisotropic diffusion of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageAniso">Output image.</param>
        /// <param name="mode">Diffusion coefficient as a function of the edge amplitude. Default: "weickert"</param>
        /// <param name="contrast">Contrast parameter. Default: 5.0</param>
        /// <param name="theta">Time step. Default: 1.0</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        public static void AnisotropicDiffusion(
          HObject image,
          out HObject imageAniso,
          HTuple mode,
          HTuple contrast,
          HTuple theta,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1406);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, contrast);
            HalconAPI.Store(proc, 2, theta);
            HalconAPI.Store(proc, 3, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(theta);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out imageAniso);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Smooth an image using various filters.</summary>
        /// <param name="image">Image to be smoothed.</param>
        /// <param name="imageSmooth">Smoothed image.</param>
        /// <param name="filter">Filter. Default: "deriche2"</param>
        /// <param name="alpha">Filterparameter: small values cause strong smoothing (vice versa by using bei 'gauss'). Default: 0.5</param>
        public static void SmoothImage(
          HObject image,
          out HObject imageSmooth,
          HTuple filter,
          HTuple alpha)
        {
            IntPtr proc = HalconAPI.PreCall(1407);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, alpha);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(alpha);
            int procResult = HObject.LoadNew(proc, 1, err, out imageSmooth);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Non-linear smoothing with the sigma filter.</summary>
        /// <param name="image">Image to be smoothed.</param>
        /// <param name="imageSigma">Smoothed image.</param>
        /// <param name="maskHeight">Height of the mask (number of lines). Default: 5</param>
        /// <param name="maskWidth">Width of the mask (number of columns). Default: 5</param>
        /// <param name="sigma">Max. deviation to the average. Default: 3</param>
        public static void SigmaImage(
          HObject image,
          out HObject imageSigma,
          HTuple maskHeight,
          HTuple maskWidth,
          HTuple sigma)
        {
            IntPtr proc = HalconAPI.PreCall(1408);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.Store(proc, 2, sigma);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(sigma);
            int procResult = HObject.LoadNew(proc, 1, err, out imageSigma);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the average of maximum and minimum inside any mask.</summary>
        /// <param name="image">Image to be filtered.</param>
        /// <param name="mask">Filter mask.</param>
        /// <param name="imageMidrange">Filtered image.</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        public static void MidrangeImage(
          HObject image,
          HObject mask,
          out HObject imageMidrange,
          HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1409);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)mask);
            HalconAPI.Store(proc, 0, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(margin);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMidrange);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)mask);
        }

        /// <summary>Smooth an image with an arbitrary rank mask.</summary>
        /// <param name="image">Image to be filtered.</param>
        /// <param name="mask">Image whose region serves as filter mask.</param>
        /// <param name="imageTMean">Filtered output image.</param>
        /// <param name="number">Number of averaged pixels. Typical value:       Surface(Mask) / 2. Default: 5</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        public static void TrimmedMean(
          HObject image,
          HObject mask,
          out HObject imageTMean,
          HTuple number,
          HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1410);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)mask);
            HalconAPI.Store(proc, 0, number);
            HalconAPI.Store(proc, 1, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(number);
            HalconAPI.UnpinTuple(margin);
            int procResult = HObject.LoadNew(proc, 1, err, out imageTMean);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)mask);
        }

        /// <summary>Separated median filtering with rectangle masks.</summary>
        /// <param name="image">Image to be filtered.</param>
        /// <param name="imageSMedian">Median filtered image.</param>
        /// <param name="maskWidth">Width of rank mask. Default: 25</param>
        /// <param name="maskHeight">Height of rank mask. Default: 25</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        public static void MedianSeparate(
          HObject image,
          out HObject imageSMedian,
          HTuple maskWidth,
          HTuple maskHeight,
          HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1411);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.Store(proc, 2, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(margin);
            int procResult = HObject.LoadNew(proc, 1, err, out imageSMedian);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute a median filter with rectangular masks.</summary>
        /// <param name="image">Image to be filtered.</param>
        /// <param name="imageMedian">Filtered image.</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 15</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 15</param>
        public static void MedianRect(
          HObject image,
          out HObject imageMedian,
          HTuple maskWidth,
          HTuple maskHeight)
        {
            IntPtr proc = HalconAPI.PreCall(1412);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMedian);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute a median filter with various masks.</summary>
        /// <param name="image">Image to be filtered.</param>
        /// <param name="imageMedian">Filtered image.</param>
        /// <param name="maskType">Filter mask type. Default: "circle"</param>
        /// <param name="radius">Radius of the filter mask. Default: 1</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        public static void MedianImage(
          HObject image,
          out HObject imageMedian,
          HTuple maskType,
          HTuple radius,
          HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1413);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskType);
            HalconAPI.Store(proc, 1, radius);
            HalconAPI.Store(proc, 2, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskType);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(margin);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMedian);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Weighted median filtering with different rank masks.</summary>
        /// <param name="image">Image to be filtered.</param>
        /// <param name="imageWMedian">Median filtered image.</param>
        /// <param name="maskType">Type of median mask. Default: "inner"</param>
        /// <param name="maskSize">mask size. Default: 3</param>
        public static void MedianWeighted(
          HObject image,
          out HObject imageWMedian,
          HTuple maskType,
          HTuple maskSize)
        {
            IntPtr proc = HalconAPI.PreCall(1414);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskType);
            HalconAPI.Store(proc, 1, maskSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskType);
            HalconAPI.UnpinTuple(maskSize);
            int procResult = HObject.LoadNew(proc, 1, err, out imageWMedian);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute a rank filter with rectangular masks.</summary>
        /// <param name="image">Image to be filtered.</param>
        /// <param name="imageRank">Filtered image.</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 15</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 15</param>
        /// <param name="rank">Rank of the output gray value. Default: 5</param>
        public static void RankRect(
          HObject image,
          out HObject imageRank,
          HTuple maskWidth,
          HTuple maskHeight,
          HTuple rank)
        {
            IntPtr proc = HalconAPI.PreCall(1415);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.Store(proc, 2, rank);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(rank);
            int procResult = HObject.LoadNew(proc, 1, err, out imageRank);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute a rank filter with arbitrary masks.</summary>
        /// <param name="image">Image to be filtered.</param>
        /// <param name="mask">Filter mask.</param>
        /// <param name="imageRank">Filtered image.</param>
        /// <param name="rank">Rank of the output gray value. Default: 5</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        public static void RankImage(
          HObject image,
          HObject mask,
          out HObject imageRank,
          HTuple rank,
          HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1416);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)mask);
            HalconAPI.Store(proc, 0, rank);
            HalconAPI.Store(proc, 1, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rank);
            HalconAPI.UnpinTuple(margin);
            int procResult = HObject.LoadNew(proc, 1, err, out imageRank);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)mask);
        }

        /// <summary>Opening, Median and Closing with circle or rectangle mask.</summary>
        /// <param name="image">Image to be filtered.</param>
        /// <param name="imageRank">Filtered Image.</param>
        /// <param name="maskType">Shape of the mask. Default: "circle"</param>
        /// <param name="radius">Radius of the filter mask. Default: 1</param>
        /// <param name="modePercent">Filter Mode: 0 corresponds to a gray value opening , 50 corresponds to a median and 100 to a gray values closing. Default: 10</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        public static void DualRank(
          HObject image,
          out HObject imageRank,
          HTuple maskType,
          HTuple radius,
          HTuple modePercent,
          HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1417);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskType);
            HalconAPI.Store(proc, 1, radius);
            HalconAPI.Store(proc, 2, modePercent);
            HalconAPI.Store(proc, 3, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskType);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(modePercent);
            HalconAPI.UnpinTuple(margin);
            int procResult = HObject.LoadNew(proc, 1, err, out imageRank);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Smooth by averaging.</summary>
        /// <param name="image">Image to be smoothed.</param>
        /// <param name="imageMean">Smoothed image.</param>
        /// <param name="maskWidth">Width of filter mask. Default: 9</param>
        /// <param name="maskHeight">Height of filter mask. Default: 9</param>
        public static void MeanImage(
          HObject image,
          out HObject imageMean,
          HTuple maskWidth,
          HTuple maskHeight)
        {
            IntPtr proc = HalconAPI.PreCall(1418);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMean);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Information on smoothing filter smooth_image.</summary>
        /// <param name="filter">Name of required filter. Default: "deriche2"</param>
        /// <param name="alpha">Filter parameter: small values effect strong smoothing (reversed in case of 'gauss'). Default: 0.5</param>
        /// <param name="size">Width of filter is approx. size x size pixels.</param>
        /// <param name="coeffs">In case of gauss filter: coefficients of the "positive" half of the 1D impulse answer.</param>
        public static void InfoSmooth(HTuple filter, HTuple alpha, out HTuple size, out HTuple coeffs)
        {
            IntPtr proc = HalconAPI.PreCall(1419);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, alpha);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(alpha);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out size);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out coeffs);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Smooth an image using the binomial filter.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageBinomial">Smoothed image.</param>
        /// <param name="maskWidth">Filter width. Default: 5</param>
        /// <param name="maskHeight">Filter height. Default: 5</param>
        public static void BinomialFilter(
          HObject image,
          out HObject imageBinomial,
          HTuple maskWidth,
          HTuple maskHeight)
        {
            IntPtr proc = HalconAPI.PreCall(1420);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            int procResult = HObject.LoadNew(proc, 1, err, out imageBinomial);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Smooth an image using discrete Gaussian functions.</summary>
        /// <param name="image">Image to be smoothed.</param>
        /// <param name="imageGauss">Filtered image.</param>
        /// <param name="size">Required filter size. Default: 5</param>
        public static void GaussImage(HObject image, out HObject imageGauss, HTuple size)
        {
            IntPtr proc = HalconAPI.PreCall(1421);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, size);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(size);
            int procResult = HObject.LoadNew(proc, 1, err, out imageGauss);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Smooth using discrete gauss functions.</summary>
        /// <param name="image">Image to be smoothed.</param>
        /// <param name="imageGauss">Filtered image.</param>
        /// <param name="size">Required filter size. Default: 5</param>
        public static void GaussFilter(HObject image, out HObject imageGauss, HTuple size)
        {
            IntPtr proc = HalconAPI.PreCall(1422);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, size);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(size);
            int procResult = HObject.LoadNew(proc, 1, err, out imageGauss);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Smooth an image in the spatial domain to suppress noise.</summary>
        /// <param name="image">Image to smooth.</param>
        /// <param name="filteredImage">Smoothed image.</param>
        /// <param name="maskWidth">Width of filter mask. Default: 3</param>
        /// <param name="maskHeight">Height of filter mask. Default: 3</param>
        /// <param name="gap">Gap between local maximum/minimum and all other gray values of the neighborhood. Default: 1.0</param>
        /// <param name="mode">Replacement rule (1 = next minimum/maximum, 2 = average, 3 =median). Default: 3</param>
        public static void EliminateMinMax(
          HObject image,
          out HObject filteredImage,
          HTuple maskWidth,
          HTuple maskHeight,
          HTuple gap,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1423);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.Store(proc, 2, gap);
            HalconAPI.Store(proc, 3, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(gap);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out filteredImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Interpolate 2 video half images.</summary>
        /// <param name="imageCamera">Gray image consisting of two half images.</param>
        /// <param name="imageFilled">Full image with interpolated/removed lines.</param>
        /// <param name="mode">Instruction whether even or odd lines should be replaced/removed. Default: "odd"</param>
        public static void FillInterlace(HObject imageCamera, out HObject imageFilled, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1424);
            HalconAPI.Store(proc, 1, (HObjectBase)imageCamera);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFilled);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageCamera);
        }

        /// <summary>Return gray values with given rank from multiple channels.</summary>
        /// <param name="image">Multichannel gray image.</param>
        /// <param name="rankImage">Result of the rank function.</param>
        /// <param name="rankIndex">Rank of the gray value images to return. Default: 2</param>
        public static void RankN(HObject image, out HObject rankImage, HTuple rankIndex)
        {
            IntPtr proc = HalconAPI.PreCall(1425);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, rankIndex);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rankIndex);
            int procResult = HObject.LoadNew(proc, 1, err, out rankImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Average gray values over several channels.</summary>
        /// <param name="image">Multichannel gray image.</param>
        /// <param name="imageMean">Result of averaging.</param>
        public static void MeanN(HObject image, out HObject imageMean)
        {
            IntPtr proc = HalconAPI.PreCall(1426);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMean);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Replace values outside of thresholds with average value.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageFillSP">Smoothed image.</param>
        /// <param name="maskWidth">Width of filter mask. Default: 3</param>
        /// <param name="maskHeight">Height of filter mask. Default: 3</param>
        /// <param name="minThresh">Minimum gray value. Default: 1</param>
        /// <param name="maxThresh">Maximum gray value. Default: 254</param>
        public static void EliminateSp(
          HObject image,
          out HObject imageFillSP,
          HTuple maskWidth,
          HTuple maskHeight,
          HTuple minThresh,
          HTuple maxThresh)
        {
            IntPtr proc = HalconAPI.PreCall(1427);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.Store(proc, 2, minThresh);
            HalconAPI.Store(proc, 3, maxThresh);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(minThresh);
            HalconAPI.UnpinTuple(maxThresh);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFillSP);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Suppress salt and pepper noise.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageSPMean">Smoothed image.</param>
        /// <param name="maskWidth">Width of filter mask. Default: 3</param>
        /// <param name="maskHeight">Height of filter mask. Default: 3</param>
        /// <param name="minThresh">Minimum gray value. Default: 1</param>
        /// <param name="maxThresh">Maximum gray value. Default: 254</param>
        public static void MeanSp(
          HObject image,
          out HObject imageSPMean,
          HTuple maskWidth,
          HTuple maskHeight,
          HTuple minThresh,
          HTuple maxThresh)
        {
            IntPtr proc = HalconAPI.PreCall(1428);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.Store(proc, 2, minThresh);
            HalconAPI.Store(proc, 3, maxThresh);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(minThresh);
            HalconAPI.UnpinTuple(maxThresh);
            int procResult = HObject.LoadNew(proc, 1, err, out imageSPMean);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Find corners using the Sojka operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="maskSize">Required filter size. Default: 9</param>
        /// <param name="sigmaW">Sigma of the weight function according to the distance to the corner candidate. Default: 2.5</param>
        /// <param name="sigmaD">Sigma of the weight function for the distance to the ideal gray value edge. Default: 0.75</param>
        /// <param name="minGrad">Threshold for the magnitude of the gradient. Default: 30.0</param>
        /// <param name="minApparentness">Threshold for Apparentness. Default: 90.0</param>
        /// <param name="minAngle">Threshold for the direction change in a corner point (radians). Default: 0.5</param>
        /// <param name="subpix">Subpixel precise calculation of the corner points. Default: "false"</param>
        /// <param name="row">Row coordinates of the detected corner points.</param>
        /// <param name="column">Column coordinates of the detected corner points.</param>
        public static void PointsSojka(
          HObject image,
          HTuple maskSize,
          HTuple sigmaW,
          HTuple sigmaD,
          HTuple minGrad,
          HTuple minApparentness,
          HTuple minAngle,
          HTuple subpix,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1429);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskSize);
            HalconAPI.Store(proc, 1, sigmaW);
            HalconAPI.Store(proc, 2, sigmaD);
            HalconAPI.Store(proc, 3, minGrad);
            HalconAPI.Store(proc, 4, minApparentness);
            HalconAPI.Store(proc, 5, minAngle);
            HalconAPI.Store(proc, 6, subpix);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(sigmaW);
            HalconAPI.UnpinTuple(sigmaD);
            HalconAPI.UnpinTuple(minGrad);
            HalconAPI.UnpinTuple(minApparentness);
            HalconAPI.UnpinTuple(minAngle);
            HalconAPI.UnpinTuple(subpix);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Enhance circular dots in an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="dotImage">Output image.</param>
        /// <param name="diameter">Diameter of the dots to be enhanced. Default: 5</param>
        /// <param name="filterType">Enhance dark, light, or all dots. Default: "light"</param>
        /// <param name="pixelShift">Shift of the filter response. Default: 0</param>
        public static void DotsImage(
          HObject image,
          out HObject dotImage,
          HTuple diameter,
          HTuple filterType,
          HTuple pixelShift)
        {
            IntPtr proc = HalconAPI.PreCall(1430);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, diameter);
            HalconAPI.Store(proc, 1, filterType);
            HalconAPI.Store(proc, 2, pixelShift);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(diameter);
            HalconAPI.UnpinTuple(filterType);
            HalconAPI.UnpinTuple(pixelShift);
            int procResult = HObject.LoadNew(proc, 1, err, out dotImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Subpixel precise detection of local minima in an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="filter">Method for the calculation of the partial derivatives. Default: "facet"</param>
        /// <param name="sigma">Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image.</param>
        /// <param name="threshold">Minimum absolute value of the eigenvalues of the Hessian matrix. Default: 5.0</param>
        /// <param name="row">Row coordinates of the detected minima.</param>
        /// <param name="column">Column coordinates of the detected minima.</param>
        public static void LocalMinSubPix(
          HObject image,
          HTuple filter,
          HTuple sigma,
          HTuple threshold,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1431);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(threshold);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Subpixel precise detection of local maxima in an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="filter">Method for the calculation of the partial derivatives. Default: "facet"</param>
        /// <param name="sigma">Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image.</param>
        /// <param name="threshold">Minimum absolute value of the eigenvalues of the Hessian matrix. Default: 5.0</param>
        /// <param name="row">Row coordinates of the detected maxima.</param>
        /// <param name="column">Column coordinates of the detected maxima.</param>
        public static void LocalMaxSubPix(
          HObject image,
          HTuple filter,
          HTuple sigma,
          HTuple threshold,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1432);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(threshold);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Subpixel precise detection of saddle points in an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="filter">Method for the calculation of the partial derivatives. Default: "facet"</param>
        /// <param name="sigma">Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image.</param>
        /// <param name="threshold">Minimum absolute value of the eigenvalues of the Hessian matrix. Default: 5.0</param>
        /// <param name="row">Row coordinates of the detected saddle points.</param>
        /// <param name="column">Column coordinates of the detected saddle points.</param>
        public static void SaddlePointsSubPix(
          HObject image,
          HTuple filter,
          HTuple sigma,
          HTuple threshold,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1433);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(threshold);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Subpixel precise detection of critical points in an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="filter">Method for the calculation of the partial derivatives. Default: "facet"</param>
        /// <param name="sigma">Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image.</param>
        /// <param name="threshold">Minimum absolute value of the eigenvalues of the Hessian matrix. Default: 5.0</param>
        /// <param name="rowMin">Row coordinates of the detected minima.</param>
        /// <param name="columnMin">Column coordinates of the detected minima.</param>
        /// <param name="rowMax">Row coordinates of the detected maxima.</param>
        /// <param name="columnMax">Column coordinates of the detected maxima.</param>
        /// <param name="rowSaddle">Row coordinates of the detected saddle points.</param>
        /// <param name="columnSaddle">Column coordinates of the detected saddle points.</param>
        public static void CriticalPointsSubPix(
          HObject image,
          HTuple filter,
          HTuple sigma,
          HTuple threshold,
          out HTuple rowMin,
          out HTuple columnMin,
          out HTuple rowMax,
          out HTuple columnMax,
          out HTuple rowSaddle,
          out HTuple columnSaddle)
        {
            IntPtr proc = HalconAPI.PreCall(1434);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(threshold);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowMin);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnMin);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out rowMax);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out columnMax);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out rowSaddle);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out columnSaddle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect points of interest using the Harris operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="sigmaGrad">Amount of smoothing used for the calculation of the gradient. Default: 0.7</param>
        /// <param name="sigmaSmooth">Amount of smoothing used for the integration of the gradients. Default: 2.0</param>
        /// <param name="alpha">Weight of the squared trace of the squared gradient matrix. Default: 0.08</param>
        /// <param name="threshold">Minimum filter response for the points. Default: 1000.0</param>
        /// <param name="row">Row coordinates of the detected points.</param>
        /// <param name="column">Column coordinates of the detected points.</param>
        public static void PointsHarris(
          HObject image,
          HTuple sigmaGrad,
          HTuple sigmaSmooth,
          HTuple alpha,
          HTuple threshold,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1435);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sigmaGrad);
            HalconAPI.Store(proc, 1, sigmaSmooth);
            HalconAPI.Store(proc, 2, alpha);
            HalconAPI.Store(proc, 3, threshold);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigmaGrad);
            HalconAPI.UnpinTuple(sigmaSmooth);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.UnpinTuple(threshold);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect points of interest using the binomial approximation of the Harris operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="maskSizeGrad">Amount of binomial smoothing used for the calculation of the gradient. Default: 5</param>
        /// <param name="maskSizeSmooth">Amount of smoothing used for the integration of the gradients. Default: 15</param>
        /// <param name="alpha">Weight of the squared trace of the squared gradient matrix. Default: 0.08</param>
        /// <param name="threshold">Minimum filter response for the points. Default: 1000.0</param>
        /// <param name="subpix">Turn on or off subpixel refinement. Default: "on"</param>
        /// <param name="row">Row coordinates of the detected points.</param>
        /// <param name="column">Column coordinates of the detected points.</param>
        public static void PointsHarrisBinomial(
          HObject image,
          HTuple maskSizeGrad,
          HTuple maskSizeSmooth,
          HTuple alpha,
          HTuple threshold,
          HTuple subpix,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1436);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskSizeGrad);
            HalconAPI.Store(proc, 1, maskSizeSmooth);
            HalconAPI.Store(proc, 2, alpha);
            HalconAPI.Store(proc, 3, threshold);
            HalconAPI.Store(proc, 4, subpix);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskSizeGrad);
            HalconAPI.UnpinTuple(maskSizeSmooth);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.UnpinTuple(threshold);
            HalconAPI.UnpinTuple(subpix);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect points of interest using the Lepetit operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="radius">Radius of the circle. Default: 3</param>
        /// <param name="checkNeighbor">Number of checked neighbors on the circle. Default: 1</param>
        /// <param name="minCheckNeighborDiff">Threshold of grayvalue difference to each circle point. Default: 15</param>
        /// <param name="minScore">Threshold of grayvalue difference to all circle points. Default: 30</param>
        /// <param name="subpix">Subpixel accuracy of point coordinates. Default: "interpolation"</param>
        /// <param name="row">Row-coordinates of the detected points.</param>
        /// <param name="column">Column-coordinates of the detected points.</param>
        public static void PointsLepetit(
          HObject image,
          HTuple radius,
          HTuple checkNeighbor,
          HTuple minCheckNeighborDiff,
          HTuple minScore,
          HTuple subpix,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1437);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, radius);
            HalconAPI.Store(proc, 1, checkNeighbor);
            HalconAPI.Store(proc, 2, minCheckNeighborDiff);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, subpix);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(checkNeighbor);
            HalconAPI.UnpinTuple(minCheckNeighborDiff);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(subpix);
            int err2 = HTuple.LoadNew(proc, 0, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect points of interest using the Foerstner operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="sigmaGrad">Amount of smoothing used for the calculation of the gradient. If Smoothing is 'mean', SigmaGrad is ignored. Default: 1.0</param>
        /// <param name="sigmaInt">Amount of smoothing used for the integration of the gradients. Default: 2.0</param>
        /// <param name="sigmaPoints">Amount of smoothing used in the optimization functions. Default: 3.0</param>
        /// <param name="threshInhom">Threshold for the segmentation of inhomogeneous image areas. Default: 200</param>
        /// <param name="threshShape">Threshold for the segmentation of point areas. Default: 0.3</param>
        /// <param name="smoothing">Used smoothing method. Default: "gauss"</param>
        /// <param name="eliminateDoublets">Elimination of multiply detected points. Default: "false"</param>
        /// <param name="rowJunctions">Row coordinates of the detected junction points.</param>
        /// <param name="columnJunctions">Column coordinates of the detected junction points.</param>
        /// <param name="coRRJunctions">Row part of the covariance matrix of the detected junction points.</param>
        /// <param name="coRCJunctions">Mixed part of the covariance matrix of the detected junction points.</param>
        /// <param name="coCCJunctions">Column part of the covariance matrix of the detected junction points.</param>
        /// <param name="rowArea">Row coordinates of the detected area points.</param>
        /// <param name="columnArea">Column coordinates of the detected area points.</param>
        /// <param name="coRRArea">Row part of the covariance matrix of the detected area points.</param>
        /// <param name="coRCArea">Mixed part of the covariance matrix of the detected area points.</param>
        /// <param name="coCCArea">Column part of the covariance matrix of the detected area points.</param>
        public static void PointsFoerstner(
          HObject image,
          HTuple sigmaGrad,
          HTuple sigmaInt,
          HTuple sigmaPoints,
          HTuple threshInhom,
          HTuple threshShape,
          HTuple smoothing,
          HTuple eliminateDoublets,
          out HTuple rowJunctions,
          out HTuple columnJunctions,
          out HTuple coRRJunctions,
          out HTuple coRCJunctions,
          out HTuple coCCJunctions,
          out HTuple rowArea,
          out HTuple columnArea,
          out HTuple coRRArea,
          out HTuple coRCArea,
          out HTuple coCCArea)
        {
            IntPtr proc = HalconAPI.PreCall(1438);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sigmaGrad);
            HalconAPI.Store(proc, 1, sigmaInt);
            HalconAPI.Store(proc, 2, sigmaPoints);
            HalconAPI.Store(proc, 3, threshInhom);
            HalconAPI.Store(proc, 4, threshShape);
            HalconAPI.Store(proc, 5, smoothing);
            HalconAPI.Store(proc, 6, eliminateDoublets);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigmaGrad);
            HalconAPI.UnpinTuple(sigmaInt);
            HalconAPI.UnpinTuple(sigmaPoints);
            HalconAPI.UnpinTuple(threshInhom);
            HalconAPI.UnpinTuple(threshShape);
            HalconAPI.UnpinTuple(smoothing);
            HalconAPI.UnpinTuple(eliminateDoublets);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowJunctions);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnJunctions);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out coRRJunctions);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out coRCJunctions);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out coCCJunctions);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out rowArea);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out columnArea);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out coRRArea);
            int err10 = HTuple.LoadNew(proc, 8, HTupleType.DOUBLE, err9, out coRCArea);
            int procResult = HTuple.LoadNew(proc, 9, HTupleType.DOUBLE, err10, out coCCArea);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Estimate the image noise from a single image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="method">Method to estimate the image noise. Default: "foerstner"</param>
        /// <param name="percent">Percentage of used image points. Default: 20</param>
        /// <param name="sigma">Standard deviation of the image noise.</param>
        public static void EstimateNoise(
          HObject image,
          HTuple method,
          HTuple percent,
          out HTuple sigma)
        {
            IntPtr proc = HalconAPI.PreCall(1439);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, method);
            HalconAPI.Store(proc, 1, percent);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(percent);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out sigma);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determine the noise distribution of an image.</summary>
        /// <param name="constRegion">Region from which the noise distribution is to be estimated.</param>
        /// <param name="image">Corresponding image.</param>
        /// <param name="filterSize">Size of the mean filter. Default: 21</param>
        /// <param name="distribution">Noise distribution of all input regions.</param>
        public static void NoiseDistributionMean(
          HObject constRegion,
          HObject image,
          HTuple filterSize,
          out HTuple distribution)
        {
            IntPtr proc = HalconAPI.PreCall(1440);
            HalconAPI.Store(proc, 1, (HObjectBase)constRegion);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filterSize);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filterSize);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out distribution);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)constRegion);
            GC.KeepAlive((object)image);
        }

        /// <summary>Add noise to an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageNoise">Noisy image.</param>
        /// <param name="amp">Maximum noise amplitude. Default: 60.0</param>
        public static void AddNoiseWhite(HObject image, out HObject imageNoise, HTuple amp)
        {
            IntPtr proc = HalconAPI.PreCall(1441);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, amp);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(amp);
            int procResult = HObject.LoadNew(proc, 1, err, out imageNoise);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Add noise to an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageNoise">Noisy image.</param>
        /// <param name="distribution">Noise distribution.</param>
        public static void AddNoiseDistribution(
          HObject image,
          out HObject imageNoise,
          HTuple distribution)
        {
            IntPtr proc = HalconAPI.PreCall(1442);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, distribution);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distribution);
            int procResult = HObject.LoadNew(proc, 1, err, out imageNoise);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Generate a Gaussian noise distribution.</summary>
        /// <param name="sigma">Standard deviation of the Gaussian noise distribution. Default: 2.0</param>
        /// <param name="distribution">Resulting Gaussian noise distribution.</param>
        public static void GaussDistribution(HTuple sigma, out HTuple distribution)
        {
            IntPtr proc = HalconAPI.PreCall(1443);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out distribution);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate a salt-and-pepper noise distribution.</summary>
        /// <param name="percentSalt">Percentage of salt (white noise pixels). Default: 5.0</param>
        /// <param name="percentPepper">Percentage of pepper (black noise pixels). Default: 5.0</param>
        /// <param name="distribution">Resulting noise distribution.</param>
        public static void SpDistribution(
          HTuple percentSalt,
          HTuple percentPepper,
          out HTuple distribution)
        {
            IntPtr proc = HalconAPI.PreCall(1444);
            HalconAPI.Store(proc, 0, percentSalt);
            HalconAPI.Store(proc, 1, percentPepper);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(percentSalt);
            HalconAPI.UnpinTuple(percentPepper);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out distribution);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate standard deviation over several channels.</summary>
        /// <param name="image">Multichannel gray image.</param>
        /// <param name="imageDeviation">Result of calculation.</param>
        public static void DeviationN(HObject image, out HObject imageDeviation)
        {
            IntPtr proc = HalconAPI.PreCall(1445);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageDeviation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Perform an inpainting by texture propagation.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="region">Inpainting region.</param>
        /// <param name="inpaintedImage">Output image.</param>
        /// <param name="maskSize">Size of the inpainting blocks. Default: 9</param>
        /// <param name="searchSize">Size of the search window. Default: 30</param>
        /// <param name="anisotropy">Influence of the edge amplitude on the inpainting order. Default: 1.0</param>
        /// <param name="postIteration">Post-iteration for artifact reduction. Default: "none"</param>
        /// <param name="smoothness">Gray value tolerance for post-iteration. Default: 1.0</param>
        public static void InpaintingTexture(
          HObject image,
          HObject region,
          out HObject inpaintedImage,
          HTuple maskSize,
          HTuple searchSize,
          HTuple anisotropy,
          HTuple postIteration,
          HTuple smoothness)
        {
            IntPtr proc = HalconAPI.PreCall(1446);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.Store(proc, 0, maskSize);
            HalconAPI.Store(proc, 1, searchSize);
            HalconAPI.Store(proc, 2, anisotropy);
            HalconAPI.Store(proc, 3, postIteration);
            HalconAPI.Store(proc, 4, smoothness);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(searchSize);
            HalconAPI.UnpinTuple(anisotropy);
            HalconAPI.UnpinTuple(postIteration);
            HalconAPI.UnpinTuple(smoothness);
            int procResult = HObject.LoadNew(proc, 1, err, out inpaintedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)region);
        }

        /// <summary>Perform an inpainting by coherence transport.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="region">Inpainting region.</param>
        /// <param name="inpaintedImage">Output image.</param>
        /// <param name="epsilon">Radius of the pixel neighborhood. Default: 5.0</param>
        /// <param name="kappa">Sharpness parameter in percent. Default: 25.0</param>
        /// <param name="sigma">Pre-smoothing parameter. Default: 1.41</param>
        /// <param name="rho">Smoothing parameter for the direction estimation. Default: 4.0</param>
        /// <param name="channelCoefficients">Channel weights. Default: 1</param>
        public static void InpaintingCt(
          HObject image,
          HObject region,
          out HObject inpaintedImage,
          HTuple epsilon,
          HTuple kappa,
          HTuple sigma,
          HTuple rho,
          HTuple channelCoefficients)
        {
            IntPtr proc = HalconAPI.PreCall(1447);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.Store(proc, 0, epsilon);
            HalconAPI.Store(proc, 1, kappa);
            HalconAPI.Store(proc, 2, sigma);
            HalconAPI.Store(proc, 3, rho);
            HalconAPI.Store(proc, 4, channelCoefficients);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(epsilon);
            HalconAPI.UnpinTuple(kappa);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(rho);
            HalconAPI.UnpinTuple(channelCoefficients);
            int procResult = HObject.LoadNew(proc, 1, err, out inpaintedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)region);
        }

        /// <summary>Perform an inpainting by smoothing of level lines.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="region">Inpainting region.</param>
        /// <param name="inpaintedImage">Output image.</param>
        /// <param name="sigma">Smoothing for derivative operator. Default: 0.5</param>
        /// <param name="theta">Time step. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        public static void InpaintingMcf(
          HObject image,
          HObject region,
          out HObject inpaintedImage,
          HTuple sigma,
          HTuple theta,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1448);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, theta);
            HalconAPI.Store(proc, 2, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(theta);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out inpaintedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)region);
        }

        /// <summary>Perform an inpainting by coherence enhancing diffusion.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="region">Inpainting region.</param>
        /// <param name="inpaintedImage">Output image.</param>
        /// <param name="sigma">Smoothing for derivative operator. Default: 0.5</param>
        /// <param name="rho">Smoothing for diffusion coefficients. Default: 3.0</param>
        /// <param name="theta">Time step. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        public static void InpaintingCed(
          HObject image,
          HObject region,
          out HObject inpaintedImage,
          HTuple sigma,
          HTuple rho,
          HTuple theta,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1449);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, rho);
            HalconAPI.Store(proc, 2, theta);
            HalconAPI.Store(proc, 3, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(rho);
            HalconAPI.UnpinTuple(theta);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out inpaintedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)region);
        }

        /// <summary>Perform an inpainting by anisotropic diffusion.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="region">Inpainting region.</param>
        /// <param name="inpaintedImage">Output image.</param>
        /// <param name="mode">Type of edge sharpening algorithm. Default: "weickert"</param>
        /// <param name="contrast">Contrast parameter. Default: 5.0</param>
        /// <param name="theta">Step size. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        /// <param name="rho">Smoothing coefficient for edge information. Default: 3.0</param>
        public static void InpaintingAniso(
          HObject image,
          HObject region,
          out HObject inpaintedImage,
          HTuple mode,
          HTuple contrast,
          HTuple theta,
          HTuple iterations,
          HTuple rho)
        {
            IntPtr proc = HalconAPI.PreCall(1450);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, contrast);
            HalconAPI.Store(proc, 2, theta);
            HalconAPI.Store(proc, 3, iterations);
            HalconAPI.Store(proc, 4, rho);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(theta);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(rho);
            int procResult = HObject.LoadNew(proc, 1, err, out inpaintedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)region);
        }

        /// <summary>Perform a harmonic interpolation on an image region.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="region">Inpainting region.</param>
        /// <param name="inpaintedImage">Output image.</param>
        /// <param name="precision">Computational accuracy. Default: 0.001</param>
        public static void HarmonicInterpolation(
          HObject image,
          HObject region,
          out HObject inpaintedImage,
          HTuple precision)
        {
            IntPtr proc = HalconAPI.PreCall(1451);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.Store(proc, 0, precision);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(precision);
            int procResult = HObject.LoadNew(proc, 1, err, out inpaintedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)region);
        }

        /// <summary>Expand the domain of an image and set the gray values in the expanded domain.</summary>
        /// <param name="inputImage">Input image with domain to be expanded.</param>
        /// <param name="expandedImage">Output image with new gray values in the expanded domain.</param>
        /// <param name="expansionRange">Radius of the gray value expansion, measured in pixels. Default: 2</param>
        public static void ExpandDomainGray(
          HObject inputImage,
          out HObject expandedImage,
          HTuple expansionRange)
        {
            IntPtr proc = HalconAPI.PreCall(1452);
            HalconAPI.Store(proc, 1, (HObjectBase)inputImage);
            HalconAPI.Store(proc, 0, expansionRange);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(expansionRange);
            int procResult = HObject.LoadNew(proc, 1, err, out expandedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)inputImage);
        }

        /// <summary>Compute the topographic primal sketch of an image.</summary>
        /// <param name="image">Image for which the topographic primal sketch is to be computed.</param>
        /// <param name="sketch">Label image containing the 11 classes.</param>
        public static void TopographicSketch(HObject image, out HObject sketch)
        {
            IntPtr proc = HalconAPI.PreCall(1453);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out sketch);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute an affine transformation of the color values of a multichannel image.</summary>
        /// <param name="image">Multichannel input image.</param>
        /// <param name="imageTrans">Multichannel output image.</param>
        /// <param name="transMat">Transformation matrix for the color values.</param>
        public static void LinearTransColor(HObject image, out HObject imageTrans, HTuple transMat)
        {
            IntPtr proc = HalconAPI.PreCall(1454);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, transMat);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(transMat);
            int procResult = HObject.LoadNew(proc, 1, err, out imageTrans);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute the transformation matrix of the principal component analysis of multichannel images.</summary>
        /// <param name="multichannelImage">Multichannel input image.</param>
        /// <param name="trans">Transformation matrix for the computation of the PCA.</param>
        /// <param name="transInv">Transformation matrix for the computation of the inverse PCA.</param>
        /// <param name="mean">Mean gray value of the channels.</param>
        /// <param name="cov">Covariance matrix of the channels.</param>
        /// <param name="infoPerComp">Information content of the transformed channels.</param>
        public static void GenPrincipalCompTrans(
          HObject multichannelImage,
          out HTuple trans,
          out HTuple transInv,
          out HTuple mean,
          out HTuple cov,
          out HTuple infoPerComp)
        {
            IntPtr proc = HalconAPI.PreCall(1455);
            HalconAPI.Store(proc, 1, (HObjectBase)multichannelImage);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out trans);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out transInv);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out mean);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out cov);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out infoPerComp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multichannelImage);
        }

        /// <summary>Compute the principal components of multichannel images.</summary>
        /// <param name="multichannelImage">Multichannel input image.</param>
        /// <param name="PCAImage">Multichannel output image.</param>
        /// <param name="infoPerComp">Information content of each output channel.</param>
        public static void PrincipalComp(
          HObject multichannelImage,
          out HObject PCAImage,
          out HTuple infoPerComp)
        {
            IntPtr proc = HalconAPI.PreCall(1456);
            HalconAPI.Store(proc, 1, (HObjectBase)multichannelImage);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out PCAImage);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out infoPerComp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multichannelImage);
        }

        /// <summary>Determine the fuzzy entropy of regions.</summary>
        /// <param name="regions">Regions for which the fuzzy entropy is to be calculated.</param>
        /// <param name="image">Input image containing the fuzzy membership values.</param>
        /// <param name="apar">Start of the fuzzy function. Default: 0</param>
        /// <param name="cpar">End of the fuzzy function. Default: 255</param>
        /// <param name="entropy">Fuzzy entropy of a region.</param>
        public static void FuzzyEntropy(
          HObject regions,
          HObject image,
          HTuple apar,
          HTuple cpar,
          out HTuple entropy)
        {
            IntPtr proc = HalconAPI.PreCall(1457);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, apar);
            HalconAPI.Store(proc, 1, cpar);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(apar);
            HalconAPI.UnpinTuple(cpar);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out entropy);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the fuzzy perimeter of a region.</summary>
        /// <param name="regions">Regions for which the fuzzy perimeter is to be calculated.</param>
        /// <param name="image">Input image containing the fuzzy membership values.</param>
        /// <param name="apar">Start of the fuzzy function. Default: 0</param>
        /// <param name="cpar">End of the fuzzy function. Default: 255</param>
        /// <param name="perimeter">Fuzzy perimeter of a region.</param>
        public static void FuzzyPerimeter(
          HObject regions,
          HObject image,
          HTuple apar,
          HTuple cpar,
          out HTuple perimeter)
        {
            IntPtr proc = HalconAPI.PreCall(1458);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, apar);
            HalconAPI.Store(proc, 1, cpar);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(apar);
            HalconAPI.UnpinTuple(cpar);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out perimeter);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Perform a grayvalue closing with a selected mask.</summary>
        /// <param name="image">Image for which the minimum gray values are to be calculated.</param>
        /// <param name="imageClosing">Image containing the minimum gray values.</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        public static void GrayClosingShape(
          HObject image,
          out HObject imageClosing,
          HTuple maskHeight,
          HTuple maskWidth,
          HTuple maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1459);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.Store(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskShape);
            int procResult = HObject.LoadNew(proc, 1, err, out imageClosing);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Perform a gray value opening with a selected mask.</summary>
        /// <param name="image">Image for which the minimum gray values are to be calculated.</param>
        /// <param name="imageOpening">Image containing the minimum gray values.</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        public static void GrayOpeningShape(
          HObject image,
          out HObject imageOpening,
          HTuple maskHeight,
          HTuple maskWidth,
          HTuple maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1460);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.Store(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskShape);
            int procResult = HObject.LoadNew(proc, 1, err, out imageOpening);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determine the minimum gray value within a selected mask.</summary>
        /// <param name="image">Image for which the minimum gray values are to be calculated.</param>
        /// <param name="imageMin">Image containing the minimum gray values.</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        public static void GrayErosionShape(
          HObject image,
          out HObject imageMin,
          HTuple maskHeight,
          HTuple maskWidth,
          HTuple maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1461);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.Store(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskShape);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMin);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determine the maximum gray value within a selected mask.</summary>
        /// <param name="image">Image for which the maximum gray values are to be calculated.</param>
        /// <param name="imageMax">Image containing the maximum gray values.</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        public static void GrayDilationShape(
          HObject image,
          out HObject imageMax,
          HTuple maskHeight,
          HTuple maskWidth,
          HTuple maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1462);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.Store(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskShape);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determine the gray value range within a rectangle.</summary>
        /// <param name="image">Image for which the gray value range is to be calculated.</param>
        /// <param name="imageResult">Image containing the gray value range.</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        public static void GrayRangeRect(
          HObject image,
          out HObject imageResult,
          HTuple maskHeight,
          HTuple maskWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1463);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Perform a gray value closing with a rectangular mask.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageClosing">Gray-closed image.</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        public static void GrayClosingRect(
          HObject image,
          out HObject imageClosing,
          HTuple maskHeight,
          HTuple maskWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1464);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            int procResult = HObject.LoadNew(proc, 1, err, out imageClosing);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Perform a gray value opening with a rectangular mask.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageOpening">Gray-opened image.</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        public static void GrayOpeningRect(
          HObject image,
          out HObject imageOpening,
          HTuple maskHeight,
          HTuple maskWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1465);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            int procResult = HObject.LoadNew(proc, 1, err, out imageOpening);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determine the minimum gray value within a rectangle.</summary>
        /// <param name="image">Image for which the minimum gray values are to be calculated.</param>
        /// <param name="imageMin">Image containing the minimum gray values.</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        public static void GrayErosionRect(
          HObject image,
          out HObject imageMin,
          HTuple maskHeight,
          HTuple maskWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1466);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMin);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determine the maximum gray value within a rectangle.</summary>
        /// <param name="image">Image for which the maximum gray values are to be calculated.</param>
        /// <param name="imageMax">Image containing the maximum gray values.</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        public static void GrayDilationRect(
          HObject image,
          out HObject imageMax,
          HTuple maskHeight,
          HTuple maskWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1467);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Thinning of gray value images.</summary>
        /// <param name="image">Image to be thinned.</param>
        /// <param name="graySkeleton">Thinned image.</param>
        public static void GraySkeleton(HObject image, out HObject graySkeleton)
        {
            IntPtr proc = HalconAPI.PreCall(1468);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out graySkeleton);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Transform an image with a gray-value look-up-table</summary>
        /// <param name="image">Image whose gray values are to be transformed.</param>
        /// <param name="imageResult">Transformed image.</param>
        /// <param name="lut">Table containing the transformation.</param>
        public static void LutTrans(HObject image, out HObject imageResult, HTuple lut)
        {
            IntPtr proc = HalconAPI.PreCall(1469);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, lut);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(lut);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the correlation between an image and an arbitrary filter mask</summary>
        /// <param name="image">Images for which the correlation will be calculated.</param>
        /// <param name="imageResult">Result of the correlation.</param>
        /// <param name="filterMask">Filter mask as file name or tuple. Default: "sobel"</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        public static void ConvolImage(
          HObject image,
          out HObject imageResult,
          HTuple filterMask,
          HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1470);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filterMask);
            HalconAPI.Store(proc, 1, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filterMask);
            HalconAPI.UnpinTuple(margin);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Convert the type of an image.</summary>
        /// <param name="image">Image whose image type is to be changed.</param>
        /// <param name="imageConverted">Converted image.</param>
        /// <param name="newType">Desired image type (i.e., type of the gray values). Default: "byte"</param>
        public static void ConvertImageType(HObject image, out HObject imageConverted, HTuple newType)
        {
            IntPtr proc = HalconAPI.PreCall(1471);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, newType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(newType);
            int procResult = HObject.LoadNew(proc, 1, err, out imageConverted);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Convert two real-valued images into a vector field image.</summary>
        /// <param name="row">Vector component in the row direction.</param>
        /// <param name="col">Vector component in the column direction.</param>
        /// <param name="vectorField">Displacement vector field.</param>
        /// <param name="type">Semantic kind of the vector field. Default: "vector_field_relative"</param>
        public static void RealToVectorField(
          HObject row,
          HObject col,
          out HObject vectorField,
          HTuple type)
        {
            IntPtr proc = HalconAPI.PreCall(1472);
            HalconAPI.Store(proc, 1, (HObjectBase)row);
            HalconAPI.Store(proc, 2, (HObjectBase)col);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            int procResult = HObject.LoadNew(proc, 1, err, out vectorField);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)row);
            GC.KeepAlive((object)col);
        }

        /// <summary>Convert a vector field image into two real-valued images.</summary>
        /// <param name="vectorField">Vector field.</param>
        /// <param name="row">Vector component in the row direction.</param>
        /// <param name="col">Vector component in the column direction.</param>
        public static void VectorFieldToReal(HObject vectorField, out HObject row, out HObject col)
        {
            IntPtr proc = HalconAPI.PreCall(1473);
            HalconAPI.Store(proc, 1, (HObjectBase)vectorField);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out row);
            int procResult = HObject.LoadNew(proc, 2, err2, out col);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)vectorField);
        }

        /// <summary>Convert two real images into a complex image.</summary>
        /// <param name="imageReal">Real part.</param>
        /// <param name="imageImaginary">Imaginary part.</param>
        /// <param name="imageComplex">Complex image.</param>
        public static void RealToComplex(
          HObject imageReal,
          HObject imageImaginary,
          out HObject imageComplex)
        {
            IntPtr proc = HalconAPI.PreCall(1474);
            HalconAPI.Store(proc, 1, (HObjectBase)imageReal);
            HalconAPI.Store(proc, 2, (HObjectBase)imageImaginary);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageComplex);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageReal);
            GC.KeepAlive((object)imageImaginary);
        }

        /// <summary>Convert a complex image into two real images.</summary>
        /// <param name="imageComplex">Complex image.</param>
        /// <param name="imageReal">Real part.</param>
        /// <param name="imageImaginary">Imaginary part.</param>
        public static void ComplexToReal(
          HObject imageComplex,
          out HObject imageReal,
          out HObject imageImaginary)
        {
            IntPtr proc = HalconAPI.PreCall(1475);
            HalconAPI.Store(proc, 1, (HObjectBase)imageComplex);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out imageReal);
            int procResult = HObject.LoadNew(proc, 2, err2, out imageImaginary);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageComplex);
        }

        /// <summary>Paint regions with their average gray value.</summary>
        /// <param name="regions">Input regions.</param>
        /// <param name="image">original gray-value image.</param>
        /// <param name="imageMean">Result image with painted regions.</param>
        public static void RegionToMean(HObject regions, HObject image, out HObject imageMean)
        {
            IntPtr proc = HalconAPI.PreCall(1476);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMean);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the lowest possible gray value on an arbitrary path to the image border for each point in the image.</summary>
        /// <param name="image">Image being processed.</param>
        /// <param name="imageDist">Result image.</param>
        public static void GrayInside(HObject image, out HObject imageDist)
        {
            IntPtr proc = HalconAPI.PreCall(1477);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageDist);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Symmetry of gray values along a row.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageSymmetry">Symmetry image.</param>
        /// <param name="maskSize">Extension of search area. Default: 40</param>
        /// <param name="direction">Angle of test direction. Default: 0.0</param>
        /// <param name="exponent">Exponent for weighting. Default: 0.5</param>
        public static void Symmetry(
          HObject image,
          out HObject imageSymmetry,
          HTuple maskSize,
          HTuple direction,
          HTuple exponent)
        {
            IntPtr proc = HalconAPI.PreCall(1478);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskSize);
            HalconAPI.Store(proc, 1, direction);
            HalconAPI.Store(proc, 2, exponent);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(direction);
            HalconAPI.UnpinTuple(exponent);
            int procResult = HObject.LoadNew(proc, 1, err, out imageSymmetry);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Selection of gray values of a multi-channel image using an index image.</summary>
        /// <param name="multichannelImage">Multi-channel gray value image.</param>
        /// <param name="indexImage">Image, where pixel values are interpreted as channel index.</param>
        /// <param name="selected">Resulting image.</param>
        public static void SelectGrayvaluesFromChannels(
          HObject multichannelImage,
          HObject indexImage,
          out HObject selected)
        {
            IntPtr proc = HalconAPI.PreCall(1479);
            HalconAPI.Store(proc, 1, (HObjectBase)multichannelImage);
            HalconAPI.Store(proc, 2, (HObjectBase)indexImage);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out selected);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multichannelImage);
            GC.KeepAlive((object)indexImage);
        }

        /// <summary>Extract depth using multiple focus levels.</summary>
        /// <param name="multiFocusImage">Multichannel gray image consisting of multiple focus levels.</param>
        /// <param name="depth">Depth image.</param>
        /// <param name="confidence">Confidence of depth estimation.</param>
        /// <param name="filter">Filter used to find sharp pixels. Default: "highpass"</param>
        /// <param name="selection">Method used to find sharp pixels. Default: "next_maximum"</param>
        public static void DepthFromFocus(
          HObject multiFocusImage,
          out HObject depth,
          out HObject confidence,
          HTuple filter,
          HTuple selection)
        {
            IntPtr proc = HalconAPI.PreCall(1480);
            HalconAPI.Store(proc, 1, (HObjectBase)multiFocusImage);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, selection);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(selection);
            int err2 = HObject.LoadNew(proc, 1, err1, out depth);
            int procResult = HObject.LoadNew(proc, 2, err2, out confidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multiFocusImage);
        }

        /// <summary>Compute the calibrated scene flow between two stereo image pairs.</summary>
        /// <param name="imageRect1T1">Input image 1 at time @f$t_{1}$t_1.</param>
        /// <param name="imageRect2T1">Input image 2 at time @f$t_{1}$t_1.</param>
        /// <param name="imageRect1T2">Input image 1 at time @f$t_{2}$t_2.</param>
        /// <param name="imageRect2T2">Input image 2 at time @f$t_{2}$t_2.</param>
        /// <param name="disparity">Disparity between input images 1 and 2 at time @f$t_{1}$t_1.</param>
        /// <param name="smoothingFlow">Weight of the regularization term relative to the data term (derivatives of the optical flow). Default: 40.0</param>
        /// <param name="smoothingDisparity">Weight of the regularization term relative to the data term (derivatives of the disparity change). Default: 40.0</param>
        /// <param name="genParamName">Parameter name(s) for the algorithm. Default: "default_parameters"</param>
        /// <param name="genParamValue">Parameter value(s) for the algorithm. Default: "accurate"</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Pose of the rectified camera 2 in relation to the rectified camera 1.</param>
        /// <param name="objectModel3D">Handle of the 3D object model.</param>
        public static void SceneFlowCalib(
          HObject imageRect1T1,
          HObject imageRect2T1,
          HObject imageRect1T2,
          HObject imageRect2T2,
          HObject disparity,
          HTuple smoothingFlow,
          HTuple smoothingDisparity,
          HTuple genParamName,
          HTuple genParamValue,
          HTuple camParamRect1,
          HTuple camParamRect2,
          HTuple relPoseRect,
          out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(1481);
            HalconAPI.Store(proc, 1, (HObjectBase)imageRect1T1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2T1);
            HalconAPI.Store(proc, 3, (HObjectBase)imageRect1T2);
            HalconAPI.Store(proc, 4, (HObjectBase)imageRect2T2);
            HalconAPI.Store(proc, 5, (HObjectBase)disparity);
            HalconAPI.Store(proc, 0, smoothingFlow);
            HalconAPI.Store(proc, 1, smoothingDisparity);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.Store(proc, 4, camParamRect1);
            HalconAPI.Store(proc, 5, camParamRect2);
            HalconAPI.Store(proc, 6, relPoseRect);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(smoothingFlow);
            HalconAPI.UnpinTuple(smoothingDisparity);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.UnpinTuple(camParamRect1);
            HalconAPI.UnpinTuple(camParamRect2);
            HalconAPI.UnpinTuple(relPoseRect);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageRect1T1);
            GC.KeepAlive((object)imageRect2T1);
            GC.KeepAlive((object)imageRect1T2);
            GC.KeepAlive((object)imageRect2T2);
            GC.KeepAlive((object)disparity);
        }

        /// <summary>Compute the uncalibrated scene flow between two stereo image pairs.</summary>
        /// <param name="imageRect1T1">Input image 1 at time @f$t_{1}$t_1.</param>
        /// <param name="imageRect2T1">Input image 2 at time @f$t_{1}$t_1.</param>
        /// <param name="imageRect1T2">Input image 1 at time @f$t_{2}$t_2.</param>
        /// <param name="imageRect2T2">Input image 2 at time @f$t_{2}$t_2.</param>
        /// <param name="disparity">Disparity between input images 1 and 2 at time @f$t_{1}$t_1.</param>
        /// <param name="opticalFlow">Estimated optical flow.</param>
        /// <param name="disparityChange">Estimated change in disparity.</param>
        /// <param name="smoothingFlow">Weight of the regularization term relative to the data term (derivatives of the optical flow). Default: 40.0</param>
        /// <param name="smoothingDisparity">Weight of the regularization term relative to the data term (derivatives of the disparity change). Default: 40.0</param>
        /// <param name="genParamName">Parameter name(s) for the algorithm. Default: "default_parameters"</param>
        /// <param name="genParamValue">Parameter value(s) for the algorithm. Default: "accurate"</param>
        public static void SceneFlowUncalib(
          HObject imageRect1T1,
          HObject imageRect2T1,
          HObject imageRect1T2,
          HObject imageRect2T2,
          HObject disparity,
          out HObject opticalFlow,
          out HObject disparityChange,
          HTuple smoothingFlow,
          HTuple smoothingDisparity,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1482);
            HalconAPI.Store(proc, 1, (HObjectBase)imageRect1T1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2T1);
            HalconAPI.Store(proc, 3, (HObjectBase)imageRect1T2);
            HalconAPI.Store(proc, 4, (HObjectBase)imageRect2T2);
            HalconAPI.Store(proc, 5, (HObjectBase)disparity);
            HalconAPI.Store(proc, 0, smoothingFlow);
            HalconAPI.Store(proc, 1, smoothingDisparity);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(smoothingFlow);
            HalconAPI.UnpinTuple(smoothingDisparity);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HObject.LoadNew(proc, 1, err1, out opticalFlow);
            int procResult = HObject.LoadNew(proc, 2, err2, out disparityChange);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageRect1T1);
            GC.KeepAlive((object)imageRect2T1);
            GC.KeepAlive((object)imageRect1T2);
            GC.KeepAlive((object)imageRect2T2);
            GC.KeepAlive((object)disparity);
        }

        /// <summary>Unwarp an image using a vector field.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="vectorField">Input vector field.</param>
        /// <param name="imageUnwarped">Unwarped image.</param>
        public static void UnwarpImageVectorField(
          HObject image,
          HObject vectorField,
          out HObject imageUnwarped)
        {
            IntPtr proc = HalconAPI.PreCall(1483);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)vectorField);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageUnwarped);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)vectorField);
        }

        /// <summary>Convolve a vector field with derivatives of the Gaussian.</summary>
        /// <param name="vectorField">Input vector field.</param>
        /// <param name="result">Filtered result images.</param>
        /// <param name="sigma">Sigma of the Gaussian. Default: 1.0</param>
        /// <param name="component">Component to be calculated. Default: "mean_curvature"</param>
        public static void DerivateVectorField(
          HObject vectorField,
          out HObject result,
          HTuple sigma,
          HTuple component)
        {
            IntPtr proc = HalconAPI.PreCall(1484);
            HalconAPI.Store(proc, 1, (HObjectBase)vectorField);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, component);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(component);
            int procResult = HObject.LoadNew(proc, 1, err, out result);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)vectorField);
        }

        /// <summary>Compute the length of the vectors of a vector field.</summary>
        /// <param name="vectorField">Input vector field</param>
        /// <param name="length">Length of the vectors of the vector field.</param>
        /// <param name="mode">Mode for computing the length of the vectors. Default: "length"</param>
        public static void VectorFieldLength(HObject vectorField, out HObject length, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1485);
            HalconAPI.Store(proc, 1, (HObjectBase)vectorField);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out length);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)vectorField);
        }

        /// <summary>Compute the optical flow between two images.</summary>
        /// <param name="imageT1">Input image 1.</param>
        /// <param name="imageT2">Input image 2.</param>
        /// <param name="vectorField">Optical flow.</param>
        /// <param name="algorithm">Algorithm for computing the optical flow. Default: "fdrig"</param>
        /// <param name="smoothingSigma">Standard deviation for initial Gaussian smoothing. Default: 0.8</param>
        /// <param name="integrationSigma">Standard deviation of the integration filter. Default: 1.0</param>
        /// <param name="flowSmoothness">Weight of the smoothing term relative to the data term. Default: 20.0</param>
        /// <param name="gradientConstancy">Weight of the gradient constancy relative to the gray value constancy. Default: 5.0</param>
        /// <param name="MGParamName">Parameter name(s) for the multigrid algorithm. Default: "default_parameters"</param>
        /// <param name="MGParamValue">Parameter value(s) for the multigrid algorithm. Default: "accurate"</param>
        public static void OpticalFlowMg(
          HObject imageT1,
          HObject imageT2,
          out HObject vectorField,
          HTuple algorithm,
          HTuple smoothingSigma,
          HTuple integrationSigma,
          HTuple flowSmoothness,
          HTuple gradientConstancy,
          HTuple MGParamName,
          HTuple MGParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1486);
            HalconAPI.Store(proc, 1, (HObjectBase)imageT1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageT2);
            HalconAPI.Store(proc, 0, algorithm);
            HalconAPI.Store(proc, 1, smoothingSigma);
            HalconAPI.Store(proc, 2, integrationSigma);
            HalconAPI.Store(proc, 3, flowSmoothness);
            HalconAPI.Store(proc, 4, gradientConstancy);
            HalconAPI.Store(proc, 5, MGParamName);
            HalconAPI.Store(proc, 6, MGParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(algorithm);
            HalconAPI.UnpinTuple(smoothingSigma);
            HalconAPI.UnpinTuple(integrationSigma);
            HalconAPI.UnpinTuple(flowSmoothness);
            HalconAPI.UnpinTuple(gradientConstancy);
            HalconAPI.UnpinTuple(MGParamName);
            HalconAPI.UnpinTuple(MGParamValue);
            int procResult = HObject.LoadNew(proc, 1, err, out vectorField);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageT1);
            GC.KeepAlive((object)imageT2);
        }

        /// <summary>Matching a template and an image in a resolution pyramid.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageTemplate">The domain of this image will be matched with Image.</param>
        /// <param name="imageMatch">Result image and result region: values of the matching criterion within the determined "region of interest".</param>
        /// <param name="mode">Desired matching criterion. Default: "dfd"</param>
        /// <param name="level">Startlevel in the resolution pyramid (highest resolution: Level 0). Default: 1</param>
        /// <param name="threshold">Threshold to determine the "region of interest". Default: 30</param>
        public static void ExhaustiveMatchMg(
          HObject image,
          HObject imageTemplate,
          out HObject imageMatch,
          HTuple mode,
          HTuple level,
          HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(1487);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)imageTemplate);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, level);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(level);
            HalconAPI.UnpinTuple(threshold);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMatch);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)imageTemplate);
        }

        /// <summary>Preparing a pattern for template matching with rotation.</summary>
        /// <param name="template">Input image whose domain will be processed for the pattern matching.</param>
        /// <param name="numLevel">Maximal number of pyramid levels. Default: 4</param>
        /// <param name="angleStart">Smallest Rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtend">Maximum positive Extension of AngleStart. Default: 0.79</param>
        /// <param name="angleStep">Step rate (angle precision) of matching. Default: 0.0982</param>
        /// <param name="optimize">Kind of optimizing. Default: "sort"</param>
        /// <param name="grayValues">Kind of grayvalues. Default: "original"</param>
        /// <param name="templateID">Template number.</param>
        public static void CreateTemplateRot(
          HObject template,
          HTuple numLevel,
          HTuple angleStart,
          HTuple angleExtend,
          HTuple angleStep,
          HTuple optimize,
          HTuple grayValues,
          out HTuple templateID)
        {
            IntPtr proc = HalconAPI.PreCall(1488);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, numLevel);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtend);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, optimize);
            HalconAPI.Store(proc, 5, grayValues);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevel);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtend);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(optimize);
            HalconAPI.UnpinTuple(grayValues);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out templateID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Preparing a pattern for template matching.</summary>
        /// <param name="template">Input image whose domain will be processed for the pattern matching.</param>
        /// <param name="firstError">Not yet in use. Default: 255</param>
        /// <param name="numLevel">Maximal number of pyramid levels. Default: 4</param>
        /// <param name="optimize">Kind of optimizing. Default: "sort"</param>
        /// <param name="grayValues">Kind of grayvalues. Default: "original"</param>
        /// <param name="templateID">Template number.</param>
        public static void CreateTemplate(
          HObject template,
          HTuple firstError,
          HTuple numLevel,
          HTuple optimize,
          HTuple grayValues,
          out HTuple templateID)
        {
            IntPtr proc = HalconAPI.PreCall(1489);
            HalconAPI.Store(proc, 1, (HObjectBase)template);
            HalconAPI.Store(proc, 0, firstError);
            HalconAPI.Store(proc, 1, numLevel);
            HalconAPI.Store(proc, 2, optimize);
            HalconAPI.Store(proc, 3, grayValues);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(firstError);
            HalconAPI.UnpinTuple(numLevel);
            HalconAPI.UnpinTuple(optimize);
            HalconAPI.UnpinTuple(grayValues);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out templateID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)template);
        }

        /// <summary>Serialize a template.</summary>
        /// <param name="templateID">Handle of the template.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeTemplate(HTuple templateID, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1490);
            HalconAPI.Store(proc, 0, templateID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized template.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="templateID">Template number.</param>
        public static void DeserializeTemplate(HTuple serializedItemHandle, out HTuple templateID)
        {
            IntPtr proc = HalconAPI.PreCall(1491);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out templateID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Writing a template to file.</summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="fileName">file name.</param>
        public static void WriteTemplate(HTuple templateID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1492);
            HalconAPI.Store(proc, 0, templateID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Reading a template from file.</summary>
        /// <param name="fileName">file name.</param>
        /// <param name="templateID">Template number.</param>
        public static void ReadTemplate(HTuple fileName, out HTuple templateID)
        {
            IntPtr proc = HalconAPI.PreCall(1493);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out templateID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deallocation of the memory of all templates.</summary>
        public static void ClearAllTemplates()
        {
            IntPtr proc = HalconAPI.PreCall(1494);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deallocation of the memory of a template.</summary>
        /// <param name="templateID">Template number.</param>
        public static void ClearTemplate(HTuple templateID)
        {
            IntPtr proc = HalconAPI.PreCall(1495);
            HalconAPI.Store(proc, 0, templateID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Gray value offset for template.</summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="grayOffset">Offset of gray values. Default: 0</param>
        public static void SetOffsetTemplate(HTuple templateID, HTuple grayOffset)
        {
            IntPtr proc = HalconAPI.PreCall(1496);
            HalconAPI.Store(proc, 0, templateID);
            HalconAPI.Store(proc, 1, grayOffset);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.UnpinTuple(grayOffset);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define reference position for a matching template.</summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="row">Reference position of template (row).</param>
        /// <param name="column">Reference position of template (column).</param>
        public static void SetReferenceTemplate(HTuple templateID, HTuple row, HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1497);
            HalconAPI.Store(proc, 0, templateID);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Adapting a template to the size of an image.</summary>
        /// <param name="image">Image which determines the size of the later matching.</param>
        /// <param name="templateID">Template number.</param>
        public static void AdaptTemplate(HObject image, HTuple templateID)
        {
            IntPtr proc = HalconAPI.PreCall(1498);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, templateID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Searching all good grayvalue matches in a pyramid.</summary>
        /// <param name="image">Input image inside of which the pattern has to be found.</param>
        /// <param name="matches">All points which have an error below a certain threshold.</param>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximal average difference of the grayvalues. Default: 30.0</param>
        /// <param name="numLevel">Number of levels in the pyramid. Default: 3</param>
        public static void FastMatchMg(
          HObject image,
          out HObject matches,
          HTuple templateID,
          HTuple maxError,
          HTuple numLevel)
        {
            IntPtr proc = HalconAPI.PreCall(1499);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, templateID);
            HalconAPI.Store(proc, 1, maxError);
            HalconAPI.Store(proc, 2, numLevel);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.UnpinTuple(maxError);
            HalconAPI.UnpinTuple(numLevel);
            int procResult = HObject.LoadNew(proc, 1, err, out matches);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Searching the best grayvalue matches in a pre generated pyramid.</summary>
        /// <param name="imagePyramid">Image pyramid inside of which the pattern has to be found.</param>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximal average difference of the grayvalues. Default: 30.0</param>
        /// <param name="subPixel">Exactness in subpixels in case of 'true'. Default: "false"</param>
        /// <param name="numLevels">Number of the used resolution levels. Default: 3</param>
        /// <param name="whichLevels">Resolution level up to which the method "best match" is used. Default: "original"</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="error">Average divergence of the grayvalues in the best match.</param>
        public static void BestMatchPreMg(
          HObject imagePyramid,
          HTuple templateID,
          HTuple maxError,
          HTuple subPixel,
          HTuple numLevels,
          HTuple whichLevels,
          out HTuple row,
          out HTuple column,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1500);
            HalconAPI.Store(proc, 1, (HObjectBase)imagePyramid);
            HalconAPI.Store(proc, 0, templateID);
            HalconAPI.Store(proc, 1, maxError);
            HalconAPI.Store(proc, 2, subPixel);
            HalconAPI.Store(proc, 3, numLevels);
            HalconAPI.Store(proc, 4, whichLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.UnpinTuple(maxError);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(whichLevels);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imagePyramid);
        }

        /// <summary>Searching the best grayvalue matches in a pyramid.</summary>
        /// <param name="image">Input image inside of which the pattern has to be found.</param>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximal average difference of the grayvalues. Default: 30.0</param>
        /// <param name="subPixel">Exactness in subpixels in case of 'true'. Default: "false"</param>
        /// <param name="numLevels">Number of the used resolution levels. Default: 4</param>
        /// <param name="whichLevels">Resolution level up to which the method "best match" is used. Default: 2</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="error">Average divergence of the grayvalues in the best match.</param>
        public static void BestMatchMg(
          HObject image,
          HTuple templateID,
          HTuple maxError,
          HTuple subPixel,
          HTuple numLevels,
          HTuple whichLevels,
          out HTuple row,
          out HTuple column,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1501);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, templateID);
            HalconAPI.Store(proc, 1, maxError);
            HalconAPI.Store(proc, 2, subPixel);
            HalconAPI.Store(proc, 3, numLevels);
            HalconAPI.Store(proc, 4, whichLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.UnpinTuple(maxError);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(whichLevels);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Searching all good matches of a template and an image.</summary>
        /// <param name="image">Input image inside of which the pattern has to be found.</param>
        /// <param name="matches">All points whose error lies below a certain threshold.</param>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximal average difference of the grayvalues. Default: 20.0</param>
        public static void FastMatch(
          HObject image,
          out HObject matches,
          HTuple templateID,
          HTuple maxError)
        {
            IntPtr proc = HalconAPI.PreCall(1502);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, templateID);
            HalconAPI.Store(proc, 1, maxError);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.UnpinTuple(maxError);
            int procResult = HObject.LoadNew(proc, 1, err, out matches);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Searching the best matching of a template and a pyramid with rotation.</summary>
        /// <param name="image">Input image inside of which the pattern has to be found.</param>
        /// <param name="templateID">Template number.</param>
        /// <param name="angleStart">Smallest Rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtend">Maximum positive Extension of AngleStart. Default: 0.79</param>
        /// <param name="maxError">Maximum average difference of the grayvalues. Default: 40.0</param>
        /// <param name="subPixel">Subpixel accuracy in case of 'true'. Default: "false"</param>
        /// <param name="numLevels">Number of the used resolution levels. Default: 3</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="angle">Rotation angle of pattern.</param>
        /// <param name="error">Average divergence of the grayvalues of the best match.</param>
        public static void BestMatchRotMg(
          HObject image,
          HTuple templateID,
          HTuple angleStart,
          HTuple angleExtend,
          HTuple maxError,
          HTuple subPixel,
          HTuple numLevels,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1503);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, templateID);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtend);
            HalconAPI.Store(proc, 3, maxError);
            HalconAPI.Store(proc, 4, subPixel);
            HalconAPI.Store(proc, 5, numLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtend);
            HalconAPI.UnpinTuple(maxError);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Searching the best matching of a template and an image with rotation.</summary>
        /// <param name="image">Input image inside of which the pattern has to be found.</param>
        /// <param name="templateID">Template number.</param>
        /// <param name="angleStart">Smallest Rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtend">Maximum positive Extension of AngleStart. Default: 0.79</param>
        /// <param name="maxError">Maximum average difference of the grayvalues. Default: 30.0</param>
        /// <param name="subPixel">Subpixel accuracy in case of 'true'. Default: "false"</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="angle">Rotation angle of pattern.</param>
        /// <param name="error">Average divergence of the grayvalues of the best match.</param>
        public static void BestMatchRot(
          HObject image,
          HTuple templateID,
          HTuple angleStart,
          HTuple angleExtend,
          HTuple maxError,
          HTuple subPixel,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1504);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, templateID);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtend);
            HalconAPI.Store(proc, 3, maxError);
            HalconAPI.Store(proc, 4, subPixel);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtend);
            HalconAPI.UnpinTuple(maxError);
            HalconAPI.UnpinTuple(subPixel);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Searching the best matching of a template and an image.</summary>
        /// <param name="image">Input image inside of which the pattern has to be found.</param>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximum average difference of the grayvalues. Default: 20.0</param>
        /// <param name="subPixel">Subpixel accuracy in case of 'true'. Default: "false"</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="error">Average divergence of the grayvalues of the best match.</param>
        public static void BestMatch(
          HObject image,
          HTuple templateID,
          HTuple maxError,
          HTuple subPixel,
          out HTuple row,
          out HTuple column,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1505);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, templateID);
            HalconAPI.Store(proc, 1, maxError);
            HalconAPI.Store(proc, 2, subPixel);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(templateID);
            HalconAPI.UnpinTuple(maxError);
            HalconAPI.UnpinTuple(subPixel);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Matching of a template and an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="regionOfInterest">Area to be searched in the input image.</param>
        /// <param name="imageTemplate">This area  will be "matched" by Image within the RegionOfInterest.</param>
        /// <param name="imageMatch">Result image: values of the matching criterion.</param>
        /// <param name="mode">Desired matching criterion. Default: "dfd"</param>
        public static void ExhaustiveMatch(
          HObject image,
          HObject regionOfInterest,
          HObject imageTemplate,
          out HObject imageMatch,
          HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1506);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)regionOfInterest);
            HalconAPI.Store(proc, 3, (HObjectBase)imageTemplate);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMatch);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)regionOfInterest);
            GC.KeepAlive((object)imageTemplate);
        }

        /// <summary>Searching corners in images.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageCorner">Result of the filtering.</param>
        /// <param name="size">Desired filtersize of the graymask. Default: 3</param>
        /// <param name="weight">Weighting. Default: 0.04</param>
        public static void CornerResponse(
          HObject image,
          out HObject imageCorner,
          HTuple size,
          HTuple weight)
        {
            IntPtr proc = HalconAPI.PreCall(1507);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, size);
            HalconAPI.Store(proc, 1, weight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(size);
            HalconAPI.UnpinTuple(weight);
            int procResult = HObject.LoadNew(proc, 1, err, out imageCorner);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculating a Gauss pyramid.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imagePyramid">Output images.</param>
        /// <param name="mode">Kind of filtermask. Default: "weighted"</param>
        /// <param name="scale">Factor for scaling down. Default: 0.5</param>
        public static void GenGaussPyramid(
          HObject image,
          out HObject imagePyramid,
          HTuple mode,
          HTuple scale)
        {
            IntPtr proc = HalconAPI.PreCall(1508);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, scale);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(scale);
            int procResult = HObject.LoadNew(proc, 1, err, out imagePyramid);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculating the monotony operation.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageMonotony">Result of the monotony operator.</param>
        public static void Monotony(HObject image, out HObject imageMonotony)
        {
            IntPtr proc = HalconAPI.PreCall(1509);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMonotony);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Edge extraction using bandpass filters.</summary>
        /// <param name="image">Input images.</param>
        /// <param name="imageBandpass">Bandpass-filtered images.</param>
        /// <param name="filterType">Filter type: currently only 'lines' is supported. Default: "lines"</param>
        public static void BandpassImage(HObject image, out HObject imageBandpass, HTuple filterType)
        {
            IntPtr proc = HalconAPI.PreCall(1510);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filterType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filterType);
            int procResult = HObject.LoadNew(proc, 1, err, out imageBandpass);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect color lines and their width.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="lines">Extracted lines.</param>
        /// <param name="sigma">Amount of Gaussian smoothing to be applied. Default: 1.5</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 3</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 8</param>
        /// <param name="extractWidth">Should the line width be extracted? Default: "true"</param>
        /// <param name="completeJunctions">Should junctions be added where they cannot be extracted? Default: "true"</param>
        public static void LinesColor(
          HObject image,
          out HObject lines,
          HTuple sigma,
          HTuple low,
          HTuple high,
          HTuple extractWidth,
          HTuple completeJunctions)
        {
            IntPtr proc = HalconAPI.PreCall(1511);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, low);
            HalconAPI.Store(proc, 2, high);
            HalconAPI.Store(proc, 3, extractWidth);
            HalconAPI.Store(proc, 4, completeJunctions);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            HalconAPI.UnpinTuple(extractWidth);
            HalconAPI.UnpinTuple(completeJunctions);
            int procResult = HObject.LoadNew(proc, 1, err, out lines);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect lines and their width.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="lines">Extracted lines.</param>
        /// <param name="sigma">Amount of Gaussian smoothing to be applied. Default: 1.5</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 3</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 8</param>
        /// <param name="lightDark">Extract bright or dark lines. Default: "light"</param>
        /// <param name="extractWidth">Should the line width be extracted? Default: "true"</param>
        /// <param name="lineModel">Line model used to correct the line position and width. Default: "bar-shaped"</param>
        /// <param name="completeJunctions">Should junctions be added where they cannot be extracted? Default: "true"</param>
        public static void LinesGauss(
          HObject image,
          out HObject lines,
          HTuple sigma,
          HTuple low,
          HTuple high,
          HTuple lightDark,
          HTuple extractWidth,
          HTuple lineModel,
          HTuple completeJunctions)
        {
            IntPtr proc = HalconAPI.PreCall(1512);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, low);
            HalconAPI.Store(proc, 2, high);
            HalconAPI.Store(proc, 3, lightDark);
            HalconAPI.Store(proc, 4, extractWidth);
            HalconAPI.Store(proc, 5, lineModel);
            HalconAPI.Store(proc, 6, completeJunctions);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            HalconAPI.UnpinTuple(lightDark);
            HalconAPI.UnpinTuple(extractWidth);
            HalconAPI.UnpinTuple(lineModel);
            HalconAPI.UnpinTuple(completeJunctions);
            int procResult = HObject.LoadNew(proc, 1, err, out lines);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detection of lines using the facet model.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="lines">Extracted lines.</param>
        /// <param name="maskSize">Size of the facet model mask. Default: 5</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 3</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 8</param>
        /// <param name="lightDark">Extract bright or dark lines. Default: "light"</param>
        public static void LinesFacet(
          HObject image,
          out HObject lines,
          HTuple maskSize,
          HTuple low,
          HTuple high,
          HTuple lightDark)
        {
            IntPtr proc = HalconAPI.PreCall(1513);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskSize);
            HalconAPI.Store(proc, 1, low);
            HalconAPI.Store(proc, 2, high);
            HalconAPI.Store(proc, 3, lightDark);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            HalconAPI.UnpinTuple(lightDark);
            int procResult = HObject.LoadNew(proc, 1, err, out lines);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Store a filter mask in the spatial domain as a real-image.</summary>
        /// <param name="imageFilter">Filter in the spatial domain.</param>
        /// <param name="filterMask">Filter mask as file name or tuple. Default: "gauss"</param>
        /// <param name="scale">Scaling factor. Default: 1.0</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public static void GenFilterMask(
          out HObject imageFilter,
          HTuple filterMask,
          HTuple scale,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1514);
            HalconAPI.Store(proc, 0, filterMask);
            HalconAPI.Store(proc, 1, scale);
            HalconAPI.Store(proc, 2, width);
            HalconAPI.Store(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filterMask);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFilter);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate a mean filter in the frequency domain.</summary>
        /// <param name="imageMean">Mean filter as image in the frequency domain.</param>
        /// <param name="maskShape">Shape of the filter mask in the spatial domain. Default: "ellipse"</param>
        /// <param name="diameter1">Diameter of the mean filter in the principal direction of the filter in the spatial domain. Default: 11.0</param>
        /// <param name="diameter2">Diameter of the mean filter perpendicular to the principal direction of the filter in the spatial domain. Default: 11.0</param>
        /// <param name="phi">Principal direction of the filter in the spatial domain. Default: 0.0</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public static void GenMeanFilter(
          out HObject imageMean,
          HTuple maskShape,
          HTuple diameter1,
          HTuple diameter2,
          HTuple phi,
          HTuple norm,
          HTuple mode,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1515);
            HalconAPI.Store(proc, 0, maskShape);
            HalconAPI.Store(proc, 1, diameter1);
            HalconAPI.Store(proc, 2, diameter2);
            HalconAPI.Store(proc, 3, phi);
            HalconAPI.Store(proc, 4, norm);
            HalconAPI.Store(proc, 5, mode);
            HalconAPI.Store(proc, 6, width);
            HalconAPI.Store(proc, 7, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskShape);
            HalconAPI.UnpinTuple(diameter1);
            HalconAPI.UnpinTuple(diameter2);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMean);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate a Gaussian filter in the frequency domain.</summary>
        /// <param name="imageGauss">Gaussian filter as image in the frequency domain.</param>
        /// <param name="sigma1">Standard deviation of the Gaussian in the principal direction of the filter in the spatial domain. Default: 1.0</param>
        /// <param name="sigma2">Standard deviation of the Gaussian perpendicular to the principal direction of the filter in the spatial domain. Default: 1.0</param>
        /// <param name="phi">Principal direction of the filter in the spatial domain. Default: 0.0</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public static void GenGaussFilter(
          out HObject imageGauss,
          HTuple sigma1,
          HTuple sigma2,
          HTuple phi,
          HTuple norm,
          HTuple mode,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1516);
            HalconAPI.Store(proc, 0, sigma1);
            HalconAPI.Store(proc, 1, sigma2);
            HalconAPI.Store(proc, 2, phi);
            HalconAPI.Store(proc, 3, norm);
            HalconAPI.Store(proc, 4, mode);
            HalconAPI.Store(proc, 5, width);
            HalconAPI.Store(proc, 6, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma1);
            HalconAPI.UnpinTuple(sigma2);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageGauss);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate a derivative filter in the frequency domain.</summary>
        /// <param name="imageDerivative">Derivative filter as image in the frequency domain.</param>
        /// <param name="derivative">Derivative to be computed. Default: "x"</param>
        /// <param name="exponent">Exponent used in the reverse transform. Default: 1</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public static void GenDerivativeFilter(
          out HObject imageDerivative,
          HTuple derivative,
          HTuple exponent,
          HTuple norm,
          HTuple mode,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1517);
            HalconAPI.Store(proc, 0, derivative);
            HalconAPI.Store(proc, 1, exponent);
            HalconAPI.Store(proc, 2, norm);
            HalconAPI.Store(proc, 3, mode);
            HalconAPI.Store(proc, 4, width);
            HalconAPI.Store(proc, 5, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(derivative);
            HalconAPI.UnpinTuple(exponent);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageDerivative);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate a bandpass filter with Gaussian or sinusoidal shape.</summary>
        /// <param name="imageFilter">Bandpass filter as image in the frequency domain.</param>
        /// <param name="frequency">Distance of the filter's maximum from the DC term. Default: 0.1</param>
        /// <param name="sigma">Bandwidth of the filter (standard deviation). Default: 0.01</param>
        /// <param name="type">Filter type. Default: "sin"</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public static void GenStdBandpass(
          out HObject imageFilter,
          HTuple frequency,
          HTuple sigma,
          HTuple type,
          HTuple norm,
          HTuple mode,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1518);
            HalconAPI.Store(proc, 0, frequency);
            HalconAPI.Store(proc, 1, sigma);
            HalconAPI.Store(proc, 2, type);
            HalconAPI.Store(proc, 3, norm);
            HalconAPI.Store(proc, 4, mode);
            HalconAPI.Store(proc, 5, width);
            HalconAPI.Store(proc, 6, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(frequency);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFilter);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate a bandpass filter with sinusoidal shape.</summary>
        /// <param name="imageFilter">Bandpass filter as image in the frequency domain.</param>
        /// <param name="frequency">Distance of the filter's maximum from the DC term. Default: 0.1</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public static void GenSinBandpass(
          out HObject imageFilter,
          HTuple frequency,
          HTuple norm,
          HTuple mode,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1519);
            HalconAPI.Store(proc, 0, frequency);
            HalconAPI.Store(proc, 1, norm);
            HalconAPI.Store(proc, 2, mode);
            HalconAPI.Store(proc, 3, width);
            HalconAPI.Store(proc, 4, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(frequency);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFilter);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate an ideal band filter.</summary>
        /// <param name="imageFilter">Band filter in the frequency domain.</param>
        /// <param name="minFrequency">Minimum frequency. Default: 0.1</param>
        /// <param name="maxFrequency">Maximum frequency. Default: 0.2</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public static void GenBandfilter(
          out HObject imageFilter,
          HTuple minFrequency,
          HTuple maxFrequency,
          HTuple norm,
          HTuple mode,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1520);
            HalconAPI.Store(proc, 0, minFrequency);
            HalconAPI.Store(proc, 1, maxFrequency);
            HalconAPI.Store(proc, 2, norm);
            HalconAPI.Store(proc, 3, mode);
            HalconAPI.Store(proc, 4, width);
            HalconAPI.Store(proc, 5, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minFrequency);
            HalconAPI.UnpinTuple(maxFrequency);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFilter);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate an ideal bandpass filter.</summary>
        /// <param name="imageBandpass">Bandpass filter in the frequency domain.</param>
        /// <param name="minFrequency">Minimum frequency. Default: 0.1</param>
        /// <param name="maxFrequency">Maximum frequency. Default: 0.2</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public static void GenBandpass(
          out HObject imageBandpass,
          HTuple minFrequency,
          HTuple maxFrequency,
          HTuple norm,
          HTuple mode,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1521);
            HalconAPI.Store(proc, 0, minFrequency);
            HalconAPI.Store(proc, 1, maxFrequency);
            HalconAPI.Store(proc, 2, norm);
            HalconAPI.Store(proc, 3, mode);
            HalconAPI.Store(proc, 4, width);
            HalconAPI.Store(proc, 5, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minFrequency);
            HalconAPI.UnpinTuple(maxFrequency);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageBandpass);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate an ideal lowpass filter.</summary>
        /// <param name="imageLowpass">Lowpass filter in the frequency domain.</param>
        /// <param name="frequency">Cutoff frequency. Default: 0.1</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public static void GenLowpass(
          out HObject imageLowpass,
          HTuple frequency,
          HTuple norm,
          HTuple mode,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1522);
            HalconAPI.Store(proc, 0, frequency);
            HalconAPI.Store(proc, 1, norm);
            HalconAPI.Store(proc, 2, mode);
            HalconAPI.Store(proc, 3, width);
            HalconAPI.Store(proc, 4, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(frequency);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageLowpass);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate an ideal highpass filter.</summary>
        /// <param name="imageHighpass">Highpass filter in the frequency domain.</param>
        /// <param name="frequency">Cutoff frequency. Default: 0.1</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public static void GenHighpass(
          out HObject imageHighpass,
          HTuple frequency,
          HTuple norm,
          HTuple mode,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1523);
            HalconAPI.Store(proc, 0, frequency);
            HalconAPI.Store(proc, 1, norm);
            HalconAPI.Store(proc, 2, mode);
            HalconAPI.Store(proc, 3, width);
            HalconAPI.Store(proc, 4, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(frequency);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageHighpass);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the power spectrum of a complex image.</summary>
        /// <param name="image">Input image in frequency domain.</param>
        /// <param name="imageResult">Power spectrum of the input image.</param>
        public static void PowerLn(HObject image, out HObject imageResult)
        {
            IntPtr proc = HalconAPI.PreCall(1524);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Return the power spectrum of a complex image.</summary>
        /// <param name="image">Input image in frequency domain.</param>
        /// <param name="imageResult">Power spectrum of the input image.</param>
        public static void PowerReal(HObject image, out HObject imageResult)
        {
            IntPtr proc = HalconAPI.PreCall(1525);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Return the power spectrum of a complex image.</summary>
        /// <param name="image">Input image in frequency domain.</param>
        /// <param name="powerByte">Power spectrum of the input image.</param>
        public static void PowerByte(HObject image, out HObject powerByte)
        {
            IntPtr proc = HalconAPI.PreCall(1526);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out powerByte);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Return the phase of a complex image in degrees.</summary>
        /// <param name="imageComplex">Input image in frequency domain.</param>
        /// <param name="imagePhase">Phase of the image in degrees.</param>
        public static void PhaseDeg(HObject imageComplex, out HObject imagePhase)
        {
            IntPtr proc = HalconAPI.PreCall(1527);
            HalconAPI.Store(proc, 1, (HObjectBase)imageComplex);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imagePhase);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageComplex);
        }

        /// <summary>Return the phase of a complex image in radians.</summary>
        /// <param name="imageComplex">Input image in frequency domain.</param>
        /// <param name="imagePhase">Phase of the image in radians.</param>
        public static void PhaseRad(HObject imageComplex, out HObject imagePhase)
        {
            IntPtr proc = HalconAPI.PreCall(1528);
            HalconAPI.Store(proc, 1, (HObjectBase)imageComplex);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imagePhase);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageComplex);
        }

        /// <summary>Calculate the energy of a two-channel image.</summary>
        /// <param name="imageGabor">1st channel of input image (usually: Gabor image).</param>
        /// <param name="imageHilbert">2nd channel of input image (usually: Hilbert image).</param>
        /// <param name="energy">Image containing the local energy.</param>
        public static void EnergyGabor(HObject imageGabor, HObject imageHilbert, out HObject energy)
        {
            IntPtr proc = HalconAPI.PreCall(1529);
            HalconAPI.Store(proc, 1, (HObjectBase)imageGabor);
            HalconAPI.Store(proc, 2, (HObjectBase)imageHilbert);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out energy);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageGabor);
            GC.KeepAlive((object)imageHilbert);
        }

        /// <summary>Convolve an image with a Gabor filter in the frequency domain.</summary>
        /// <param name="imageFFT">Input image.</param>
        /// <param name="gaborFilter">Gabor/Hilbert-Filter.</param>
        /// <param name="imageResultGabor">Result of the Gabor filter.</param>
        /// <param name="imageResultHilbert">Result of the Hilbert filter.</param>
        public static void ConvolGabor(
          HObject imageFFT,
          HObject gaborFilter,
          out HObject imageResultGabor,
          out HObject imageResultHilbert)
        {
            IntPtr proc = HalconAPI.PreCall(1530);
            HalconAPI.Store(proc, 1, (HObjectBase)imageFFT);
            HalconAPI.Store(proc, 2, (HObjectBase)gaborFilter);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out imageResultGabor);
            int procResult = HObject.LoadNew(proc, 2, err2, out imageResultHilbert);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageFFT);
            GC.KeepAlive((object)gaborFilter);
        }

        /// <summary>Generate a Gabor filter.</summary>
        /// <param name="imageFilter">Gabor and Hilbert filter.</param>
        /// <param name="angle">Angle range, inversely proportional to the range of orientations. Default: 1.4</param>
        /// <param name="frequency">Distance of the center of the filter to the DC term. Default: 0.4</param>
        /// <param name="bandwidth">Bandwidth range, inversely proportional to the range of frequencies being passed. Default: 1.0</param>
        /// <param name="orientation">Angle of the principal orientation. Default: 1.5</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public static void GenGabor(
          out HObject imageFilter,
          HTuple angle,
          HTuple frequency,
          HTuple bandwidth,
          HTuple orientation,
          HTuple norm,
          HTuple mode,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1531);
            HalconAPI.Store(proc, 0, angle);
            HalconAPI.Store(proc, 1, frequency);
            HalconAPI.Store(proc, 2, bandwidth);
            HalconAPI.Store(proc, 3, orientation);
            HalconAPI.Store(proc, 4, norm);
            HalconAPI.Store(proc, 5, mode);
            HalconAPI.Store(proc, 6, width);
            HalconAPI.Store(proc, 7, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(angle);
            HalconAPI.UnpinTuple(frequency);
            HalconAPI.UnpinTuple(bandwidth);
            HalconAPI.UnpinTuple(orientation);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFilter);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the phase correlation of two images in the frequency domain.</summary>
        /// <param name="imageFFT1">Fourier-transformed input image 1.</param>
        /// <param name="imageFFT2">Fourier-transformed input image 2.</param>
        /// <param name="imagePhaseCorrelation">Phase correlation of the input images in the frequency domain.</param>
        public static void PhaseCorrelationFft(
          HObject imageFFT1,
          HObject imageFFT2,
          out HObject imagePhaseCorrelation)
        {
            IntPtr proc = HalconAPI.PreCall(1532);
            HalconAPI.Store(proc, 1, (HObjectBase)imageFFT1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageFFT2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imagePhaseCorrelation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageFFT1);
            GC.KeepAlive((object)imageFFT2);
        }

        /// <summary>Compute the correlation of two images in the frequency domain.</summary>
        /// <param name="imageFFT1">Fourier-transformed input image 1.</param>
        /// <param name="imageFFT2">Fourier-transformed input image 2.</param>
        /// <param name="imageCorrelation">Correlation of the input images in the frequency domain.</param>
        public static void CorrelationFft(
          HObject imageFFT1,
          HObject imageFFT2,
          out HObject imageCorrelation)
        {
            IntPtr proc = HalconAPI.PreCall(1533);
            HalconAPI.Store(proc, 1, (HObjectBase)imageFFT1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageFFT2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageCorrelation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageFFT1);
            GC.KeepAlive((object)imageFFT2);
        }

        /// <summary>Convolve an image with a filter in the frequency domain.</summary>
        /// <param name="imageFFT">Complex input image.</param>
        /// <param name="imageFilter">Filter in frequency domain.</param>
        /// <param name="imageConvol">Result of applying the filter.</param>
        public static void ConvolFft(HObject imageFFT, HObject imageFilter, out HObject imageConvol)
        {
            IntPtr proc = HalconAPI.PreCall(1534);
            HalconAPI.Store(proc, 1, (HObjectBase)imageFFT);
            HalconAPI.Store(proc, 2, (HObjectBase)imageFilter);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageConvol);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageFFT);
            GC.KeepAlive((object)imageFilter);
        }

        /// <summary>Deserialize FFT speed optimization data.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void DeserializeFftOptimizationData(HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1535);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize FFT speed optimization data.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeFftOptimizationData(out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1536);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Load FFT speed optimization data from a file.</summary>
        /// <param name="fileName">File name of the optimization data. Default: "fft_opt.dat"</param>
        public static void ReadFftOptimizationData(HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1537);
            HalconAPI.Store(proc, 0, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Store FFT speed optimization data in a file.</summary>
        /// <param name="fileName">File name of the optimization data. Default: "fft_opt.dat"</param>
        public static void WriteFftOptimizationData(HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1538);
            HalconAPI.Store(proc, 0, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Optimize the runtime of the real-valued FFT.</summary>
        /// <param name="width">Width of the image for which the runtime should be optimized. Default: 512</param>
        /// <param name="height">Height of the image for which the runtime should be optimized. Default: 512</param>
        /// <param name="mode">Thoroughness of the search for the optimum runtime. Default: "standard"</param>
        public static void OptimizeRftSpeed(HTuple width, HTuple height, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1539);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.Store(proc, 2, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Optimize the runtime of the FFT.</summary>
        /// <param name="width">Width of the image for which the runtime should be optimized. Default: 512</param>
        /// <param name="height">Height of the image for which the runtime should be optimized. Default: 512</param>
        /// <param name="mode">Thoroughness of the search for the optimum runtime. Default: "standard"</param>
        public static void OptimizeFftSpeed(HTuple width, HTuple height, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1540);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.Store(proc, 2, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the real-valued fast Fourier transform of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageFFT">Fourier-transformed image.</param>
        /// <param name="direction">Calculate forward or reverse transform. Default: "to_freq"</param>
        /// <param name="norm">Normalizing factor of the transform. Default: "sqrt"</param>
        /// <param name="resultType">Image type of the output image. Default: "complex"</param>
        /// <param name="width">Width of the image for which the runtime should be optimized. Default: 512</param>
        public static void RftGeneric(
          HObject image,
          out HObject imageFFT,
          HTuple direction,
          HTuple norm,
          HTuple resultType,
          HTuple width)
        {
            IntPtr proc = HalconAPI.PreCall(1541);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, direction);
            HalconAPI.Store(proc, 1, norm);
            HalconAPI.Store(proc, 2, resultType);
            HalconAPI.Store(proc, 3, width);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(direction);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(resultType);
            HalconAPI.UnpinTuple(width);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFFT);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute the inverse fast Fourier transform of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageFFTInv">Inverse-Fourier-transformed image.</param>
        public static void FftImageInv(HObject image, out HObject imageFFTInv)
        {
            IntPtr proc = HalconAPI.PreCall(1542);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFFTInv);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute the fast Fourier transform of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageFFT">Fourier-transformed image.</param>
        public static void FftImage(HObject image, out HObject imageFFT)
        {
            IntPtr proc = HalconAPI.PreCall(1543);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFFT);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute the fast Fourier transform of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageFFT">Fourier-transformed image.</param>
        /// <param name="direction">Calculate forward or reverse transform. Default: "to_freq"</param>
        /// <param name="exponent">Sign of the exponent. Default: -1</param>
        /// <param name="norm">Normalizing factor of the transform. Default: "sqrt"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="resultType">Image type of the output image. Default: "complex"</param>
        public static void FftGeneric(
          HObject image,
          out HObject imageFFT,
          HTuple direction,
          HTuple exponent,
          HTuple norm,
          HTuple mode,
          HTuple resultType)
        {
            IntPtr proc = HalconAPI.PreCall(1544);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, direction);
            HalconAPI.Store(proc, 1, exponent);
            HalconAPI.Store(proc, 2, norm);
            HalconAPI.Store(proc, 3, mode);
            HalconAPI.Store(proc, 4, resultType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(direction);
            HalconAPI.UnpinTuple(exponent);
            HalconAPI.UnpinTuple(norm);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(resultType);
            int procResult = HObject.LoadNew(proc, 1, err, out imageFFT);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Apply a shock filter to an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="sharpenedImage">Output image.</param>
        /// <param name="theta">Time step. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        /// <param name="mode">Type of edge detector. Default: "canny"</param>
        /// <param name="sigma">Smoothing of edge detector. Default: 1.0</param>
        public static void ShockFilter(
          HObject image,
          out HObject sharpenedImage,
          HTuple theta,
          HTuple iterations,
          HTuple mode,
          HTuple sigma)
        {
            IntPtr proc = HalconAPI.PreCall(1545);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, theta);
            HalconAPI.Store(proc, 1, iterations);
            HalconAPI.Store(proc, 2, mode);
            HalconAPI.Store(proc, 3, sigma);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(theta);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(sigma);
            int procResult = HObject.LoadNew(proc, 1, err, out sharpenedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Apply the mean curvature flow to an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageMCF">Output image.</param>
        /// <param name="sigma">Smoothing parameter for derivative operator. Default: 0.5</param>
        /// <param name="theta">Time step. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        public static void MeanCurvatureFlow(
          HObject image,
          out HObject imageMCF,
          HTuple sigma,
          HTuple theta,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1546);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, theta);
            HalconAPI.Store(proc, 2, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(theta);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMCF);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Perform a coherence enhancing diffusion of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageCED">Output image.</param>
        /// <param name="sigma">Smoothing for derivative operator. Default: 0.5</param>
        /// <param name="rho">Smoothing for diffusion coefficients. Default: 3.0</param>
        /// <param name="theta">Time step. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        public static void CoherenceEnhancingDiff(
          HObject image,
          out HObject imageCED,
          HTuple sigma,
          HTuple rho,
          HTuple theta,
          HTuple iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1547);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, rho);
            HalconAPI.Store(proc, 2, theta);
            HalconAPI.Store(proc, 3, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(rho);
            HalconAPI.UnpinTuple(theta);
            HalconAPI.UnpinTuple(iterations);
            int procResult = HObject.LoadNew(proc, 1, err, out imageCED);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Histogram linearization of images</summary>
        /// <param name="image">Image to be enhanced.</param>
        /// <param name="imageEquHisto">Image with linearized gray values.</param>
        public static void EquHistoImage(HObject image, out HObject imageEquHisto)
        {
            IntPtr proc = HalconAPI.PreCall(1548);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageEquHisto);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Illuminate image.</summary>
        /// <param name="image">Image to be enhanced.</param>
        /// <param name="imageIlluminate">"`Illuminated"' image.</param>
        /// <param name="maskWidth">Width of low pass mask. Default: 101</param>
        /// <param name="maskHeight">Height of low pass mask. Default: 101</param>
        /// <param name="factor">Scales the "`correction gray value"' added to the original gray values. Default: 0.7</param>
        public static void Illuminate(
          HObject image,
          out HObject imageIlluminate,
          HTuple maskWidth,
          HTuple maskHeight,
          HTuple factor)
        {
            IntPtr proc = HalconAPI.PreCall(1549);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.Store(proc, 2, factor);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(factor);
            int procResult = HObject.LoadNew(proc, 1, err, out imageIlluminate);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Enhance contrast of the image.</summary>
        /// <param name="image">Image to be enhanced.</param>
        /// <param name="imageEmphasize">contrast enhanced image.</param>
        /// <param name="maskWidth">Width of low pass mask. Default: 7</param>
        /// <param name="maskHeight">Height of the low pass mask. Default: 7</param>
        /// <param name="factor">Intensity of contrast emphasis. Default: 1.0</param>
        public static void Emphasize(
          HObject image,
          out HObject imageEmphasize,
          HTuple maskWidth,
          HTuple maskHeight,
          HTuple factor)
        {
            IntPtr proc = HalconAPI.PreCall(1550);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, maskWidth);
            HalconAPI.Store(proc, 1, maskHeight);
            HalconAPI.Store(proc, 2, factor);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskWidth);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(factor);
            int procResult = HObject.LoadNew(proc, 1, err, out imageEmphasize);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Maximum gray value spreading in the value range 0 to 255.</summary>
        /// <param name="image">Image to be scaled.</param>
        /// <param name="imageScaleMax">contrast enhanced image.</param>
        public static void ScaleImageMax(HObject image, out HObject imageScaleMax)
        {
            IntPtr proc = HalconAPI.PreCall(1551);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageScaleMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect edges (amplitude and direction) using the Robinson operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageEdgeAmp">Edge amplitude (gradient magnitude) image.</param>
        /// <param name="imageEdgeDir">Edge direction image.</param>
        public static void RobinsonDir(
          HObject image,
          out HObject imageEdgeAmp,
          out HObject imageEdgeDir)
        {
            IntPtr proc = HalconAPI.PreCall(1552);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out imageEdgeAmp);
            int procResult = HObject.LoadNew(proc, 2, err2, out imageEdgeDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect edges (amplitude) using the Robinson operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageEdgeAmp">Edge amplitude (gradient magnitude) image.</param>
        public static void RobinsonAmp(HObject image, out HObject imageEdgeAmp)
        {
            IntPtr proc = HalconAPI.PreCall(1553);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageEdgeAmp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect edges (amplitude and direction) using the Kirsch operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageEdgeAmp">Edge amplitude (gradient magnitude) image.</param>
        /// <param name="imageEdgeDir">Edge direction image.</param>
        public static void KirschDir(HObject image, out HObject imageEdgeAmp, out HObject imageEdgeDir)
        {
            IntPtr proc = HalconAPI.PreCall(1554);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out imageEdgeAmp);
            int procResult = HObject.LoadNew(proc, 2, err2, out imageEdgeDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect edges (amplitude) using the Kirsch operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageEdgeAmp">Edge amplitude (gradient magnitude) image.</param>
        public static void KirschAmp(HObject image, out HObject imageEdgeAmp)
        {
            IntPtr proc = HalconAPI.PreCall(1555);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageEdgeAmp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect edges (amplitude and direction) using the Frei-Chen operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageEdgeAmp">Edge amplitude (gradient magnitude) image.</param>
        /// <param name="imageEdgeDir">Edge direction image.</param>
        public static void FreiDir(HObject image, out HObject imageEdgeAmp, out HObject imageEdgeDir)
        {
            IntPtr proc = HalconAPI.PreCall(1556);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out imageEdgeAmp);
            int procResult = HObject.LoadNew(proc, 2, err2, out imageEdgeDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect edges (amplitude) using the Frei-Chen operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageEdgeAmp">Edge amplitude (gradient magnitude) image.</param>
        public static void FreiAmp(HObject image, out HObject imageEdgeAmp)
        {
            IntPtr proc = HalconAPI.PreCall(1557);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageEdgeAmp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect edges (amplitude and direction) using the Prewitt operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageEdgeAmp">Edge amplitude (gradient magnitude) image.</param>
        /// <param name="imageEdgeDir">Edge direction image.</param>
        public static void PrewittDir(
          HObject image,
          out HObject imageEdgeAmp,
          out HObject imageEdgeDir)
        {
            IntPtr proc = HalconAPI.PreCall(1558);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HObject.LoadNew(proc, 1, err1, out imageEdgeAmp);
            int procResult = HObject.LoadNew(proc, 2, err2, out imageEdgeDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect edges (amplitude) using the Prewitt operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageEdgeAmp">Edge amplitude (gradient magnitude) image.</param>
        public static void PrewittAmp(HObject image, out HObject imageEdgeAmp)
        {
            IntPtr proc = HalconAPI.PreCall(1559);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageEdgeAmp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect edges (amplitude) using the Sobel operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="edgeAmplitude">Edge amplitude (gradient magnitude) image.</param>
        /// <param name="filterType">Filter type. Default: "sum_abs"</param>
        /// <param name="size">Size of filter mask. Default: 3</param>
        public static void SobelAmp(
          HObject image,
          out HObject edgeAmplitude,
          HTuple filterType,
          HTuple size)
        {
            IntPtr proc = HalconAPI.PreCall(1560);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filterType);
            HalconAPI.Store(proc, 1, size);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filterType);
            HalconAPI.UnpinTuple(size);
            int procResult = HObject.LoadNew(proc, 1, err, out edgeAmplitude);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect edges (amplitude and direction) using the Sobel operator.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="edgeAmplitude">Edge amplitude (gradient magnitude) image.</param>
        /// <param name="edgeDirection">Edge direction image.</param>
        /// <param name="filterType">Filter type. Default: "sum_abs"</param>
        /// <param name="size">Size of filter mask. Default: 3</param>
        public static void SobelDir(
          HObject image,
          out HObject edgeAmplitude,
          out HObject edgeDirection,
          HTuple filterType,
          HTuple size)
        {
            IntPtr proc = HalconAPI.PreCall(1561);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filterType);
            HalconAPI.Store(proc, 1, size);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filterType);
            HalconAPI.UnpinTuple(size);
            int err2 = HObject.LoadNew(proc, 1, err1, out edgeAmplitude);
            int procResult = HObject.LoadNew(proc, 2, err2, out edgeDirection);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect edges using the Roberts filter.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageRoberts">Roberts-filtered result images.</param>
        /// <param name="filterType">Filter type. Default: "gradient_sum"</param>
        public static void Roberts(HObject image, out HObject imageRoberts, HTuple filterType)
        {
            IntPtr proc = HalconAPI.PreCall(1562);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filterType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filterType);
            int procResult = HObject.LoadNew(proc, 1, err, out imageRoberts);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the Laplace operator by using finite differences.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageLaplace">Laplace-filtered result image.</param>
        /// <param name="resultType">Type of the result image, whereas for byte and uint2 the absolute value is used. Default: "absolute"</param>
        /// <param name="maskSize">Size of filter mask. Default: 3</param>
        /// <param name="filterMask">Filter mask used in the Laplace operator Default: "n_4"</param>
        public static void Laplace(
          HObject image,
          out HObject imageLaplace,
          HTuple resultType,
          HTuple maskSize,
          HTuple filterMask)
        {
            IntPtr proc = HalconAPI.PreCall(1563);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, resultType);
            HalconAPI.Store(proc, 1, maskSize);
            HalconAPI.Store(proc, 2, filterMask);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(resultType);
            HalconAPI.UnpinTuple(maskSize);
            HalconAPI.UnpinTuple(filterMask);
            int procResult = HObject.LoadNew(proc, 1, err, out imageLaplace);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract high frequency components from an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="highpass">High-pass-filtered result image.</param>
        /// <param name="width">Width of the filter mask. Default: 9</param>
        /// <param name="height">Height of the filter mask. Default: 9</param>
        public static void HighpassImage(
          HObject image,
          out HObject highpass,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1564);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out highpass);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Estimate the width of a filter in edges_image.</summary>
        /// <param name="filter">Name of the edge operator. Default: "lanser2"</param>
        /// <param name="mode">1D edge filter ('edge') or 1D smoothing filter ('smooth'). Default: "edge"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 0.5</param>
        /// <param name="size">Filter width in pixels.</param>
        /// <param name="coeffs">For Canny filters: Coefficients of the "positive" half of the 1D impulse response.</param>
        public static void InfoEdges(
          HTuple filter,
          HTuple mode,
          HTuple alpha,
          out HTuple size,
          out HTuple coeffs)
        {
            IntPtr proc = HalconAPI.PreCall(1565);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, mode);
            HalconAPI.Store(proc, 2, alpha);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(alpha);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out size);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out coeffs);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Extract subpixel precise color edges using Deriche, Shen, or Canny filters.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="edges">Extracted edges.</param>
        /// <param name="filter">Edge operator to be applied. Default: "canny"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 1.0</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 20</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 40</param>
        public static void EdgesColorSubPix(
          HObject image,
          out HObject edges,
          HTuple filter,
          HTuple alpha,
          HTuple low,
          HTuple high)
        {
            IntPtr proc = HalconAPI.PreCall(1566);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, alpha);
            HalconAPI.Store(proc, 2, low);
            HalconAPI.Store(proc, 3, high);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            int procResult = HObject.LoadNew(proc, 1, err, out edges);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract color edges using Canny, Deriche, or Shen filters.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imaAmp">Edge amplitude (gradient magnitude) image.</param>
        /// <param name="imaDir">Edge direction image.</param>
        /// <param name="filter">Edge operator to be applied. Default: "canny"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 1.0</param>
        /// <param name="NMS">Non-maximum suppression ('none', if not desired). Default: "nms"</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation (negative if no thresholding is desired). Default: 20</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation (negative if no thresholding is desired). Default: 40</param>
        public static void EdgesColor(
          HObject image,
          out HObject imaAmp,
          out HObject imaDir,
          HTuple filter,
          HTuple alpha,
          HTuple NMS,
          HTuple low,
          HTuple high)
        {
            IntPtr proc = HalconAPI.PreCall(1567);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, alpha);
            HalconAPI.Store(proc, 2, NMS);
            HalconAPI.Store(proc, 3, low);
            HalconAPI.Store(proc, 4, high);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.UnpinTuple(NMS);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            int err2 = HObject.LoadNew(proc, 1, err1, out imaAmp);
            int procResult = HObject.LoadNew(proc, 2, err2, out imaDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract sub-pixel precise edges using Deriche, Lanser, Shen, or Canny filters.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="edges">Extracted edges.</param>
        /// <param name="filter">Edge operator to be applied. Default: "canny"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 1.0</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 20</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 40</param>
        public static void EdgesSubPix(
          HObject image,
          out HObject edges,
          HTuple filter,
          HTuple alpha,
          HTuple low,
          HTuple high)
        {
            IntPtr proc = HalconAPI.PreCall(1568);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, alpha);
            HalconAPI.Store(proc, 2, low);
            HalconAPI.Store(proc, 3, high);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            int procResult = HObject.LoadNew(proc, 1, err, out edges);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract edges using Deriche, Lanser, Shen, or Canny filters.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imaAmp">Edge amplitude (gradient magnitude) image.</param>
        /// <param name="imaDir">Edge direction image.</param>
        /// <param name="filter">Edge operator to be applied. Default: "canny"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 1.0</param>
        /// <param name="NMS">Non-maximum suppression ('none', if not desired). Default: "nms"</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation (negative, if no thresholding is desired). Default: 20</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation (negative, if no thresholding is desired). Default: 40</param>
        public static void EdgesImage(
          HObject image,
          out HObject imaAmp,
          out HObject imaDir,
          HTuple filter,
          HTuple alpha,
          HTuple NMS,
          HTuple low,
          HTuple high)
        {
            IntPtr proc = HalconAPI.PreCall(1569);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, alpha);
            HalconAPI.Store(proc, 2, NMS);
            HalconAPI.Store(proc, 3, low);
            HalconAPI.Store(proc, 4, high);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.UnpinTuple(NMS);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            int err2 = HObject.LoadNew(proc, 1, err1, out imaAmp);
            int procResult = HObject.LoadNew(proc, 2, err2, out imaDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Convolve an image with derivatives of the Gaussian.</summary>
        /// <param name="image">Input images.</param>
        /// <param name="derivGauss">Filtered result images.</param>
        /// <param name="sigma">Sigma of the Gaussian. Default: 1.0</param>
        /// <param name="component">Derivative or feature to be calculated. Default: "x"</param>
        public static void DerivateGauss(
          HObject image,
          out HObject derivGauss,
          HTuple sigma,
          HTuple component)
        {
            IntPtr proc = HalconAPI.PreCall(1570);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, component);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(component);
            int procResult = HObject.LoadNew(proc, 1, err, out derivGauss);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>LoG-Operator (Laplace of Gaussian).</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageLaplace">Laplace filtered image.</param>
        /// <param name="sigma">Smoothing parameter of the Gaussian. Default: 2.0</param>
        public static void LaplaceOfGauss(HObject image, out HObject imageLaplace, HTuple sigma)
        {
            IntPtr proc = HalconAPI.PreCall(1571);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            int procResult = HObject.LoadNew(proc, 1, err, out imageLaplace);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Approximate the LoG operator (Laplace of Gaussian).</summary>
        /// <param name="image">Input image</param>
        /// <param name="diffOfGauss">LoG image.</param>
        /// <param name="sigma">Smoothing parameter of the Laplace operator to approximate. Default: 3.0</param>
        /// <param name="sigFactor">Ratio of the standard deviations used (Marr recommends 1.6). Default: 1.6</param>
        public static void DiffOfGauss(
          HObject image,
          out HObject diffOfGauss,
          HTuple sigma,
          HTuple sigFactor)
        {
            IntPtr proc = HalconAPI.PreCall(1572);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, sigFactor);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(sigFactor);
            int procResult = HObject.LoadNew(proc, 1, err, out diffOfGauss);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Close edge gaps using the edge amplitude image.</summary>
        /// <param name="edges">Region containing one pixel thick edges.</param>
        /// <param name="gradient">Edge amplitude (gradient) image.</param>
        /// <param name="closedEdges">Region containing closed edges.</param>
        /// <param name="minAmplitude">Minimum edge amplitude. Default: 16</param>
        /// <param name="maxGapLength">Maximal number of points by which edges are extended. Default: 3</param>
        public static void CloseEdgesLength(
          HObject edges,
          HObject gradient,
          out HObject closedEdges,
          HTuple minAmplitude,
          HTuple maxGapLength)
        {
            IntPtr proc = HalconAPI.PreCall(1573);
            HalconAPI.Store(proc, 1, (HObjectBase)edges);
            HalconAPI.Store(proc, 2, (HObjectBase)gradient);
            HalconAPI.Store(proc, 0, minAmplitude);
            HalconAPI.Store(proc, 1, maxGapLength);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minAmplitude);
            HalconAPI.UnpinTuple(maxGapLength);
            int procResult = HObject.LoadNew(proc, 1, err, out closedEdges);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)edges);
            GC.KeepAlive((object)gradient);
        }

        /// <summary>Close edge gaps using the edge amplitude image.</summary>
        /// <param name="edges">Region containing one pixel thick edges.</param>
        /// <param name="edgeImage">Edge amplitude (gradient) image.</param>
        /// <param name="regionResult">Region containing closed edges.</param>
        /// <param name="minAmplitude">Minimum edge amplitude. Default: 16</param>
        public static void CloseEdges(
          HObject edges,
          HObject edgeImage,
          out HObject regionResult,
          HTuple minAmplitude)
        {
            IntPtr proc = HalconAPI.PreCall(1574);
            HalconAPI.Store(proc, 1, (HObjectBase)edges);
            HalconAPI.Store(proc, 2, (HObjectBase)edgeImage);
            HalconAPI.Store(proc, 0, minAmplitude);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minAmplitude);
            int procResult = HObject.LoadNew(proc, 1, err, out regionResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)edges);
            GC.KeepAlive((object)edgeImage);
        }

        /// <summary>Detect straight edge segments.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="sobelSize">Mask size of the Sobel operator. Default: 5</param>
        /// <param name="minAmplitude">Minimum edge strength. Default: 32</param>
        /// <param name="maxDistance">Maximum distance of the approximating line to its original edge. Default: 3</param>
        /// <param name="minLength">Minimum length of to resulting line segments. Default: 10</param>
        /// <param name="beginRow">Row coordinate of the line segments' start points.</param>
        /// <param name="beginCol">Column coordinate of the line segments' start points.</param>
        /// <param name="endRow">Row coordinate of the line segments' end points.</param>
        /// <param name="endCol">Column coordinate of the line segments' end points.</param>
        public static void DetectEdgeSegments(
          HObject image,
          HTuple sobelSize,
          HTuple minAmplitude,
          HTuple maxDistance,
          HTuple minLength,
          out HTuple beginRow,
          out HTuple beginCol,
          out HTuple endRow,
          out HTuple endCol)
        {
            IntPtr proc = HalconAPI.PreCall(1575);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, sobelSize);
            HalconAPI.Store(proc, 1, minAmplitude);
            HalconAPI.Store(proc, 2, maxDistance);
            HalconAPI.Store(proc, 3, minLength);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sobelSize);
            HalconAPI.UnpinTuple(minAmplitude);
            HalconAPI.UnpinTuple(maxDistance);
            HalconAPI.UnpinTuple(minLength);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out beginRow);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out beginCol);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out endRow);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out endCol);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Delete all look-up-tables of the color space transformation.</summary>
        public static void ClearAllColorTransLuts()
        {
            IntPtr proc = HalconAPI.PreCall(1576);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Release the look-up-table needed for color space transformation.</summary>
        /// <param name="colorTransLUTHandle">Handle of the look-up-table handle for the color space transformation.</param>
        public static void ClearColorTransLut(HTuple colorTransLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1577);
            HalconAPI.Store(proc, 0, colorTransLUTHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(colorTransLUTHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Color space transformation using pre-generated look-up-table.</summary>
        /// <param name="image1">Input image (channel 2).</param>
        /// <param name="image2">Input image (channel 2).</param>
        /// <param name="image3">Input image (channel 3).</param>
        /// <param name="imageResult1">Color-transformed output image (channel 1).</param>
        /// <param name="imageResult2">Color-transformed output image (channel 2).</param>
        /// <param name="imageResult3">Color-transformed output image (channel 3).</param>
        /// <param name="colorTransLUTHandle">Handle of the look-up-table for the color space transformation.</param>
        public static void ApplyColorTransLut(
          HObject image1,
          HObject image2,
          HObject image3,
          out HObject imageResult1,
          out HObject imageResult2,
          out HObject imageResult3,
          HTuple colorTransLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1578);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.Store(proc, 0, colorTransLUTHandle);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(colorTransLUTHandle);
            int err2 = HObject.LoadNew(proc, 1, err1, out imageResult1);
            int err3 = HObject.LoadNew(proc, 2, err2, out imageResult2);
            int procResult = HObject.LoadNew(proc, 3, err3, out imageResult3);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
        }

        /// <summary>Creates the look-up-table for transformation of an image from the RGB color space to an arbitrary color space.</summary>
        /// <param name="colorSpace">Color space of the output image. Default: "hsv"</param>
        /// <param name="transDirection">Direction of color space transformation. Default: "from_rgb"</param>
        /// <param name="numBits">Number of bits of the input image. Default: 8</param>
        /// <param name="colorTransLUTHandle">Handle of the look-up-table for color space transformation.</param>
        public static void CreateColorTransLut(
          HTuple colorSpace,
          HTuple transDirection,
          HTuple numBits,
          out HTuple colorTransLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1579);
            HalconAPI.Store(proc, 0, colorSpace);
            HalconAPI.Store(proc, 1, transDirection);
            HalconAPI.Store(proc, 2, numBits);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(colorSpace);
            HalconAPI.UnpinTuple(transDirection);
            HalconAPI.UnpinTuple(numBits);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out colorTransLUTHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a single-channel color filter array image into an RGB image.</summary>
        /// <param name="CFAImage">Input image.</param>
        /// <param name="RGBImage">Output image.</param>
        /// <param name="CFAType">Color filter array type. Default: "bayer_gb"</param>
        /// <param name="interpolation">Interpolation type. Default: "bilinear"</param>
        public static void CfaToRgb(
          HObject CFAImage,
          out HObject RGBImage,
          HTuple CFAType,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1580);
            HalconAPI.Store(proc, 1, (HObjectBase)CFAImage);
            HalconAPI.Store(proc, 0, CFAType);
            HalconAPI.Store(proc, 1, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(CFAType);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HObject.LoadNew(proc, 1, err, out RGBImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)CFAImage);
        }

        /// <summary>Transform an RGB image into a gray scale image.</summary>
        /// <param name="RGBImage">Three-channel RBG image.</param>
        /// <param name="grayImage">Gray scale image.</param>
        public static void Rgb1ToGray(HObject RGBImage, out HObject grayImage)
        {
            IntPtr proc = HalconAPI.PreCall(1581);
            HalconAPI.Store(proc, 1, (HObjectBase)RGBImage);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out grayImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)RGBImage);
        }

        /// <summary>Transform an RGB image to a gray scale image.</summary>
        /// <param name="imageRed">Input image (red channel).</param>
        /// <param name="imageGreen">Input image (green channel).</param>
        /// <param name="imageBlue">Input image (blue channel).</param>
        /// <param name="imageGray">Gray scale image.</param>
        public static void Rgb3ToGray(
          HObject imageRed,
          HObject imageGreen,
          HObject imageBlue,
          out HObject imageGray)
        {
            IntPtr proc = HalconAPI.PreCall(1582);
            HalconAPI.Store(proc, 1, (HObjectBase)imageRed);
            HalconAPI.Store(proc, 2, (HObjectBase)imageGreen);
            HalconAPI.Store(proc, 3, (HObjectBase)imageBlue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageGray);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageRed);
            GC.KeepAlive((object)imageGreen);
            GC.KeepAlive((object)imageBlue);
        }

        /// <summary>Transform an image from the RGB color space to an arbitrary color space.</summary>
        /// <param name="imageRed">Input image (red channel).</param>
        /// <param name="imageGreen">Input image (green channel).</param>
        /// <param name="imageBlue">Input image (blue channel).</param>
        /// <param name="imageResult1">Color-transformed output image (channel 1).</param>
        /// <param name="imageResult2">Color-transformed output image (channel 1).</param>
        /// <param name="imageResult3">Color-transformed output image (channel 1).</param>
        /// <param name="colorSpace">Color space of the output image. Default: "hsv"</param>
        public static void TransFromRgb(
          HObject imageRed,
          HObject imageGreen,
          HObject imageBlue,
          out HObject imageResult1,
          out HObject imageResult2,
          out HObject imageResult3,
          HTuple colorSpace)
        {
            IntPtr proc = HalconAPI.PreCall(1583);
            HalconAPI.Store(proc, 1, (HObjectBase)imageRed);
            HalconAPI.Store(proc, 2, (HObjectBase)imageGreen);
            HalconAPI.Store(proc, 3, (HObjectBase)imageBlue);
            HalconAPI.Store(proc, 0, colorSpace);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(colorSpace);
            int err2 = HObject.LoadNew(proc, 1, err1, out imageResult1);
            int err3 = HObject.LoadNew(proc, 2, err2, out imageResult2);
            int procResult = HObject.LoadNew(proc, 3, err3, out imageResult3);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageRed);
            GC.KeepAlive((object)imageGreen);
            GC.KeepAlive((object)imageBlue);
        }

        /// <summary>Transform an image from an arbitrary color space to the RGB color space.</summary>
        /// <param name="imageInput1">Input image (channel 1).</param>
        /// <param name="imageInput2">Input image (channel 2).</param>
        /// <param name="imageInput3">Input image (channel 3).</param>
        /// <param name="imageRed">Red channel.</param>
        /// <param name="imageGreen">Green channel.</param>
        /// <param name="imageBlue">Blue channel.</param>
        /// <param name="colorSpace">Color space of the input image. Default: "hsv"</param>
        public static void TransToRgb(
          HObject imageInput1,
          HObject imageInput2,
          HObject imageInput3,
          out HObject imageRed,
          out HObject imageGreen,
          out HObject imageBlue,
          HTuple colorSpace)
        {
            IntPtr proc = HalconAPI.PreCall(1584);
            HalconAPI.Store(proc, 1, (HObjectBase)imageInput1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageInput2);
            HalconAPI.Store(proc, 3, (HObjectBase)imageInput3);
            HalconAPI.Store(proc, 0, colorSpace);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(colorSpace);
            int err2 = HObject.LoadNew(proc, 1, err1, out imageRed);
            int err3 = HObject.LoadNew(proc, 2, err2, out imageGreen);
            int procResult = HObject.LoadNew(proc, 3, err3, out imageBlue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageInput1);
            GC.KeepAlive((object)imageInput2);
            GC.KeepAlive((object)imageInput3);
        }

        /// <summary>Logical "AND" of each pixel using a bit mask.</summary>
        /// <param name="image">Input image(s).</param>
        /// <param name="imageMask">Result image(s) by combination with mask.</param>
        /// <param name="bitMask">Bit field Default: 128</param>
        public static void BitMask(HObject image, out HObject imageMask, HTuple bitMask)
        {
            IntPtr proc = HalconAPI.PreCall(1585);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, bitMask);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(bitMask);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMask);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Extract a bit from the pixels.</summary>
        /// <param name="image">Input image(s).</param>
        /// <param name="imageSlice">Result image(s) by extraction.</param>
        /// <param name="bit">Bit to be selected. Default: 8</param>
        public static void BitSlice(HObject image, out HObject imageSlice, HTuple bit)
        {
            IntPtr proc = HalconAPI.PreCall(1586);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, bit);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(bit);
            int procResult = HObject.LoadNew(proc, 1, err, out imageSlice);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Right shift of all pixels of the image.</summary>
        /// <param name="image">Input image(s).</param>
        /// <param name="imageRShift">Result image(s) by shift operation.</param>
        /// <param name="shift">shift value Default: 3</param>
        public static void BitRshift(HObject image, out HObject imageRShift, HTuple shift)
        {
            IntPtr proc = HalconAPI.PreCall(1587);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, shift);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(shift);
            int procResult = HObject.LoadNew(proc, 1, err, out imageRShift);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Left shift of all pixels of the image.</summary>
        /// <param name="image">Input image(s).</param>
        /// <param name="imageLShift">Result image(s) by shift operation.</param>
        /// <param name="shift">Shift value. Default: 3</param>
        public static void BitLshift(HObject image, out HObject imageLShift, HTuple shift)
        {
            IntPtr proc = HalconAPI.PreCall(1588);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, shift);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(shift);
            int procResult = HObject.LoadNew(proc, 1, err, out imageLShift);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Complement all bits of the pixels.</summary>
        /// <param name="image">Input image(s).</param>
        /// <param name="imageNot">Result image(s) by complement operation.</param>
        public static void BitNot(HObject image, out HObject imageNot)
        {
            IntPtr proc = HalconAPI.PreCall(1589);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageNot);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Bit-by-bit XOR of all pixels of the input images.</summary>
        /// <param name="image1">Input image(s) 1.</param>
        /// <param name="image2">Input image(s) 2.</param>
        /// <param name="imageXor">Result image(s) by XOR-operation.</param>
        public static void BitXor(HObject image1, HObject image2, out HObject imageXor)
        {
            IntPtr proc = HalconAPI.PreCall(1590);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageXor);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Bit-by-bit OR of all pixels of the input images.</summary>
        /// <param name="image1">Input image(s) 1.</param>
        /// <param name="image2">Input image(s) 2.</param>
        /// <param name="imageOr">Result image(s) by OR-operation.</param>
        public static void BitOr(HObject image1, HObject image2, out HObject imageOr)
        {
            IntPtr proc = HalconAPI.PreCall(1591);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageOr);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Bit-by-bit AND of all pixels of the input images.</summary>
        /// <param name="image1">Input image(s) 1.</param>
        /// <param name="image2">Input image(s) 2.</param>
        /// <param name="imageAnd">Result image(s) by AND-operation.</param>
        public static void BitAnd(HObject image1, HObject image2, out HObject imageAnd)
        {
            IntPtr proc = HalconAPI.PreCall(1592);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageAnd);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Perform a gamma encoding or decoding of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="gammaImage">Output image.</param>
        /// <param name="gamma">Gamma coefficient of the exponential part of the transformation. Default: 0.416666666667</param>
        /// <param name="offset">Offset of the exponential part of the transformation. Default: 0.055</param>
        /// <param name="threshold">Gray value for which the transformation switches from linear to exponential. Default: 0.0031308</param>
        /// <param name="maxGray">Maximum gray value of the input image type. Default: 255.0</param>
        /// <param name="encode">If 'true', perform a gamma encoding, otherwise a gamma decoding. Default: "true"</param>
        public static void GammaImage(
          HObject image,
          out HObject gammaImage,
          HTuple gamma,
          HTuple offset,
          HTuple threshold,
          HTuple maxGray,
          HTuple encode)
        {
            IntPtr proc = HalconAPI.PreCall(1593);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, gamma);
            HalconAPI.Store(proc, 1, offset);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.Store(proc, 3, maxGray);
            HalconAPI.Store(proc, 4, encode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(gamma);
            HalconAPI.UnpinTuple(offset);
            HalconAPI.UnpinTuple(threshold);
            HalconAPI.UnpinTuple(maxGray);
            HalconAPI.UnpinTuple(encode);
            int procResult = HObject.LoadNew(proc, 1, err, out gammaImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Raise an image to a power.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="powImage">Output image.</param>
        /// <param name="exponent">Power to which the gray values are raised. Default: 2</param>
        public static void PowImage(HObject image, out HObject powImage, HTuple exponent)
        {
            IntPtr proc = HalconAPI.PreCall(1594);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, exponent);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(exponent);
            int procResult = HObject.LoadNew(proc, 1, err, out powImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the exponentiation of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="expImage">Output image.</param>
        /// <param name="baseVal">Base of the exponentiation. Default: "e"</param>
        public static void ExpImage(HObject image, out HObject expImage, HTuple baseVal)
        {
            IntPtr proc = HalconAPI.PreCall(1595);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, baseVal);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(baseVal);
            int procResult = HObject.LoadNew(proc, 1, err, out expImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the logarithm of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="logImage">Output image.</param>
        /// <param name="baseVal">Base of the logarithm. Default: "e"</param>
        public static void LogImage(HObject image, out HObject logImage, HTuple baseVal)
        {
            IntPtr proc = HalconAPI.PreCall(1596);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, baseVal);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(baseVal);
            int procResult = HObject.LoadNew(proc, 1, err, out logImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the arctangent of two images.</summary>
        /// <param name="imageY">Input image 1.</param>
        /// <param name="imageX">Input image 2.</param>
        /// <param name="arctanImage">Output image.</param>
        public static void Atan2Image(HObject imageY, HObject imageX, out HObject arctanImage)
        {
            IntPtr proc = HalconAPI.PreCall(1597);
            HalconAPI.Store(proc, 1, (HObjectBase)imageY);
            HalconAPI.Store(proc, 2, (HObjectBase)imageX);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out arctanImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageY);
            GC.KeepAlive((object)imageX);
        }

        /// <summary>Calculate the arctangent of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="arctanImage">Output image.</param>
        public static void AtanImage(HObject image, out HObject arctanImage)
        {
            IntPtr proc = HalconAPI.PreCall(1598);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out arctanImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the arccosine of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="arccosImage">Output image.</param>
        public static void AcosImage(HObject image, out HObject arccosImage)
        {
            IntPtr proc = HalconAPI.PreCall(1599);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out arccosImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the arcsine of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="arcsinImage">Output image.</param>
        public static void AsinImage(HObject image, out HObject arcsinImage)
        {
            IntPtr proc = HalconAPI.PreCall(1600);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out arcsinImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the tangent of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="tanImage">Output image.</param>
        public static void TanImage(HObject image, out HObject tanImage)
        {
            IntPtr proc = HalconAPI.PreCall(1601);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out tanImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the cosine of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="cosImage">Output image.</param>
        public static void CosImage(HObject image, out HObject cosImage)
        {
            IntPtr proc = HalconAPI.PreCall(1602);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out cosImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the sine of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="sinImage">Output image.</param>
        public static void SinImage(HObject image, out HObject sinImage)
        {
            IntPtr proc = HalconAPI.PreCall(1603);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out sinImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the absolute difference of two images.</summary>
        /// <param name="image1">Input image 1.</param>
        /// <param name="image2">Input image 2.</param>
        /// <param name="imageAbsDiff">Absolute value of the difference of the input images.</param>
        /// <param name="mult">Scale factor. Default: 1.0</param>
        public static void AbsDiffImage(
          HObject image1,
          HObject image2,
          out HObject imageAbsDiff,
          HTuple mult)
        {
            IntPtr proc = HalconAPI.PreCall(1604);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            int procResult = HObject.LoadNew(proc, 1, err, out imageAbsDiff);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Calculate the square root of an image.</summary>
        /// <param name="image">Input image</param>
        /// <param name="sqrtImage">Output image</param>
        public static void SqrtImage(HObject image, out HObject sqrtImage)
        {
            IntPtr proc = HalconAPI.PreCall(1605);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out sqrtImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Subtract two images.</summary>
        /// <param name="imageMinuend">Minuend(s).</param>
        /// <param name="imageSubtrahend">Subtrahend(s).</param>
        /// <param name="imageSub">Result image(s) by the subtraction.</param>
        /// <param name="mult">Correction factor. Default: 1.0</param>
        /// <param name="add">Correction value. Default: 128.0</param>
        public static void SubImage(
          HObject imageMinuend,
          HObject imageSubtrahend,
          out HObject imageSub,
          HTuple mult,
          HTuple add)
        {
            IntPtr proc = HalconAPI.PreCall(1606);
            HalconAPI.Store(proc, 1, (HObjectBase)imageMinuend);
            HalconAPI.Store(proc, 2, (HObjectBase)imageSubtrahend);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.Store(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            HalconAPI.UnpinTuple(add);
            int procResult = HObject.LoadNew(proc, 1, err, out imageSub);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageMinuend);
            GC.KeepAlive((object)imageSubtrahend);
        }

        /// <summary>Scale the gray values of an image.</summary>
        /// <param name="image">Image(s) whose gray values are to be scaled.</param>
        /// <param name="imageScaled">Result image(s) by the scale.</param>
        /// <param name="mult">Scale factor. Default: 0.01</param>
        /// <param name="add">Offset. Default: 0</param>
        public static void ScaleImage(HObject image, out HObject imageScaled, HTuple mult, HTuple add)
        {
            IntPtr proc = HalconAPI.PreCall(1607);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.Store(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            HalconAPI.UnpinTuple(add);
            int procResult = HObject.LoadNew(proc, 1, err, out imageScaled);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Divide two images.</summary>
        /// <param name="image1">Image(s) 1.</param>
        /// <param name="image2">Image(s) 2.</param>
        /// <param name="imageResult">Result image(s) by the division.</param>
        /// <param name="mult">Factor for gray range adaption. Default: 255</param>
        /// <param name="add">Value for gray range adaption. Default: 0</param>
        public static void DivImage(
          HObject image1,
          HObject image2,
          out HObject imageResult,
          HTuple mult,
          HTuple add)
        {
            IntPtr proc = HalconAPI.PreCall(1608);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.Store(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            HalconAPI.UnpinTuple(add);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Multiply two images.</summary>
        /// <param name="image1">Image(s) 1.</param>
        /// <param name="image2">Image(s) 2.</param>
        /// <param name="imageResult">Result image(s) by the product.</param>
        /// <param name="mult">Factor for gray range adaption. Default: 0.005</param>
        /// <param name="add">Value for gray range adaption. Default: 0</param>
        public static void MultImage(
          HObject image1,
          HObject image2,
          out HObject imageResult,
          HTuple mult,
          HTuple add)
        {
            IntPtr proc = HalconAPI.PreCall(1609);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.Store(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            HalconAPI.UnpinTuple(add);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Add two images.</summary>
        /// <param name="image1">Image(s) 1.</param>
        /// <param name="image2">Image(s) 2.</param>
        /// <param name="imageResult">Result image(s) by the addition.</param>
        /// <param name="mult">Factor for gray value adaption. Default: 0.5</param>
        /// <param name="add">Value for gray value range adaption. Default: 0</param>
        public static void AddImage(
          HObject image1,
          HObject image2,
          out HObject imageResult,
          HTuple mult,
          HTuple add)
        {
            IntPtr proc = HalconAPI.PreCall(1610);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.Store(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            HalconAPI.UnpinTuple(add);
            int procResult = HObject.LoadNew(proc, 1, err, out imageResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Calculate the absolute value (modulus) of an image.</summary>
        /// <param name="image">Image(s) for which the absolute gray values are to be calculated.</param>
        /// <param name="imageAbs">Result image(s).</param>
        public static void AbsImage(HObject image, out HObject imageAbs)
        {
            IntPtr proc = HalconAPI.PreCall(1611);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageAbs);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the minimum of two images pixel by pixel.</summary>
        /// <param name="image1">Image(s) 1.</param>
        /// <param name="image2">Image(s) 2.</param>
        /// <param name="imageMin">Result image(s) by the minimization.</param>
        public static void MinImage(HObject image1, HObject image2, out HObject imageMin)
        {
            IntPtr proc = HalconAPI.PreCall(1612);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMin);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Calculate the maximum of two images pixel by pixel.</summary>
        /// <param name="image1">Image(s) 1.</param>
        /// <param name="image2">Image(s) 2.</param>
        /// <param name="imageMax">Result image(s) by the maximization.</param>
        public static void MaxImage(HObject image1, HObject image2, out HObject imageMax)
        {
            IntPtr proc = HalconAPI.PreCall(1613);
            HalconAPI.Store(proc, 1, (HObjectBase)image1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMax);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image1);
            GC.KeepAlive((object)image2);
        }

        /// <summary>Invert an image.</summary>
        /// <param name="image">Input image(s).</param>
        /// <param name="imageInvert">Image(s) with inverted gray values.</param>
        public static void InvertImage(HObject image, out HObject imageInvert)
        {
            IntPtr proc = HalconAPI.PreCall(1614);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageInvert);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Apply an automatic color correction to panorama images.</summary>
        /// <param name="images">Input images.</param>
        /// <param name="correctedImages">Output images.</param>
        /// <param name="from">List of source images.</param>
        /// <param name="to">List of destination images.</param>
        /// <param name="referenceImage">Reference image.</param>
        /// <param name="homMatrices2D">Projective matrices.</param>
        /// <param name="estimationMethod">Estimation algorithm for the correction. Default: "standard"</param>
        /// <param name="estimateParameters">Parameters to be estimated. Default: ["mult_gray"]</param>
        /// <param name="OECFModel">Model of OECF to be used. Default: ["laguerre"]</param>
        public static void AdjustMosaicImages(
          HObject images,
          out HObject correctedImages,
          HTuple from,
          HTuple to,
          HTuple referenceImage,
          HTuple homMatrices2D,
          HTuple estimationMethod,
          HTuple estimateParameters,
          HTuple OECFModel)
        {
            IntPtr proc = HalconAPI.PreCall(1615);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, from);
            HalconAPI.Store(proc, 1, to);
            HalconAPI.Store(proc, 2, referenceImage);
            HalconAPI.Store(proc, 3, homMatrices2D);
            HalconAPI.Store(proc, 4, estimationMethod);
            HalconAPI.Store(proc, 5, estimateParameters);
            HalconAPI.Store(proc, 6, OECFModel);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(from);
            HalconAPI.UnpinTuple(to);
            HalconAPI.UnpinTuple(referenceImage);
            HalconAPI.UnpinTuple(homMatrices2D);
            HalconAPI.UnpinTuple(estimationMethod);
            HalconAPI.UnpinTuple(estimateParameters);
            HalconAPI.UnpinTuple(OECFModel);
            int procResult = HObject.LoadNew(proc, 1, err, out correctedImages);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Create 6 cube map images of a spherical mosaic.</summary>
        /// <param name="images">Input images.</param>
        /// <param name="front">Front cube map.</param>
        /// <param name="rear">Rear cube map.</param>
        /// <param name="left">Left cube map.</param>
        /// <param name="right">Right cube map.</param>
        /// <param name="top">Top cube map.</param>
        /// <param name="bottom">Bottom cube map.</param>
        /// <param name="cameraMatrices">(Array of) 3x3 projective camera matrices that determine the internal camera parameters.</param>
        /// <param name="rotationMatrices">Array of 3x3 transformation matrices that determine rotation of the camera in the respective image.</param>
        /// <param name="cubeMapDimension">Width and height of the resulting cube maps. Default: 1000</param>
        /// <param name="stackingOrder">Mode of adding the images to the mosaic image. Default: "voronoi"</param>
        /// <param name="interpolation">Mode of image interpolation. Default: "bilinear"</param>
        public static void GenCubeMapMosaic(
          HObject images,
          out HObject front,
          out HObject rear,
          out HObject left,
          out HObject right,
          out HObject top,
          out HObject bottom,
          HTuple cameraMatrices,
          HTuple rotationMatrices,
          HTuple cubeMapDimension,
          HTuple stackingOrder,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1616);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, cameraMatrices);
            HalconAPI.Store(proc, 1, rotationMatrices);
            HalconAPI.Store(proc, 2, cubeMapDimension);
            HalconAPI.Store(proc, 3, stackingOrder);
            HalconAPI.Store(proc, 4, interpolation);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraMatrices);
            HalconAPI.UnpinTuple(rotationMatrices);
            HalconAPI.UnpinTuple(cubeMapDimension);
            HalconAPI.UnpinTuple(stackingOrder);
            HalconAPI.UnpinTuple(interpolation);
            int err2 = HObject.LoadNew(proc, 1, err1, out front);
            int err3 = HObject.LoadNew(proc, 2, err2, out rear);
            int err4 = HObject.LoadNew(proc, 3, err3, out left);
            int err5 = HObject.LoadNew(proc, 4, err4, out right);
            int err6 = HObject.LoadNew(proc, 5, err5, out top);
            int procResult = HObject.LoadNew(proc, 6, err6, out bottom);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Create a spherical mosaic image.</summary>
        /// <param name="images">Input images.</param>
        /// <param name="mosaicImage">Output image.</param>
        /// <param name="cameraMatrices">(Array of) 3x3 projective camera matrices that determine the internal camera parameters.</param>
        /// <param name="rotationMatrices">Array of 3x3 transformation matrices that determine rotation of the camera in the respective image.</param>
        /// <param name="latMin">Minimum latitude of points in the spherical mosaic image. Default: -90</param>
        /// <param name="latMax">Maximum latitude of points in the spherical mosaic image. Default: 90</param>
        /// <param name="longMin">Minimum longitude of points in the spherical mosaic image. Default: -180</param>
        /// <param name="longMax">Maximum longitude of points in the spherical mosaic image. Default: 180</param>
        /// <param name="latLongStep">Latitude and longitude angle step width. Default: 0.1</param>
        /// <param name="stackingOrder">Mode of adding the images to the mosaic image. Default: "voronoi"</param>
        /// <param name="interpolation">Mode of interpolation when creating the mosaic image. Default: "bilinear"</param>
        public static void GenSphericalMosaic(
          HObject images,
          out HObject mosaicImage,
          HTuple cameraMatrices,
          HTuple rotationMatrices,
          HTuple latMin,
          HTuple latMax,
          HTuple longMin,
          HTuple longMax,
          HTuple latLongStep,
          HTuple stackingOrder,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1617);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, cameraMatrices);
            HalconAPI.Store(proc, 1, rotationMatrices);
            HalconAPI.Store(proc, 2, latMin);
            HalconAPI.Store(proc, 3, latMax);
            HalconAPI.Store(proc, 4, longMin);
            HalconAPI.Store(proc, 5, longMax);
            HalconAPI.Store(proc, 6, latLongStep);
            HalconAPI.Store(proc, 7, stackingOrder);
            HalconAPI.Store(proc, 8, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraMatrices);
            HalconAPI.UnpinTuple(rotationMatrices);
            HalconAPI.UnpinTuple(latMin);
            HalconAPI.UnpinTuple(latMax);
            HalconAPI.UnpinTuple(longMin);
            HalconAPI.UnpinTuple(longMax);
            HalconAPI.UnpinTuple(latLongStep);
            HalconAPI.UnpinTuple(stackingOrder);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HObject.LoadNew(proc, 1, err, out mosaicImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Combine multiple images into a mosaic image.</summary>
        /// <param name="images">Input images.</param>
        /// <param name="mosaicImage">Output image.</param>
        /// <param name="homMatrices2D">Array of 3x3 projective transformation matrices.</param>
        /// <param name="stackingOrder">Stacking order of the images in the mosaic. Default: "default"</param>
        /// <param name="transformDomain">Should the domains of the input images also be transformed? Default: "false"</param>
        /// <param name="transMat2D">3x3 projective transformation matrix that describes the translation that was necessary to transform all images completely into the output image.</param>
        public static void GenBundleAdjustedMosaic(
          HObject images,
          out HObject mosaicImage,
          HTuple homMatrices2D,
          HTuple stackingOrder,
          HTuple transformDomain,
          out HTuple transMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(1618);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, homMatrices2D);
            HalconAPI.Store(proc, 1, stackingOrder);
            HalconAPI.Store(proc, 2, transformDomain);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMatrices2D);
            HalconAPI.UnpinTuple(stackingOrder);
            HalconAPI.UnpinTuple(transformDomain);
            int err2 = HObject.LoadNew(proc, 1, err1, out mosaicImage);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out transMat2D);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Combine multiple images into a mosaic image.</summary>
        /// <param name="images">Input images.</param>
        /// <param name="mosaicImage">Output image.</param>
        /// <param name="startImage">Index of the central input image.</param>
        /// <param name="mappingSource">Indices of the source images of the transformations.</param>
        /// <param name="mappingDest">Indices of the target images of the transformations.</param>
        /// <param name="homMatrices2D">Array of 3x3 projective transformation matrices.</param>
        /// <param name="stackingOrder">Stacking order of the images in the mosaic. Default: "default"</param>
        /// <param name="transformDomain">Should the domains of the input images also be transformed? Default: "false"</param>
        /// <param name="mosaicMatrices2D">Array of 3x3 projective transformation matrices that determine the position of the images in the mosaic.</param>
        public static void GenProjectiveMosaic(
          HObject images,
          out HObject mosaicImage,
          HTuple startImage,
          HTuple mappingSource,
          HTuple mappingDest,
          HTuple homMatrices2D,
          HTuple stackingOrder,
          HTuple transformDomain,
          out HTuple mosaicMatrices2D)
        {
            IntPtr proc = HalconAPI.PreCall(1619);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, startImage);
            HalconAPI.Store(proc, 1, mappingSource);
            HalconAPI.Store(proc, 2, mappingDest);
            HalconAPI.Store(proc, 3, homMatrices2D);
            HalconAPI.Store(proc, 4, stackingOrder);
            HalconAPI.Store(proc, 5, transformDomain);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(startImage);
            HalconAPI.UnpinTuple(mappingSource);
            HalconAPI.UnpinTuple(mappingDest);
            HalconAPI.UnpinTuple(homMatrices2D);
            HalconAPI.UnpinTuple(stackingOrder);
            HalconAPI.UnpinTuple(transformDomain);
            int err2 = HObject.LoadNew(proc, 1, err1, out mosaicImage);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out mosaicMatrices2D);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Apply a projective transformation to an image and specify the output image size.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="transImage">Output image.</param>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "bilinear"</param>
        /// <param name="width">Output image width.</param>
        /// <param name="height">Output image height.</param>
        /// <param name="transformDomain">Should the domain of the input image also be transformed? Default: "false"</param>
        public static void ProjectiveTransImageSize(
          HObject image,
          out HObject transImage,
          HTuple homMat2D,
          HTuple interpolation,
          HTuple width,
          HTuple height,
          HTuple transformDomain)
        {
            IntPtr proc = HalconAPI.PreCall(1620);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, interpolation);
            HalconAPI.Store(proc, 2, width);
            HalconAPI.Store(proc, 3, height);
            HalconAPI.Store(proc, 4, transformDomain);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(interpolation);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(transformDomain);
            int procResult = HObject.LoadNew(proc, 1, err, out transImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Apply a projective transformation to an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="transImage">Output image.</param>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "bilinear"</param>
        /// <param name="adaptImageSize">Adapt the size of the output image automatically? Default: "false"</param>
        /// <param name="transformDomain">Should the domain of the input image also be transformed? Default: "false"</param>
        public static void ProjectiveTransImage(
          HObject image,
          out HObject transImage,
          HTuple homMat2D,
          HTuple interpolation,
          HTuple adaptImageSize,
          HTuple transformDomain)
        {
            IntPtr proc = HalconAPI.PreCall(1621);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, interpolation);
            HalconAPI.Store(proc, 2, adaptImageSize);
            HalconAPI.Store(proc, 3, transformDomain);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(interpolation);
            HalconAPI.UnpinTuple(adaptImageSize);
            HalconAPI.UnpinTuple(transformDomain);
            int procResult = HObject.LoadNew(proc, 1, err, out transImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Apply an arbitrary affine 2D transformation to an image and specify the output image size.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageAffineTrans">Transformed image.</param>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="interpolation">Type of interpolation. Default: "constant"</param>
        /// <param name="width">Width of the output image. Default: 640</param>
        /// <param name="height">Height of the output image. Default: 480</param>
        public static void AffineTransImageSize(
          HObject image,
          out HObject imageAffineTrans,
          HTuple homMat2D,
          HTuple interpolation,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1622);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, interpolation);
            HalconAPI.Store(proc, 2, width);
            HalconAPI.Store(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(interpolation);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageAffineTrans);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Apply an arbitrary affine 2D transformation to images.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageAffineTrans">Transformed image.</param>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="interpolation">Type of interpolation. Default: "constant"</param>
        /// <param name="adaptImageSize">Adaption of size of result image. Default: "false"</param>
        public static void AffineTransImage(
          HObject image,
          out HObject imageAffineTrans,
          HTuple homMat2D,
          HTuple interpolation,
          HTuple adaptImageSize)
        {
            IntPtr proc = HalconAPI.PreCall(1623);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, homMat2D);
            HalconAPI.Store(proc, 1, interpolation);
            HalconAPI.Store(proc, 2, adaptImageSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat2D);
            HalconAPI.UnpinTuple(interpolation);
            HalconAPI.UnpinTuple(adaptImageSize);
            int procResult = HObject.LoadNew(proc, 1, err, out imageAffineTrans);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Zoom an image by a given factor.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageZoomed">Scaled image.</param>
        /// <param name="scaleWidth">Scale factor for the width of the image. Default: 0.5</param>
        /// <param name="scaleHeight">Scale factor for the height of the image. Default: 0.5</param>
        /// <param name="interpolation">Type of interpolation. Default: "constant"</param>
        public static void ZoomImageFactor(
          HObject image,
          out HObject imageZoomed,
          HTuple scaleWidth,
          HTuple scaleHeight,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1624);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, scaleWidth);
            HalconAPI.Store(proc, 1, scaleHeight);
            HalconAPI.Store(proc, 2, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scaleWidth);
            HalconAPI.UnpinTuple(scaleHeight);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HObject.LoadNew(proc, 1, err, out imageZoomed);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Zoom an image to a given size.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageZoom">Scaled image.</param>
        /// <param name="width">Width of the resulting image. Default: 512</param>
        /// <param name="height">Height of the resulting image. Default: 512</param>
        /// <param name="interpolation">Type of interpolation. Default: "constant"</param>
        public static void ZoomImageSize(
          HObject image,
          out HObject imageZoom,
          HTuple width,
          HTuple height,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1625);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.Store(proc, 2, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HObject.LoadNew(proc, 1, err, out imageZoom);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Mirror an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageMirror">Reflected image.</param>
        /// <param name="mode">Axis of reflection. Default: "row"</param>
        public static void MirrorImage(HObject image, out HObject imageMirror, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(1626);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMirror);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Rotate an image about its center.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageRotate">Rotated image.</param>
        /// <param name="phi">Rotation angle. Default: 90</param>
        /// <param name="interpolation">Type of interpolation. Default: "constant"</param>
        public static void RotateImage(
          HObject image,
          out HObject imageRotate,
          HTuple phi,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1627);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, phi);
            HalconAPI.Store(proc, 1, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HObject.LoadNew(proc, 1, err, out imageRotate);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Transform an image in polar coordinates back to cartesian coordinates</summary>
        /// <param name="polarImage">Input image.</param>
        /// <param name="XYTransImage">Output image.</param>
        /// <param name="row">Row coordinate of the center of the arc. Default: 256</param>
        /// <param name="column">Column coordinate of the center of the arc. Default: 256</param>
        /// <param name="angleStart">Angle of the ray to map the first column of the input image to. Default: 0.0</param>
        /// <param name="angleEnd">Angle of the ray to map the last column of the input image to. Default: 6.2831853</param>
        /// <param name="radiusStart">Radius of the circle to map the first row of the input image to. Default: 0</param>
        /// <param name="radiusEnd">Radius of the circle to map the last row of the input image to. Default: 100</param>
        /// <param name="width">Width of the output image. Default: 512</param>
        /// <param name="height">Height of the output image. Default: 512</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "nearest_neighbor"</param>
        public static void PolarTransImageInv(
          HObject polarImage,
          out HObject XYTransImage,
          HTuple row,
          HTuple column,
          HTuple angleStart,
          HTuple angleEnd,
          HTuple radiusStart,
          HTuple radiusEnd,
          HTuple width,
          HTuple height,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1628);
            HalconAPI.Store(proc, 1, (HObjectBase)polarImage);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, angleStart);
            HalconAPI.Store(proc, 3, angleEnd);
            HalconAPI.Store(proc, 4, radiusStart);
            HalconAPI.Store(proc, 5, radiusEnd);
            HalconAPI.Store(proc, 6, width);
            HalconAPI.Store(proc, 7, height);
            HalconAPI.Store(proc, 8, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleEnd);
            HalconAPI.UnpinTuple(radiusStart);
            HalconAPI.UnpinTuple(radiusEnd);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HObject.LoadNew(proc, 1, err, out XYTransImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polarImage);
        }

        /// <summary>Transform an annular arc in an image to polar coordinates.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="polarTransImage">Output image.</param>
        /// <param name="row">Row coordinate of the center of the arc. Default: 256</param>
        /// <param name="column">Column coordinate of the center of the arc. Default: 256</param>
        /// <param name="angleStart">Angle of the ray to be mapped to the first column of the output image. Default: 0.0</param>
        /// <param name="angleEnd">Angle of the ray to be mapped to the last column of the output image. Default: 6.2831853</param>
        /// <param name="radiusStart">Radius of the circle to be mapped to the first row of the output image. Default: 0</param>
        /// <param name="radiusEnd">Radius of the circle to be mapped to the last row of the output image. Default: 100</param>
        /// <param name="width">Width of the output image. Default: 512</param>
        /// <param name="height">Height of the output image. Default: 512</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "nearest_neighbor"</param>
        public static void PolarTransImageExt(
          HObject image,
          out HObject polarTransImage,
          HTuple row,
          HTuple column,
          HTuple angleStart,
          HTuple angleEnd,
          HTuple radiusStart,
          HTuple radiusEnd,
          HTuple width,
          HTuple height,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1629);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, angleStart);
            HalconAPI.Store(proc, 3, angleEnd);
            HalconAPI.Store(proc, 4, radiusStart);
            HalconAPI.Store(proc, 5, radiusEnd);
            HalconAPI.Store(proc, 6, width);
            HalconAPI.Store(proc, 7, height);
            HalconAPI.Store(proc, 8, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleEnd);
            HalconAPI.UnpinTuple(radiusStart);
            HalconAPI.UnpinTuple(radiusEnd);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HObject.LoadNew(proc, 1, err, out polarTransImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Transform an image to polar coordinates</summary>
        /// <param name="imageXY">Input image in cartesian coordinates.</param>
        /// <param name="imagePolar">Result image in polar coordinates.</param>
        /// <param name="row">Row coordinate of the center of the coordinate system. Default: 100</param>
        /// <param name="column">Column coordinate of the center of the coordinate system. Default: 100</param>
        /// <param name="width">Width of the result image. Default: 314</param>
        /// <param name="height">Height of the result image. Default: 200</param>
        public static void PolarTransImage(
          HObject imageXY,
          out HObject imagePolar,
          HTuple row,
          HTuple column,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1630);
            HalconAPI.Store(proc, 1, (HObjectBase)imageXY);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, width);
            HalconAPI.Store(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imagePolar);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)imageXY);
        }

        /// <summary>Approximate an affine map from a displacement vector field.</summary>
        /// <param name="vectorField">Input image.</param>
        /// <param name="homMat2D">Output transformation matrix.</param>
        public static void VectorFieldToHomMat2d(HObject vectorField, out HTuple homMat2D)
        {
            IntPtr proc = HalconAPI.PreCall(1631);
            HalconAPI.Store(proc, 1, (HObjectBase)vectorField);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat2D);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)vectorField);
        }

        /// <summary>Deserialize a serialized XLD object.</summary>
        /// <param name="XLD">XLD object.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void DeserializeXld(out HObject XLD, HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1632);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out XLD);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize an XLD object.</summary>
        /// <param name="XLD">XLD object.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeXld(HObject XLD, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1633);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Read XLD polygons from a DXF file.</summary>
        /// <param name="polygons">Read XLD polygons.</param>
        /// <param name="fileName">Name of the DXF file.</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the DXF input. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the DXF input. Default: []</param>
        /// <param name="dxfStatus">Status information.</param>
        public static void ReadPolygonXldDxf(
          out HObject polygons,
          HTuple fileName,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple dxfStatus)
        {
            IntPtr proc = HalconAPI.PreCall(1634);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HObject.LoadNew(proc, 1, err1, out polygons);
            int procResult = HTuple.LoadNew(proc, 0, err2, out dxfStatus);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write XLD polygons to a file in DXF format.</summary>
        /// <param name="polygons">XLD polygons to be written.</param>
        /// <param name="fileName">Name of the DXF file.</param>
        public static void WritePolygonXldDxf(HObject polygons, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1635);
            HalconAPI.Store(proc, 1, (HObjectBase)polygons);
            HalconAPI.Store(proc, 0, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)polygons);
        }

        /// <summary>Read XLD contours from a DXF file.</summary>
        /// <param name="contours">Read XLD contours.</param>
        /// <param name="fileName">Name of the DXF file.</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the DXF input. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the DXF input. Default: []</param>
        /// <param name="dxfStatus">Status information.</param>
        public static void ReadContourXldDxf(
          out HObject contours,
          HTuple fileName,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple dxfStatus)
        {
            IntPtr proc = HalconAPI.PreCall(1636);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HObject.LoadNew(proc, 1, err1, out contours);
            int procResult = HTuple.LoadNew(proc, 0, err2, out dxfStatus);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write XLD contours to a file in DXF format.</summary>
        /// <param name="contours">XLD contours to be written.</param>
        /// <param name="fileName">Name of the DXF file.</param>
        public static void WriteContourXldDxf(HObject contours, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1637);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Copy a file to a new location.</summary>
        /// <param name="sourceFile">File to be copied.</param>
        /// <param name="destinationFile">Target location.</param>
        public static void CopyFile(HTuple sourceFile, HTuple destinationFile)
        {
            IntPtr proc = HalconAPI.PreCall(1638);
            HalconAPI.Store(proc, 0, sourceFile);
            HalconAPI.Store(proc, 1, destinationFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sourceFile);
            HalconAPI.UnpinTuple(destinationFile);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the current working directory.</summary>
        /// <param name="dirName">Name of current working directory to be set.</param>
        public static void SetCurrentDir(HTuple dirName)
        {
            IntPtr proc = HalconAPI.PreCall(1639);
            HalconAPI.Store(proc, 0, dirName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dirName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current working directory.</summary>
        /// <param name="dirName">Name of current working directory.</param>
        public static void GetCurrentDir(out HTuple dirName)
        {
            IntPtr proc = HalconAPI.PreCall(1640);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, err, out dirName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete an empty directory.</summary>
        /// <param name="dirName">Name of directory to be deleted.</param>
        public static void RemoveDir(HTuple dirName)
        {
            IntPtr proc = HalconAPI.PreCall(1641);
            HalconAPI.Store(proc, 0, dirName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dirName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Make a directory.</summary>
        /// <param name="dirName">Name of directory to be created.</param>
        public static void MakeDir(HTuple dirName)
        {
            IntPtr proc = HalconAPI.PreCall(1642);
            HalconAPI.Store(proc, 0, dirName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dirName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>List all files in a directory.</summary>
        /// <param name="directory">Name of directory to be listed.</param>
        /// <param name="options">Processing options. Default: "files"</param>
        /// <param name="files">Found files (and directories).</param>
        public static void ListFiles(HTuple directory, HTuple options, out HTuple files)
        {
            IntPtr proc = HalconAPI.PreCall(1643);
            HalconAPI.Store(proc, 0, directory);
            HalconAPI.Store(proc, 1, options);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(directory);
            HalconAPI.UnpinTuple(options);
            int procResult = HTuple.LoadNew(proc, 0, err, out files);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete a file.</summary>
        /// <param name="fileName">File to be deleted.</param>
        public static void DeleteFile(HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1644);
            HalconAPI.Store(proc, 0, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Check whether file exists.</summary>
        /// <param name="fileName">Name of file to be checked. Default: "/bin/cc"</param>
        /// <param name="fileExists">boolean number.</param>
        public static void FileExists(HTuple fileName, out HTuple fileExists)
        {
            IntPtr proc = HalconAPI.PreCall(1645);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out fileExists);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read an iconic object.</summary>
        /// <param name="objectVal">Iconic object.</param>
        /// <param name="fileName">Name of file.</param>
        public static void ReadObject(out HObject objectVal, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1646);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HObject.LoadNew(proc, 1, err, out objectVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write an iconic object.</summary>
        /// <param name="objectVal">Iconic object.</param>
        /// <param name="fileName">Name of file.</param>
        public static void WriteObject(HObject objectVal, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1647);
            HalconAPI.Store(proc, 1, (HObjectBase)objectVal);
            HalconAPI.Store(proc, 0, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objectVal);
        }

        /// <summary>Deserialize a serialized iconic object.</summary>
        /// <param name="objectVal">Iconic object.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void DeserializeObject(out HObject objectVal, HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1648);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out objectVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize an iconic object.</summary>
        /// <param name="objectVal">Iconic object.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeObject(HObject objectVal, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1649);
            HalconAPI.Store(proc, 1, (HObjectBase)objectVal);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objectVal);
        }

        /// <summary>Deserialize a serialized image object.</summary>
        /// <param name="image">Image object.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void DeserializeImage(out HObject image, HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1650);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize an image object.</summary>
        /// <param name="image">Image object.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeImage(HObject image, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1651);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Deserialize a serialized region.</summary>
        /// <param name="region">Region.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void DeserializeRegion(out HObject region, HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1652);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a region.</summary>
        /// <param name="region">Region.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeRegion(HObject region, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1653);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Write regions to a file.</summary>
        /// <param name="region">Region of the images which are returned.</param>
        /// <param name="fileName">Name of region file. Default: "region.hobj"</param>
        public static void WriteRegion(HObject region, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1654);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Write images in graphic formats.</summary>
        /// <param name="image">Input images.</param>
        /// <param name="format">Graphic format. Default: "tiff"</param>
        /// <param name="fillColor">Fill gray value for pixels not belonging to the image domain (region). Default: 0</param>
        /// <param name="fileName">Name of image file.</param>
        public static void WriteImage(HObject image, HTuple format, HTuple fillColor, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1655);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, format);
            HalconAPI.Store(proc, 1, fillColor);
            HalconAPI.Store(proc, 2, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(format);
            HalconAPI.UnpinTuple(fillColor);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Read images.</summary>
        /// <param name="image">Image read.</param>
        /// <param name="headerSize">Number of bytes for file header. Default: 0</param>
        /// <param name="sourceWidth">Number of image columns of the filed image. Default: 512</param>
        /// <param name="sourceHeight">Number of image lines of the filed image. Default: 512</param>
        /// <param name="startRow">Starting point of image area (line). Default: 0</param>
        /// <param name="startColumn">Starting point of image area (column). Default: 0</param>
        /// <param name="destWidth">Number of image columns of output image. Default: 512</param>
        /// <param name="destHeight">Number of image lines of output image. Default: 512</param>
        /// <param name="pixelType">Type of pixel values. Default: "byte"</param>
        /// <param name="bitOrder">Sequence of bits within one byte. Default: "MSBFirst"</param>
        /// <param name="byteOrder">Sequence of bytes within one 'short' unit. Default: "MSBFirst"</param>
        /// <param name="pad">Data units within one image line (alignment). Default: "byte"</param>
        /// <param name="index">Number of images in the file. Default: 1</param>
        /// <param name="fileName">Name of input file.</param>
        public static void ReadSequence(
          out HObject image,
          HTuple headerSize,
          HTuple sourceWidth,
          HTuple sourceHeight,
          HTuple startRow,
          HTuple startColumn,
          HTuple destWidth,
          HTuple destHeight,
          HTuple pixelType,
          HTuple bitOrder,
          HTuple byteOrder,
          HTuple pad,
          HTuple index,
          HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1656);
            HalconAPI.Store(proc, 0, headerSize);
            HalconAPI.Store(proc, 1, sourceWidth);
            HalconAPI.Store(proc, 2, sourceHeight);
            HalconAPI.Store(proc, 3, startRow);
            HalconAPI.Store(proc, 4, startColumn);
            HalconAPI.Store(proc, 5, destWidth);
            HalconAPI.Store(proc, 6, destHeight);
            HalconAPI.Store(proc, 7, pixelType);
            HalconAPI.Store(proc, 8, bitOrder);
            HalconAPI.Store(proc, 9, byteOrder);
            HalconAPI.Store(proc, 10, pad);
            HalconAPI.Store(proc, 11, index);
            HalconAPI.Store(proc, 12, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(headerSize);
            HalconAPI.UnpinTuple(sourceWidth);
            HalconAPI.UnpinTuple(sourceHeight);
            HalconAPI.UnpinTuple(startRow);
            HalconAPI.UnpinTuple(startColumn);
            HalconAPI.UnpinTuple(destWidth);
            HalconAPI.UnpinTuple(destHeight);
            HalconAPI.UnpinTuple(pixelType);
            HalconAPI.UnpinTuple(bitOrder);
            HalconAPI.UnpinTuple(byteOrder);
            HalconAPI.UnpinTuple(pad);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read binary images or HALCON regions.</summary>
        /// <param name="region">Read region.</param>
        /// <param name="fileName">Name of the region to be read.</param>
        public static void ReadRegion(out HObject region, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1657);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HObject.LoadNew(proc, 1, err, out region);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read an image with different file formats.</summary>
        /// <param name="image">Read image.</param>
        /// <param name="fileName">Name of the image to be read. Default: "printer_chip/printer_chip_01"</param>
        public static void ReadImage(out HObject image, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1658);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open a file in ASCII or a binary format.</summary>
        /// <param name="fileName">Name of file to be opened. Default: "standard"</param>
        /// <param name="fileType">Type of file. Default: "output"</param>
        /// <param name="fileHandle">File handle.</param>
        public static void OpenFile(HTuple fileName, HTuple fileType, out HTuple fileHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1659);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.Store(proc, 1, fileType);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.UnpinTuple(fileType);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out fileHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write values in a file.</summary>
        /// <param name="fileHandle">File handle.</param>
        /// <param name="stringVal">Values to be put out on the file. Default: "hallo"</param>
        public static void FwriteString(HTuple fileHandle, HTuple stringVal)
        {
            IntPtr proc = HalconAPI.PreCall(1660);
            HalconAPI.Store(proc, 0, fileHandle);
            HalconAPI.Store(proc, 1, stringVal);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileHandle);
            HalconAPI.UnpinTuple(stringVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a line from a file.</summary>
        /// <param name="fileHandle">File handle.</param>
        /// <param name="outLine">Read line.</param>
        /// <param name="isEOF">Reached end of file.</param>
        public static void FreadLine(HTuple fileHandle, out HTuple outLine, out HTuple isEOF)
        {
            IntPtr proc = HalconAPI.PreCall(1661);
            HalconAPI.Store(proc, 0, fileHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out outLine);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out isEOF);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read strings from a file.</summary>
        /// <param name="fileHandle">File handle.</param>
        /// <param name="outString">Read character sequence.</param>
        /// <param name="isEOF">Reached end of file.</param>
        public static void FreadString(HTuple fileHandle, out HTuple outString, out HTuple isEOF)
        {
            IntPtr proc = HalconAPI.PreCall(1662);
            HalconAPI.Store(proc, 0, fileHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out outString);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out isEOF);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a character from a file.</summary>
        /// <param name="fileHandle">File handle.</param>
        /// <param name="charVal">Read character or control string ('eof').</param>
        public static void FreadChar(HTuple fileHandle, out HTuple charVal)
        {
            IntPtr proc = HalconAPI.PreCall(1663);
            HalconAPI.Store(proc, 0, fileHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out charVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a line feed.</summary>
        /// <param name="fileHandle">File handle.</param>
        public static void FnewLine(HTuple fileHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1664);
            HalconAPI.Store(proc, 0, fileHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Closing a text file.</summary>
        /// <param name="fileHandle">File handle.</param>
        public static void CloseFile(HTuple fileHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1665);
            HalconAPI.Store(proc, 0, fileHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close all open files.</summary>
        public static void CloseAllFiles()
        {
            IntPtr proc = HalconAPI.PreCall(1666);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Test whether contours or polygons are closed.</summary>
        /// <param name="XLD">Contours or polygons to be tested.</param>
        /// <param name="isClosed">Tuple with boolean numbers.</param>
        public static void TestClosedXld(HObject XLD, out HTuple isClosed)
        {
            IntPtr proc = HalconAPI.PreCall(1667);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isClosed);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Return gray values of an image at the positions of an XLD contour.</summary>
        /// <param name="image">Image whose gray values are to be accessed.</param>
        /// <param name="contour">Input XLD contour with the coordinates of the positions.</param>
        /// <param name="interpolation">Interpolation method. Default: "nearest_neighbor"</param>
        /// <param name="grayval">Gray values of the selected image coordinates.</param>
        public static void GetGrayvalContourXld(
          HObject image,
          HObject contour,
          HTuple interpolation,
          out HTuple grayval)
        {
            IntPtr proc = HalconAPI.PreCall(1668);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, interpolation);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HTuple.LoadNew(proc, 0, err, out grayval);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Arbitrary geometric moments of contours or polygons treated as point clouds.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="mode">Computation mode. Default: "unnormalized"</param>
        /// <param name="area">Area enclosed by the contour or polygon.</param>
        /// <param name="centerRow">Row coordinate of the centroid.</param>
        /// <param name="centerCol">Column coordinate of the centroid.</param>
        /// <param name="p">First index of the desired moments M[P,Q]@f$M_{p,q}$. Default: 1</param>
        /// <param name="q">Second index of the desired moments M[P,Q]@f$M_{p,q}$. Default: 1</param>
        /// <param name="m">The computed moments.</param>
        public static void MomentsAnyPointsXld(
          HObject XLD,
          HTuple mode,
          HTuple area,
          HTuple centerRow,
          HTuple centerCol,
          HTuple p,
          HTuple q,
          out HTuple m)
        {
            IntPtr proc = HalconAPI.PreCall(1669);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, area);
            HalconAPI.Store(proc, 2, centerRow);
            HalconAPI.Store(proc, 3, centerCol);
            HalconAPI.Store(proc, 4, p);
            HalconAPI.Store(proc, 5, q);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(area);
            HalconAPI.UnpinTuple(centerRow);
            HalconAPI.UnpinTuple(centerCol);
            HalconAPI.UnpinTuple(p);
            HalconAPI.UnpinTuple(q);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out m);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Anisometry of contours or polygons treated as point clouds.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="anisometry">Anisometry of the contours or polygons.</param>
        public static void EccentricityPointsXld(HObject XLD, out HTuple anisometry)
        {
            IntPtr proc = HalconAPI.PreCall(1670);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out anisometry);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Parameters of the equivalent ellipse of contours or polygons treated as point clouds.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="ra">Major radius.</param>
        /// <param name="rb">Minor radius.</param>
        /// <param name="phi">Angle between the major axis and the column axis (radians).</param>
        public static void EllipticAxisPointsXld(
          HObject XLD,
          out HTuple ra,
          out HTuple rb,
          out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(1671);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out ra);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out rb);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Orientation of contours or polygons treated as point clouds.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="phi">Orientation of the contours or polygons (radians).</param>
        public static void OrientationPointsXld(HObject XLD, out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(1672);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out phi);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Geometric moments M20@f$M_{20}$, M02@f$M_{02}$, and M11@f$M_{11}$ of contours or polygons treated as point clouds.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="m11">Mixed second order moment.</param>
        /// <param name="m20">Second order moment along the row axis.</param>
        /// <param name="m02">Second order moment along the column axis.</param>
        public static void MomentsPointsXld(
          HObject XLD,
          out HTuple m11,
          out HTuple m20,
          out HTuple m02)
        {
            IntPtr proc = HalconAPI.PreCall(1673);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out m11);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out m20);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out m02);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Area and center of gravity (centroid) of contours and polygons treated as point clouds.</summary>
        /// <param name="XLD">Point clouds to be examined in form of contours or polygons.</param>
        /// <param name="area">Area of the point cloud.</param>
        /// <param name="row">Row coordinate of the centroid.</param>
        /// <param name="column">Column coordinate of the centroid.</param>
        public static void AreaCenterPointsXld(
          HObject XLD,
          out HTuple area,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1674);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out area);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out row);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Test XLD contours or polygons for self intersection.</summary>
        /// <param name="XLD">Input contours or polygons.</param>
        /// <param name="closeXLD">Should the input contours or polygons be closed first? Default: "true"</param>
        /// <param name="doesIntersect">1 for contours or polygons with self intersection and 0 otherwise.</param>
        public static void TestSelfIntersectionXld(
          HObject XLD,
          HTuple closeXLD,
          out HTuple doesIntersect)
        {
            IntPtr proc = HalconAPI.PreCall(1675);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.Store(proc, 0, closeXLD);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(closeXLD);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out doesIntersect);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Choose all contours or polygons containing a given point.</summary>
        /// <param name="XLDs">Contours or polygons to be examined.</param>
        /// <param name="destXLDs">All contours or polygons containing the test point.</param>
        /// <param name="row">Line coordinate of the test point. Default: 100.0</param>
        /// <param name="column">Column coordinate of the test point. Default: 100.0</param>
        public static void SelectXldPoint(
          HObject XLDs,
          out HObject destXLDs,
          HTuple row,
          HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1676);
            HalconAPI.Store(proc, 1, (HObjectBase)XLDs);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HObject.LoadNew(proc, 1, err, out destXLDs);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLDs);
        }

        /// <summary>Test whether one or more contours or polygons enclose the given point(s).</summary>
        /// <param name="XLD">Contours or polygons to be tested.</param>
        /// <param name="row">Row coordinates of the points to be tested.</param>
        /// <param name="column">Column coordinates of the points to be tested.</param>
        /// <param name="isInside">Tuple with boolean numbers.</param>
        public static void TestXldPoint(HObject XLD, HTuple row, HTuple column, out HTuple isInside)
        {
            IntPtr proc = HalconAPI.PreCall(1677);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isInside);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Select contours or polygons using shape features.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="selectedXLD">Contours or polygons fulfilling the condition(s).</param>
        /// <param name="features">Shape features to be checked. Default: "area"</param>
        /// <param name="operation">Operation type between the individual features. Default: "and"</param>
        /// <param name="min">Lower limits of the features or 'min'. Default: 150.0</param>
        /// <param name="max">Upper limits of the features or 'max'. Default: 99999.0</param>
        public static void SelectShapeXld(
          HObject XLD,
          out HObject selectedXLD,
          HTuple features,
          HTuple operation,
          HTuple min,
          HTuple max)
        {
            IntPtr proc = HalconAPI.PreCall(1678);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.Store(proc, 0, features);
            HalconAPI.Store(proc, 1, operation);
            HalconAPI.Store(proc, 2, min);
            HalconAPI.Store(proc, 3, max);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(operation);
            HalconAPI.UnpinTuple(min);
            HalconAPI.UnpinTuple(max);
            int procResult = HObject.LoadNew(proc, 1, err, out selectedXLD);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Orientation of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="phi">Orientation of the contours or polygons (radians).</param>
        public static void OrientationXld(HObject XLD, out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(1679);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out phi);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Shape features derived from the ellipse parameters of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="anisometry">Anisometry of the contours or polygons.</param>
        /// <param name="bulkiness">Bulkiness of the contours or polygons.</param>
        /// <param name="structureFactor">Structure factor of the contours or polygons.</param>
        public static void EccentricityXld(
          HObject XLD,
          out HTuple anisometry,
          out HTuple bulkiness,
          out HTuple structureFactor)
        {
            IntPtr proc = HalconAPI.PreCall(1680);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out anisometry);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out bulkiness);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out structureFactor);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Shape factor for the compactness of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="compactness">Compactness of the input contours or polygons.</param>
        public static void CompactnessXld(HObject XLD, out HTuple compactness)
        {
            IntPtr proc = HalconAPI.PreCall(1681);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out compactness);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Maximum distance between two contour or polygon points.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="row1">Row coordinate of the first extreme point of the contours or polygons.</param>
        /// <param name="column1">Column coordinate of the first extreme point of the contours or polygons.</param>
        /// <param name="row2">Row coordinate of the second extreme point of the contour or polygons.</param>
        /// <param name="column2">Column coordinate of the second extreme point of the contours or polygons.</param>
        /// <param name="diameter">Distance of the two extreme points of the contours or polygons.</param>
        public static void DiameterXld(
          HObject XLD,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2,
          out HTuple diameter)
        {
            IntPtr proc = HalconAPI.PreCall(1682);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out row2);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out column2);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out diameter);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Shape factor for the convexity of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="convexity">Convexity of the input contours or polygons.</param>
        public static void ConvexityXld(HObject XLD, out HTuple convexity)
        {
            IntPtr proc = HalconAPI.PreCall(1683);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out convexity);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Shape factor for the circularity (similarity to a circle) of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="circularity">Roundness of the input contours or polygons.</param>
        public static void CircularityXld(HObject XLD, out HTuple circularity)
        {
            IntPtr proc = HalconAPI.PreCall(1684);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out circularity);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Parameters of the equivalent ellipse of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="ra">Major radius.</param>
        /// <param name="rb">Minor radius.</param>
        /// <param name="phi">Angle between the major axis and the x axis (radians).</param>
        public static void EllipticAxisXld(HObject XLD, out HTuple ra, out HTuple rb, out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(1685);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out ra);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out rb);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Smallest enclosing rectangle with arbitrary orientation of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="row">Row coordinate of the center point of the enclosing rectangle.</param>
        /// <param name="column">Column coordinate of the center point of the enclosing rectangle.</param>
        /// <param name="phi">Orientation of the enclosing rectangle (arc measure)</param>
        /// <param name="length1">First radius (half length) of the enclosing rectangle.</param>
        /// <param name="length2">Second radius (half width) of the enclosing rectangle.</param>
        public static void SmallestRectangle2Xld(
          HObject XLD,
          out HTuple row,
          out HTuple column,
          out HTuple phi,
          out HTuple length1,
          out HTuple length2)
        {
            IntPtr proc = HalconAPI.PreCall(1686);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out length1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out length2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Enclosing rectangle parallel to the coordinate axes of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="row1">Row coordinate of upper left corner point of the enclosing rectangle.</param>
        /// <param name="column1">Column coordinate of upper left corner point of the enclosing rectangle.</param>
        /// <param name="row2">Row coordinate of lower right corner point of the enclosing rectangle.</param>
        /// <param name="column2">Column coordinate of lower right corner point of the enclosing rectangle.</param>
        public static void SmallestRectangle1Xld(
          HObject XLD,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1687);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out row2);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out column2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Smallest enclosing circle of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="row">Row coordinate of the center of the enclosing circle.</param>
        /// <param name="column">Column coordinate of the center of the enclosing circle.</param>
        /// <param name="radius">Radius of the enclosing circle.</param>
        public static void SmallestCircleXld(
          HObject XLD,
          out HTuple row,
          out HTuple column,
          out HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(1688);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out radius);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Transform the shape of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be transformed.</param>
        /// <param name="XLDTrans">Transformed contours respectively polygons.</param>
        /// <param name="type">Type of transformation. Default: "convex"</param>
        public static void ShapeTransXld(HObject XLD, out HObject XLDTrans, HTuple type)
        {
            IntPtr proc = HalconAPI.PreCall(1689);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            int procResult = HObject.LoadNew(proc, 1, err, out XLDTrans);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Length of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="length">Length of the contour or polygon.</param>
        public static void LengthXld(HObject XLD, out HTuple length)
        {
            IntPtr proc = HalconAPI.PreCall(1690);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out length);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Arbitrary geometric moments of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="mode">Computation mode. Default: "unnormalized"</param>
        /// <param name="pointOrder">Point order along the boundary. Default: "positive"</param>
        /// <param name="area">Area enclosed by the contour or polygon.</param>
        /// <param name="centerRow">Row coordinate of the centroid.</param>
        /// <param name="centerCol">Column coordinate of the centroid.</param>
        /// <param name="p">First index of the desired moments M[P,Q]@f$M_{p,q}$. Default: 1</param>
        /// <param name="q">Second index of the desired moments M[P,Q]@f$M_{p,q}$. Default: 1</param>
        /// <param name="m">The computed moments.</param>
        public static void MomentsAnyXld(
          HObject XLD,
          HTuple mode,
          HTuple pointOrder,
          HTuple area,
          HTuple centerRow,
          HTuple centerCol,
          HTuple p,
          HTuple q,
          out HTuple m)
        {
            IntPtr proc = HalconAPI.PreCall(1691);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, pointOrder);
            HalconAPI.Store(proc, 2, area);
            HalconAPI.Store(proc, 3, centerRow);
            HalconAPI.Store(proc, 4, centerCol);
            HalconAPI.Store(proc, 5, p);
            HalconAPI.Store(proc, 6, q);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(pointOrder);
            HalconAPI.UnpinTuple(area);
            HalconAPI.UnpinTuple(centerRow);
            HalconAPI.UnpinTuple(centerCol);
            HalconAPI.UnpinTuple(p);
            HalconAPI.UnpinTuple(q);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out m);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Geometric moments M20@f$M_{20}$, M02@f$M_{02}$, and M11@f$M_{11}$ of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="m11">Mixed second order moment.</param>
        /// <param name="m20">Second order moment along the row axis.</param>
        /// <param name="m02">Second order moment along the column axis.</param>
        public static void MomentsXld(HObject XLD, out HTuple m11, out HTuple m20, out HTuple m02)
        {
            IntPtr proc = HalconAPI.PreCall(1692);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out m11);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out m20);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out m02);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Area and center of gravity (centroid) of contours and polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="area">Area enclosed by the contour or polygon.</param>
        /// <param name="row">Row coordinate of the centroid.</param>
        /// <param name="column">Column coordinate of the centroid.</param>
        /// <param name="pointOrder">point order along the boundary ('positive'/'negative').</param>
        public static void AreaCenterXld(
          HObject XLD,
          out HTuple area,
          out HTuple row,
          out HTuple column,
          out HTuple pointOrder)
        {
            IntPtr proc = HalconAPI.PreCall(1693);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out area);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out row);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out column);
            int procResult = HTuple.LoadNew(proc, 3, err4, out pointOrder);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Geometric moments of regions.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="PSI1">Moment of 2nd order.</param>
        /// <param name="PSI2">Moment of 2nd order.</param>
        /// <param name="PSI3">Moment of 2nd order.</param>
        /// <param name="PSI4">Moment of 2nd order.</param>
        public static void MomentsRegionCentralInvar(
          HObject regions,
          out HTuple PSI1,
          out HTuple PSI2,
          out HTuple PSI3,
          out HTuple PSI4)
        {
            IntPtr proc = HalconAPI.PreCall(1694);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out PSI1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out PSI2);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out PSI3);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out PSI4);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Geometric moments of regions.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="i1">Moment of 2nd order.</param>
        /// <param name="i2">Moment of 2nd order.</param>
        /// <param name="i3">Moment of 2nd order.</param>
        /// <param name="i4">Moment of 3rd order.</param>
        public static void MomentsRegionCentral(
          HObject regions,
          out HTuple i1,
          out HTuple i2,
          out HTuple i3,
          out HTuple i4)
        {
            IntPtr proc = HalconAPI.PreCall(1695);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out i1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out i2);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out i3);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out i4);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Geometric moments of regions.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="m21">Moment of 3rd order (line-dependent).</param>
        /// <param name="m12">Moment of 3rd order (column-dependent).</param>
        /// <param name="m03">Moment of 3rd order (column-dependent).</param>
        /// <param name="m30">Moment of 3rd order (line-dependent).</param>
        public static void MomentsRegion3rdInvar(
          HObject regions,
          out HTuple m21,
          out HTuple m12,
          out HTuple m03,
          out HTuple m30)
        {
            IntPtr proc = HalconAPI.PreCall(1696);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out m21);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out m12);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out m03);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out m30);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Geometric moments of regions.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="m21">Moment of 3rd order (line-dependent).</param>
        /// <param name="m12">Moment of 3rd order (column-dependent).</param>
        /// <param name="m03">Moment of 3rd order (column-dependent).</param>
        /// <param name="m30">Moment of 3rd order (line-dependent).</param>
        public static void MomentsRegion3rd(
          HObject regions,
          out HTuple m21,
          out HTuple m12,
          out HTuple m03,
          out HTuple m30)
        {
            IntPtr proc = HalconAPI.PreCall(1697);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out m21);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out m12);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out m03);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out m30);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Smallest surrounding rectangle with any orientation.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="row">Line index of the center.</param>
        /// <param name="column">Column index of the center.</param>
        /// <param name="phi">Orientation of the surrounding rectangle (arc measure)</param>
        /// <param name="length1">First radius (half length) of the surrounding rectangle.</param>
        /// <param name="length2">Second radius (half width) of the surrounding rectangle.</param>
        public static void SmallestRectangle2(
          HObject regions,
          out HTuple row,
          out HTuple column,
          out HTuple phi,
          out HTuple length1,
          out HTuple length2)
        {
            IntPtr proc = HalconAPI.PreCall(1698);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out length1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out length2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Surrounding rectangle parallel to the coordinate axes.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="row1">Line index of upper left corner point.</param>
        /// <param name="column1">Column index of upper left corner point.</param>
        /// <param name="row2">Line index of lower right corner point.</param>
        /// <param name="column2">Column index of lower right corner point.</param>
        public static void SmallestRectangle1(
          HObject regions,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1699);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out row1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out column1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out row2);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out column2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Smallest surrounding circle of a region.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="row">Line index of the center.</param>
        /// <param name="column">Column index of the center.</param>
        /// <param name="radius">Radius of the surrounding circle.</param>
        public static void SmallestCircle(
          HObject regions,
          out HTuple row,
          out HTuple column,
          out HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(1700);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out radius);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Choose regions having a certain relation to each other.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="pattern">Region compared to Regions.</param>
        /// <param name="selectedRegions">Regions fulfilling the condition.</param>
        /// <param name="feature">Shape features to be checked. Default: "covers"</param>
        /// <param name="min">Lower border of feature. Default: 50.0</param>
        /// <param name="max">Upper border of the feature. Default: 100.0</param>
        public static void SelectShapeProto(
          HObject regions,
          HObject pattern,
          out HObject selectedRegions,
          HTuple feature,
          HTuple min,
          HTuple max)
        {
            IntPtr proc = HalconAPI.PreCall(1701);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)pattern);
            HalconAPI.Store(proc, 0, feature);
            HalconAPI.Store(proc, 1, min);
            HalconAPI.Store(proc, 2, max);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(feature);
            HalconAPI.UnpinTuple(min);
            HalconAPI.UnpinTuple(max);
            int procResult = HObject.LoadNew(proc, 1, err, out selectedRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)pattern);
        }

        /// <summary>Calculate shape features of regions.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="features">Shape features to be calculated. Default: "area"</param>
        /// <param name="value">The calculated features.</param>
        public static void RegionFeatures(HObject regions, HTuple features, out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(1702);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, features);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(features);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out value);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Choose regions with the aid of shape features.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="selectedRegions">Regions fulfilling the condition.</param>
        /// <param name="features">Shape features to be checked. Default: "area"</param>
        /// <param name="operation">Linkage type of the individual features. Default: "and"</param>
        /// <param name="min">Lower limits of the features or 'min'. Default: 150.0</param>
        /// <param name="max">Upper limits of the features or 'max'. Default: 99999.0</param>
        public static void SelectShape(
          HObject regions,
          out HObject selectedRegions,
          HTuple features,
          HTuple operation,
          HTuple min,
          HTuple max)
        {
            IntPtr proc = HalconAPI.PreCall(1703);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, features);
            HalconAPI.Store(proc, 1, operation);
            HalconAPI.Store(proc, 2, min);
            HalconAPI.Store(proc, 3, max);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(operation);
            HalconAPI.UnpinTuple(min);
            HalconAPI.UnpinTuple(max);
            int procResult = HObject.LoadNew(proc, 1, err, out selectedRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Characteristic values for runlength coding of regions.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="numRuns">Number of runs.</param>
        /// <param name="KFactor">Storing factor in relation to a square.</param>
        /// <param name="LFactor">Mean number of runs per line.</param>
        /// <param name="meanLength">Mean length of runs.</param>
        /// <param name="bytes">Number of bytes necessary for coding the region.</param>
        public static void RunlengthFeatures(
          HObject regions,
          out HTuple numRuns,
          out HTuple KFactor,
          out HTuple LFactor,
          out HTuple meanLength,
          out HTuple bytes)
        {
            IntPtr proc = HalconAPI.PreCall(1704);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out numRuns);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out KFactor);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out LFactor);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out meanLength);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out bytes);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Search direct neighbors.</summary>
        /// <param name="regions1">Starting regions.</param>
        /// <param name="regions2">Comparative regions.</param>
        /// <param name="maxDistance">Maximal distance of regions. Default: 1</param>
        /// <param name="regionIndex1">Indices of the found regions from Regions1.</param>
        /// <param name="regionIndex2">Indices of the found regions from Regions2.</param>
        public static void FindNeighbors(
          HObject regions1,
          HObject regions2,
          HTuple maxDistance,
          out HTuple regionIndex1,
          out HTuple regionIndex2)
        {
            IntPtr proc = HalconAPI.PreCall(1705);
            HalconAPI.Store(proc, 1, (HObjectBase)regions1);
            HalconAPI.Store(proc, 2, (HObjectBase)regions2);
            HalconAPI.Store(proc, 0, maxDistance);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maxDistance);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out regionIndex1);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out regionIndex2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions1);
            GC.KeepAlive((object)regions2);
        }

        /// <summary>Geometric moments of regions.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="PHI1">Moment of 2nd order.</param>
        /// <param name="PHI2">Moment of 2nd order.</param>
        public static void MomentsRegion2ndRelInvar(HObject regions, out HTuple PHI1, out HTuple PHI2)
        {
            IntPtr proc = HalconAPI.PreCall(1706);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out PHI1);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out PHI2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Geometric moments of regions.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="m11">Product of inertia of the axes through the center parallel to the coordinate axes.</param>
        /// <param name="m20">Moment of 2nd order (line-dependent).</param>
        /// <param name="m02">Moment of 2nd order (column-dependent).</param>
        public static void MomentsRegion2ndInvar(
          HObject regions,
          out HTuple m11,
          out HTuple m20,
          out HTuple m02)
        {
            IntPtr proc = HalconAPI.PreCall(1707);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out m11);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out m20);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out m02);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Calculate the geometric moments of regions.</summary>
        /// <param name="regions">Input regions.</param>
        /// <param name="m11">Product of inertia of the axes through the center parallel to the coordinate axes.</param>
        /// <param name="m20">Moment of 2nd order (row-dependent).</param>
        /// <param name="m02">Moment of 2nd order (column-dependent).</param>
        /// <param name="ia">Length of the major axis of the input region.</param>
        /// <param name="ib">Length of the minor axis of the input region.</param>
        public static void MomentsRegion2nd(
          HObject regions,
          out HTuple m11,
          out HTuple m20,
          out HTuple m02,
          out HTuple ia,
          out HTuple ib)
        {
            IntPtr proc = HalconAPI.PreCall(1708);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out m11);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out m20);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out m02);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out ia);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out ib);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Minimum distance between the contour pixels of two regions each.</summary>
        /// <param name="regions1">Regions to be examined.</param>
        /// <param name="regions2">Regions to be examined.</param>
        /// <param name="minDistance">Minimum distance between contours of the regions.</param>
        /// <param name="row1">Line index on contour in Regions1.</param>
        /// <param name="column1">Column index on contour in Regions1.</param>
        /// <param name="row2">Line index on contour in Regions2.</param>
        /// <param name="column2">Column index on contour in Regions2.</param>
        public static void DistanceRrMin(
          HObject regions1,
          HObject regions2,
          out HTuple minDistance,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1709);
            HalconAPI.Store(proc, 1, (HObjectBase)regions1);
            HalconAPI.Store(proc, 2, (HObjectBase)regions2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out minDistance);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out row1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out column1);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out row2);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out column2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions1);
            GC.KeepAlive((object)regions2);
        }

        /// <summary>Minimum distance between two regions with the help of dilation.</summary>
        /// <param name="regions1">Regions to be examined.</param>
        /// <param name="regions2">Regions to be examined.</param>
        /// <param name="minDistance">Minimum distances of the regions.</param>
        public static void DistanceRrMinDil(HObject regions1, HObject regions2, out HTuple minDistance)
        {
            IntPtr proc = HalconAPI.PreCall(1710);
            HalconAPI.Store(proc, 1, (HObjectBase)regions1);
            HalconAPI.Store(proc, 2, (HObjectBase)regions2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out minDistance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions1);
            GC.KeepAlive((object)regions2);
        }

        /// <summary>Maximal distance between two boundary points of a region.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="row1">Row index of the first extreme point.</param>
        /// <param name="column1">Column index of the first extreme point.</param>
        /// <param name="row2">Row index of the second extreme point.</param>
        /// <param name="column2">Column index of the second extreme point.</param>
        /// <param name="diameter">Distance of the two extreme points.</param>
        public static void DiameterRegion(
          HObject regions,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2,
          out HTuple diameter)
        {
            IntPtr proc = HalconAPI.PreCall(1711);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out row1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out column1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out row2);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out column2);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out diameter);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Test if the region contains a given point.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="row">Row index of the test pixel(s). Default: 100</param>
        /// <param name="column">Column index of the test pixel(s). Default: 100</param>
        /// <param name="isInside">Boolean result value.</param>
        public static void TestRegionPoint(
          HObject regions,
          HTuple row,
          HTuple column,
          out HTuple isInside)
        {
            IntPtr proc = HalconAPI.PreCall(1712);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out isInside);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Index of all regions containing a given pixel.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="row">Line index of the test pixel. Default: 100</param>
        /// <param name="column">Column index of the test pixel. Default: 100</param>
        /// <param name="index">Index of the regions containing the test pixel.</param>
        public static void GetRegionIndex(
          HObject regions,
          HTuple row,
          HTuple column,
          out HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(1713);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out index);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Choose all regions containing a given pixel.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="destRegions">All regions containing the test pixel.</param>
        /// <param name="row">Line index of the test pixel. Default: 100</param>
        /// <param name="column">Column index of the test pixel. Default: 100</param>
        public static void SelectRegionPoint(
          HObject regions,
          out HObject destRegions,
          HTuple row,
          HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1714);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int procResult = HObject.LoadNew(proc, 1, err, out destRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Select regions of a given shape.</summary>
        /// <param name="regions">Input regions to be selected.</param>
        /// <param name="selectedRegions">Regions with desired shape.</param>
        /// <param name="shape">Shape features to be checked. Default: "max_area"</param>
        /// <param name="percent">Similarity measure. Default: 70.0</param>
        public static void SelectShapeStd(
          HObject regions,
          out HObject selectedRegions,
          HTuple shape,
          HTuple percent)
        {
            IntPtr proc = HalconAPI.PreCall(1715);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, shape);
            HalconAPI.Store(proc, 1, percent);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(shape);
            HalconAPI.UnpinTuple(percent);
            int procResult = HObject.LoadNew(proc, 1, err, out selectedRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Hamming distance between two regions using normalization.</summary>
        /// <param name="regions1">Regions to be examined.</param>
        /// <param name="regions2">Comparative regions.</param>
        /// <param name="norm">Type of normalization. Default: "center"</param>
        /// <param name="distance">Hamming distance of two regions.</param>
        /// <param name="similarity">Similarity of two regions.</param>
        public static void HammingDistanceNorm(
          HObject regions1,
          HObject regions2,
          HTuple norm,
          out HTuple distance,
          out HTuple similarity)
        {
            IntPtr proc = HalconAPI.PreCall(1716);
            HalconAPI.Store(proc, 1, (HObjectBase)regions1);
            HalconAPI.Store(proc, 2, (HObjectBase)regions2);
            HalconAPI.Store(proc, 0, norm);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(norm);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out distance);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out similarity);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions1);
            GC.KeepAlive((object)regions2);
        }

        /// <summary>Hamming distance between two regions.</summary>
        /// <param name="regions1">Regions to be examined.</param>
        /// <param name="regions2">Comparative regions.</param>
        /// <param name="distance">Hamming distance of two regions.</param>
        /// <param name="similarity">Similarity of two regions.</param>
        public static void HammingDistance(
          HObject regions1,
          HObject regions2,
          out HTuple distance,
          out HTuple similarity)
        {
            IntPtr proc = HalconAPI.PreCall(1717);
            HalconAPI.Store(proc, 1, (HObjectBase)regions1);
            HalconAPI.Store(proc, 2, (HObjectBase)regions2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out distance);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out similarity);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions1);
            GC.KeepAlive((object)regions2);
        }

        /// <summary>Shape features derived from the ellipse parameters.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="anisometry">Shape feature (in case of a circle = 1.0).</param>
        /// <param name="bulkiness">Calculated shape feature.</param>
        /// <param name="structureFactor">Calculated shape feature.</param>
        public static void Eccentricity(
          HObject regions,
          out HTuple anisometry,
          out HTuple bulkiness,
          out HTuple structureFactor)
        {
            IntPtr proc = HalconAPI.PreCall(1718);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out anisometry);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out bulkiness);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out structureFactor);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Calculate the Euler number.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="eulerNumber">Calculated Euler number.</param>
        public static void EulerNumber(HObject regions, out HTuple eulerNumber)
        {
            IntPtr proc = HalconAPI.PreCall(1719);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out eulerNumber);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Orientation of a region.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="phi">Orientation of region (arc measure).</param>
        public static void OrientationRegion(HObject regions, out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(1720);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out phi);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Calculate the parameters of the equivalent ellipse.</summary>
        /// <param name="regions">Input regions.</param>
        /// <param name="ra">Main radius (normalized to the area).</param>
        /// <param name="rb">Secondary radius (normalized to the area).</param>
        /// <param name="phi">Angle between main radius and x-axis in radians.</param>
        public static void EllipticAxis(HObject regions, out HTuple ra, out HTuple rb, out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(1721);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out ra);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out rb);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Pose relation of regions.</summary>
        /// <param name="regions1">Starting regions</param>
        /// <param name="regions2">Comparative regions</param>
        /// <param name="direction">Desired neighboring relation. Default: "left"</param>
        /// <param name="regionIndex1">Indices in the input tuples (Regions1 or ParRef{Regions2}), respectively.</param>
        /// <param name="regionIndex2">Indices in the input tuples (Regions1 or ParRef{Regions2}), respectively.</param>
        public static void SelectRegionSpatial(
          HObject regions1,
          HObject regions2,
          HTuple direction,
          out HTuple regionIndex1,
          out HTuple regionIndex2)
        {
            IntPtr proc = HalconAPI.PreCall(1722);
            HalconAPI.Store(proc, 1, (HObjectBase)regions1);
            HalconAPI.Store(proc, 2, (HObjectBase)regions2);
            HalconAPI.Store(proc, 0, direction);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(direction);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out regionIndex1);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out regionIndex2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions1);
            GC.KeepAlive((object)regions2);
        }

        /// <summary>Pose relation of regions with regard to </summary>
        /// <param name="regions1">Starting regions.</param>
        /// <param name="regions2">Comparative regions.</param>
        /// <param name="percent">Percentage of the area of the comparative region which must be located left/right or  Default: 50</param>
        /// <param name="regionIndex1">Indices of the regions in the tuple of the input regions which fulfill the pose relation.</param>
        /// <param name="regionIndex2">Indices of the regions in the tuple of the input regions which fulfill the pose relation.</param>
        /// <param name="relation1">Horizontal pose relation in which RegionIndex2[n] stands with RegionIndex1[n].</param>
        /// <param name="relation2">Vertical pose relation in which RegionIndex2[n] stands with RegionIndex1[n].</param>
        public static void SpatialRelation(
          HObject regions1,
          HObject regions2,
          HTuple percent,
          out HTuple regionIndex1,
          out HTuple regionIndex2,
          out HTuple relation1,
          out HTuple relation2)
        {
            IntPtr proc = HalconAPI.PreCall(1723);
            HalconAPI.Store(proc, 1, (HObjectBase)regions1);
            HalconAPI.Store(proc, 2, (HObjectBase)regions2);
            HalconAPI.Store(proc, 0, percent);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(percent);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out regionIndex1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out regionIndex2);
            int err4 = HTuple.LoadNew(proc, 2, err3, out relation1);
            int procResult = HTuple.LoadNew(proc, 3, err4, out relation2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions1);
            GC.KeepAlive((object)regions2);
        }

        /// <summary>Shape factor for the convexity of a region.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="convexity">Convexity of the input region(s).</param>
        public static void Convexity(HObject regions, out HTuple convexity)
        {
            IntPtr proc = HalconAPI.PreCall(1724);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out convexity);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Contour length of a region.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="contLength">Contour length of the input region(s).</param>
        public static void Contlength(HObject regions, out HTuple contLength)
        {
            IntPtr proc = HalconAPI.PreCall(1725);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out contLength);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Number of connection components and holes</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="numConnected">Number of connection components of a region.</param>
        /// <param name="numHoles">Number of holes of a region.</param>
        public static void ConnectAndHoles(
          HObject regions,
          out HTuple numConnected,
          out HTuple numHoles)
        {
            IntPtr proc = HalconAPI.PreCall(1726);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out numConnected);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out numHoles);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Shape factor for the rectangularity of a region.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="rectangularity">Rectangularity of the input region(s).</param>
        public static void Rectangularity(HObject regions, out HTuple rectangularity)
        {
            IntPtr proc = HalconAPI.PreCall(1727);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out rectangularity);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Shape factor for the compactness of a region.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="compactness">Compactness of the input region(s).</param>
        public static void Compactness(HObject regions, out HTuple compactness)
        {
            IntPtr proc = HalconAPI.PreCall(1728);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out compactness);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Shape factor for the circularity (similarity to a circle) of a region.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="circularity">Circularity of the input region(s).</param>
        public static void Circularity(HObject regions, out HTuple circularity)
        {
            IntPtr proc = HalconAPI.PreCall(1729);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out circularity);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Compute the area of holes of regions.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="area">Area(s) of holes of the region(s).</param>
        public static void AreaHoles(HObject regions, out HTuple area)
        {
            IntPtr proc = HalconAPI.PreCall(1730);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out area);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Area and center of regions.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="area">Area of the region.</param>
        /// <param name="row">Line index of the center.</param>
        /// <param name="column">Column index of the center.</param>
        public static void AreaCenter(
          HObject regions,
          out HTuple area,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1731);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out area);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out row);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Distribution of runs needed for runlength encoding of a region.</summary>
        /// <param name="region">Region to be examined.</param>
        /// <param name="foreground">Length distribution of the region (foreground).</param>
        /// <param name="background">Length distribution of the background.</param>
        public static void RunlengthDistribution(
          HObject region,
          out HTuple foreground,
          out HTuple background)
        {
            IntPtr proc = HalconAPI.PreCall(1732);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out foreground);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out background);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
        }

        /// <summary>Shape factors from contour.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="distance">Mean distance from the center.</param>
        /// <param name="sigma">Standard deviation of Distance.</param>
        /// <param name="roundness">Shape factor for roundness.</param>
        /// <param name="sides">Number of polygon sides.</param>
        public static void Roundness(
          HObject regions,
          out HTuple distance,
          out HTuple sigma,
          out HTuple roundness,
          out HTuple sides)
        {
            IntPtr proc = HalconAPI.PreCall(1733);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distance);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out sigma);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out roundness);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out sides);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Largest inner rectangle of a region.</summary>
        /// <param name="regions">Region to be examined.</param>
        /// <param name="row1">Row coordinate of the upper left corner point.</param>
        /// <param name="column1">Column coordinate of the upper left corner point.</param>
        /// <param name="row2">Row coordinate of the lower right corner point.</param>
        /// <param name="column2">Column coordinate of the lower right corner point.</param>
        public static void InnerRectangle1(
          HObject regions,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1734);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out row1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out column1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out row2);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out column2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Largest inner circle of a region.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="row">Line index of the center.</param>
        /// <param name="column">Column index of the center.</param>
        /// <param name="radius">Radius of the inner circle.</param>
        public static void InnerCircle(
          HObject regions,
          out HTuple row,
          out HTuple column,
          out HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(1735);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out radius);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Select the longest input lines.</summary>
        /// <param name="rowBeginIn">Row coordinates of the starting points of the input lines.</param>
        /// <param name="colBeginIn">Column coordinates of the starting points of the input lines.</param>
        /// <param name="rowEndIn">Row coordinates of the ending points of the input lines.</param>
        /// <param name="colEndIn">Column coordinates  of the ending points of the input lines.</param>
        /// <param name="num">(Maximum) desired number of output lines. Default: 10</param>
        /// <param name="rowBeginOut">Row coordinates of the starting points of the output lines.</param>
        /// <param name="colBeginOut">Column coordinates of the starting points of the output lines.</param>
        /// <param name="rowEndOut">Row coordinates of the ending points of the output lines.</param>
        /// <param name="colEndOut">Column coordinates of the ending points of the output lines.</param>
        public static void SelectLinesLongest(
          HTuple rowBeginIn,
          HTuple colBeginIn,
          HTuple rowEndIn,
          HTuple colEndIn,
          HTuple num,
          out HTuple rowBeginOut,
          out HTuple colBeginOut,
          out HTuple rowEndOut,
          out HTuple colEndOut)
        {
            IntPtr proc = HalconAPI.PreCall(1736);
            HalconAPI.Store(proc, 0, rowBeginIn);
            HalconAPI.Store(proc, 1, colBeginIn);
            HalconAPI.Store(proc, 2, rowEndIn);
            HalconAPI.Store(proc, 3, colEndIn);
            HalconAPI.Store(proc, 4, num);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rowBeginIn);
            HalconAPI.UnpinTuple(colBeginIn);
            HalconAPI.UnpinTuple(rowEndIn);
            HalconAPI.UnpinTuple(colEndIn);
            HalconAPI.UnpinTuple(num);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out rowBeginOut);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out colBeginOut);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out rowEndOut);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out colEndOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Partition lines according to various criteria.</summary>
        /// <param name="rowBeginIn">Row coordinates of the starting points of the input lines.</param>
        /// <param name="colBeginIn">Column coordinates of the starting points of the input lines.</param>
        /// <param name="rowEndIn">Row coordinates of the ending points of the input lines.</param>
        /// <param name="colEndIn">Column coordinates  of the ending points of the input lines.</param>
        /// <param name="feature">Features to be used for selection.</param>
        /// <param name="operation">Desired combination of the features.</param>
        /// <param name="min">Lower limits of the features or 'min'. Default: "min"</param>
        /// <param name="max">Upper limits of the features or 'max'. Default: "max"</param>
        /// <param name="rowBeginOut">Row coordinates of the starting points of the lines fulfilling the conditions.</param>
        /// <param name="colBeginOut">Column coordinates of the starting points of the lines fulfilling the conditions.</param>
        /// <param name="rowEndOut">Row coordinates of the ending points of the lines fulfilling the conditions.</param>
        /// <param name="colEndOut">Column coordinates of the ending points of the lines fulfilling the conditions.</param>
        /// <param name="failRowBOut">Row coordinates of the starting points of the lines not fulfilling the conditions.</param>
        /// <param name="failColBOut">Column coordinates of the starting points of the lines not fulfilling the conditions.</param>
        /// <param name="failRowEOut">Row coordinates of the ending points of the lines not fulfilling the conditions.</param>
        /// <param name="failColEOut">Column coordinates of the ending points of the lines not fulfilling the conditions.</param>
        public static void PartitionLines(
          HTuple rowBeginIn,
          HTuple colBeginIn,
          HTuple rowEndIn,
          HTuple colEndIn,
          HTuple feature,
          HTuple operation,
          HTuple min,
          HTuple max,
          out HTuple rowBeginOut,
          out HTuple colBeginOut,
          out HTuple rowEndOut,
          out HTuple colEndOut,
          out HTuple failRowBOut,
          out HTuple failColBOut,
          out HTuple failRowEOut,
          out HTuple failColEOut)
        {
            IntPtr proc = HalconAPI.PreCall(1737);
            HalconAPI.Store(proc, 0, rowBeginIn);
            HalconAPI.Store(proc, 1, colBeginIn);
            HalconAPI.Store(proc, 2, rowEndIn);
            HalconAPI.Store(proc, 3, colEndIn);
            HalconAPI.Store(proc, 4, feature);
            HalconAPI.Store(proc, 5, operation);
            HalconAPI.Store(proc, 6, min);
            HalconAPI.Store(proc, 7, max);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rowBeginIn);
            HalconAPI.UnpinTuple(colBeginIn);
            HalconAPI.UnpinTuple(rowEndIn);
            HalconAPI.UnpinTuple(colEndIn);
            HalconAPI.UnpinTuple(feature);
            HalconAPI.UnpinTuple(operation);
            HalconAPI.UnpinTuple(min);
            HalconAPI.UnpinTuple(max);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out rowBeginOut);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out colBeginOut);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out rowEndOut);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out colEndOut);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out failRowBOut);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out failColBOut);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.INTEGER, err7, out failRowEOut);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.INTEGER, err8, out failColEOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select lines according to various criteria.</summary>
        /// <param name="rowBeginIn">Row coordinates of the starting points of the input lines.</param>
        /// <param name="colBeginIn">Column coordinates of the starting points of the input lines.</param>
        /// <param name="rowEndIn">Row coordinates of the ending points of the input lines.</param>
        /// <param name="colEndIn">Column coordinates  of the ending points of the input lines.</param>
        /// <param name="feature">Features to be used for selection. Default: "length"</param>
        /// <param name="operation">Desired combination of the features. Default: "and"</param>
        /// <param name="min">Lower limits of the features or 'min'. Default: "min"</param>
        /// <param name="max">Upper limits of the features or 'max'. Default: "max"</param>
        /// <param name="rowBeginOut">Row coordinates of the starting points of the output lines.</param>
        /// <param name="colBeginOut">Column coordinates of the starting points of the output lines.</param>
        /// <param name="rowEndOut">Row coordinates of the ending points of the output lines.</param>
        /// <param name="colEndOut">Column coordinates of the ending points of the output lines.</param>
        public static void SelectLines(
          HTuple rowBeginIn,
          HTuple colBeginIn,
          HTuple rowEndIn,
          HTuple colEndIn,
          HTuple feature,
          HTuple operation,
          HTuple min,
          HTuple max,
          out HTuple rowBeginOut,
          out HTuple colBeginOut,
          out HTuple rowEndOut,
          out HTuple colEndOut)
        {
            IntPtr proc = HalconAPI.PreCall(1738);
            HalconAPI.Store(proc, 0, rowBeginIn);
            HalconAPI.Store(proc, 1, colBeginIn);
            HalconAPI.Store(proc, 2, rowEndIn);
            HalconAPI.Store(proc, 3, colEndIn);
            HalconAPI.Store(proc, 4, feature);
            HalconAPI.Store(proc, 5, operation);
            HalconAPI.Store(proc, 6, min);
            HalconAPI.Store(proc, 7, max);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rowBeginIn);
            HalconAPI.UnpinTuple(colBeginIn);
            HalconAPI.UnpinTuple(rowEndIn);
            HalconAPI.UnpinTuple(colEndIn);
            HalconAPI.UnpinTuple(feature);
            HalconAPI.UnpinTuple(operation);
            HalconAPI.UnpinTuple(min);
            HalconAPI.UnpinTuple(max);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out rowBeginOut);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out colBeginOut);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out rowEndOut);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out colEndOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the center of gravity, length, and orientation of a line.</summary>
        /// <param name="rowBegin">Row coordinates of the starting points of the input lines.</param>
        /// <param name="colBegin">Column coordinates of the starting points of the input lines.</param>
        /// <param name="rowEnd">Row coordinates of the ending points of the input lines.</param>
        /// <param name="colEnd">Column coordinates  of the ending points of the input lines.</param>
        /// <param name="rowCenter">Row coordinates of the centers of gravity of the input lines.</param>
        /// <param name="colCenter">Column coordinates of the centers of gravity of the input lines.</param>
        /// <param name="length">Euclidean length of the input lines.</param>
        /// <param name="phi">Orientation of the input lines.</param>
        public static void LinePosition(
          HTuple rowBegin,
          HTuple colBegin,
          HTuple rowEnd,
          HTuple colEnd,
          out HTuple rowCenter,
          out HTuple colCenter,
          out HTuple length,
          out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(1739);
            HalconAPI.Store(proc, 0, rowBegin);
            HalconAPI.Store(proc, 1, colBegin);
            HalconAPI.Store(proc, 2, rowEnd);
            HalconAPI.Store(proc, 3, colEnd);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rowBegin);
            HalconAPI.UnpinTuple(colBegin);
            HalconAPI.UnpinTuple(rowEnd);
            HalconAPI.UnpinTuple(colEnd);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowCenter);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out colCenter);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out length);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out phi);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the orientation of lines.</summary>
        /// <param name="rowBegin">Row coordinates of the starting points of the input lines.</param>
        /// <param name="colBegin">Column coordinates of the starting points of the input lines.</param>
        /// <param name="rowEnd">Row coordinates of the ending points of the input lines.</param>
        /// <param name="colEnd">Column coordinates  of the ending points of the input lines.</param>
        /// <param name="phi">Orientation of the input lines.</param>
        public static void LineOrientation(
          HTuple rowBegin,
          HTuple colBegin,
          HTuple rowEnd,
          HTuple colEnd,
          out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(1740);
            HalconAPI.Store(proc, 0, rowBegin);
            HalconAPI.Store(proc, 1, colBegin);
            HalconAPI.Store(proc, 2, rowEnd);
            HalconAPI.Store(proc, 3, colEnd);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rowBegin);
            HalconAPI.UnpinTuple(colBegin);
            HalconAPI.UnpinTuple(rowEnd);
            HalconAPI.UnpinTuple(colEnd);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out phi);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Approximate a contour by arcs and lines.</summary>
        /// <param name="row">Row of the contour. Default: 32</param>
        /// <param name="column">Column of the contour. Default: 32</param>
        /// <param name="arcCenterRow">Row of the center of an arc.</param>
        /// <param name="arcCenterCol">Column of the center of an arc.</param>
        /// <param name="arcAngle">Angle of an arc.</param>
        /// <param name="arcBeginRow">Row of the starting point of an arc.</param>
        /// <param name="arcBeginCol">Column of the starting point of an arc.</param>
        /// <param name="lineBeginRow">Row of the starting point of a line segment.</param>
        /// <param name="lineBeginCol">Column of the starting point of a line segment.</param>
        /// <param name="lineEndRow">Row of the ending point of a line segment.</param>
        /// <param name="lineEndCol">Column of the ending point of a line segment.</param>
        /// <param name="order">Sequence of line (value 0) and arc segments (value 1).</param>
        public static void ApproxChainSimple(
          HTuple row,
          HTuple column,
          out HTuple arcCenterRow,
          out HTuple arcCenterCol,
          out HTuple arcAngle,
          out HTuple arcBeginRow,
          out HTuple arcBeginCol,
          out HTuple lineBeginRow,
          out HTuple lineBeginCol,
          out HTuple lineEndRow,
          out HTuple lineEndCol,
          out HTuple order)
        {
            IntPtr proc = HalconAPI.PreCall(1741);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out arcCenterRow);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out arcCenterCol);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out arcAngle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out arcBeginRow);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out arcBeginCol);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out lineBeginRow);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.INTEGER, err7, out lineBeginCol);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.INTEGER, err8, out lineEndRow);
            int err10 = HTuple.LoadNew(proc, 8, HTupleType.INTEGER, err9, out lineEndCol);
            int procResult = HTuple.LoadNew(proc, 9, HTupleType.INTEGER, err10, out order);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Approximate a contour by arcs and lines.</summary>
        /// <param name="row">Row of the contour. Default: 32</param>
        /// <param name="column">Column of the contour. Default: 32</param>
        /// <param name="minWidthCoord">Minimum width of Gauss operator for coordinate smoothing ($ greater than $ 0.4). Default: 0.5</param>
        /// <param name="maxWidthCoord">Maximum width of Gauss operator for coordinate smoothing ($ greater than $ 0.4). Default: 2.4</param>
        /// <param name="threshStart">Minimum threshold value of the curvature for accepting a corner (relative to the largest curvature present). Default: 0.3</param>
        /// <param name="threshEnd">Maximum threshold value of the curvature for accepting a corner (relative to the largest curvature present). Default: 0.9</param>
        /// <param name="threshStep">Step width for threshold increase. Default: 0.2</param>
        /// <param name="minWidthSmooth">Minimum width of Gauss operator for smoothing the curvature function ($ greater than $ 0.4). Default: 0.5</param>
        /// <param name="maxWidthSmooth">Maximum width of Gauss operator for smoothing the curvature function. Default: 2.4</param>
        /// <param name="minWidthCurve">Minimum width of curve area for curvature determination ($ greater than $ 0.4). Default: 2</param>
        /// <param name="maxWidthCurve">Maximum width of curve area for curvature determination. Default: 12</param>
        /// <param name="weight1">Weighting factor for approximation precision. Default: 1.0</param>
        /// <param name="weight2">Weighting factor for large segments. Default: 1.0</param>
        /// <param name="weight3">Weighting factor for small segments. Default: 1.0</param>
        /// <param name="arcCenterRow">Row of the center of an arc.</param>
        /// <param name="arcCenterCol">Column of the center of an arc.</param>
        /// <param name="arcAngle">Angle of an arc.</param>
        /// <param name="arcBeginRow">Row of the starting point of an arc.</param>
        /// <param name="arcBeginCol">Column of the starting point of an arc.</param>
        /// <param name="lineBeginRow">Row of the starting point of a line segment.</param>
        /// <param name="lineBeginCol">Column of the starting point of a line segment.</param>
        /// <param name="lineEndRow">Row of the ending point of a line segment.</param>
        /// <param name="lineEndCol">Column of the ending point of a line segment.</param>
        /// <param name="order">Sequence of line (value 0) and arc segments (value 1).</param>
        public static void ApproxChain(
          HTuple row,
          HTuple column,
          HTuple minWidthCoord,
          HTuple maxWidthCoord,
          HTuple threshStart,
          HTuple threshEnd,
          HTuple threshStep,
          HTuple minWidthSmooth,
          HTuple maxWidthSmooth,
          HTuple minWidthCurve,
          HTuple maxWidthCurve,
          HTuple weight1,
          HTuple weight2,
          HTuple weight3,
          out HTuple arcCenterRow,
          out HTuple arcCenterCol,
          out HTuple arcAngle,
          out HTuple arcBeginRow,
          out HTuple arcBeginCol,
          out HTuple lineBeginRow,
          out HTuple lineBeginCol,
          out HTuple lineEndRow,
          out HTuple lineEndCol,
          out HTuple order)
        {
            IntPtr proc = HalconAPI.PreCall(1742);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, minWidthCoord);
            HalconAPI.Store(proc, 3, maxWidthCoord);
            HalconAPI.Store(proc, 4, threshStart);
            HalconAPI.Store(proc, 5, threshEnd);
            HalconAPI.Store(proc, 6, threshStep);
            HalconAPI.Store(proc, 7, minWidthSmooth);
            HalconAPI.Store(proc, 8, maxWidthSmooth);
            HalconAPI.Store(proc, 9, minWidthCurve);
            HalconAPI.Store(proc, 10, maxWidthCurve);
            HalconAPI.Store(proc, 11, weight1);
            HalconAPI.Store(proc, 12, weight2);
            HalconAPI.Store(proc, 13, weight3);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(minWidthCoord);
            HalconAPI.UnpinTuple(maxWidthCoord);
            HalconAPI.UnpinTuple(threshStart);
            HalconAPI.UnpinTuple(threshEnd);
            HalconAPI.UnpinTuple(threshStep);
            HalconAPI.UnpinTuple(minWidthSmooth);
            HalconAPI.UnpinTuple(maxWidthSmooth);
            HalconAPI.UnpinTuple(minWidthCurve);
            HalconAPI.UnpinTuple(maxWidthCurve);
            HalconAPI.UnpinTuple(weight1);
            HalconAPI.UnpinTuple(weight2);
            HalconAPI.UnpinTuple(weight3);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out arcCenterRow);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out arcCenterCol);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out arcAngle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out arcBeginRow);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out arcBeginCol);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out lineBeginRow);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.INTEGER, err7, out lineBeginCol);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.INTEGER, err8, out lineEndRow);
            int err10 = HTuple.LoadNew(proc, 8, HTupleType.INTEGER, err9, out lineEndCol);
            int procResult = HTuple.LoadNew(proc, 9, HTupleType.INTEGER, err10, out order);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate gray value moments and approximation by a first order surface (plane).</summary>
        /// <param name="regions">Regions to be checked.</param>
        /// <param name="image">Corresponding gray values.</param>
        /// <param name="algorithm">Algorithm for the fitting. Default: "regression"</param>
        /// <param name="iterations">Maximum number of iterations (unused for 'regression'). Default: 5</param>
        /// <param name="clippingFactor">Clipping factor for the elimination of outliers. Default: 2.0</param>
        /// <param name="alpha">Parameter Alpha of the approximating surface.</param>
        /// <param name="beta">Parameter Beta of the approximating surface.</param>
        /// <param name="gamma">Parameter Gamma of the approximating surface.</param>
        public static void FitSurfaceFirstOrder(
          HObject regions,
          HObject image,
          HTuple algorithm,
          HTuple iterations,
          HTuple clippingFactor,
          out HTuple alpha,
          out HTuple beta,
          out HTuple gamma)
        {
            IntPtr proc = HalconAPI.PreCall(1743);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, algorithm);
            HalconAPI.Store(proc, 1, iterations);
            HalconAPI.Store(proc, 2, clippingFactor);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(algorithm);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(clippingFactor);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out alpha);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out beta);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out gamma);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate gray value moments and approximation by a second order surface.</summary>
        /// <param name="regions">Regions to be checked.</param>
        /// <param name="image">Corresponding gray values.</param>
        /// <param name="algorithm">Algorithm for the fitting. Default: "regression"</param>
        /// <param name="iterations">Maximum number of iterations (unused for 'regression'). Default: 5</param>
        /// <param name="clippingFactor">Clipping factor for the elimination of outliers. Default: 2.0</param>
        /// <param name="alpha">Parameter Alpha of the approximating surface.</param>
        /// <param name="beta">Parameter Beta of the approximating surface.</param>
        /// <param name="gamma">Parameter Gamma of the approximating surface.</param>
        /// <param name="delta">Parameter Delta of the approximating surface.</param>
        /// <param name="epsilon">Parameter Epsilon of the approximating surface.</param>
        /// <param name="zeta">Parameter Zeta of the approximating surface.</param>
        public static void FitSurfaceSecondOrder(
          HObject regions,
          HObject image,
          HTuple algorithm,
          HTuple iterations,
          HTuple clippingFactor,
          out HTuple alpha,
          out HTuple beta,
          out HTuple gamma,
          out HTuple delta,
          out HTuple epsilon,
          out HTuple zeta)
        {
            IntPtr proc = HalconAPI.PreCall(1744);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, algorithm);
            HalconAPI.Store(proc, 1, iterations);
            HalconAPI.Store(proc, 2, clippingFactor);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(algorithm);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(clippingFactor);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out alpha);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out beta);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out gamma);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out delta);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out epsilon);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out zeta);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Create a curved gray surface with second order polynomial.</summary>
        /// <param name="imageSurface">Created image with new image matrix.</param>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="alpha">Second order coefficient in vertical direction. Default: 1.0</param>
        /// <param name="beta">Second order coefficient in horizontal direction. Default: 1.0</param>
        /// <param name="gamma">Mixed second order coefficient. Default: 1.0</param>
        /// <param name="delta">First order coefficient in vertical direction. Default: 1.0</param>
        /// <param name="epsilon">First order coefficient in horizontal direction. Default: 1.0</param>
        /// <param name="zeta">Zero order coefficient. Default: 1.0</param>
        /// <param name="row">Row coordinate of the reference point of the surface. Default: 256.0</param>
        /// <param name="column">Column coordinate of the reference point of the surface. Default: 256.0</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        public static void GenImageSurfaceSecondOrder(
          out HObject imageSurface,
          HTuple type,
          HTuple alpha,
          HTuple beta,
          HTuple gamma,
          HTuple delta,
          HTuple epsilon,
          HTuple zeta,
          HTuple row,
          HTuple column,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1745);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, alpha);
            HalconAPI.Store(proc, 2, beta);
            HalconAPI.Store(proc, 3, gamma);
            HalconAPI.Store(proc, 4, delta);
            HalconAPI.Store(proc, 5, epsilon);
            HalconAPI.Store(proc, 6, zeta);
            HalconAPI.Store(proc, 7, row);
            HalconAPI.Store(proc, 8, column);
            HalconAPI.Store(proc, 9, width);
            HalconAPI.Store(proc, 10, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.UnpinTuple(beta);
            HalconAPI.UnpinTuple(gamma);
            HalconAPI.UnpinTuple(delta);
            HalconAPI.UnpinTuple(epsilon);
            HalconAPI.UnpinTuple(zeta);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageSurface);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a tilted gray surface with first order polynomial.</summary>
        /// <param name="imageSurface">Created image with new image matrix.</param>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="alpha">First order coefficient in vertical direction. Default: 1.0</param>
        /// <param name="beta">First order coefficient in horizontal direction. Default: 1.0</param>
        /// <param name="gamma">Zero order coefficient. Default: 1.0</param>
        /// <param name="row">Row coordinate of the reference point of the surface. Default: 256.0</param>
        /// <param name="column">Column coordinate of the reference point of the surface. Default: 256.0</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        public static void GenImageSurfaceFirstOrder(
          out HObject imageSurface,
          HTuple type,
          HTuple alpha,
          HTuple beta,
          HTuple gamma,
          HTuple row,
          HTuple column,
          HTuple width,
          HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1746);
            HalconAPI.Store(proc, 0, type);
            HalconAPI.Store(proc, 1, alpha);
            HalconAPI.Store(proc, 2, beta);
            HalconAPI.Store(proc, 3, gamma);
            HalconAPI.Store(proc, 4, row);
            HalconAPI.Store(proc, 5, column);
            HalconAPI.Store(proc, 6, width);
            HalconAPI.Store(proc, 7, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(type);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.UnpinTuple(beta);
            HalconAPI.UnpinTuple(gamma);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            int procResult = HObject.LoadNew(proc, 1, err, out imageSurface);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Determine a histogram of features along all threshold values.</summary>
        /// <param name="region">Region in which the features are to be examined.</param>
        /// <param name="image">Gray value image.</param>
        /// <param name="feature">Feature to be examined. Default: "convexity"</param>
        /// <param name="row">Row of the pixel which the region must contain. Default: 256</param>
        /// <param name="column">Column of the pixel which the region must contain. Default: 256</param>
        /// <param name="absoluteHisto">Absolute distribution of the feature.</param>
        /// <param name="relativeHisto">Relative distribution of the feature.</param>
        public static void ShapeHistoPoint(
          HObject region,
          HObject image,
          HTuple feature,
          HTuple row,
          HTuple column,
          out HTuple absoluteHisto,
          out HTuple relativeHisto)
        {
            IntPtr proc = HalconAPI.PreCall(1747);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, feature);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(feature);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int err2 = HTuple.LoadNew(proc, 0, err1, out absoluteHisto);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out relativeHisto);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determine a histogram of features along all threshold values.</summary>
        /// <param name="region">Region in which the features are to be examined.</param>
        /// <param name="image">Gray value image.</param>
        /// <param name="feature">Feature to be examined. Default: "connected_components"</param>
        /// <param name="absoluteHisto">Absolute distribution of the feature.</param>
        /// <param name="relativeHisto">Relative distribution of the feature.</param>
        public static void ShapeHistoAll(
          HObject region,
          HObject image,
          HTuple feature,
          out HTuple absoluteHisto,
          out HTuple relativeHisto)
        {
            IntPtr proc = HalconAPI.PreCall(1748);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, feature);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(feature);
            int err2 = HTuple.LoadNew(proc, 0, err1, out absoluteHisto);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out relativeHisto);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculates gray value features for a set of regions.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="image">Gray value image.</param>
        /// <param name="features">Names of the features. Default: "mean"</param>
        /// <param name="value">Value sof the features.</param>
        public static void GrayFeatures(
          HObject regions,
          HObject image,
          HTuple features,
          out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(1749);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, features);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(features);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out value);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Select regions based on gray value features.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="image">Gray value image.</param>
        /// <param name="selectedRegions">Regions having features within the limits.</param>
        /// <param name="features">Names of the features. Default: "mean"</param>
        /// <param name="operation">Logical connection of features. Default: "and"</param>
        /// <param name="min">Lower limit(s) of features. Default: 128.0</param>
        /// <param name="max">Upper limit(s) of features. Default: 255.0</param>
        public static void SelectGray(
          HObject regions,
          HObject image,
          out HObject selectedRegions,
          HTuple features,
          HTuple operation,
          HTuple min,
          HTuple max)
        {
            IntPtr proc = HalconAPI.PreCall(1750);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, features);
            HalconAPI.Store(proc, 1, operation);
            HalconAPI.Store(proc, 2, min);
            HalconAPI.Store(proc, 3, max);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(operation);
            HalconAPI.UnpinTuple(min);
            HalconAPI.UnpinTuple(max);
            int procResult = HObject.LoadNew(proc, 1, err, out selectedRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determine the minimum and maximum gray values within regions.</summary>
        /// <param name="regions">Regions, the features of which are to be calculated.</param>
        /// <param name="image">Gray value image.</param>
        /// <param name="percent">Percentage below (above) the absolute maximum (minimum). Default: 0</param>
        /// <param name="min">"Minimum" gray value.</param>
        /// <param name="max">"Maximum" gray value.</param>
        /// <param name="range">Difference between Max and Min.</param>
        public static void MinMaxGray(
          HObject regions,
          HObject image,
          HTuple percent,
          out HTuple min,
          out HTuple max,
          out HTuple range)
        {
            IntPtr proc = HalconAPI.PreCall(1751);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, percent);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(percent);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out min);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out max);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out range);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the mean and deviation of gray values.</summary>
        /// <param name="regions">Regions in which the features are calculated.</param>
        /// <param name="image">Gray value image.</param>
        /// <param name="mean">Mean gray value of a region.</param>
        /// <param name="deviation">Deviation of gray values within a region.</param>
        public static void Intensity(
          HObject regions,
          HObject image,
          out HTuple mean,
          out HTuple deviation)
        {
            IntPtr proc = HalconAPI.PreCall(1752);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out mean);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out deviation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the gray value distribution of a single channel image within a certain gray value range.</summary>
        /// <param name="regions">Region in which the histogram is to be calculated.</param>
        /// <param name="image">Input image.</param>
        /// <param name="min">Minimum gray value. Default: 0</param>
        /// <param name="max">Maximum gray value. Default: 255</param>
        /// <param name="numBins">Number of bins. Default: 256</param>
        /// <param name="histo">Histogram to be calculated.</param>
        /// <param name="binSize">Bin size.</param>
        public static void GrayHistoRange(
          HObject regions,
          HObject image,
          HTuple min,
          HTuple max,
          HTuple numBins,
          out HTuple histo,
          out HTuple binSize)
        {
            IntPtr proc = HalconAPI.PreCall(1753);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, min);
            HalconAPI.Store(proc, 1, max);
            HalconAPI.Store(proc, 2, numBins);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(min);
            HalconAPI.UnpinTuple(max);
            HalconAPI.UnpinTuple(numBins);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out histo);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out binSize);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the histogram of two-channel gray value images.</summary>
        /// <param name="regions">Region in which the histogram is to be calculated.</param>
        /// <param name="imageCol">Channel 1.</param>
        /// <param name="imageRow">Channel 2.</param>
        /// <param name="histo2Dim">Histogram to be calculated.</param>
        public static void Histo2dim(
          HObject regions,
          HObject imageCol,
          HObject imageRow,
          out HObject histo2Dim)
        {
            IntPtr proc = HalconAPI.PreCall(1754);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)imageCol);
            HalconAPI.Store(proc, 3, (HObjectBase)imageRow);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out histo2Dim);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)imageCol);
            GC.KeepAlive((object)imageRow);
        }

        /// <summary>Calculate the gray value distribution.</summary>
        /// <param name="regions">Region in which the histogram is to be calculated.</param>
        /// <param name="image">Image the gray value distribution of which is to be calculated.</param>
        /// <param name="quantization">Quantization of the gray values. Default: 1.0</param>
        /// <param name="absoluteHisto">Absolute frequencies of the gray values.</param>
        public static void GrayHistoAbs(
          HObject regions,
          HObject image,
          HTuple quantization,
          out HTuple absoluteHisto)
        {
            IntPtr proc = HalconAPI.PreCall(1755);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, quantization);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(quantization);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out absoluteHisto);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the gray value distribution.</summary>
        /// <param name="regions">Region in which the histogram is to be calculated.</param>
        /// <param name="image">Image the gray value distribution of which is to be calculated.</param>
        /// <param name="absoluteHisto">Absolute frequencies of the gray values.</param>
        /// <param name="relativeHisto">Frequencies, normalized to the area of the region.</param>
        public static void GrayHisto(
          HObject regions,
          HObject image,
          out HTuple absoluteHisto,
          out HTuple relativeHisto)
        {
            IntPtr proc = HalconAPI.PreCall(1756);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out absoluteHisto);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out relativeHisto);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Determine the entropy and anisotropy of images.</summary>
        /// <param name="regions">Regions where the features are to be determined.</param>
        /// <param name="image">Gray value image.</param>
        /// <param name="entropy">Information content (entropy) of the gray values.</param>
        /// <param name="anisotropy">Measure of the symmetry of gray value distribution.</param>
        public static void EntropyGray(
          HObject regions,
          HObject image,
          out HTuple entropy,
          out HTuple anisotropy)
        {
            IntPtr proc = HalconAPI.PreCall(1757);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out entropy);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out anisotropy);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate gray value features from a co-occurrence matrix.</summary>
        /// <param name="coocMatrix">Co-occurrence matrix.</param>
        /// <param name="energy">Homogeneity of the gray values.</param>
        /// <param name="correlation">Correlation of gray values.</param>
        /// <param name="homogeneity">Local homogeneity of gray values.</param>
        /// <param name="contrast">Gray value contrast.</param>
        public static void CoocFeatureMatrix(
          HObject coocMatrix,
          out HTuple energy,
          out HTuple correlation,
          out HTuple homogeneity,
          out HTuple contrast)
        {
            IntPtr proc = HalconAPI.PreCall(1758);
            HalconAPI.Store(proc, 1, (HObjectBase)coocMatrix);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out energy);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out correlation);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out homogeneity);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out contrast);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)coocMatrix);
        }

        /// <summary>Calculate a co-occurrence matrix and derive gray value features thereof.</summary>
        /// <param name="regions">Region to be examined.</param>
        /// <param name="image">Corresponding gray values.</param>
        /// <param name="ldGray">Number of gray values to be distinguished (2^LdGray@f$2^{LdGray}$). Default: 6</param>
        /// <param name="direction">Direction in which the matrix is to be calculated. Default: 0</param>
        /// <param name="energy">Gray value energy.</param>
        /// <param name="correlation">Correlation of gray values.</param>
        /// <param name="homogeneity">Local homogeneity of gray values.</param>
        /// <param name="contrast">Gray value contrast.</param>
        public static void CoocFeatureImage(
          HObject regions,
          HObject image,
          HTuple ldGray,
          HTuple direction,
          out HTuple energy,
          out HTuple correlation,
          out HTuple homogeneity,
          out HTuple contrast)
        {
            IntPtr proc = HalconAPI.PreCall(1759);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, ldGray);
            HalconAPI.Store(proc, 1, direction);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ldGray);
            HalconAPI.UnpinTuple(direction);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out energy);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out correlation);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out homogeneity);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out contrast);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the co-occurrence matrix of a region in an image.</summary>
        /// <param name="regions">Region to be checked.</param>
        /// <param name="image">Image providing the gray values.</param>
        /// <param name="matrix">Co-occurrence matrix (matrices).</param>
        /// <param name="ldGray">Number of gray values to be distinguished (2^LdGray@f$2^{LdGray}$). Default: 6</param>
        /// <param name="direction">Direction of neighbor relation. Default: 0</param>
        public static void GenCoocMatrix(
          HObject regions,
          HObject image,
          out HObject matrix,
          HTuple ldGray,
          HTuple direction)
        {
            IntPtr proc = HalconAPI.PreCall(1760);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, ldGray);
            HalconAPI.Store(proc, 1, direction);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(ldGray);
            HalconAPI.UnpinTuple(direction);
            int procResult = HObject.LoadNew(proc, 1, err, out matrix);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate gray value moments and approximation by a plane.</summary>
        /// <param name="regions">Regions to be checked.</param>
        /// <param name="image">Corresponding gray values.</param>
        /// <param name="MRow">Mixed moments along a line.</param>
        /// <param name="MCol">Mixed moments along a column.</param>
        /// <param name="alpha">Parameter Alpha of the approximating plane.</param>
        /// <param name="beta">Parameter Beta of the approximating plane.</param>
        /// <param name="mean">Mean gray value.</param>
        public static void MomentsGrayPlane(
          HObject regions,
          HObject image,
          out HTuple MRow,
          out HTuple MCol,
          out HTuple alpha,
          out HTuple beta,
          out HTuple mean)
        {
            IntPtr proc = HalconAPI.PreCall(1761);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out MRow);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out MCol);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out alpha);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out beta);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out mean);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate the deviation of the gray values from the approximating image plane.</summary>
        /// <param name="regions">Regions, of which the plane deviation is to be calculated.</param>
        /// <param name="image">Gray value image.</param>
        /// <param name="deviation">Deviation of the gray values within a region.</param>
        public static void PlaneDeviation(HObject regions, HObject image, out HTuple deviation)
        {
            IntPtr proc = HalconAPI.PreCall(1762);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out deviation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute the orientation and major axes of a region in a gray value image.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="image">Gray value image.</param>
        /// <param name="ra">Major axis of the region.</param>
        /// <param name="rb">Minor axis of the region.</param>
        /// <param name="phi">Angle enclosed by the major axis and the x-axis.</param>
        public static void EllipticAxisGray(
          HObject regions,
          HObject image,
          out HTuple ra,
          out HTuple rb,
          out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(1763);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out ra);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out rb);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Compute the area and center of gravity of a region in a gray value image.</summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="image">Gray value image.</param>
        /// <param name="area">Gray value volume of the region.</param>
        /// <param name="row">Row coordinate of the gray value center of gravity.</param>
        /// <param name="column">Column coordinate of the gray value center of gravity.</param>
        public static void AreaCenterGray(
          HObject regions,
          HObject image,
          out HTuple area,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1764);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out area);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out row);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)image);
        }

        /// <summary>Calculate horizontal and vertical gray-value projections.</summary>
        /// <param name="region">Region to be processed.</param>
        /// <param name="image">Grayvalues for projections.</param>
        /// <param name="mode">Method to compute the projections. Default: "simple"</param>
        /// <param name="horProjection">Horizontal projection.</param>
        /// <param name="vertProjection">Vertical projection.</param>
        public static void GrayProjections(
          HObject region,
          HObject image,
          HTuple mode,
          out HTuple horProjection,
          out HTuple vertProjection)
        {
            IntPtr proc = HalconAPI.PreCall(1765);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out horProjection);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out vertProjection);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)region);
            GC.KeepAlive((object)image);
        }

        /// <summary>Access iconic objects that were created during the search for 2D data code symbols.</summary>
        /// <param name="dataCodeObjects">Objects that are created as intermediate results during the detection or evaluation of 2D data codes.</param>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        /// <param name="candidateHandle">Handle of the 2D data code candidate or name of a group of candidates for which the iconic data is requested. Default: "all_candidates"</param>
        /// <param name="objectName">Name of the iconic object to return. Default: "candidate_xld"</param>
        public static void GetDataCode2dObjects(
          out HObject dataCodeObjects,
          HTuple dataCodeHandle,
          HTuple candidateHandle,
          HTuple objectName)
        {
            IntPtr proc = HalconAPI.PreCall(1766);
            HalconAPI.Store(proc, 0, dataCodeHandle);
            HalconAPI.Store(proc, 1, candidateHandle);
            HalconAPI.Store(proc, 2, objectName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dataCodeHandle);
            HalconAPI.UnpinTuple(candidateHandle);
            HalconAPI.UnpinTuple(objectName);
            int procResult = HObject.LoadNew(proc, 1, err, out dataCodeObjects);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the alphanumerical results that were accumulated during the search for 2D data code symbols.</summary>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        /// <param name="candidateHandle">Handle of the 2D data code candidate or name of a group of candidates for which the data is required. Default: "all_candidates"</param>
        /// <param name="resultNames">Names of the results of the 2D data code to return. Default: "status"</param>
        /// <param name="resultValues">List with the results.</param>
        public static void GetDataCode2dResults(
          HTuple dataCodeHandle,
          HTuple candidateHandle,
          HTuple resultNames,
          out HTuple resultValues)
        {
            IntPtr proc = HalconAPI.PreCall(1767);
            HalconAPI.Store(proc, 0, dataCodeHandle);
            HalconAPI.Store(proc, 1, candidateHandle);
            HalconAPI.Store(proc, 2, resultNames);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dataCodeHandle);
            HalconAPI.UnpinTuple(candidateHandle);
            HalconAPI.UnpinTuple(resultNames);
            int procResult = HTuple.LoadNew(proc, 0, err, out resultValues);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Detect and read 2D data code symbols in an image or train the 2D data code model.</summary>
        /// <param name="image">Input image. If the image has a reduced domain, the data code search is reduced to that domain. This usually reduces the runtime of the operator. However, if the datacode is not fully inside the domain, the datacode might not be found correctly. In rare cases, data codes may be found outside the domain. If these results  are undesirable, they have to be subsequently eliminated. </param>
        /// <param name="symbolXLDs">XLD contours that surround the successfully decoded data code symbols. The order of the contour points reflects the orientation of the detected symbols. The contours begin in the top left corner (see 'orientation' at get_data_code_2d_results) and continue clockwise.  Alignment{left} Figure[1][1][60]{get_data_code_2d_results-xld_qrcode} Order of points of SymbolXLDs Figure Alignment @f$ </param>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        /// <param name="genParamName">Names of (optional) parameters for controlling the behavior of the operator. Default: []</param>
        /// <param name="genParamValue">Values of the optional generic parameters. Default: []</param>
        /// <param name="resultHandles">Handles of all successfully decoded 2D data code symbols.</param>
        /// <param name="decodedDataStrings">Decoded data strings of all detected 2D data code symbols in the image.</param>
        public static void FindDataCode2d(
          HObject image,
          out HObject symbolXLDs,
          HTuple dataCodeHandle,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple resultHandles,
          out HTuple decodedDataStrings)
        {
            IntPtr proc = HalconAPI.PreCall(1768);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, dataCodeHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dataCodeHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HObject.LoadNew(proc, 1, err1, out symbolXLDs);
            int err3 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err2, out resultHandles);
            int procResult = HTuple.LoadNew(proc, 1, err3, out decodedDataStrings);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Set selected parameters of the 2D data code model.</summary>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        /// <param name="genParamName">Names of the generic parameters that shall be adjusted for the 2D data code. Default: "polarity"</param>
        /// <param name="genParamValue">Values of the generic parameters that are adjusted for the 2D data code. Default: "light_on_dark"</param>
        public static void SetDataCode2dParam(
          HTuple dataCodeHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1769);
            HalconAPI.Store(proc, 0, dataCodeHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dataCodeHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get one or several parameters that describe the 2D data code model.</summary>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        /// <param name="genParamName">Names of the generic parameters that are to be queried for the 2D data code model. Default: "contrast_min"</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        public static void GetDataCode2dParam(
          HTuple dataCodeHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1770);
            HalconAPI.Store(proc, 0, dataCodeHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dataCodeHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get for a given 2D data code model the names of the generic parameters or objects that can be used in the other 2D data code operators.</summary>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        /// <param name="queryName">Name of the parameter group. Default: "get_result_params"</param>
        /// <param name="genParamName">List containing the names of the supported generic parameters.</param>
        public static void QueryDataCode2dParams(
          HTuple dataCodeHandle,
          HTuple queryName,
          out HTuple genParamName)
        {
            IntPtr proc = HalconAPI.PreCall(1771);
            HalconAPI.Store(proc, 0, dataCodeHandle);
            HalconAPI.Store(proc, 1, queryName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dataCodeHandle);
            HalconAPI.UnpinTuple(queryName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized 2D data code model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        public static void DeserializeDataCode2dModel(
          HTuple serializedItemHandle,
          out HTuple dataCodeHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1772);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out dataCodeHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a 2D data code model.</summary>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeDataCode2dModel(
          HTuple dataCodeHandle,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1773);
            HalconAPI.Store(proc, 0, dataCodeHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dataCodeHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a 2D data code model from a file and create a new model.</summary>
        /// <param name="fileName">Name of the 2D data code model file. Default: "data_code_model.dcm"</param>
        /// <param name="dataCodeHandle">Handle of the created 2D data code model.</param>
        public static void ReadDataCode2dModel(HTuple fileName, out HTuple dataCodeHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1774);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out dataCodeHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Writes a 2D data code model into a file.</summary>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        /// <param name="fileName">Name of the 2D data code model file. Default: "data_code_model.dcm"</param>
        public static void WriteDataCode2dModel(HTuple dataCodeHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1775);
            HalconAPI.Store(proc, 0, dataCodeHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dataCodeHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete all 2D data code models and free the allocated memory.</summary>
        public static void ClearAllDataCode2dModels()
        {
            IntPtr proc = HalconAPI.PreCall(1776);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete a 2D data code model and free the allocated memory.</summary>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        public static void ClearDataCode2dModel(HTuple dataCodeHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1777);
            HalconAPI.Store(proc, 0, dataCodeHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dataCodeHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a model of a 2D data code class.</summary>
        /// <param name="symbolType">Type of the 2D data code. Default: "Data Matrix ECC 200"</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the 2D data code model. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the 2D data code model. Default: []</param>
        /// <param name="dataCodeHandle">Handle for using and accessing the 2D data code model.</param>
        public static void CreateDataCode2dModel(
          HTuple symbolType,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple dataCodeHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1778);
            HalconAPI.Store(proc, 0, symbolType);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(symbolType);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out dataCodeHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize serialized training data for classifiers.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="classTrainDataHandle">Handle of the training data.</param>
        public static void DeserializeClassTrainData(
          HTuple serializedItemHandle,
          out HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1779);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize training data for classifiers.</summary>
        /// <param name="classTrainDataHandle">Handle of the training data.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeClassTrainData(
          HTuple classTrainDataHandle,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1780);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read the training data for classifiers from a file.</summary>
        /// <param name="fileName">File name of the training data.</param>
        /// <param name="classTrainDataHandle">Handle of the training data.</param>
        public static void ReadClassTrainData(HTuple fileName, out HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1781);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Save the training data for classifiers in a file.</summary>
        /// <param name="classTrainDataHandle">Handle of the training data.</param>
        /// <param name="fileName">Name of the file in which the training data will be written.</param>
        public static void WriteClassTrainData(HTuple classTrainDataHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1782);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Select certain features from training data to create  training data containing less features.</summary>
        /// <param name="classTrainDataHandle">Handle of the training data.</param>
        /// <param name="subFeatureIndices">Indices or names to select the subfeatures or columns.</param>
        /// <param name="selectedClassTrainDataHandle">Handle of the reduced training data.</param>
        public static void SelectSubFeatureClassTrainData(
          HTuple classTrainDataHandle,
          HTuple subFeatureIndices,
          out HTuple selectedClassTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1783);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            HalconAPI.Store(proc, 1, subFeatureIndices);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.UnpinTuple(subFeatureIndices);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out selectedClassTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define subfeatures in training data.</summary>
        /// <param name="classTrainDataHandle">Handle of the training data that should be  partitioned into subfeatures.</param>
        /// <param name="subFeatureLength">Length of the subfeatures.</param>
        /// <param name="names">Names of the subfeatures.</param>
        public static void SetFeatureLengthsClassTrainData(
          HTuple classTrainDataHandle,
          HTuple subFeatureLength,
          HTuple names)
        {
            IntPtr proc = HalconAPI.PreCall(1784);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            HalconAPI.Store(proc, 1, subFeatureLength);
            HalconAPI.Store(proc, 2, names);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.UnpinTuple(subFeatureLength);
            HalconAPI.UnpinTuple(names);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the training data of a Gaussian Mixture Model (GMM).</summary>
        /// <param name="GMMHandle">Handle of a GMM that contains training data.</param>
        /// <param name="classTrainDataHandle">Handle of the training data of the classifier.</param>
        public static void GetClassTrainDataGmm(HTuple GMMHandle, out HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1785);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add training data to a Gaussian Mixture Model (GMM).</summary>
        /// <param name="GMMHandle">Handle of a GMM which receives the training data.</param>
        /// <param name="classTrainDataHandle">Handle of training data for a classifier.</param>
        public static void AddClassTrainDataGmm(HTuple GMMHandle, HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1786);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, classTrainDataHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the training data of a multilayer perceptron (MLP).</summary>
        /// <param name="MLPHandle">Handle of a MLP that contains training data.</param>
        /// <param name="classTrainDataHandle">Handle of the training data of the classifier.</param>
        public static void GetClassTrainDataMlp(HTuple MLPHandle, out HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1787);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add training data to a multilayer perceptron (MLP).</summary>
        /// <param name="MLPHandle">MLP handle which receives the training data.</param>
        /// <param name="classTrainDataHandle">Training data for a classifier.</param>
        public static void AddClassTrainDataMlp(HTuple MLPHandle, HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1788);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, classTrainDataHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the training data of a k-nearest neighbors (k-NN) classifier.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier  that contains training data.</param>
        /// <param name="classTrainDataHandle">Handle of the training data of the classifier.</param>
        public static void GetClassTrainDataKnn(HTuple KNNHandle, out HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1789);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add training data to a k-nearest neighbors (k-NN) classifier.</summary>
        /// <param name="KNNHandle">Handle of a k-NN which receives the  training data.</param>
        /// <param name="classTrainDataHandle">Training data for a classifier.</param>
        public static void AddClassTrainDataKnn(HTuple KNNHandle, HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1790);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.Store(proc, 1, classTrainDataHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the training data of a support vector machine (SVM).</summary>
        /// <param name="SVMHandle">Handle of a SVM that contains training data.</param>
        /// <param name="classTrainDataHandle">Handle of the training data of the classifier.</param>
        public static void GetClassTrainDataSvm(HTuple SVMHandle, out HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1791);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add training data to a support vector machine (SVM).</summary>
        /// <param name="SVMHandle">Handle of a SVM which receives the training data.</param>
        /// <param name="classTrainDataHandle">Training data for a classifier.</param>
        public static void AddClassTrainDataSvm(HTuple SVMHandle, HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1792);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, classTrainDataHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the number of training samples stored in the training data.</summary>
        /// <param name="classTrainDataHandle">Handle of training data.</param>
        /// <param name="numSamples">Number of stored training samples.</param>
        public static void GetSampleNumClassTrainData(
          HTuple classTrainDataHandle,
          out HTuple numSamples)
        {
            IntPtr proc = HalconAPI.PreCall(1793);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out numSamples);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return a training sample from training data.</summary>
        /// <param name="classTrainDataHandle">Handle of training data for a classifier.</param>
        /// <param name="indexSample">Number of stored training sample.</param>
        /// <param name="features">Feature vector of the training sample.</param>
        /// <param name="classID">Class of the training sample.</param>
        public static void GetSampleClassTrainData(
          HTuple classTrainDataHandle,
          HTuple indexSample,
          out HTuple features,
          out HTuple classID)
        {
            IntPtr proc = HalconAPI.PreCall(1794);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            HalconAPI.Store(proc, 1, indexSample);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.UnpinTuple(indexSample);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out features);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out classID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all training data for classifiers.</summary>
        public static void ClearAllClassTrainData()
        {
            IntPtr proc = HalconAPI.PreCall(1795);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clears training data for classifiers.</summary>
        /// <param name="classTrainDataHandle">Handle of training data for a classifier.</param>
        public static void ClearClassTrainData(HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1796);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a training sample to training data.</summary>
        /// <param name="classTrainDataHandle">Handle of the training data.</param>
        /// <param name="order">The order of the feature vector. Default: "row"</param>
        /// <param name="features">Feature vector of the training sample.</param>
        /// <param name="classID">Class of the training sample.</param>
        public static void AddSampleClassTrainData(
          HTuple classTrainDataHandle,
          HTuple order,
          HTuple features,
          HTuple classID)
        {
            IntPtr proc = HalconAPI.PreCall(1797);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            HalconAPI.Store(proc, 1, order);
            HalconAPI.Store(proc, 2, features);
            HalconAPI.Store(proc, 3, classID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.UnpinTuple(order);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(classID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a handle for training data for classifiers.</summary>
        /// <param name="numDim">Number of dimensions of the feature vector. Default: 10</param>
        /// <param name="classTrainDataHandle">Handle of the training data.</param>
        public static void CreateClassTrainData(HTuple numDim, out HTuple classTrainDataHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1798);
            HalconAPI.Store(proc, 0, numDim);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numDim);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classTrainDataHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Selects an optimal combination of features to classify the provided data.</summary>
        /// <param name="classTrainDataHandle">Handle of the training data.</param>
        /// <param name="selectionMethod">Method to perform the selection. Default: "greedy"</param>
        /// <param name="genParamName">Names of generic parameters to configure the  selection process and the classifier. Default: []</param>
        /// <param name="genParamValue">Values of generic parameters to configure the  selection process and the classifier. Default: []</param>
        /// <param name="MLPHandle">A trained MLP classifier using only the selected  features.</param>
        /// <param name="selectedFeatureIndices">The selected feature set, contains  indices referring.</param>
        /// <param name="score">The achieved score using two-fold cross-validation.</param>
        public static void SelectFeatureSetMlp(
          HTuple classTrainDataHandle,
          HTuple selectionMethod,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple MLPHandle,
          out HTuple selectedFeatureIndices,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(1799);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            HalconAPI.Store(proc, 1, selectionMethod);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.UnpinTuple(selectionMethod);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out MLPHandle);
            int err3 = HTuple.LoadNew(proc, 1, err2, out selectedFeatureIndices);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Selects an optimal combination of features to classify the provided data.</summary>
        /// <param name="classTrainDataHandle">Handle of the training data.</param>
        /// <param name="selectionMethod">Method to perform the selection. Default: "greedy"</param>
        /// <param name="genParamName">Names of generic parameters to configure the  selection process and the classifier. Default: []</param>
        /// <param name="genParamValue">Values of generic parameters to configure the  selection process and the classifier. Default: []</param>
        /// <param name="SVMHandle">A trained SVM classifier using only the selected  features.</param>
        /// <param name="selectedFeatureIndices">The selected feature set, contains  indices.</param>
        /// <param name="score">The achieved score using two-fold cross-validation.</param>
        public static void SelectFeatureSetSvm(
          HTuple classTrainDataHandle,
          HTuple selectionMethod,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple SVMHandle,
          out HTuple selectedFeatureIndices,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(1800);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            HalconAPI.Store(proc, 1, selectionMethod);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.UnpinTuple(selectionMethod);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out SVMHandle);
            int err3 = HTuple.LoadNew(proc, 1, err2, out selectedFeatureIndices);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Selects an optimal combination from a set of features to classify the  provided data.</summary>
        /// <param name="classTrainDataHandle">Handle of the training data.</param>
        /// <param name="selectionMethod">Method to perform the selection. Default: "greedy"</param>
        /// <param name="genParamName">Names of generic parameters to configure  the classifier. Default: []</param>
        /// <param name="genParamValue">Values of generic parameters to configure  the classifier. Default: []</param>
        /// <param name="GMMHandle">A trained GMM classifier using only the selected  features.</param>
        /// <param name="selectedFeatureIndices">The selected feature set, contains indices or names.</param>
        /// <param name="score">The achieved score using two-fold cross-validation.</param>
        public static void SelectFeatureSetGmm(
          HTuple classTrainDataHandle,
          HTuple selectionMethod,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple GMMHandle,
          out HTuple selectedFeatureIndices,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(1801);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            HalconAPI.Store(proc, 1, selectionMethod);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.UnpinTuple(selectionMethod);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out GMMHandle);
            int err3 = HTuple.LoadNew(proc, 1, err2, out selectedFeatureIndices);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Selects an optimal subset from a set of features to solve a certain  classification problem.</summary>
        /// <param name="classTrainDataHandle">Handle of the training data.</param>
        /// <param name="selectionMethod">Method to perform the selection. Default: "greedy"</param>
        /// <param name="genParamName">Names of generic parameters to configure the selection process and the classifier. Default: []</param>
        /// <param name="genParamValue">Values of generic parameters to configure the  selection process and the classifier. Default: []</param>
        /// <param name="KNNHandle">A trained k-NN classifier using only the selected  features.</param>
        /// <param name="selectedFeatureIndices">The selected feature set, contains  indices or names.</param>
        /// <param name="score">The achieved score using two-fold cross-validation.</param>
        public static void SelectFeatureSetKnn(
          HTuple classTrainDataHandle,
          HTuple selectionMethod,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple KNNHandle,
          out HTuple selectedFeatureIndices,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(1802);
            HalconAPI.Store(proc, 0, classTrainDataHandle);
            HalconAPI.Store(proc, 1, selectionMethod);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classTrainDataHandle);
            HalconAPI.UnpinTuple(selectionMethod);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out KNNHandle);
            int err3 = HTuple.LoadNew(proc, 1, err2, out selectedFeatureIndices);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all k-NN classifiers.</summary>
        public static void ClearAllClassKnn()
        {
            IntPtr proc = HalconAPI.PreCall(1803);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a k-NN classifier.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        public static void ClearClassKnn(HTuple KNNHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1804);
            HalconAPI.Store(proc, 0, KNNHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the number of training samples stored in the training data of a k-nearest neighbors (k-NN) classifier.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="numSamples">Number of stored training samples.</param>
        public static void GetSampleNumClassKnn(HTuple KNNHandle, out HTuple numSamples)
        {
            IntPtr proc = HalconAPI.PreCall(1805);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out numSamples);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return a training sample from the training data of a k-nearest neighbors  (k-NN) classifier.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="indexSample">Index of the training sample.</param>
        /// <param name="features">Feature vector of the training sample.</param>
        /// <param name="classID">Class of the training sample.</param>
        public static void GetSampleClassKnn(
          HTuple KNNHandle,
          HTuple indexSample,
          out HTuple features,
          out HTuple classID)
        {
            IntPtr proc = HalconAPI.PreCall(1806);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.Store(proc, 1, indexSample);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.UnpinTuple(indexSample);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out features);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out classID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized k-NN classifier.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        public static void DeserializeClassKnn(HTuple serializedItemHandle, out HTuple KNNHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1807);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out KNNHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a k-NN classifier.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeClassKnn(HTuple KNNHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1808);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read the k-NN classifier from a file.</summary>
        /// <param name="fileName">File name of the classifier.</param>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        public static void ReadClassKnn(HTuple fileName, out HTuple KNNHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1809);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out KNNHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Save the k-NN classifier in a file.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="fileName">Name of the file in which the classifier will be written.</param>
        public static void WriteClassKnn(HTuple KNNHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1810);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get parameters of a k-NN classification.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="genParamName">Names of the parameters that can be read from the k-NN classifier. Default: ["method","k"]</param>
        /// <param name="genParamValue">Values of the selected parameters.</param>
        public static void GetParamsClassKnn(
          HTuple KNNHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1811);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters for k-NN classification.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the k-NN classifier. Default: ["method","k","max_num_classes"]</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the k-NN classifier. Default: ["classes_distance",5,1]</param>
        public static void SetParamsClassKnn(
          HTuple KNNHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1812);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Search for the next neighbors for a given feature vector.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="features">Features that should be classified.</param>
        /// <param name="result">The classification result, either class IDs or sample  indices.</param>
        /// <param name="rating">A rating for the results. This value contains either a  distance, a frequency or a weighted frequency.</param>
        public static void ClassifyClassKnn(
          HTuple KNNHandle,
          HTuple features,
          out HTuple result,
          out HTuple rating)
        {
            IntPtr proc = HalconAPI.PreCall(1813);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.UnpinTuple(features);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out result);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out rating);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Creates the search trees for a k-NN classifier.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the k-NN classifier creation. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the k-NN classifier creation. Default: []</param>
        public static void TrainClassKnn(HTuple KNNHandle, HTuple genParamName, HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1814);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a sample to a  k-nearest neighbors (k-NN) classifier.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="features">List of features to add.</param>
        /// <param name="classID">Class IDs of the features.</param>
        public static void AddSampleClassKnn(HTuple KNNHandle, HTuple features, HTuple classID)
        {
            IntPtr proc = HalconAPI.PreCall(1815);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.Store(proc, 2, classID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(classID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a k-nearest neighbors (k-NN) classifier.</summary>
        /// <param name="numDim">Number of dimensions of the feature. Default: 10</param>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        public static void CreateClassKnn(HTuple numDim, out HTuple KNNHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1816);
            HalconAPI.Store(proc, 0, numDim);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numDim);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out KNNHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all look-up table classifiers.</summary>
        public static void ClearAllClassLut()
        {
            IntPtr proc = HalconAPI.PreCall(1817);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a look-up table classifier.</summary>
        /// <param name="classLUTHandle">Handle of the LUT classifier.</param>
        public static void ClearClassLut(HTuple classLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1818);
            HalconAPI.Store(proc, 0, classLUTHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classLUTHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a look-up table using a k-nearest neighbors classifier (k-NN) to classify byte images.</summary>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the LUT classifier creation. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the LUT classifier creation. Default: []</param>
        /// <param name="classLUTHandle">Handle of the LUT classifier.</param>
        public static void CreateClassLutKnn(
          HTuple KNNHandle,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple classLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1819);
            HalconAPI.Store(proc, 0, KNNHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(KNNHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classLUTHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a look-up table using a gaussian mixture model to classify byte images.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the LUT classifier creation. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the LUT classifier creation. Default: []</param>
        /// <param name="classLUTHandle">Handle of the LUT classifier.</param>
        public static void CreateClassLutGmm(
          HTuple GMMHandle,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple classLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1820);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classLUTHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a look-up table using a Support-Vector-Machine to classify byte images.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the LUT classifier creation. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the LUT classifier creation. Default: []</param>
        /// <param name="classLUTHandle">Handle of the LUT classifier.</param>
        public static void CreateClassLutSvm(
          HTuple SVMHandle,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple classLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1821);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classLUTHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a look-up table using a multi-layer perceptron to classify byte images.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the LUT classifier creation. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the LUT classifier creation. Default: []</param>
        /// <param name="classLUTHandle">Handle of the LUT classifier.</param>
        public static void CreateClassLutMlp(
          HTuple MLPHandle,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple classLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1822);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classLUTHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all Gaussian Mixture Models.</summary>
        public static void ClearAllClassGmm()
        {
            IntPtr proc = HalconAPI.PreCall(1823);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a Gaussian Mixture Model.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        public static void ClearClassGmm(HTuple GMMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1824);
            HalconAPI.Store(proc, 0, GMMHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear the training data of a Gaussian Mixture Model.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        public static void ClearSamplesClassGmm(HTuple GMMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1825);
            HalconAPI.Store(proc, 0, GMMHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized Gaussian Mixture Model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="GMMHandle">GMM handle.</param>
        public static void DeserializeClassGmm(HTuple serializedItemHandle, out HTuple GMMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1826);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out GMMHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a Gaussian Mixture Model (GMM).</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeClassGmm(HTuple GMMHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1827);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a Gaussian Mixture Model from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="GMMHandle">GMM handle.</param>
        public static void ReadClassGmm(HTuple fileName, out HTuple GMMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1828);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out GMMHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a Gaussian Mixture Model to a file.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteClassGmm(HTuple GMMHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1829);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read the training data of a Gaussian Mixture Model from a file.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="fileName">File name.</param>
        public static void ReadSamplesClassGmm(HTuple GMMHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1830);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write the training data of a Gaussian Mixture Model to a file.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteSamplesClassGmm(HTuple GMMHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1831);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the class of a feature vector by a Gaussian Mixture Model.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="features">Feature vector.</param>
        /// <param name="num">Number of best classes to determine. Default: 1</param>
        /// <param name="classID">Result of classifying the feature vector with the GMM.</param>
        /// <param name="classProb">A-posteriori probability of the classes.</param>
        /// <param name="density">Probability density of the feature vector.</param>
        /// <param name="KSigmaProb">Normalized k-sigma-probability for the feature vector.</param>
        public static void ClassifyClassGmm(
          HTuple GMMHandle,
          HTuple features,
          HTuple num,
          out HTuple classID,
          out HTuple classProb,
          out HTuple density,
          out HTuple KSigmaProb)
        {
            IntPtr proc = HalconAPI.PreCall(1832);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.Store(proc, 2, num);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(num);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out classID);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out classProb);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out density);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out KSigmaProb);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Evaluate a feature vector by a Gaussian Mixture Model.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="features">Feature vector.</param>
        /// <param name="classProb">A-posteriori probability of the classes.</param>
        /// <param name="density">Probability density of the feature vector.</param>
        /// <param name="KSigmaProb">Normalized k-sigma-probability for the feature vector.</param>
        public static void EvaluateClassGmm(
          HTuple GMMHandle,
          HTuple features,
          out HTuple classProb,
          out HTuple density,
          out HTuple KSigmaProb)
        {
            IntPtr proc = HalconAPI.PreCall(1833);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(features);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out classProb);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out density);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out KSigmaProb);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train a Gaussian Mixture Model.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="maxIter">Maximum number of iterations of the expectation maximization algorithm Default: 100</param>
        /// <param name="threshold">Threshold for relative change of the error for the expectation maximization algorithm to terminate. Default: 0.001</param>
        /// <param name="classPriors">Mode to determine the a-priori probabilities of the classes Default: "training"</param>
        /// <param name="regularize">Regularization value for preventing covariance matrix singularity. Default: 0.0001</param>
        /// <param name="centers">Number of found centers per class</param>
        /// <param name="iter">Number of executed iterations per class</param>
        public static void TrainClassGmm(
          HTuple GMMHandle,
          HTuple maxIter,
          HTuple threshold,
          HTuple classPriors,
          HTuple regularize,
          out HTuple centers,
          out HTuple iter)
        {
            IntPtr proc = HalconAPI.PreCall(1834);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, maxIter);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.Store(proc, 3, classPriors);
            HalconAPI.Store(proc, 4, regularize);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(maxIter);
            HalconAPI.UnpinTuple(threshold);
            HalconAPI.UnpinTuple(classPriors);
            HalconAPI.UnpinTuple(regularize);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out centers);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out iter);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the information content of the preprocessed feature vectors of a GMM.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors. Default: "principal_components"</param>
        /// <param name="informationCont">Relative information content of the transformed feature vectors.</param>
        /// <param name="cumInformationCont">Cumulative information content of the transformed feature vectors.</param>
        public static void GetPrepInfoClassGmm(
          HTuple GMMHandle,
          HTuple preprocessing,
          out HTuple informationCont,
          out HTuple cumInformationCont)
        {
            IntPtr proc = HalconAPI.PreCall(1835);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, preprocessing);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(preprocessing);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out informationCont);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out cumInformationCont);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the number of training samples stored in the training data of a Gaussian Mixture Model (GMM).</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="numSamples">Number of stored training samples.</param>
        public static void GetSampleNumClassGmm(HTuple GMMHandle, out HTuple numSamples)
        {
            IntPtr proc = HalconAPI.PreCall(1836);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out numSamples);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return a training sample from the training data of a Gaussian Mixture Models (GMM).</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="numSample">Index of the stored training sample.</param>
        /// <param name="features">Feature vector of the training sample.</param>
        /// <param name="classID">Class of the training sample.</param>
        public static void GetSampleClassGmm(
          HTuple GMMHandle,
          HTuple numSample,
          out HTuple features,
          out HTuple classID)
        {
            IntPtr proc = HalconAPI.PreCall(1837);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, numSample);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(numSample);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out features);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out classID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a training sample to the training data of a Gaussian Mixture Model.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="features">Feature vector of the training sample to be stored.</param>
        /// <param name="classID">Class of the training sample to be stored.</param>
        /// <param name="randomize">Standard deviation of the Gaussian noise added to the training data. Default: 0.0</param>
        public static void AddSampleClassGmm(
          HTuple GMMHandle,
          HTuple features,
          HTuple classID,
          HTuple randomize)
        {
            IntPtr proc = HalconAPI.PreCall(1838);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.Store(proc, 2, classID);
            HalconAPI.Store(proc, 3, randomize);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(classID);
            HalconAPI.UnpinTuple(randomize);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters of a Gaussian Mixture Model.</summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="numDim">Number of dimensions of the feature space.</param>
        /// <param name="numClasses">Number of classes of the GMM.</param>
        /// <param name="minCenters">Minimum number of centers per GMM class.</param>
        /// <param name="maxCenters">Maximum number of centers per GMM class.</param>
        /// <param name="covarType">Type of the covariance matrices.</param>
        public static void GetParamsClassGmm(
          HTuple GMMHandle,
          out HTuple numDim,
          out HTuple numClasses,
          out HTuple minCenters,
          out HTuple maxCenters,
          out HTuple covarType)
        {
            IntPtr proc = HalconAPI.PreCall(1839);
            HalconAPI.Store(proc, 0, GMMHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(GMMHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out numDim);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out numClasses);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out minCenters);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out maxCenters);
            int procResult = HTuple.LoadNew(proc, 4, err5, out covarType);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a Gaussian Mixture Model for classification</summary>
        /// <param name="numDim">Number of dimensions of the feature space. Default: 3</param>
        /// <param name="numClasses">Number of classes of the GMM. Default: 5</param>
        /// <param name="numCenters">Number of centers per class. Default: 1</param>
        /// <param name="covarType">Type of the covariance matrices. Default: "spherical"</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors. Default: "normalization"</param>
        /// <param name="numComponents">Preprocessing parameter: Number of transformed features (ignored for Preprocessing $=$ 'none' and Preprocessing $=$ 'normalization'). Default: 10</param>
        /// <param name="randSeed">Seed value of the random number generator that is used to initialize the GMM with random values. Default: 42</param>
        /// <param name="GMMHandle">GMM handle.</param>
        public static void CreateClassGmm(
          HTuple numDim,
          HTuple numClasses,
          HTuple numCenters,
          HTuple covarType,
          HTuple preprocessing,
          HTuple numComponents,
          HTuple randSeed,
          out HTuple GMMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1840);
            HalconAPI.Store(proc, 0, numDim);
            HalconAPI.Store(proc, 1, numClasses);
            HalconAPI.Store(proc, 2, numCenters);
            HalconAPI.Store(proc, 3, covarType);
            HalconAPI.Store(proc, 4, preprocessing);
            HalconAPI.Store(proc, 5, numComponents);
            HalconAPI.Store(proc, 6, randSeed);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numDim);
            HalconAPI.UnpinTuple(numClasses);
            HalconAPI.UnpinTuple(numCenters);
            HalconAPI.UnpinTuple(covarType);
            HalconAPI.UnpinTuple(preprocessing);
            HalconAPI.UnpinTuple(numComponents);
            HalconAPI.UnpinTuple(randSeed);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out GMMHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all support vector machines.</summary>
        public static void ClearAllClassSvm()
        {
            IntPtr proc = HalconAPI.PreCall(1841);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a support vector machine.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        public static void ClearClassSvm(HTuple SVMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1842);
            HalconAPI.Store(proc, 0, SVMHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear the training data of a support vector machine.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        public static void ClearSamplesClassSvm(HTuple SVMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1843);
            HalconAPI.Store(proc, 0, SVMHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized support vector machine (SVM).</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="SVMHandle">SVM handle.</param>
        public static void DeserializeClassSvm(HTuple serializedItemHandle, out HTuple SVMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1844);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out SVMHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a support vector machine (SVM).</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeClassSvm(HTuple SVMHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1845);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a support vector machine from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="SVMHandle">SVM handle.</param>
        public static void ReadClassSvm(HTuple fileName, out HTuple SVMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1846);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out SVMHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a support vector machine to a file.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteClassSvm(HTuple SVMHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1847);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read the training data of a support vector machine from a file.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="fileName">File name.</param>
        public static void ReadSamplesClassSvm(HTuple SVMHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1848);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write the training data of a support vector machine to a file.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteSamplesClassSvm(HTuple SVMHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1849);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Evaluate a feature vector by a support vector machine.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="features">Feature vector.</param>
        /// <param name="result">Result of evaluating the feature vector with the SVM.</param>
        public static void EvaluateClassSvm(HTuple SVMHandle, HTuple features, out HTuple result)
        {
            IntPtr proc = HalconAPI.PreCall(1850);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(features);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out result);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Classify a feature vector by a support vector machine.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="features">Feature vector.</param>
        /// <param name="num">Number of best classes to determine. Default: 1</param>
        /// <param name="classVal">Result of classifying the feature vector with the SVM.</param>
        public static void ClassifyClassSvm(
          HTuple SVMHandle,
          HTuple features,
          HTuple num,
          out HTuple classVal)
        {
            IntPtr proc = HalconAPI.PreCall(1851);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.Store(proc, 2, num);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(num);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Approximate a trained support vector machine by a reduced support vector machine for faster classification.</summary>
        /// <param name="SVMHandle">Original SVM handle.</param>
        /// <param name="method">Type of postprocessing to reduce number of SV. Default: "bottom_up"</param>
        /// <param name="minRemainingSV">Minimum number of remaining SVs. Default: 2</param>
        /// <param name="maxError">Maximum allowed error of reduction. Default: 0.001</param>
        /// <param name="SVMHandleReduced">SVMHandle of reduced SVM.</param>
        public static void ReduceClassSvm(
          HTuple SVMHandle,
          HTuple method,
          HTuple minRemainingSV,
          HTuple maxError,
          out HTuple SVMHandleReduced)
        {
            IntPtr proc = HalconAPI.PreCall(1852);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, method);
            HalconAPI.Store(proc, 2, minRemainingSV);
            HalconAPI.Store(proc, 3, maxError);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(minRemainingSV);
            HalconAPI.UnpinTuple(maxError);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out SVMHandleReduced);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train a support vector machine.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="epsilon">Stop parameter for training. Default: 0.001</param>
        /// <param name="trainMode">Mode of training. For normal operation: 'default'. If SVs already included in the SVM should be used for training: 'add_sv_to_train_set'. For alpha seeding: the respective SVM handle. Default: "default"</param>
        public static void TrainClassSvm(HTuple SVMHandle, HTuple epsilon, HTuple trainMode)
        {
            IntPtr proc = HalconAPI.PreCall(1853);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, epsilon);
            HalconAPI.Store(proc, 2, trainMode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(epsilon);
            HalconAPI.UnpinTuple(trainMode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the information content of the preprocessed feature vectors of a support vector machine</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors. Default: "principal_components"</param>
        /// <param name="informationCont">Relative information content of the transformed feature vectors.</param>
        /// <param name="cumInformationCont">Cumulative information content of the transformed feature vectors.</param>
        public static void GetPrepInfoClassSvm(
          HTuple SVMHandle,
          HTuple preprocessing,
          out HTuple informationCont,
          out HTuple cumInformationCont)
        {
            IntPtr proc = HalconAPI.PreCall(1854);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, preprocessing);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(preprocessing);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out informationCont);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out cumInformationCont);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the number of support vectors of a support vector machine.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="numSupportVectors">Total number of support vectors.</param>
        /// <param name="numSVPerSVM">Number of SV of each sub-SVM.</param>
        public static void GetSupportVectorNumClassSvm(
          HTuple SVMHandle,
          out HTuple numSupportVectors,
          out HTuple numSVPerSVM)
        {
            IntPtr proc = HalconAPI.PreCall(1855);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out numSupportVectors);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out numSVPerSVM);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the index of a support vector from a trained support vector machine.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="indexSupportVector">Number of stored support vectors.</param>
        /// <param name="index">Index of the support vector in the training set.</param>
        public static void GetSupportVectorClassSvm(
          HTuple SVMHandle,
          HTuple indexSupportVector,
          out HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(1856);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, indexSupportVector);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(indexSupportVector);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out index);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the number of training samples stored in the training data of a support vector machine.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="numSamples">Number of stored training samples.</param>
        public static void GetSampleNumClassSvm(HTuple SVMHandle, out HTuple numSamples)
        {
            IntPtr proc = HalconAPI.PreCall(1857);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out numSamples);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return a training sample from the training data of a support vector machine.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="indexSample">Number of the stored training sample.</param>
        /// <param name="features">Feature vector of the training sample.</param>
        /// <param name="target">Target vector of the training sample.</param>
        public static void GetSampleClassSvm(
          HTuple SVMHandle,
          HTuple indexSample,
          out HTuple features,
          out HTuple target)
        {
            IntPtr proc = HalconAPI.PreCall(1858);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, indexSample);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(indexSample);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out features);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out target);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a training sample to the training data of a support vector machine.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="features">Feature vector of the training sample to be stored.</param>
        /// <param name="classVal">Class of the training sample to be stored.</param>
        public static void AddSampleClassSvm(HTuple SVMHandle, HTuple features, HTuple classVal)
        {
            IntPtr proc = HalconAPI.PreCall(1859);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.Store(proc, 2, classVal);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(classVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters of a support vector machine.</summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <param name="numFeatures">Number of input variables (features) of the SVM.</param>
        /// <param name="kernelType">The kernel type.</param>
        /// <param name="kernelParam">Additional parameter for the kernel.</param>
        /// <param name="nu">Regularization constant of the SVM.</param>
        /// <param name="numClasses">Number of classes of the test data.</param>
        /// <param name="mode">The mode of the SVM.</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors.</param>
        /// <param name="numComponents">Preprocessing parameter: Number of transformed features (ignored for Preprocessing $=$ 'none' and Preprocessing $=$ 'normalization').</param>
        public static void GetParamsClassSvm(
          HTuple SVMHandle,
          out HTuple numFeatures,
          out HTuple kernelType,
          out HTuple kernelParam,
          out HTuple nu,
          out HTuple numClasses,
          out HTuple mode,
          out HTuple preprocessing,
          out HTuple numComponents)
        {
            IntPtr proc = HalconAPI.PreCall(1860);
            HalconAPI.Store(proc, 0, SVMHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(SVMHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out numFeatures);
            int err3 = HTuple.LoadNew(proc, 1, err2, out kernelType);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out kernelParam);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out nu);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out numClasses);
            int err7 = HTuple.LoadNew(proc, 5, err6, out mode);
            int err8 = HTuple.LoadNew(proc, 6, err7, out preprocessing);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.INTEGER, err8, out numComponents);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a support vector machine for pattern classification.</summary>
        /// <param name="numFeatures">Number of input variables (features) of the SVM. Default: 10</param>
        /// <param name="kernelType">The kernel type. Default: "rbf"</param>
        /// <param name="kernelParam">Additional parameter for the kernel function. In case of RBF kernel the value for gamma@f$  Default: 0.02</param>
        /// <param name="nu">Regularisation constant of the SVM. Default: 0.05</param>
        /// <param name="numClasses">Number of classes. Default: 5</param>
        /// <param name="mode">The mode of the SVM. Default: "one-versus-one"</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors. Default: "normalization"</param>
        /// <param name="numComponents">Preprocessing parameter: Number of transformed features (ignored for Preprocessing $=$ 'none' and Preprocessing $=$ 'normalization'). Default: 10</param>
        /// <param name="SVMHandle">SVM handle.</param>
        public static void CreateClassSvm(
          HTuple numFeatures,
          HTuple kernelType,
          HTuple kernelParam,
          HTuple nu,
          HTuple numClasses,
          HTuple mode,
          HTuple preprocessing,
          HTuple numComponents,
          out HTuple SVMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1861);
            HalconAPI.Store(proc, 0, numFeatures);
            HalconAPI.Store(proc, 1, kernelType);
            HalconAPI.Store(proc, 2, kernelParam);
            HalconAPI.Store(proc, 3, nu);
            HalconAPI.Store(proc, 4, numClasses);
            HalconAPI.Store(proc, 5, mode);
            HalconAPI.Store(proc, 6, preprocessing);
            HalconAPI.Store(proc, 7, numComponents);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numFeatures);
            HalconAPI.UnpinTuple(kernelType);
            HalconAPI.UnpinTuple(kernelParam);
            HalconAPI.UnpinTuple(nu);
            HalconAPI.UnpinTuple(numClasses);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(preprocessing);
            HalconAPI.UnpinTuple(numComponents);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out SVMHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear all multilayer perceptrons.</summary>
        public static void ClearAllClassMlp()
        {
            IntPtr proc = HalconAPI.PreCall(1862);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        public static void ClearClassMlp(HTuple MLPHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1863);
            HalconAPI.Store(proc, 0, MLPHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear the training data of a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        public static void ClearSamplesClassMlp(HTuple MLPHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1864);
            HalconAPI.Store(proc, 0, MLPHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized multilayer perceptron.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="MLPHandle">MLP handle.</param>
        public static void DeserializeClassMlp(HTuple serializedItemHandle, out HTuple MLPHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1865);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out MLPHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a multilayer perceptron (MLP).</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeClassMlp(HTuple MLPHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1866);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a multilayer perceptron from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="MLPHandle">MLP handle.</param>
        public static void ReadClassMlp(HTuple fileName, out HTuple MLPHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1867);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out MLPHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a multilayer perceptron to a file.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteClassMlp(HTuple MLPHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1868);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read the training data of a multilayer perceptron from a file.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="fileName">File name.</param>
        public static void ReadSamplesClassMlp(HTuple MLPHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1869);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write the training data of a multilayer perceptron to a file.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteSamplesClassMlp(HTuple MLPHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1870);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the class of a feature vector by a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="features">Feature vector.</param>
        /// <param name="num">Number of best classes to determine. Default: 1</param>
        /// <param name="classVal">Result of classifying the feature vector with the MLP.</param>
        /// <param name="confidence">Confidence(s) of the class(es) of the feature vector.</param>
        public static void ClassifyClassMlp(
          HTuple MLPHandle,
          HTuple features,
          HTuple num,
          out HTuple classVal,
          out HTuple confidence)
        {
            IntPtr proc = HalconAPI.PreCall(1871);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.Store(proc, 2, num);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(num);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out classVal);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidence);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the evaluation of a feature vector by a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="features">Feature vector.</param>
        /// <param name="result">Result of evaluating the feature vector with the MLP.</param>
        public static void EvaluateClassMlp(HTuple MLPHandle, HTuple features, out HTuple result)
        {
            IntPtr proc = HalconAPI.PreCall(1872);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(features);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out result);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="maxIterations">Maximum number of iterations of the optimization algorithm. Default: 200</param>
        /// <param name="weightTolerance">Threshold for the difference of the weights of the MLP between two iterations of the optimization algorithm. Default: 1.0</param>
        /// <param name="errorTolerance">Threshold for the difference of the mean error of the MLP on the training data between two iterations of the optimization algorithm. Default: 0.01</param>
        /// <param name="error">Mean error of the MLP on the training data.</param>
        /// <param name="errorLog">Mean error of the MLP on the training data as a function of the number of iterations of the optimization algorithm.</param>
        public static void TrainClassMlp(
          HTuple MLPHandle,
          HTuple maxIterations,
          HTuple weightTolerance,
          HTuple errorTolerance,
          out HTuple error,
          out HTuple errorLog)
        {
            IntPtr proc = HalconAPI.PreCall(1873);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, maxIterations);
            HalconAPI.Store(proc, 2, weightTolerance);
            HalconAPI.Store(proc, 3, errorTolerance);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(maxIterations);
            HalconAPI.UnpinTuple(weightTolerance);
            HalconAPI.UnpinTuple(errorTolerance);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out error);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out errorLog);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the information content of the preprocessed feature vectors of a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors. Default: "principal_components"</param>
        /// <param name="informationCont">Relative information content of the transformed feature vectors.</param>
        /// <param name="cumInformationCont">Cumulative information content of the transformed feature vectors.</param>
        public static void GetPrepInfoClassMlp(
          HTuple MLPHandle,
          HTuple preprocessing,
          out HTuple informationCont,
          out HTuple cumInformationCont)
        {
            IntPtr proc = HalconAPI.PreCall(1874);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, preprocessing);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(preprocessing);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out informationCont);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out cumInformationCont);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the number of training samples stored in the training data of a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="numSamples">Number of stored training samples.</param>
        public static void GetSampleNumClassMlp(HTuple MLPHandle, out HTuple numSamples)
        {
            IntPtr proc = HalconAPI.PreCall(1875);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out numSamples);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return a training sample from the training data of a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="indexSample">Number of stored training sample.</param>
        /// <param name="features">Feature vector of the training sample.</param>
        /// <param name="target">Target vector of the training sample.</param>
        public static void GetSampleClassMlp(
          HTuple MLPHandle,
          HTuple indexSample,
          out HTuple features,
          out HTuple target)
        {
            IntPtr proc = HalconAPI.PreCall(1876);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, indexSample);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(indexSample);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out features);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out target);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the parameters of a rejection class.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="genParamName">Names of the generic parameters to return. Default: "sampling_strategy"</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        public static void GetRejectionParamsClassMlp(
          HTuple MLPHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1877);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the parameters of a rejection class.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="genParamName">Names of the generic parameters. Default: "sampling_strategy"</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: "hyperbox_around_all_classes"</param>
        public static void SetRejectionParamsClassMlp(
          HTuple MLPHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1878);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a training sample to the training data of a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="features">Feature vector of the training sample to be stored.</param>
        /// <param name="target">Class or target vector of the training sample to be stored.</param>
        public static void AddSampleClassMlp(HTuple MLPHandle, HTuple features, HTuple target)
        {
            IntPtr proc = HalconAPI.PreCall(1879);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.Store(proc, 2, target);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(target);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the regularization parameters of a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="genParamName">Name of the regularization parameter to return. Default: "weight_prior"</param>
        /// <param name="genParamValue">Value of the regularization parameter.</param>
        public static void GetRegularizationParamsClassMlp(
          HTuple MLPHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1880);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the regularization parameters of a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="genParamName">Name of the regularization parameter to set. Default: "weight_prior"</param>
        /// <param name="genParamValue">Value of the regularization parameter. Default: 1.0</param>
        public static void SetRegularizationParamsClassMlp(
          HTuple MLPHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1881);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters of a multilayer perceptron.</summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="numInput">Number of input variables (features) of the MLP.</param>
        /// <param name="numHidden">Number of hidden units of the MLP.</param>
        /// <param name="numOutput">Number of output variables (classes) of the MLP.</param>
        /// <param name="outputFunction">Type of the activation function in the output layer of the MLP.</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors.</param>
        /// <param name="numComponents">Preprocessing parameter: Number of transformed features.</param>
        public static void GetParamsClassMlp(
          HTuple MLPHandle,
          out HTuple numInput,
          out HTuple numHidden,
          out HTuple numOutput,
          out HTuple outputFunction,
          out HTuple preprocessing,
          out HTuple numComponents)
        {
            IntPtr proc = HalconAPI.PreCall(1882);
            HalconAPI.Store(proc, 0, MLPHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MLPHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out numInput);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out numHidden);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out numOutput);
            int err5 = HTuple.LoadNew(proc, 3, err4, out outputFunction);
            int err6 = HTuple.LoadNew(proc, 4, err5, out preprocessing);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out numComponents);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a multilayer perceptron for classification or regression.</summary>
        /// <param name="numInput">Number of input variables (features) of the MLP. Default: 20</param>
        /// <param name="numHidden">Number of hidden units of the MLP. Default: 10</param>
        /// <param name="numOutput">Number of output variables (classes) of the MLP. Default: 5</param>
        /// <param name="outputFunction">Type of the activation function in the output layer of the MLP. Default: "softmax"</param>
        /// <param name="preprocessing">Type of preprocessing used to transform the feature vectors. Default: "normalization"</param>
        /// <param name="numComponents">Preprocessing parameter: Number of transformed features (ignored for Preprocessing $=$ 'none' and Preprocessing $=$ 'normalization'). Default: 10</param>
        /// <param name="randSeed">Seed value of the random number generator that is used to initialize the MLP with random values. Default: 42</param>
        /// <param name="MLPHandle">MLP handle.</param>
        public static void CreateClassMlp(
          HTuple numInput,
          HTuple numHidden,
          HTuple numOutput,
          HTuple outputFunction,
          HTuple preprocessing,
          HTuple numComponents,
          HTuple randSeed,
          out HTuple MLPHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1883);
            HalconAPI.Store(proc, 0, numInput);
            HalconAPI.Store(proc, 1, numHidden);
            HalconAPI.Store(proc, 2, numOutput);
            HalconAPI.Store(proc, 3, outputFunction);
            HalconAPI.Store(proc, 4, preprocessing);
            HalconAPI.Store(proc, 5, numComponents);
            HalconAPI.Store(proc, 6, randSeed);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numInput);
            HalconAPI.UnpinTuple(numHidden);
            HalconAPI.UnpinTuple(numOutput);
            HalconAPI.UnpinTuple(outputFunction);
            HalconAPI.UnpinTuple(preprocessing);
            HalconAPI.UnpinTuple(numComponents);
            HalconAPI.UnpinTuple(randSeed);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out MLPHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized classifier.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void DeserializeClassBox(HTuple classifHandle, HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1884);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.Store(proc, 1, serializedItemHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.UnpinTuple(serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a classifier.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeClassBox(HTuple classifHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1885);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Save a classifier in a file.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="fileName">Name of the file which contains the written data.</param>
        public static void WriteClassBox(HTuple classifHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1886);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set system parameters for classification.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="flag">Name of the wanted parameter. Default: "split_error"</param>
        /// <param name="value">Value of the parameter. Default: 0.1</param>
        public static void SetClassBoxParam(HTuple classifHandle, HTuple flag, HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(1887);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.Store(proc, 1, flag);
            HalconAPI.Store(proc, 2, value);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.UnpinTuple(flag);
            HalconAPI.UnpinTuple(value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a training data set from a file.</summary>
        /// <param name="fileName">Filename of the data set to train. Default: "sampset1"</param>
        /// <param name="sampKey">Identification of the data set to train.</param>
        public static void ReadSampset(HTuple fileName, out HTuple sampKey)
        {
            IntPtr proc = HalconAPI.PreCall(1888);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out sampKey);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a classifier from a file.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="fileName">Filename of the classifier.</param>
        public static void ReadClassBox(HTuple classifHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1889);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train the classifier with one data set.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="sampKey">Number of the data set to train.</param>
        /// <param name="outfile">Name of the protocol file. Default: "training_prot"</param>
        /// <param name="NSamples">Number of arrays of attributes to learn. Default: 500</param>
        /// <param name="stopError">Classification error for termination. Default: 0.05</param>
        /// <param name="errorN">Error during the assignment. Default: 100</param>
        public static void LearnSampsetBox(
          HTuple classifHandle,
          HTuple sampKey,
          HTuple outfile,
          HTuple NSamples,
          HTuple stopError,
          HTuple errorN)
        {
            IntPtr proc = HalconAPI.PreCall(1890);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.Store(proc, 1, sampKey);
            HalconAPI.Store(proc, 2, outfile);
            HalconAPI.Store(proc, 3, NSamples);
            HalconAPI.Store(proc, 4, stopError);
            HalconAPI.Store(proc, 5, errorN);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.UnpinTuple(sampKey);
            HalconAPI.UnpinTuple(outfile);
            HalconAPI.UnpinTuple(NSamples);
            HalconAPI.UnpinTuple(stopError);
            HalconAPI.UnpinTuple(errorN);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train the classifier.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="features">Array of attributes to learn. Default: [1.0,1.5,2.0]</param>
        /// <param name="classVal">Class to which the array has to be assigned. Default: 1</param>
        public static void LearnClassBox(HTuple classifHandle, HTuple features, HTuple classVal)
        {
            IntPtr proc = HalconAPI.PreCall(1891);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.Store(proc, 2, classVal);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(classVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get information about the current parameter.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="flag">Name of the system parameter. Default: "split_error"</param>
        /// <param name="value">Value of the system parameter.</param>
        public static void GetClassBoxParam(HTuple classifHandle, HTuple flag, out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(1892);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.Store(proc, 1, flag);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.UnpinTuple(flag);
            int procResult = HTuple.LoadNew(proc, 0, err, out value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free memory of a data set.</summary>
        /// <param name="sampKey">Number of the data set.</param>
        public static void ClearSampset(HTuple sampKey)
        {
            IntPtr proc = HalconAPI.PreCall(1893);
            HalconAPI.Store(proc, 0, sampKey);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sampKey);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Destroy the classifier.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        public static void CloseClassBox(HTuple classifHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1894);
            HalconAPI.Store(proc, 0, classifHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a new classifier.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        public static void CreateClassBox(out HTuple classifHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1895);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classifHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Describe the classes of a box classifier.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="dimensions">Highest dimension for output. Default: 3</param>
        /// <param name="classIdx">Indices of the classes.</param>
        /// <param name="boxIdx">Indices of the boxes.</param>
        /// <param name="boxLowerBound">Lower bounds of the boxes (for each dimension).</param>
        /// <param name="boxHigherBound">Higher bounds of the boxes (for each dimension).</param>
        /// <param name="boxNumSamplesTrain">Number of training samples that were used to define this box (for each dimension).</param>
        /// <param name="boxNumSamplesWrong">Number of training samples that were assigned incorrectly to the box.</param>
        public static void DescriptClassBox(
          HTuple classifHandle,
          HTuple dimensions,
          out HTuple classIdx,
          out HTuple boxIdx,
          out HTuple boxLowerBound,
          out HTuple boxHigherBound,
          out HTuple boxNumSamplesTrain,
          out HTuple boxNumSamplesWrong)
        {
            IntPtr proc = HalconAPI.PreCall(1896);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.Store(proc, 1, dimensions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.UnpinTuple(dimensions);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out classIdx);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out boxIdx);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out boxLowerBound);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out boxHigherBound);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out boxNumSamplesTrain);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out boxNumSamplesWrong);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Classify a set of arrays.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="sampKey">Key of the test data.</param>
        /// <param name="error">Error during the assignment.</param>
        public static void TestSampsetBox(HTuple classifHandle, HTuple sampKey, out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1897);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.Store(proc, 1, sampKey);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.UnpinTuple(sampKey);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out error);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Classify a tuple of attributes with rejection class.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="featureList">Array of attributes which has to be classified. Default: 1.0</param>
        /// <param name="classVal">Number of the class, to which the array of attributes had been assigned or -1 for the rejection class.</param>
        public static void EnquireRejectClassBox(
          HTuple classifHandle,
          HTuple featureList,
          out HTuple classVal)
        {
            IntPtr proc = HalconAPI.PreCall(1898);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.Store(proc, 1, featureList);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.UnpinTuple(featureList);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Classify a tuple of attributes.</summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <param name="featureList">Array of attributes which has to be classified. Default: 1.0</param>
        /// <param name="classVal">Number of the class to which the array of attributes had been assigned.</param>
        public static void EnquireClassBox(
          HTuple classifHandle,
          HTuple featureList,
          out HTuple classVal)
        {
            IntPtr proc = HalconAPI.PreCall(1899);
            HalconAPI.Store(proc, 0, classifHandle);
            HalconAPI.Store(proc, 1, featureList);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classifHandle);
            HalconAPI.UnpinTuple(featureList);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out classVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Destroy all classifiers.</summary>
        public static void CloseAllClassBox()
        {
            IntPtr proc = HalconAPI.PreCall(1900);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert image maps into other map types.</summary>
        /// <param name="map">Input map.</param>
        /// <param name="mapConverted">Converted map.</param>
        /// <param name="newType">Type of MapConverted. Default: "coord_map_sub_pix"</param>
        /// <param name="imageWidth">Width of images to be mapped. Default: "map_width"</param>
        public static void ConvertMapType(
          HObject map,
          out HObject mapConverted,
          HTuple newType,
          HTuple imageWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1901);
            HalconAPI.Store(proc, 1, (HObjectBase)map);
            HalconAPI.Store(proc, 0, newType);
            HalconAPI.Store(proc, 1, imageWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(newType);
            HalconAPI.UnpinTuple(imageWidth);
            int procResult = HObject.LoadNew(proc, 1, err, out mapConverted);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)map);
        }

        /// <summary>Compute an absolute pose out of point correspondences between world and image coordinates.</summary>
        /// <param name="worldX">X-Component of world coordinates.</param>
        /// <param name="worldY">Y-Component of world coordinates.</param>
        /// <param name="worldZ">Z-Component of world coordinates.</param>
        /// <param name="imageRow">Row-Component of image coordinates.</param>
        /// <param name="imageColumn">Column-Component of image coordinates.</param>
        /// <param name="cameraParam">The inner camera parameters from camera calibration.</param>
        /// <param name="method">Kind of algorithm Default: "iterative"</param>
        /// <param name="qualityType">Type of pose quality to be returned in Quality. Default: "error"</param>
        /// <param name="pose">Pose.</param>
        /// <param name="quality">Pose quality.</param>
        public static void VectorToPose(
          HTuple worldX,
          HTuple worldY,
          HTuple worldZ,
          HTuple imageRow,
          HTuple imageColumn,
          HTuple cameraParam,
          HTuple method,
          HTuple qualityType,
          out HTuple pose,
          out HTuple quality)
        {
            IntPtr proc = HalconAPI.PreCall(1902);
            HalconAPI.Store(proc, 0, worldX);
            HalconAPI.Store(proc, 1, worldY);
            HalconAPI.Store(proc, 2, worldZ);
            HalconAPI.Store(proc, 3, imageRow);
            HalconAPI.Store(proc, 4, imageColumn);
            HalconAPI.Store(proc, 5, cameraParam);
            HalconAPI.Store(proc, 6, method);
            HalconAPI.Store(proc, 7, qualityType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(worldX);
            HalconAPI.UnpinTuple(worldY);
            HalconAPI.UnpinTuple(worldZ);
            HalconAPI.UnpinTuple(imageRow);
            HalconAPI.UnpinTuple(imageColumn);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(qualityType);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose);
            int procResult = HTuple.LoadNew(proc, 1, err2, out quality);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute a pose out of a homography describing the relation between world and image coordinates.</summary>
        /// <param name="homography">The homography from world- to image coordinates.</param>
        /// <param name="cameraMatrix">The camera calibration matrix K.</param>
        /// <param name="method">Type of pose computation. Default: "decomposition"</param>
        /// <param name="pose">Pose of the 2D object.</param>
        public static void ProjHomMat2dToPose(
          HTuple homography,
          HTuple cameraMatrix,
          HTuple method,
          out HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(1903);
            HalconAPI.Store(proc, 0, homography);
            HalconAPI.Store(proc, 1, cameraMatrix);
            HalconAPI.Store(proc, 2, method);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homography);
            HalconAPI.UnpinTuple(cameraMatrix);
            HalconAPI.UnpinTuple(method);
            int procResult = HTuple.LoadNew(proc, 0, err, out pose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calibrate the radial distortion.</summary>
        /// <param name="contours">Contours that are available for the calibration.</param>
        /// <param name="selectedContours">Contours that were used for the calibration</param>
        /// <param name="width">Width of the images from which the contours were extracted. Default: 640</param>
        /// <param name="height">Height of the images from which the contours were extracted. Default: 480</param>
        /// <param name="inlierThreshold">Threshold for the classification of outliers. Default: 0.05</param>
        /// <param name="randSeed">Seed value for the random number generator. Default: 42</param>
        /// <param name="distortionModel">Determines the distortion model. Default: "division"</param>
        /// <param name="distortionCenter">Determines how the distortion center will be estimated. Default: "variable"</param>
        /// <param name="principalPointVar">Controls the deviation of the distortion center from the image center; larger values allow larger deviations from the image center; 0 switches the penalty term off. Default: 0.0</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        public static void RadialDistortionSelfCalibration(
          HObject contours,
          out HObject selectedContours,
          HTuple width,
          HTuple height,
          HTuple inlierThreshold,
          HTuple randSeed,
          HTuple distortionModel,
          HTuple distortionCenter,
          HTuple principalPointVar,
          out HTuple cameraParam)
        {
            IntPtr proc = HalconAPI.PreCall(1904);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, width);
            HalconAPI.Store(proc, 1, height);
            HalconAPI.Store(proc, 2, inlierThreshold);
            HalconAPI.Store(proc, 3, randSeed);
            HalconAPI.Store(proc, 4, distortionModel);
            HalconAPI.Store(proc, 5, distortionCenter);
            HalconAPI.Store(proc, 6, principalPointVar);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(inlierThreshold);
            HalconAPI.UnpinTuple(randSeed);
            HalconAPI.UnpinTuple(distortionModel);
            HalconAPI.UnpinTuple(distortionCenter);
            HalconAPI.UnpinTuple(principalPointVar);
            int err2 = HObject.LoadNew(proc, 1, err1, out selectedContours);
            int procResult = HTuple.LoadNew(proc, 0, err2, out cameraParam);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Compute a camera matrix from internal camera parameters.</summary>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="cameraMatrix">3x3 projective camera matrix that corresponds to CameraParam.</param>
        /// <param name="imageWidth">Width of the images that correspond to CameraMatrix.</param>
        /// <param name="imageHeight">Height of the images that correspond to CameraMatrix.</param>
        public static void CamParToCamMat(
          HTuple cameraParam,
          out HTuple cameraMatrix,
          out HTuple imageWidth,
          out HTuple imageHeight)
        {
            IntPtr proc = HalconAPI.PreCall(1905);
            HalconAPI.Store(proc, 0, cameraParam);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraParam);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out cameraMatrix);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out imageWidth);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out imageHeight);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the internal camera parameters from a camera matrix.</summary>
        /// <param name="cameraMatrix">3x3 projective camera matrix that determines the internal camera parameters.</param>
        /// <param name="kappa">Kappa.</param>
        /// <param name="imageWidth">Width of the images that correspond to CameraMatrix.</param>
        /// <param name="imageHeight">Height of the images that correspond to CameraMatrix.</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        public static void CamMatToCamPar(
          HTuple cameraMatrix,
          HTuple kappa,
          HTuple imageWidth,
          HTuple imageHeight,
          out HTuple cameraParam)
        {
            IntPtr proc = HalconAPI.PreCall(1906);
            HalconAPI.Store(proc, 0, cameraMatrix);
            HalconAPI.Store(proc, 1, kappa);
            HalconAPI.Store(proc, 2, imageWidth);
            HalconAPI.Store(proc, 3, imageHeight);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraMatrix);
            HalconAPI.UnpinTuple(kappa);
            HalconAPI.UnpinTuple(imageWidth);
            HalconAPI.UnpinTuple(imageHeight);
            int procResult = HTuple.LoadNew(proc, 0, err, out cameraParam);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Perform a self-calibration of a stationary projective camera.</summary>
        /// <param name="numImages">Number of different images that are used for the calibration.</param>
        /// <param name="imageWidth">Width of the images from which the points were extracted.</param>
        /// <param name="imageHeight">Height of the images from which the points were extracted.</param>
        /// <param name="referenceImage">Index of the reference image.</param>
        /// <param name="mappingSource">Indices of the source images of the transformations.</param>
        /// <param name="mappingDest">Indices of the target images of the transformations.</param>
        /// <param name="homMatrices2D">Array of 3x3 projective transformation matrices.</param>
        /// <param name="rows1">Row coordinates of corresponding points in the respective source images.</param>
        /// <param name="cols1">Column coordinates of corresponding points in the respective source images.</param>
        /// <param name="rows2">Row coordinates of corresponding points in the respective destination images.</param>
        /// <param name="cols2">Column coordinates of corresponding points in the respective destination images.</param>
        /// <param name="numCorrespondences">Number of point correspondences in the respective image pair.</param>
        /// <param name="estimationMethod">Estimation algorithm for the calibration. Default: "gold_standard"</param>
        /// <param name="cameraModel">Camera model to be used. Default: ["focus","principal_point"]</param>
        /// <param name="fixedCameraParams">Are the camera parameters identical for all images? Default: "true"</param>
        /// <param name="cameraMatrices">(Array of) 3x3 projective camera matrices that determine the internal camera parameters.</param>
        /// <param name="kappa">Radial distortion of the camera.</param>
        /// <param name="rotationMatrices">Array of 3x3 transformation matrices that determine rotation of the camera in the respective image.</param>
        /// <param name="x">X-Component of the direction vector of each point if EstimationMethod $=$ 'gold_standard' is used.</param>
        /// <param name="y">Y-Component of the direction vector of each point if EstimationMethod $=$ 'gold_standard' is used.</param>
        /// <param name="z">Z-Component of the direction vector of each point if EstimationMethod $=$ 'gold_standard' is used.</param>
        /// <param name="error">Average error per reconstructed point if EstimationMethod $=$ 'gold_standard' is used.</param>
        public static void StationaryCameraSelfCalibration(
          HTuple numImages,
          HTuple imageWidth,
          HTuple imageHeight,
          HTuple referenceImage,
          HTuple mappingSource,
          HTuple mappingDest,
          HTuple homMatrices2D,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HTuple numCorrespondences,
          HTuple estimationMethod,
          HTuple cameraModel,
          HTuple fixedCameraParams,
          out HTuple cameraMatrices,
          out HTuple kappa,
          out HTuple rotationMatrices,
          out HTuple x,
          out HTuple y,
          out HTuple z,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1907);
            HalconAPI.Store(proc, 0, numImages);
            HalconAPI.Store(proc, 1, imageWidth);
            HalconAPI.Store(proc, 2, imageHeight);
            HalconAPI.Store(proc, 3, referenceImage);
            HalconAPI.Store(proc, 4, mappingSource);
            HalconAPI.Store(proc, 5, mappingDest);
            HalconAPI.Store(proc, 6, homMatrices2D);
            HalconAPI.Store(proc, 7, rows1);
            HalconAPI.Store(proc, 8, cols1);
            HalconAPI.Store(proc, 9, rows2);
            HalconAPI.Store(proc, 10, cols2);
            HalconAPI.Store(proc, 11, numCorrespondences);
            HalconAPI.Store(proc, 12, estimationMethod);
            HalconAPI.Store(proc, 13, cameraModel);
            HalconAPI.Store(proc, 14, fixedCameraParams);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numImages);
            HalconAPI.UnpinTuple(imageWidth);
            HalconAPI.UnpinTuple(imageHeight);
            HalconAPI.UnpinTuple(referenceImage);
            HalconAPI.UnpinTuple(mappingSource);
            HalconAPI.UnpinTuple(mappingDest);
            HalconAPI.UnpinTuple(homMatrices2D);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(numCorrespondences);
            HalconAPI.UnpinTuple(estimationMethod);
            HalconAPI.UnpinTuple(cameraModel);
            HalconAPI.UnpinTuple(fixedCameraParams);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out cameraMatrices);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out kappa);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out rotationMatrices);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out x);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out y);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out z);
            int procResult = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out error);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Determine the 3D pose of a rectangle from its perspective 2D projection</summary>
        /// <param name="contour">Contour(s) to be examined.</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="width">Width of the rectangle in meters.</param>
        /// <param name="height">Height of the rectangle in meters.</param>
        /// <param name="weightingMode">Weighting mode for the optimization phase. Default: "nonweighted"</param>
        /// <param name="clippingFactor">Clipping factor for the elimination of outliers (typical: 1.0 for 'huber' and 3.0 for 'tukey'). Default: 2.0</param>
        /// <param name="pose">3D pose of the rectangle.</param>
        /// <param name="covPose">Covariances of the pose values.</param>
        /// <param name="error">Root-mean-square value of the final residual error.</param>
        public static void GetRectanglePose(
          HObject contour,
          HTuple cameraParam,
          HTuple width,
          HTuple height,
          HTuple weightingMode,
          HTuple clippingFactor,
          out HTuple pose,
          out HTuple covPose,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1908);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, cameraParam);
            HalconAPI.Store(proc, 1, width);
            HalconAPI.Store(proc, 2, height);
            HalconAPI.Store(proc, 3, weightingMode);
            HalconAPI.Store(proc, 4, clippingFactor);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(weightingMode);
            HalconAPI.UnpinTuple(clippingFactor);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covPose);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Determine the 3D pose of a circle from its perspective 2D projection. </summary>
        /// <param name="contour">Contours to be examined.</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="radius">Radius of the circle in object space.</param>
        /// <param name="outputType">Type of output parameters. Default: "pose"</param>
        /// <param name="pose1">3D pose of the first circle.</param>
        /// <param name="pose2">3D pose of the second circle.</param>
        public static void GetCirclePose(
          HObject contour,
          HTuple cameraParam,
          HTuple radius,
          HTuple outputType,
          out HTuple pose1,
          out HTuple pose2)
        {
            IntPtr proc = HalconAPI.PreCall(1909);
            HalconAPI.Store(proc, 1, (HObjectBase)contour);
            HalconAPI.Store(proc, 0, cameraParam);
            HalconAPI.Store(proc, 1, radius);
            HalconAPI.Store(proc, 2, outputType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(outputType);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose1);
            int procResult = HTuple.LoadNew(proc, 1, err2, out pose2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour);
        }

        /// <summary>Perform a radiometric self-calibration of a camera.</summary>
        /// <param name="images">Input images.</param>
        /// <param name="exposureRatios">Ratio of the exposure energies of successive image pairs. Default: 0.5</param>
        /// <param name="features">Features that are used to compute the inverse response function of the camera. Default: "2d_histogram"</param>
        /// <param name="functionType">Type of the inverse response function of the camera. Default: "discrete"</param>
        /// <param name="smoothness">Smoothness of the inverse response function of the camera. Default: 1.0</param>
        /// <param name="polynomialDegree">Degree of the polynomial if FunctionType = 'polynomial'. Default: 5</param>
        /// <param name="inverseResponse">Inverse response function of the camera.</param>
        public static void RadiometricSelfCalibration(
          HObject images,
          HTuple exposureRatios,
          HTuple features,
          HTuple functionType,
          HTuple smoothness,
          HTuple polynomialDegree,
          out HTuple inverseResponse)
        {
            IntPtr proc = HalconAPI.PreCall(1910);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, exposureRatios);
            HalconAPI.Store(proc, 1, features);
            HalconAPI.Store(proc, 2, functionType);
            HalconAPI.Store(proc, 3, smoothness);
            HalconAPI.Store(proc, 4, polynomialDegree);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(exposureRatios);
            HalconAPI.UnpinTuple(features);
            HalconAPI.UnpinTuple(functionType);
            HalconAPI.UnpinTuple(smoothness);
            HalconAPI.UnpinTuple(polynomialDegree);
            int procResult = HTuple.LoadNew(proc, 0, err, out inverseResponse);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Apply a general transformation to an image.</summary>
        /// <param name="image">Image to be mapped.</param>
        /// <param name="map">Image containing the mapping data.</param>
        /// <param name="imageMapped">Mapped image.</param>
        public static void MapImage(HObject image, HObject map, out HObject imageMapped)
        {
            IntPtr proc = HalconAPI.PreCall(1911);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)map);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = HObject.LoadNew(proc, 1, err, out imageMapped);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)map);
        }

        /// <summary>Generate a projection map that describes the mapping of images corresponding to a changing radial distortion.</summary>
        /// <param name="map">Image containing the mapping data.</param>
        /// <param name="camParamIn">Old camera parameters.</param>
        /// <param name="camParamOut">New camera parameters.</param>
        /// <param name="mapType">Type of the mapping. Default: "bilinear"</param>
        public static void GenRadialDistortionMap(
          out HObject map,
          HTuple camParamIn,
          HTuple camParamOut,
          HTuple mapType)
        {
            IntPtr proc = HalconAPI.PreCall(1912);
            HalconAPI.Store(proc, 0, camParamIn);
            HalconAPI.Store(proc, 1, camParamOut);
            HalconAPI.Store(proc, 2, mapType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParamIn);
            HalconAPI.UnpinTuple(camParamOut);
            HalconAPI.UnpinTuple(mapType);
            int procResult = HObject.LoadNew(proc, 1, err, out map);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate a projection map that describes the mapping between the image plane and a the plane z=0 of a world coordinate system.</summary>
        /// <param name="map">Image containing the mapping data.</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="worldPose">3D pose of the world coordinate system in camera coordinates.</param>
        /// <param name="widthIn">Width of the images to be transformed.</param>
        /// <param name="heightIn">Height of the images to be transformed.</param>
        /// <param name="widthMapped">Width of the resulting mapped images in pixels.</param>
        /// <param name="heightMapped">Height of the resulting mapped images in pixels.</param>
        /// <param name="scale">Scale or unit. Default: "m"</param>
        /// <param name="mapType">Type of the mapping. Default: "bilinear"</param>
        public static void GenImageToWorldPlaneMap(
          out HObject map,
          HTuple cameraParam,
          HTuple worldPose,
          HTuple widthIn,
          HTuple heightIn,
          HTuple widthMapped,
          HTuple heightMapped,
          HTuple scale,
          HTuple mapType)
        {
            IntPtr proc = HalconAPI.PreCall(1913);
            HalconAPI.Store(proc, 0, cameraParam);
            HalconAPI.Store(proc, 1, worldPose);
            HalconAPI.Store(proc, 2, widthIn);
            HalconAPI.Store(proc, 3, heightIn);
            HalconAPI.Store(proc, 4, widthMapped);
            HalconAPI.Store(proc, 5, heightMapped);
            HalconAPI.Store(proc, 6, scale);
            HalconAPI.Store(proc, 7, mapType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(worldPose);
            HalconAPI.UnpinTuple(widthIn);
            HalconAPI.UnpinTuple(heightIn);
            HalconAPI.UnpinTuple(widthMapped);
            HalconAPI.UnpinTuple(heightMapped);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.UnpinTuple(mapType);
            int procResult = HObject.LoadNew(proc, 1, err, out map);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Rectify an image by transforming it into the plane z=0 of a world coordinate system.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageWorld">Transformed image.</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="worldPose">3D pose of the world coordinate system in camera coordinates.</param>
        /// <param name="width">Width of the resulting image in pixels.</param>
        /// <param name="height">Height of the resulting image in pixels.</param>
        /// <param name="scale">Scale or unit Default: "m"</param>
        /// <param name="interpolation">Type of interpolation. Default: "bilinear"</param>
        public static void ImageToWorldPlane(
          HObject image,
          out HObject imageWorld,
          HTuple cameraParam,
          HTuple worldPose,
          HTuple width,
          HTuple height,
          HTuple scale,
          HTuple interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1914);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, cameraParam);
            HalconAPI.Store(proc, 1, worldPose);
            HalconAPI.Store(proc, 2, width);
            HalconAPI.Store(proc, 3, height);
            HalconAPI.Store(proc, 4, scale);
            HalconAPI.Store(proc, 5, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(worldPose);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HalconAPI.UnpinTuple(scale);
            HalconAPI.UnpinTuple(interpolation);
            int procResult = HObject.LoadNew(proc, 1, err, out imageWorld);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Transform an XLD contour into the plane z=0 of a world coordinate system.</summary>
        /// <param name="contours">Input XLD contours to be transformed in image coordinates.</param>
        /// <param name="contoursTrans">Transformed XLD contours in world coordinates.</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="worldPose">3D pose of the world coordinate system in camera coordinates.</param>
        /// <param name="scale">Scale or dimension Default: "m"</param>
        public static void ContourToWorldPlaneXld(
          HObject contours,
          out HObject contoursTrans,
          HTuple cameraParam,
          HTuple worldPose,
          HTuple scale)
        {
            IntPtr proc = HalconAPI.PreCall(1915);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, cameraParam);
            HalconAPI.Store(proc, 1, worldPose);
            HalconAPI.Store(proc, 2, scale);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(worldPose);
            HalconAPI.UnpinTuple(scale);
            int procResult = HObject.LoadNew(proc, 1, err, out contoursTrans);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Transform image points into the plane z=0 of a world coordinate system.</summary>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="worldPose">3D pose of the world coordinate system in camera coordinates.</param>
        /// <param name="rows">Row coordinates of the points to be transformed. Default: 100.0</param>
        /// <param name="cols">Column coordinates of the points to be transformed. Default: 100.0</param>
        /// <param name="scale">Scale or dimension Default: "m"</param>
        /// <param name="x">X coordinates of the points in the world coordinate system.</param>
        /// <param name="y">Y coordinates of the points in the world coordinate system.</param>
        public static void ImagePointsToWorldPlane(
          HTuple cameraParam,
          HTuple worldPose,
          HTuple rows,
          HTuple cols,
          HTuple scale,
          out HTuple x,
          out HTuple y)
        {
            IntPtr proc = HalconAPI.PreCall(1916);
            HalconAPI.Store(proc, 0, cameraParam);
            HalconAPI.Store(proc, 1, worldPose);
            HalconAPI.Store(proc, 2, rows);
            HalconAPI.Store(proc, 3, cols);
            HalconAPI.Store(proc, 4, scale);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(worldPose);
            HalconAPI.UnpinTuple(rows);
            HalconAPI.UnpinTuple(cols);
            HalconAPI.UnpinTuple(scale);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out x);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out y);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Translate the origin of a 3D pose.</summary>
        /// <param name="poseIn">original 3D pose.</param>
        /// <param name="DX">translation of the origin in x-direction. Default: 0</param>
        /// <param name="DY">translation of the origin in y-direction. Default: 0</param>
        /// <param name="DZ">translation of the origin in z-direction. Default: 0</param>
        /// <param name="poseNewOrigin">new 3D pose after applying the translation.</param>
        public static void SetOriginPose(
          HTuple poseIn,
          HTuple DX,
          HTuple DY,
          HTuple DZ,
          out HTuple poseNewOrigin)
        {
            IntPtr proc = HalconAPI.PreCall(1917);
            HalconAPI.Store(proc, 0, poseIn);
            HalconAPI.Store(proc, 1, DX);
            HalconAPI.Store(proc, 2, DY);
            HalconAPI.Store(proc, 3, DZ);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(poseIn);
            HalconAPI.UnpinTuple(DX);
            HalconAPI.UnpinTuple(DY);
            HalconAPI.UnpinTuple(DZ);
            int procResult = HTuple.LoadNew(proc, 0, err, out poseNewOrigin);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Perform a hand-eye calibration.</summary>
        /// <param name="x">Linear list containing all the x coordinates of the calibration points (in the order of the images).</param>
        /// <param name="y">Linear list containing all the y coordinates of the calibration points (in the order of the images).</param>
        /// <param name="z">Linear list containing all the z coordinates of the calibration points (in the order of the images).</param>
        /// <param name="row">Linear list containing all row coordinates of the calibration points (in the order of the images).</param>
        /// <param name="col">Linear list containing all the column coordinates of the calibration points (in the order of the images).</param>
        /// <param name="numPoints">Number of the calibration points for each image.</param>
        /// <param name="robotPoses">Known 3D pose of the robot for each image (moving camera: robot base in robot tool coordinates; stationary camera: robot tool in robot base coordinates).</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="method">Method of hand-eye calibration. Default: "nonlinear"</param>
        /// <param name="qualityType">Type of quality assessment. Default: "error_pose"</param>
        /// <param name="cameraPose">Computed relative camera pose: 3D pose of the robot tool (moving camera) or robot base (stationary camera), respectively, in camera coordinates.</param>
        /// <param name="calibrationPose">Computed 3D pose of the calibration points in robot base coordinates (moving camera) or in robot tool coordinates (stationary camera), respectively.</param>
        /// <param name="quality">Quality assessment of the result.</param>
        public static void HandEyeCalibration(
          HTuple x,
          HTuple y,
          HTuple z,
          HTuple row,
          HTuple col,
          HTuple numPoints,
          HTuple robotPoses,
          HTuple cameraParam,
          HTuple method,
          HTuple qualityType,
          out HTuple cameraPose,
          out HTuple calibrationPose,
          out HTuple quality)
        {
            IntPtr proc = HalconAPI.PreCall(1918);
            HalconAPI.Store(proc, 0, x);
            HalconAPI.Store(proc, 1, y);
            HalconAPI.Store(proc, 2, z);
            HalconAPI.Store(proc, 3, row);
            HalconAPI.Store(proc, 4, col);
            HalconAPI.Store(proc, 5, numPoints);
            HalconAPI.Store(proc, 6, robotPoses);
            HalconAPI.Store(proc, 7, cameraParam);
            HalconAPI.Store(proc, 8, method);
            HalconAPI.Store(proc, 9, qualityType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(x);
            HalconAPI.UnpinTuple(y);
            HalconAPI.UnpinTuple(z);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(col);
            HalconAPI.UnpinTuple(numPoints);
            HalconAPI.UnpinTuple(robotPoses);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(method);
            HalconAPI.UnpinTuple(qualityType);
            int err2 = HTuple.LoadNew(proc, 0, err1, out cameraPose);
            int err3 = HTuple.LoadNew(proc, 1, err2, out calibrationPose);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out quality);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the representation type of a 3D pose.</summary>
        /// <param name="pose">3D pose.</param>
        /// <param name="orderOfTransform">Order of rotation and translation.</param>
        /// <param name="orderOfRotation">Meaning of the rotation values.</param>
        /// <param name="viewOfTransform">View of transformation.</param>
        public static void GetPoseType(
          HTuple pose,
          out HTuple orderOfTransform,
          out HTuple orderOfRotation,
          out HTuple viewOfTransform)
        {
            IntPtr proc = HalconAPI.PreCall(1919);
            HalconAPI.Store(proc, 0, pose);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pose);
            int err2 = HTuple.LoadNew(proc, 0, err1, out orderOfTransform);
            int err3 = HTuple.LoadNew(proc, 1, err2, out orderOfRotation);
            int procResult = HTuple.LoadNew(proc, 2, err3, out viewOfTransform);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Change the representation type of a 3D pose.</summary>
        /// <param name="poseIn">Original 3D pose.</param>
        /// <param name="orderOfTransform">Order of rotation and translation. Default: "Rp+T"</param>
        /// <param name="orderOfRotation">Meaning of the rotation values. Default: "gba"</param>
        /// <param name="viewOfTransform">View of transformation. Default: "point"</param>
        /// <param name="poseOut">3D transformation.</param>
        public static void ConvertPoseType(
          HTuple poseIn,
          HTuple orderOfTransform,
          HTuple orderOfRotation,
          HTuple viewOfTransform,
          out HTuple poseOut)
        {
            IntPtr proc = HalconAPI.PreCall(1920);
            HalconAPI.Store(proc, 0, poseIn);
            HalconAPI.Store(proc, 1, orderOfTransform);
            HalconAPI.Store(proc, 2, orderOfRotation);
            HalconAPI.Store(proc, 3, viewOfTransform);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(poseIn);
            HalconAPI.UnpinTuple(orderOfTransform);
            HalconAPI.UnpinTuple(orderOfRotation);
            HalconAPI.UnpinTuple(viewOfTransform);
            int procResult = HTuple.LoadNew(proc, 0, err, out poseOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a 3D pose.</summary>
        /// <param name="transX">Translation along the x-axis (in [m]). Default: 0.1</param>
        /// <param name="transY">Translation along the y-axis (in [m]). Default: 0.1</param>
        /// <param name="transZ">Translation along the z-axis (in [m]). Default: 0.1</param>
        /// <param name="rotX">Rotation around x-axis or x component of the Rodriguez vector (in [°] or without unit). Default: 90.0</param>
        /// <param name="rotY">Rotation around y-axis or y component of the Rodriguez vector (in [°] or without unit). Default: 90.0</param>
        /// <param name="rotZ">Rotation around z-axis or z component of the Rodriguez vector (in [°] or without unit). Default: 90.0</param>
        /// <param name="orderOfTransform">Order of rotation and translation. Default: "Rp+T"</param>
        /// <param name="orderOfRotation">Meaning of the rotation values. Default: "gba"</param>
        /// <param name="viewOfTransform">View of transformation. Default: "point"</param>
        /// <param name="pose">3D pose.</param>
        public static void CreatePose(
          HTuple transX,
          HTuple transY,
          HTuple transZ,
          HTuple rotX,
          HTuple rotY,
          HTuple rotZ,
          HTuple orderOfTransform,
          HTuple orderOfRotation,
          HTuple viewOfTransform,
          out HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(1921);
            HalconAPI.Store(proc, 0, transX);
            HalconAPI.Store(proc, 1, transY);
            HalconAPI.Store(proc, 2, transZ);
            HalconAPI.Store(proc, 3, rotX);
            HalconAPI.Store(proc, 4, rotY);
            HalconAPI.Store(proc, 5, rotZ);
            HalconAPI.Store(proc, 6, orderOfTransform);
            HalconAPI.Store(proc, 7, orderOfRotation);
            HalconAPI.Store(proc, 8, viewOfTransform);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(transX);
            HalconAPI.UnpinTuple(transY);
            HalconAPI.UnpinTuple(transZ);
            HalconAPI.UnpinTuple(rotX);
            HalconAPI.UnpinTuple(rotY);
            HalconAPI.UnpinTuple(rotZ);
            HalconAPI.UnpinTuple(orderOfTransform);
            HalconAPI.UnpinTuple(orderOfRotation);
            HalconAPI.UnpinTuple(viewOfTransform);
            int procResult = HTuple.LoadNew(proc, 0, err, out pose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Change the radial distortion of contours.</summary>
        /// <param name="contours">Original contours.</param>
        /// <param name="contoursRectified">Resulting contours with modified radial distortion.</param>
        /// <param name="camParamIn">Internal camera parameter for Contours.</param>
        /// <param name="camParamOut">Internal camera parameter for ContoursRectified.</param>
        public static void ChangeRadialDistortionContoursXld(
          HObject contours,
          out HObject contoursRectified,
          HTuple camParamIn,
          HTuple camParamOut)
        {
            IntPtr proc = HalconAPI.PreCall(1922);
            HalconAPI.Store(proc, 1, (HObjectBase)contours);
            HalconAPI.Store(proc, 0, camParamIn);
            HalconAPI.Store(proc, 1, camParamOut);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParamIn);
            HalconAPI.UnpinTuple(camParamOut);
            int procResult = HObject.LoadNew(proc, 1, err, out contoursRectified);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contours);
        }

        /// <summary>Change the radial distortion of pixel coordinates.</summary>
        /// <param name="row">Original row component of pixel coordinates.</param>
        /// <param name="col">Original column component of pixel coordinates.</param>
        /// <param name="camParamIn">The inner camera parameters of the camera used to create the input pixel coordinates.</param>
        /// <param name="camParamOut">The inner camera parameters of a camera.</param>
        /// <param name="rowChanged">Row component of pixel coordinates after changing the radial distortion.</param>
        /// <param name="colChanged">Column component of pixel coordinates after changing the radial distortion.</param>
        public static void ChangeRadialDistortionPoints(
          HTuple row,
          HTuple col,
          HTuple camParamIn,
          HTuple camParamOut,
          out HTuple rowChanged,
          out HTuple colChanged)
        {
            IntPtr proc = HalconAPI.PreCall(1923);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, col);
            HalconAPI.Store(proc, 2, camParamIn);
            HalconAPI.Store(proc, 3, camParamOut);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(col);
            HalconAPI.UnpinTuple(camParamIn);
            HalconAPI.UnpinTuple(camParamOut);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowChanged);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out colChanged);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Change the radial distortion of an image.</summary>
        /// <param name="image">Original image.</param>
        /// <param name="region">Region of interest in ImageRectified.</param>
        /// <param name="imageRectified">Resulting image with modified radial distortion.</param>
        /// <param name="camParamIn">Internal camera parameter for Image.</param>
        /// <param name="camParamOut">Internal camera parameter for Image.</param>
        public static void ChangeRadialDistortionImage(
          HObject image,
          HObject region,
          out HObject imageRectified,
          HTuple camParamIn,
          HTuple camParamOut)
        {
            IntPtr proc = HalconAPI.PreCall(1924);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.Store(proc, 0, camParamIn);
            HalconAPI.Store(proc, 1, camParamOut);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParamIn);
            HalconAPI.UnpinTuple(camParamOut);
            int procResult = HObject.LoadNew(proc, 1, err, out imageRectified);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)region);
        }

        /// <summary>Determine new camera parameters in accordance to the specified radial distortion.</summary>
        /// <param name="mode">Mode Default: "adaptive"</param>
        /// <param name="camParamIn">Internal camera parameters (original).</param>
        /// <param name="distortionCoeffs">Desired radial distortions. Default: 0.0</param>
        /// <param name="camParamOut">Internal camera parameters (modified).</param>
        public static void ChangeRadialDistortionCamPar(
          HTuple mode,
          HTuple camParamIn,
          HTuple distortionCoeffs,
          out HTuple camParamOut)
        {
            IntPtr proc = HalconAPI.PreCall(1925);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.Store(proc, 1, camParamIn);
            HalconAPI.Store(proc, 2, distortionCoeffs);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.UnpinTuple(camParamIn);
            HalconAPI.UnpinTuple(distortionCoeffs);
            int procResult = HTuple.LoadNew(proc, 0, err, out camParamOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate a calibration plate description file and a corresponding PostScript file for a calibration plate with rectangularly arranged marks.</summary>
        /// <param name="XNum">Number of marks in x direction. Default: 7</param>
        /// <param name="YNum">Number of marks in y direction. Default: 7</param>
        /// <param name="markDist">Distance of the marks in meters. Default: 0.0125</param>
        /// <param name="diameterRatio">Ratio of the mark diameter to the mark distance. Default: 0.5</param>
        /// <param name="calPlateDescr">File name of the calibration plate description. Default: "caltab.descr"</param>
        /// <param name="calPlatePSFile">File name of the PostScript file. Default: "caltab.ps"</param>
        public static void GenCaltab(
          HTuple XNum,
          HTuple YNum,
          HTuple markDist,
          HTuple diameterRatio,
          HTuple calPlateDescr,
          HTuple calPlatePSFile)
        {
            IntPtr proc = HalconAPI.PreCall(1926);
            HalconAPI.Store(proc, 0, XNum);
            HalconAPI.Store(proc, 1, YNum);
            HalconAPI.Store(proc, 2, markDist);
            HalconAPI.Store(proc, 3, diameterRatio);
            HalconAPI.Store(proc, 4, calPlateDescr);
            HalconAPI.Store(proc, 5, calPlatePSFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(XNum);
            HalconAPI.UnpinTuple(YNum);
            HalconAPI.UnpinTuple(markDist);
            HalconAPI.UnpinTuple(diameterRatio);
            HalconAPI.UnpinTuple(calPlateDescr);
            HalconAPI.UnpinTuple(calPlatePSFile);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate a calibration plate description file and a corresponding PostScript file for a calibration plate with hexagonally arranged marks.</summary>
        /// <param name="numRows">Number of rows. Default: 27</param>
        /// <param name="marksPerRow">Number of marks per row. Default: 31</param>
        /// <param name="diameter">Diameter of the marks. Default: 0.00258065</param>
        /// <param name="finderRow">Row indices of the finder patterns. Default: [13,6,6,20,20]</param>
        /// <param name="finderColumn">Column indices of the finder patterns. Default: [15,6,24,6,24]</param>
        /// <param name="polarity">Polarity of the marks Default: "light_on_dark"</param>
        /// <param name="calPlateDescr">File name of the calibration plate description. Default: "calplate.cpd"</param>
        /// <param name="calPlatePSFile">File name of the PostScript file. Default: "calplate.ps"</param>
        public static void CreateCaltab(
          HTuple numRows,
          HTuple marksPerRow,
          HTuple diameter,
          HTuple finderRow,
          HTuple finderColumn,
          HTuple polarity,
          HTuple calPlateDescr,
          HTuple calPlatePSFile)
        {
            IntPtr proc = HalconAPI.PreCall(1927);
            HalconAPI.Store(proc, 0, numRows);
            HalconAPI.Store(proc, 1, marksPerRow);
            HalconAPI.Store(proc, 2, diameter);
            HalconAPI.Store(proc, 3, finderRow);
            HalconAPI.Store(proc, 4, finderColumn);
            HalconAPI.Store(proc, 5, polarity);
            HalconAPI.Store(proc, 6, calPlateDescr);
            HalconAPI.Store(proc, 7, calPlatePSFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numRows);
            HalconAPI.UnpinTuple(marksPerRow);
            HalconAPI.UnpinTuple(diameter);
            HalconAPI.UnpinTuple(finderRow);
            HalconAPI.UnpinTuple(finderColumn);
            HalconAPI.UnpinTuple(polarity);
            HalconAPI.UnpinTuple(calPlateDescr);
            HalconAPI.UnpinTuple(calPlatePSFile);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read the mark center points from the calibration plate description file.</summary>
        /// <param name="calPlateDescr">File name of the calibration plate description. Default: "calplate.cpd"</param>
        /// <param name="x">X coordinates of the mark center points in the coordinate system of the calibration plate.</param>
        /// <param name="y">Y coordinates of the mark center points in the coordinate system of the calibration plate.</param>
        /// <param name="z">Z coordinates of the mark center points in the coordinate system of the calibration plate.</param>
        public static void CaltabPoints(
          HTuple calPlateDescr,
          out HTuple x,
          out HTuple y,
          out HTuple z)
        {
            IntPtr proc = HalconAPI.PreCall(1928);
            HalconAPI.Store(proc, 0, calPlateDescr);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calPlateDescr);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out x);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out y);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out z);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the line of sight corresponding to a point in the image.</summary>
        /// <param name="row">Row coordinate of the pixel.</param>
        /// <param name="column">Column coordinate of the pixel.</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="PX">X coordinate of the first point on the line of sight in the camera coordinate system</param>
        /// <param name="PY">Y coordinate of the first point on the line of sight in the camera coordinate system</param>
        /// <param name="PZ">Z coordinate of the first point on the line of sight in the camera coordinate system</param>
        /// <param name="QX">X coordinate of the second point on the line of sight in the camera coordinate system</param>
        /// <param name="QY">Y coordinate of the second point on the line of sight in the camera coordinate system</param>
        /// <param name="QZ">Z coordinate of the second point on the line of sight in the camera coordinate system</param>
        public static void GetLineOfSight(
          HTuple row,
          HTuple column,
          HTuple cameraParam,
          out HTuple PX,
          out HTuple PY,
          out HTuple PZ,
          out HTuple QX,
          out HTuple QY,
          out HTuple QZ)
        {
            IntPtr proc = HalconAPI.PreCall(1929);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, cameraParam);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(cameraParam);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out PX);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out PY);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out PZ);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out QX);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out QY);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out QZ);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Project a homogeneous 3D point using a 3x4 projection matrix.</summary>
        /// <param name="homMat3D">3x4 projection matrix.</param>
        /// <param name="px">Input point (x coordinate).</param>
        /// <param name="py">Input point (y coordinate).</param>
        /// <param name="pz">Input point (z coordinate).</param>
        /// <param name="pw">Input point (w coordinate).</param>
        /// <param name="qx">Output point (x coordinate).</param>
        /// <param name="qy">Output point (y coordinate).</param>
        /// <param name="qw">Output point (w coordinate).</param>
        public static void ProjectHomPointHomMat3d(
          HTuple homMat3D,
          HTuple px,
          HTuple py,
          HTuple pz,
          HTuple pw,
          out HTuple qx,
          out HTuple qy,
          out HTuple qw)
        {
            IntPtr proc = HalconAPI.PreCall(1930);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.Store(proc, 3, pz);
            HalconAPI.Store(proc, 4, pw);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(pz);
            HalconAPI.UnpinTuple(pw);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out qx);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out qy);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out qw);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Project a 3D point using a 3x4 projection matrix.</summary>
        /// <param name="homMat3D">3x4 projection matrix.</param>
        /// <param name="px">Input point (x coordinate).</param>
        /// <param name="py">Input point (y coordinate).</param>
        /// <param name="pz">Input point (z coordinate).</param>
        /// <param name="qx">Output point (x coordinate).</param>
        /// <param name="qy">Output point (y coordinate).</param>
        public static void ProjectPointHomMat3d(
          HTuple homMat3D,
          HTuple px,
          HTuple py,
          HTuple pz,
          out HTuple qx,
          out HTuple qy)
        {
            IntPtr proc = HalconAPI.PreCall(1931);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.Store(proc, 1, px);
            HalconAPI.Store(proc, 2, py);
            HalconAPI.Store(proc, 3, pz);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            HalconAPI.UnpinTuple(px);
            HalconAPI.UnpinTuple(py);
            HalconAPI.UnpinTuple(pz);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out qx);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out qy);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Project 3D points into (sub-)pixel image coordinates.</summary>
        /// <param name="x">X coordinates of the 3D points to be projected in the camera coordinate system.</param>
        /// <param name="y">Y coordinates of the 3D points to be projected in the camera coordinate system.</param>
        /// <param name="z">Z coordinates of the 3D points to be projected in the camera coordinate system.</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="row">Row coordinates of the projected points (in pixels).</param>
        /// <param name="column">Column coordinates of the projected points (in pixels).</param>
        public static void Project3dPoint(
          HTuple x,
          HTuple y,
          HTuple z,
          HTuple cameraParam,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1932);
            HalconAPI.Store(proc, 0, x);
            HalconAPI.Store(proc, 1, y);
            HalconAPI.Store(proc, 2, z);
            HalconAPI.Store(proc, 3, cameraParam);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(x);
            HalconAPI.UnpinTuple(y);
            HalconAPI.UnpinTuple(z);
            HalconAPI.UnpinTuple(cameraParam);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert internal camera parameters and a 3D pose into a 3x4 projection matrix.</summary>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="pose">3D pose.</param>
        /// <param name="homMat3D">3x4 projection matrix.</param>
        public static void CamParPoseToHomMat3d(HTuple cameraParam, HTuple pose, out HTuple homMat3D)
        {
            IntPtr proc = HalconAPI.PreCall(1933);
            HalconAPI.Store(proc, 0, cameraParam);
            HalconAPI.Store(proc, 1, pose);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(pose);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a homogeneous transformation matrix into a 3D pose.</summary>
        /// <param name="homMat3D">Homogeneous transformation matrix.</param>
        /// <param name="pose">Equivalent 3D pose.</param>
        public static void HomMat3dToPose(HTuple homMat3D, out HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(1934);
            HalconAPI.Store(proc, 0, homMat3D);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(homMat3D);
            int procResult = HTuple.LoadNew(proc, 0, err, out pose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a 3D pose into a homogeneous transformation matrix.</summary>
        /// <param name="pose">3D pose.</param>
        /// <param name="homMat3D">Equivalent homogeneous transformation matrix.</param>
        public static void PoseToHomMat3d(HTuple pose, out HTuple homMat3D)
        {
            IntPtr proc = HalconAPI.PreCall(1935);
            HalconAPI.Store(proc, 0, pose);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pose);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize the serialized internal camera parameters.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        public static void DeserializeCamPar(HTuple serializedItemHandle, out HTuple cameraParam)
        {
            IntPtr proc = HalconAPI.PreCall(1936);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out cameraParam);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize the internal camera parameters.</summary>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeCamPar(HTuple cameraParam, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1937);
            HalconAPI.Store(proc, 0, cameraParam);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraParam);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized pose.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="pose">3D pose.</param>
        public static void DeserializePose(HTuple serializedItemHandle, out HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(1938);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out pose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a pose.</summary>
        /// <param name="pose">3D pose.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializePose(HTuple pose, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1939);
            HalconAPI.Store(proc, 0, pose);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pose);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a 3D pose from a text file.</summary>
        /// <param name="poseFile">File name of the external camera parameters. Default: "campose.dat"</param>
        /// <param name="pose">3D pose.</param>
        public static void ReadPose(HTuple poseFile, out HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(1940);
            HalconAPI.Store(proc, 0, poseFile);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(poseFile);
            int procResult = HTuple.LoadNew(proc, 0, err, out pose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a 3D pose to a text file.</summary>
        /// <param name="pose">3D pose.</param>
        /// <param name="poseFile">File name of the external camera parameters. Default: "campose.dat"</param>
        public static void WritePose(HTuple pose, HTuple poseFile)
        {
            IntPtr proc = HalconAPI.PreCall(1941);
            HalconAPI.Store(proc, 0, pose);
            HalconAPI.Store(proc, 1, poseFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.UnpinTuple(poseFile);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read internal camera parameters from a file.</summary>
        /// <param name="camParFile">File name of internal camera parameters. Default: "campar.dat"</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        public static void ReadCamPar(HTuple camParFile, out HTuple cameraParam)
        {
            IntPtr proc = HalconAPI.PreCall(1942);
            HalconAPI.Store(proc, 0, camParFile);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(camParFile);
            int procResult = HTuple.LoadNew(proc, 0, err, out cameraParam);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write internal camera parameters into a file.</summary>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="camParFile">File name of internal camera parameters. Default: "campar.dat"</param>
        public static void WriteCamPar(HTuple cameraParam, HTuple camParFile)
        {
            IntPtr proc = HalconAPI.PreCall(1943);
            HalconAPI.Store(proc, 0, cameraParam);
            HalconAPI.Store(proc, 1, camParFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(camParFile);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Simulate an image with calibration plate.</summary>
        /// <param name="simImage">Simulated calibration image.</param>
        /// <param name="calPlateDescr">File name of the calibration plate description. Default: "calplate.cpd"</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="calPlatePose">External camera parameters (3D pose of the calibration plate in camera coordinates).</param>
        /// <param name="grayBackground">Gray value of image background. Default: 128</param>
        /// <param name="grayPlate">Gray value of calibration plate. Default: 80</param>
        /// <param name="grayMarks">Gray value of calibration marks. Default: 224</param>
        /// <param name="scaleFac">Scaling factor to reduce oversampling. Default: 1.0</param>
        public static void SimCaltab(
          out HObject simImage,
          HTuple calPlateDescr,
          HTuple cameraParam,
          HTuple calPlatePose,
          HTuple grayBackground,
          HTuple grayPlate,
          HTuple grayMarks,
          HTuple scaleFac)
        {
            IntPtr proc = HalconAPI.PreCall(1944);
            HalconAPI.Store(proc, 0, calPlateDescr);
            HalconAPI.Store(proc, 1, cameraParam);
            HalconAPI.Store(proc, 2, calPlatePose);
            HalconAPI.Store(proc, 3, grayBackground);
            HalconAPI.Store(proc, 4, grayPlate);
            HalconAPI.Store(proc, 5, grayMarks);
            HalconAPI.Store(proc, 6, scaleFac);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calPlateDescr);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(calPlatePose);
            HalconAPI.UnpinTuple(grayBackground);
            HalconAPI.UnpinTuple(grayPlate);
            HalconAPI.UnpinTuple(grayMarks);
            HalconAPI.UnpinTuple(scaleFac);
            int procResult = HObject.LoadNew(proc, 1, err, out simImage);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Project and visualize the 3D model of the calibration plate in the image.</summary>
        /// <param name="windowHandle">Window in which the calibration plate should be visualized.</param>
        /// <param name="calPlateDescr">File name of the calibration plate description. Default: "calplate.cpd"</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="calPlatePose">External camera parameters (3D pose of the calibration plate in camera coordinates).</param>
        /// <param name="scaleFac">Scaling factor for the visualization. Default: 1.0</param>
        public static void DispCaltab(
          HTuple windowHandle,
          HTuple calPlateDescr,
          HTuple cameraParam,
          HTuple calPlatePose,
          HTuple scaleFac)
        {
            IntPtr proc = HalconAPI.PreCall(1945);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, calPlateDescr);
            HalconAPI.Store(proc, 2, cameraParam);
            HalconAPI.Store(proc, 3, calPlatePose);
            HalconAPI.Store(proc, 4, scaleFac);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(calPlateDescr);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(calPlatePose);
            HalconAPI.UnpinTuple(scaleFac);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Determine all camera parameters by a simultaneous minimization process.</summary>
        /// <param name="NX">Ordered tuple with all x coordinates of the calibration marks (in meters).</param>
        /// <param name="NY">Ordered tuple with all y coordinates of the calibration marks (in meters).</param>
        /// <param name="NZ">Ordered tuple with all z coordinates of the calibration marks (in meters).</param>
        /// <param name="NRow">Ordered tuple with all row coordinates of the extracted calibration marks (in pixels).</param>
        /// <param name="NCol">Ordered tuple with all column coordinates of the extracted calibration marks (in pixels).</param>
        /// <param name="startCamParam">Initial values for the internal camera parameters.</param>
        /// <param name="NStartPose">Ordered tuple with all initial values for the external camera parameters.</param>
        /// <param name="estimateParams">Camera parameters to be estimated. Default: "all"</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="NFinalPose">Ordered tuple with all external camera parameters.</param>
        /// <param name="errors">Average error distance in pixels.</param>
        public static void CameraCalibration(
          HTuple NX,
          HTuple NY,
          HTuple NZ,
          HTuple NRow,
          HTuple NCol,
          HTuple startCamParam,
          HTuple NStartPose,
          HTuple estimateParams,
          out HTuple cameraParam,
          out HTuple NFinalPose,
          out HTuple errors)
        {
            IntPtr proc = HalconAPI.PreCall(1946);
            HalconAPI.Store(proc, 0, NX);
            HalconAPI.Store(proc, 1, NY);
            HalconAPI.Store(proc, 2, NZ);
            HalconAPI.Store(proc, 3, NRow);
            HalconAPI.Store(proc, 4, NCol);
            HalconAPI.Store(proc, 5, startCamParam);
            HalconAPI.Store(proc, 6, NStartPose);
            HalconAPI.Store(proc, 7, estimateParams);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(NX);
            HalconAPI.UnpinTuple(NY);
            HalconAPI.UnpinTuple(NZ);
            HalconAPI.UnpinTuple(NRow);
            HalconAPI.UnpinTuple(NCol);
            HalconAPI.UnpinTuple(startCamParam);
            HalconAPI.UnpinTuple(NStartPose);
            HalconAPI.UnpinTuple(estimateParams);
            int err2 = HTuple.LoadNew(proc, 0, err1, out cameraParam);
            int err3 = HTuple.LoadNew(proc, 1, err2, out NFinalPose);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out errors);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Extract rectangularly arranged 2D calibration marks from the image and calculate initial values for the external camera parameters.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="calPlateRegion">Region of the calibration plate.</param>
        /// <param name="calPlateDescr">File name of the calibration plate description. Default: "caltab.descr"</param>
        /// <param name="startCamParam">Initial values for the internal camera parameters.</param>
        /// <param name="startThresh">Initial threshold value for contour detection. Default: 128</param>
        /// <param name="deltaThresh">Loop value for successive reduction of StartThresh. Default: 10</param>
        /// <param name="minThresh">Minimum threshold for contour detection. Default: 18</param>
        /// <param name="alpha">Filter parameter for contour detection, see edges_image. Default: 0.9</param>
        /// <param name="minContLength">Minimum length of the contours of the marks. Default: 15.0</param>
        /// <param name="maxDiamMarks">Maximum expected diameter of the marks. Default: 100.0</param>
        /// <param name="RCoord">Tuple with row coordinates of the detected marks.</param>
        /// <param name="CCoord">Tuple with column coordinates of the detected marks.</param>
        /// <param name="startPose">Estimation for the external camera parameters.</param>
        public static void FindMarksAndPose(
          HObject image,
          HObject calPlateRegion,
          HTuple calPlateDescr,
          HTuple startCamParam,
          HTuple startThresh,
          HTuple deltaThresh,
          HTuple minThresh,
          HTuple alpha,
          HTuple minContLength,
          HTuple maxDiamMarks,
          out HTuple RCoord,
          out HTuple CCoord,
          out HTuple startPose)
        {
            IntPtr proc = HalconAPI.PreCall(1947);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)calPlateRegion);
            HalconAPI.Store(proc, 0, calPlateDescr);
            HalconAPI.Store(proc, 1, startCamParam);
            HalconAPI.Store(proc, 2, startThresh);
            HalconAPI.Store(proc, 3, deltaThresh);
            HalconAPI.Store(proc, 4, minThresh);
            HalconAPI.Store(proc, 5, alpha);
            HalconAPI.Store(proc, 6, minContLength);
            HalconAPI.Store(proc, 7, maxDiamMarks);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calPlateDescr);
            HalconAPI.UnpinTuple(startCamParam);
            HalconAPI.UnpinTuple(startThresh);
            HalconAPI.UnpinTuple(deltaThresh);
            HalconAPI.UnpinTuple(minThresh);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.UnpinTuple(minContLength);
            HalconAPI.UnpinTuple(maxDiamMarks);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out RCoord);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out CCoord);
            int procResult = HTuple.LoadNew(proc, 2, err3, out startPose);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)calPlateRegion);
        }

        /// <summary>Segment the region of a standard calibration plate with rectangularly arranged marks in the image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="calPlate">Output region.</param>
        /// <param name="calPlateDescr">File name of the calibration plate description. Default: "caltab.descr"</param>
        /// <param name="sizeGauss">Filter size of the Gaussian. Default: 3</param>
        /// <param name="markThresh">Threshold value for mark extraction. Default: 112</param>
        /// <param name="minDiamMarks">Expected minimal diameter of the marks on the calibration plate. Default: 5</param>
        public static void FindCaltab(
          HObject image,
          out HObject calPlate,
          HTuple calPlateDescr,
          HTuple sizeGauss,
          HTuple markThresh,
          HTuple minDiamMarks)
        {
            IntPtr proc = HalconAPI.PreCall(1948);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, calPlateDescr);
            HalconAPI.Store(proc, 1, sizeGauss);
            HalconAPI.Store(proc, 2, markThresh);
            HalconAPI.Store(proc, 3, minDiamMarks);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calPlateDescr);
            HalconAPI.UnpinTuple(sizeGauss);
            HalconAPI.UnpinTuple(markThresh);
            HalconAPI.UnpinTuple(minDiamMarks);
            int procResult = HObject.LoadNew(proc, 1, err, out calPlate);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Free the memory of all camera setup models.</summary>
        public static void ClearAllCameraSetupModels()
        {
            IntPtr proc = HalconAPI.PreCall(1949);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a calibration setup model.</summary>
        /// <param name="cameraSetupModelID">Handle of the camera setup model.</param>
        public static void ClearCameraSetupModel(HTuple cameraSetupModelID)
        {
            IntPtr proc = HalconAPI.PreCall(1950);
            HalconAPI.Store(proc, 0, cameraSetupModelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraSetupModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a camera setup model.</summary>
        /// <param name="cameraSetupModelID">Handle to the camera setup model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeCameraSetupModel(
          HTuple cameraSetupModelID,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1951);
            HalconAPI.Store(proc, 0, cameraSetupModelID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraSetupModelID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized camera setup model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="cameraSetupModelID">Handle to the camera setup model.</param>
        public static void DeserializeCameraSetupModel(
          HTuple serializedItemHandle,
          out HTuple cameraSetupModelID)
        {
            IntPtr proc = HalconAPI.PreCall(1952);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out cameraSetupModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Store a camera setup model into a file.</summary>
        /// <param name="cameraSetupModelID">Handle to the camera setup model.</param>
        /// <param name="fileName">The file name of the model to be saved.</param>
        public static void WriteCameraSetupModel(HTuple cameraSetupModelID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1953);
            HalconAPI.Store(proc, 0, cameraSetupModelID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraSetupModelID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Restore a camera setup model from a file.</summary>
        /// <param name="fileName">The path and file name of the model file.</param>
        /// <param name="cameraSetupModelID">Handle to the camera setup model.</param>
        public static void ReadCameraSetupModel(HTuple fileName, out HTuple cameraSetupModelID)
        {
            IntPtr proc = HalconAPI.PreCall(1954);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out cameraSetupModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get generic camera setup model parameters.</summary>
        /// <param name="cameraSetupModelID">Handle to the camera setup model.</param>
        /// <param name="cameraIdx">Index of the camera in the setup. Default: 0</param>
        /// <param name="genParamName">Names of the generic parameters to be queried.</param>
        /// <param name="genParamValue">Values of the generic parameters to be queried.</param>
        public static void GetCameraSetupParam(
          HTuple cameraSetupModelID,
          HTuple cameraIdx,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1955);
            HalconAPI.Store(proc, 0, cameraSetupModelID);
            HalconAPI.Store(proc, 1, cameraIdx);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraSetupModelID);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set generic camera setup model parameters.</summary>
        /// <param name="cameraSetupModelID">Handle to the camera setup model.</param>
        /// <param name="cameraIdx">Unique index of the camera in the setup. Default: 0</param>
        /// <param name="genParamName">Names of the generic parameters to be set.</param>
        /// <param name="genParamValue">Values of the generic parameters to be set.</param>
        public static void SetCameraSetupParam(
          HTuple cameraSetupModelID,
          HTuple cameraIdx,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1956);
            HalconAPI.Store(proc, 0, cameraSetupModelID);
            HalconAPI.Store(proc, 1, cameraIdx);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraSetupModelID);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define type, parameters, and relative pose of a camera in a camera setup model.</summary>
        /// <param name="cameraSetupModelID">Handle to the camera setup model.</param>
        /// <param name="cameraIdx">Index of the camera in the setup.</param>
        /// <param name="cameraType">Type of the camera. Default: []</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="cameraPose">Pose of the camera relative to the setup's coordinate system.</param>
        public static void SetCameraSetupCamParam(
          HTuple cameraSetupModelID,
          HTuple cameraIdx,
          HTuple cameraType,
          HTuple cameraParam,
          HTuple cameraPose)
        {
            IntPtr proc = HalconAPI.PreCall(1957);
            HalconAPI.Store(proc, 0, cameraSetupModelID);
            HalconAPI.Store(proc, 1, cameraIdx);
            HalconAPI.Store(proc, 2, cameraType);
            HalconAPI.Store(proc, 3, cameraParam);
            HalconAPI.Store(proc, 4, cameraPose);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(cameraSetupModelID);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(cameraType);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.UnpinTuple(cameraPose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a model for a setup of calibrated cameras.</summary>
        /// <param name="numCameras">Number of cameras in the setup. Default: 2</param>
        /// <param name="cameraSetupModelID">Handle to the camera setup model.</param>
        public static void CreateCameraSetupModel(HTuple numCameras, out HTuple cameraSetupModelID)
        {
            IntPtr proc = HalconAPI.PreCall(1958);
            HalconAPI.Store(proc, 0, numCameras);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numCameras);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out cameraSetupModelID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of all calibration data models.</summary>
        public static void ClearAllCalibData()
        {
            IntPtr proc = HalconAPI.PreCall(1959);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Free the memory of a calibration data model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        public static void ClearCalibData(HTuple calibDataID)
        {
            IntPtr proc = HalconAPI.PreCall(1960);
            HalconAPI.Store(proc, 0, calibDataID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized calibration data model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        public static void DeserializeCalibData(HTuple serializedItemHandle, out HTuple calibDataID)
        {
            IntPtr proc = HalconAPI.PreCall(1961);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out calibDataID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a calibration data model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeCalibData(HTuple calibDataID, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1962);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Restore a calibration data model from a file.</summary>
        /// <param name="fileName">The path and file name of the model file.</param>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        public static void ReadCalibData(HTuple fileName, out HTuple calibDataID)
        {
            IntPtr proc = HalconAPI.PreCall(1963);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out calibDataID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Store a calibration data model into a file.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="fileName">The file name of the model to be saved.</param>
        public static void WriteCalibData(HTuple calibDataID, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1964);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Perform a hand-eye calibration.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="errors">Average residual error of the optimization.</param>
        public static void CalibrateHandEye(HTuple calibDataID, out HTuple errors)
        {
            IntPtr proc = HalconAPI.PreCall(1965);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out errors);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Determine all camera parameters by a simultaneous minimization process.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="error">Back projection root mean square error (RMSE) of the optimization.</param>
        public static void CalibrateCameras(HTuple calibDataID, out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1966);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out error);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Remove a data set from a calibration data model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="itemType">Type of the calibration data item. Default: "tool"</param>
        /// <param name="itemIdx">Index of the affected item. Default: 0</param>
        public static void RemoveCalibData(HTuple calibDataID, HTuple itemType, HTuple itemIdx)
        {
            IntPtr proc = HalconAPI.PreCall(1967);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, itemType);
            HalconAPI.Store(proc, 2, itemIdx);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(itemType);
            HalconAPI.UnpinTuple(itemIdx);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set data in a calibration data model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="itemType">Type of calibration data item. Default: "model"</param>
        /// <param name="itemIdx">Index of the affected item (depending on the selected ItemType). Default: "general"</param>
        /// <param name="dataName">Parameter(s) to set. Default: "reference_camera"</param>
        /// <param name="dataValue">New value(s). Default: 0</param>
        public static void SetCalibData(
          HTuple calibDataID,
          HTuple itemType,
          HTuple itemIdx,
          HTuple dataName,
          HTuple dataValue)
        {
            IntPtr proc = HalconAPI.PreCall(1968);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, itemType);
            HalconAPI.Store(proc, 2, itemIdx);
            HalconAPI.Store(proc, 3, dataName);
            HalconAPI.Store(proc, 4, dataValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(itemType);
            HalconAPI.UnpinTuple(itemIdx);
            HalconAPI.UnpinTuple(dataName);
            HalconAPI.UnpinTuple(dataValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find the HALCON calibration plate and set the extracted points and contours in a calibration data model.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="cameraIdx">Index of the observing camera. Default: 0</param>
        /// <param name="calibObjIdx">Index of the calibration object. Default: 0</param>
        /// <param name="calibObjPoseIdx">Index of the observed calibration object. Default: 0</param>
        /// <param name="genParamName">Names of the generic parameters to be set. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters to be set. Default: []</param>
        public static void FindCalibObject(
          HObject image,
          HTuple calibDataID,
          HTuple cameraIdx,
          HTuple calibObjIdx,
          HTuple calibObjPoseIdx,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1969);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, cameraIdx);
            HalconAPI.Store(proc, 2, calibObjIdx);
            HalconAPI.Store(proc, 3, calibObjPoseIdx);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(calibObjIdx);
            HalconAPI.UnpinTuple(calibObjPoseIdx);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Remove observation data from a calibration data model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="cameraIdx">Index of the observing camera. Default: 0</param>
        /// <param name="calibObjIdx">Index of the observed calibration object. Default: 0</param>
        /// <param name="calibObjPoseIdx">Index of the observed calibration object pose. Default: 0</param>
        public static void RemoveCalibDataObserv(
          HTuple calibDataID,
          HTuple cameraIdx,
          HTuple calibObjIdx,
          HTuple calibObjPoseIdx)
        {
            IntPtr proc = HalconAPI.PreCall(1970);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, cameraIdx);
            HalconAPI.Store(proc, 2, calibObjIdx);
            HalconAPI.Store(proc, 3, calibObjPoseIdx);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(calibObjIdx);
            HalconAPI.UnpinTuple(calibObjPoseIdx);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get contour-based observation data from a calibration data model.</summary>
        /// <param name="contours">Contour-based result(s).</param>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="contourName">Name of contour objects to be returned. Default: "marks"</param>
        /// <param name="cameraIdx">Index of the observing camera. Default: 0</param>
        /// <param name="calibObjIdx">Index of the observed calibration object. Default: 0</param>
        /// <param name="calibObjPoseIdx">Index of the observed calibration object pose. Default: 0</param>
        public static void GetCalibDataObservContours(
          out HObject contours,
          HTuple calibDataID,
          HTuple contourName,
          HTuple cameraIdx,
          HTuple calibObjIdx,
          HTuple calibObjPoseIdx)
        {
            IntPtr proc = HalconAPI.PreCall(1971);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, contourName);
            HalconAPI.Store(proc, 2, cameraIdx);
            HalconAPI.Store(proc, 3, calibObjIdx);
            HalconAPI.Store(proc, 4, calibObjPoseIdx);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(contourName);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(calibObjIdx);
            HalconAPI.UnpinTuple(calibObjPoseIdx);
            int procResult = HObject.LoadNew(proc, 1, err, out contours);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get observed calibration object poses from a calibration data model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="cameraIdx">Index of the observing camera. Default: 0</param>
        /// <param name="calibObjIdx">Index of the observed calibration object. Default: 0</param>
        /// <param name="calibObjPoseIdx">Index of the observed calibration object pose. Default: 0</param>
        /// <param name="objInCameraPose">Stored observed calibration object pose relative to the observing camera.</param>
        public static void GetCalibDataObservPose(
          HTuple calibDataID,
          HTuple cameraIdx,
          HTuple calibObjIdx,
          HTuple calibObjPoseIdx,
          out HTuple objInCameraPose)
        {
            IntPtr proc = HalconAPI.PreCall(1972);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, cameraIdx);
            HalconAPI.Store(proc, 2, calibObjIdx);
            HalconAPI.Store(proc, 3, calibObjPoseIdx);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(calibObjIdx);
            HalconAPI.UnpinTuple(calibObjPoseIdx);
            int procResult = HTuple.LoadNew(proc, 0, err, out objInCameraPose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set observed calibration object poses in a calibration data model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="cameraIdx">Index of the observing camera. Default: 0</param>
        /// <param name="calibObjIdx">Index of the calibration object. Default: 0</param>
        /// <param name="calibObjPoseIdx">Index of the observed calibration object. Default: 0</param>
        /// <param name="objInCameraPose">Pose of the observed calibration object relative to the observing camera.</param>
        public static void SetCalibDataObservPose(
          HTuple calibDataID,
          HTuple cameraIdx,
          HTuple calibObjIdx,
          HTuple calibObjPoseIdx,
          HTuple objInCameraPose)
        {
            IntPtr proc = HalconAPI.PreCall(1973);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, cameraIdx);
            HalconAPI.Store(proc, 2, calibObjIdx);
            HalconAPI.Store(proc, 3, calibObjPoseIdx);
            HalconAPI.Store(proc, 4, objInCameraPose);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(calibObjIdx);
            HalconAPI.UnpinTuple(calibObjPoseIdx);
            HalconAPI.UnpinTuple(objInCameraPose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get point-based observation data from a calibration data model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="cameraIdx">Index of the observing camera. Default: 0</param>
        /// <param name="calibObjIdx">Index of the observed calibration object. Default: 0</param>
        /// <param name="calibObjPoseIdx">Index of the observed calibration object pose. Default: 0</param>
        /// <param name="row">Row coordinates of the detected points.</param>
        /// <param name="column">Column coordinates of the detected points.</param>
        /// <param name="index">Correspondence of the detected points to the points of the observed calibration object.</param>
        /// <param name="pose">Roughly estimated pose of the observed calibration object relative to the observing camera.</param>
        public static void GetCalibDataObservPoints(
          HTuple calibDataID,
          HTuple cameraIdx,
          HTuple calibObjIdx,
          HTuple calibObjPoseIdx,
          out HTuple row,
          out HTuple column,
          out HTuple index,
          out HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(1974);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, cameraIdx);
            HalconAPI.Store(proc, 2, calibObjIdx);
            HalconAPI.Store(proc, 3, calibObjPoseIdx);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(calibObjIdx);
            HalconAPI.UnpinTuple(calibObjPoseIdx);
            int err2 = HTuple.LoadNew(proc, 0, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, err3, out index);
            int procResult = HTuple.LoadNew(proc, 3, err4, out pose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set point-based observation data in a calibration data model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="cameraIdx">Index of the observing camera. Default: 0</param>
        /// <param name="calibObjIdx">Index of the calibration object. Default: 0</param>
        /// <param name="calibObjPoseIdx">Index of the observed calibration object. Default: 0</param>
        /// <param name="row">Row coordinates of the extracted points.</param>
        /// <param name="column">Column coordinates of the extracted points.</param>
        /// <param name="index">Correspondence of the extracted points to the calibration marks of the observed calibration object. Default: "all"</param>
        /// <param name="pose">Roughly estimated pose of the observed calibration object relative to the observing camera.</param>
        public static void SetCalibDataObservPoints(
          HTuple calibDataID,
          HTuple cameraIdx,
          HTuple calibObjIdx,
          HTuple calibObjPoseIdx,
          HTuple row,
          HTuple column,
          HTuple index,
          HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(1975);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, cameraIdx);
            HalconAPI.Store(proc, 2, calibObjIdx);
            HalconAPI.Store(proc, 3, calibObjPoseIdx);
            HalconAPI.Store(proc, 4, row);
            HalconAPI.Store(proc, 5, column);
            HalconAPI.Store(proc, 6, index);
            HalconAPI.Store(proc, 7, pose);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(calibObjIdx);
            HalconAPI.UnpinTuple(calibObjPoseIdx);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(pose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query information about the relations between cameras, calibration objects, and calibration object poses.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="itemType">Kind of referred object. Default: "camera"</param>
        /// <param name="itemIdx">Camera index or calibration object index (depending on the selected ItemType). Default: 0</param>
        /// <param name="index1">List of calibration object indices or list of camera indices (depending on ItemType).</param>
        /// <param name="index2">Calibration object numbers.</param>
        public static void QueryCalibDataObservIndices(
          HTuple calibDataID,
          HTuple itemType,
          HTuple itemIdx,
          out HTuple index1,
          out HTuple index2)
        {
            IntPtr proc = HalconAPI.PreCall(1976);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, itemType);
            HalconAPI.Store(proc, 2, itemIdx);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(itemType);
            HalconAPI.UnpinTuple(itemIdx);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out index1);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out index2);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query data stored or computed in a calibration data model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="itemType">Type of calibration data item. Default: "camera"</param>
        /// <param name="itemIdx">Index of the affected item (depending on the selected ItemType). Default: 0</param>
        /// <param name="dataName">The name of the inspected data. Default: "params"</param>
        /// <param name="dataValue">Requested data.</param>
        public static void GetCalibData(
          HTuple calibDataID,
          HTuple itemType,
          HTuple itemIdx,
          HTuple dataName,
          out HTuple dataValue)
        {
            IntPtr proc = HalconAPI.PreCall(1977);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, itemType);
            HalconAPI.Store(proc, 2, itemIdx);
            HalconAPI.Store(proc, 3, dataName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(itemType);
            HalconAPI.UnpinTuple(itemIdx);
            HalconAPI.UnpinTuple(dataName);
            int procResult = HTuple.LoadNew(proc, 0, err, out dataValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Define a calibration object in a calibration model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="calibObjIdx">Calibration object index. Default: 0</param>
        /// <param name="calibObjDescr">3D point coordinates or a description file name.</param>
        public static void SetCalibDataCalibObject(
          HTuple calibDataID,
          HTuple calibObjIdx,
          HTuple calibObjDescr)
        {
            IntPtr proc = HalconAPI.PreCall(1978);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, calibObjIdx);
            HalconAPI.Store(proc, 2, calibObjDescr);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(calibObjIdx);
            HalconAPI.UnpinTuple(calibObjDescr);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set type and initial parameters of a camera in a calibration data model.</summary>
        /// <param name="calibDataID">Handle of a calibration data model.</param>
        /// <param name="cameraIdx">Camera index. Default: 0</param>
        /// <param name="cameraType">Type of the camera. Default: []</param>
        /// <param name="cameraParam">Initial camera internal parameters.</param>
        public static void SetCalibDataCamParam(
          HTuple calibDataID,
          HTuple cameraIdx,
          HTuple cameraType,
          HTuple cameraParam)
        {
            IntPtr proc = HalconAPI.PreCall(1979);
            HalconAPI.Store(proc, 0, calibDataID);
            HalconAPI.Store(proc, 1, cameraIdx);
            HalconAPI.Store(proc, 2, cameraType);
            HalconAPI.Store(proc, 3, cameraParam);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibDataID);
            HalconAPI.UnpinTuple(cameraIdx);
            HalconAPI.UnpinTuple(cameraType);
            HalconAPI.UnpinTuple(cameraParam);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a HALCON calibration data model.</summary>
        /// <param name="calibSetup">Type of the calibration setup. Default: "calibration_object"</param>
        /// <param name="numCameras">Number of cameras in the calibration setup. Default: 1</param>
        /// <param name="numCalibObjects">Number of calibration objects. Default: 1</param>
        /// <param name="calibDataID">Handle of the created calibration data model.</param>
        public static void CreateCalibData(
          HTuple calibSetup,
          HTuple numCameras,
          HTuple numCalibObjects,
          out HTuple calibDataID)
        {
            IntPtr proc = HalconAPI.PreCall(1980);
            HalconAPI.Store(proc, 0, calibSetup);
            HalconAPI.Store(proc, 1, numCameras);
            HalconAPI.Store(proc, 2, numCalibObjects);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(calibSetup);
            HalconAPI.UnpinTuple(numCameras);
            HalconAPI.UnpinTuple(numCalibObjects);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out calibDataID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the value of a parameter in a specific bead inspection model.</summary>
        /// <param name="beadInspectionModel">Handle of the bead inspection model.</param>
        /// <param name="genParamName">Name of the model parameter that is queried. Default: "target_thickness"</param>
        /// <param name="genParamValue">Value of the queried model parameter.</param>
        public static void GetBeadInspectionParam(
          HTuple beadInspectionModel,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1981);
            HalconAPI.Store(proc, 0, beadInspectionModel);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(beadInspectionModel);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters of the bead inspection model.</summary>
        /// <param name="beadInspectionModel">Handle of the bead inspection model.</param>
        /// <param name="genParamName">Name of the model parameter that shall be adjusted for the specified bead inspection model. Default: "target_thickness"</param>
        /// <param name="genParamValue">Value of the model parameter that shall be adjusted for the specified bead inspection model. Default: 40</param>
        public static void SetBeadInspectionParam(
          HTuple beadInspectionModel,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1982);
            HalconAPI.Store(proc, 0, beadInspectionModel);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(beadInspectionModel);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Inspect beads in an image, as defined by the bead inspection model.</summary>
        /// <param name="image">Image to apply bead inspection on.</param>
        /// <param name="leftContour">The detected left contour of the beads.</param>
        /// <param name="rightContour">The detected right contour of the beads.</param>
        /// <param name="errorSegment">Detected error segments</param>
        /// <param name="beadInspectionModel">Handle of the bead inspection model to be used.</param>
        /// <param name="errorType">Types of detected errors.</param>
        public static void ApplyBeadInspectionModel(
          HObject image,
          out HObject leftContour,
          out HObject rightContour,
          out HObject errorSegment,
          HTuple beadInspectionModel,
          out HTuple errorType)
        {
            IntPtr proc = HalconAPI.PreCall(1983);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, beadInspectionModel);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(beadInspectionModel);
            int err2 = HObject.LoadNew(proc, 1, err1, out leftContour);
            int err3 = HObject.LoadNew(proc, 2, err2, out rightContour);
            int err4 = HObject.LoadNew(proc, 3, err3, out errorSegment);
            int procResult = HTuple.LoadNew(proc, 0, err4, out errorType);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Delete the bead inspection model and free the allocated memory.</summary>
        /// <param name="beadInspectionModel">Handle of the bead inspection model.</param>
        public static void ClearBeadInspectionModel(HTuple beadInspectionModel)
        {
            IntPtr proc = HalconAPI.PreCall(1984);
            HalconAPI.Store(proc, 0, beadInspectionModel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(beadInspectionModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a model to inspect beads or adhesive in images.</summary>
        /// <param name="beadContour">XLD contour specifying the expected bead's shape and  position.</param>
        /// <param name="targetThickness">Optimal bead thickness. Default: 50</param>
        /// <param name="thicknessTolerance">Tolerance of bead's thickness with respect to  TargetThickness. Default: 15</param>
        /// <param name="positionTolerance">Tolerance of the bead's center position. Default: 15</param>
        /// <param name="polarity">The bead's polarity. Default: "light"</param>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the bead inspection model. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the bead inspection model. Default: []</param>
        /// <param name="beadInspectionModel">Handle for using and accessing the bead inspection  model.</param>
        public static void CreateBeadInspectionModel(
          HObject beadContour,
          HTuple targetThickness,
          HTuple thicknessTolerance,
          HTuple positionTolerance,
          HTuple polarity,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple beadInspectionModel)
        {
            IntPtr proc = HalconAPI.PreCall(1985);
            HalconAPI.Store(proc, 1, (HObjectBase)beadContour);
            HalconAPI.Store(proc, 0, targetThickness);
            HalconAPI.Store(proc, 1, thicknessTolerance);
            HalconAPI.Store(proc, 2, positionTolerance);
            HalconAPI.Store(proc, 3, polarity);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(targetThickness);
            HalconAPI.UnpinTuple(thicknessTolerance);
            HalconAPI.UnpinTuple(positionTolerance);
            HalconAPI.UnpinTuple(polarity);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out beadInspectionModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)beadContour);
        }

        /// <summary>Deserialize a bar code model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        public static void DeserializeBarCodeModel(
          HTuple serializedItemHandle,
          out HTuple barCodeHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1986);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out barCodeHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a bar code model.</summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeBarCodeModel(HTuple barCodeHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1987);
            HalconAPI.Store(proc, 0, barCodeHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a bar code model from a file and create a new model.</summary>
        /// <param name="fileName">Name of the bar code model file. Default: "bar_code_model.bcm"</param>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        public static void ReadBarCodeModel(HTuple fileName, out HTuple barCodeHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1988);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out barCodeHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a bar code model to a file.</summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="fileName">Name of the bar code model file. Default: "bar_code_model.bcm"</param>
        public static void WriteBarCodeModel(HTuple barCodeHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1989);
            HalconAPI.Store(proc, 0, barCodeHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Access iconic objects that were created during the search or decoding of bar code symbols.</summary>
        /// <param name="barCodeObjects">Objects that are created as intermediate results during the detection or evaluation of bar codes.</param>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="candidateHandle">Indicating the bar code results respectively candidates for which the data is required. Default: "all"</param>
        /// <param name="objectName">Name of the iconic object to return. Default: "candidate_regions"</param>
        public static void GetBarCodeObject(
          out HObject barCodeObjects,
          HTuple barCodeHandle,
          HTuple candidateHandle,
          HTuple objectName)
        {
            IntPtr proc = HalconAPI.PreCall(1990);
            HalconAPI.Store(proc, 0, barCodeHandle);
            HalconAPI.Store(proc, 1, candidateHandle);
            HalconAPI.Store(proc, 2, objectName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            HalconAPI.UnpinTuple(candidateHandle);
            HalconAPI.UnpinTuple(objectName);
            int procResult = HObject.LoadNew(proc, 1, err, out barCodeObjects);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the alphanumerical results that were accumulated during the decoding of bar code symbols.</summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="candidateHandle">Indicating the bar code results respectively candidates for which the data is required. Default: "all"</param>
        /// <param name="resultName">Names of the resulting data to return. Default: "decoded_types"</param>
        /// <param name="barCodeResults">List with the results.</param>
        public static void GetBarCodeResult(
          HTuple barCodeHandle,
          HTuple candidateHandle,
          HTuple resultName,
          out HTuple barCodeResults)
        {
            IntPtr proc = HalconAPI.PreCall(1991);
            HalconAPI.Store(proc, 0, barCodeHandle);
            HalconAPI.Store(proc, 1, candidateHandle);
            HalconAPI.Store(proc, 2, resultName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            HalconAPI.UnpinTuple(candidateHandle);
            HalconAPI.UnpinTuple(resultName);
            int procResult = HTuple.LoadNew(proc, 0, err, out barCodeResults);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Decode bar code symbols within a rectangle.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="codeType">Type of the searched bar code. Default: "EAN-13"</param>
        /// <param name="row">Row index of the center. Default: 50.0</param>
        /// <param name="column">Column index of the center. Default: 100.0</param>
        /// <param name="phi">Orientation of rectangle in radians. Default: 0.0</param>
        /// <param name="length1">Half of the length of the rectangle along the reading direction of the bar code. Default: 200.0</param>
        /// <param name="length2">Half of the length of the rectangle perpendicular to the reading direction of the bar code. Default: 100.0</param>
        /// <param name="decodedDataStrings">Data strings of all successfully decoded bar codes.</param>
        public static void DecodeBarCodeRectangle2(
          HObject image,
          HTuple barCodeHandle,
          HTuple codeType,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple length1,
          HTuple length2,
          out HTuple decodedDataStrings)
        {
            IntPtr proc = HalconAPI.PreCall(1992);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, barCodeHandle);
            HalconAPI.Store(proc, 1, codeType);
            HalconAPI.Store(proc, 2, row);
            HalconAPI.Store(proc, 3, column);
            HalconAPI.Store(proc, 4, phi);
            HalconAPI.Store(proc, 5, length1);
            HalconAPI.Store(proc, 6, length2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            HalconAPI.UnpinTuple(codeType);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(length1);
            HalconAPI.UnpinTuple(length2);
            int procResult = HTuple.LoadNew(proc, 0, err, out decodedDataStrings);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Detect and read bar code symbols in an image.</summary>
        /// <param name="image">Input image. If the image has a reduced domain, the barcode search is reduced to that domain. This usually reduces the runtime of the operator. However, if the barcode is not fully inside the domain, the barcode cannot be decoded correctly.</param>
        /// <param name="symbolRegions">Regions of the successfully decoded bar code symbols.</param>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="codeType">Type of the searched bar code. Default: "auto"</param>
        /// <param name="decodedDataStrings">Data strings of all successfully decoded bar codes.</param>
        public static void FindBarCode(
          HObject image,
          out HObject symbolRegions,
          HTuple barCodeHandle,
          HTuple codeType,
          out HTuple decodedDataStrings)
        {
            IntPtr proc = HalconAPI.PreCall(1993);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, barCodeHandle);
            HalconAPI.Store(proc, 1, codeType);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            HalconAPI.UnpinTuple(codeType);
            int err2 = HObject.LoadNew(proc, 1, err1, out symbolRegions);
            int procResult = HTuple.LoadNew(proc, 0, err2, out decodedDataStrings);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Get the names of the parameters that can be used in set_bar_code* and get_bar_code* operators for a given bar code model</summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="properties">Properties of the parameters. Default: "trained_general"</param>
        /// <param name="genParamName">Names of the generic parameters.</param>
        public static void QueryBarCodeParams(
          HTuple barCodeHandle,
          HTuple properties,
          out HTuple genParamName)
        {
            IntPtr proc = HalconAPI.PreCall(1994);
            HalconAPI.Store(proc, 0, barCodeHandle);
            HalconAPI.Store(proc, 1, properties);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            HalconAPI.UnpinTuple(properties);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get parameters that are used by the bar code reader when processing a specific bar code type. </summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="codeTypes">Names of the bar code types for which parameters should be queried. Default: "EAN-13"</param>
        /// <param name="genParamName">Names of the generic parameters that are to be queried for the bar code model. Default: "check_char"</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        public static void GetBarCodeParamSpecific(
          HTuple barCodeHandle,
          HTuple codeTypes,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1995);
            HalconAPI.Store(proc, 0, barCodeHandle);
            HalconAPI.Store(proc, 1, codeTypes);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            HalconAPI.UnpinTuple(codeTypes);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get one or several parameters that describe the bar code model.</summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="genParamName">Names of the generic parameters that are to be queried for the bar code model. Default: "element_size_min"</param>
        /// <param name="genParamValue">Values of the generic parameters.</param>
        public static void GetBarCodeParam(
          HTuple barCodeHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1996);
            HalconAPI.Store(proc, 0, barCodeHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set selected parameters of the bar code model for selected bar code types</summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="codeTypes">Names of the bar code types for which parameters should be set. Default: "EAN-13"</param>
        /// <param name="genParamName">Names of the generic parameters that shall be adjusted for finding and decoding bar codes. Default: "check_char"</param>
        /// <param name="genParamValue">Values of the generic parameters that are adjusted for finding and decoding bar codes. Default: "absent"</param>
        public static void SetBarCodeParamSpecific(
          HTuple barCodeHandle,
          HTuple codeTypes,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1997);
            HalconAPI.Store(proc, 0, barCodeHandle);
            HalconAPI.Store(proc, 1, codeTypes);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            HalconAPI.UnpinTuple(codeTypes);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set selected parameters of the bar code model.</summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="genParamName">Names of the generic parameters that shall be adjusted for finding and decoding bar codes. Default: "element_size_min"</param>
        /// <param name="genParamValue">Values of the generic parameters that are adjusted for finding and decoding bar codes. Default: 8</param>
        public static void SetBarCodeParam(
          HTuple barCodeHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1998);
            HalconAPI.Store(proc, 0, barCodeHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete all bar code models and free the allocated memory</summary>
        public static void ClearAllBarCodeModels()
        {
            IntPtr proc = HalconAPI.PreCall(1999);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete a bar code model and free the allocated memory</summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        public static void ClearBarCodeModel(HTuple barCodeHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2000);
            HalconAPI.Store(proc, 0, barCodeHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(barCodeHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a model of a bar code reader.</summary>
        /// <param name="genParamName">Names of the generic parameters that can be adjusted for the bar code model. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters that can be adjusted for the bar code model. Default: []</param>
        /// <param name="barCodeHandle">Handle for using and accessing the bar code model.</param>
        public static void CreateBarCodeModel(
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple barCodeHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2001);
            HalconAPI.Store(proc, 0, genParamName);
            HalconAPI.Store(proc, 1, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out barCodeHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Delete the background estimation data set.</summary>
        /// <param name="bgEstiHandle">ID of the BgEsti data set.</param>
        public static void CloseBgEsti(HTuple bgEstiHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2002);
            HalconAPI.Store(proc, 0, bgEstiHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(bgEstiHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the estimated background image.</summary>
        /// <param name="backgroundImage">Estimated background image of the current data set.</param>
        /// <param name="bgEstiHandle">ID of the BgEsti data set.</param>
        public static void GiveBgEsti(out HObject backgroundImage, HTuple bgEstiHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2003);
            HalconAPI.Store(proc, 0, bgEstiHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(bgEstiHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out backgroundImage);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Change the estimated background image.</summary>
        /// <param name="presentImage">Current image.</param>
        /// <param name="upDateRegion">Region describing areas to change.</param>
        /// <param name="bgEstiHandle">ID of the BgEsti data set.</param>
        public static void UpdateBgEsti(
          HObject presentImage,
          HObject upDateRegion,
          HTuple bgEstiHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2004);
            HalconAPI.Store(proc, 1, (HObjectBase)presentImage);
            HalconAPI.Store(proc, 2, (HObjectBase)upDateRegion);
            HalconAPI.Store(proc, 0, bgEstiHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(bgEstiHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)presentImage);
            GC.KeepAlive((object)upDateRegion);
        }

        /// <summary>Estimate the background and return the foreground region.</summary>
        /// <param name="presentImage">Current image.</param>
        /// <param name="foregroundRegion">Region of the detected foreground.</param>
        /// <param name="bgEstiHandle">ID of the BgEsti data set.</param>
        public static void RunBgEsti(
          HObject presentImage,
          out HObject foregroundRegion,
          HTuple bgEstiHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2005);
            HalconAPI.Store(proc, 1, (HObjectBase)presentImage);
            HalconAPI.Store(proc, 0, bgEstiHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(bgEstiHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out foregroundRegion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)presentImage);
        }

        /// <summary>Return the parameters of the data set.</summary>
        /// <param name="bgEstiHandle">ID of the BgEsti data set.</param>
        /// <param name="syspar1">1. system matrix parameter.</param>
        /// <param name="syspar2">2. system matrix parameter.</param>
        /// <param name="gainMode">Gain type.</param>
        /// <param name="gain1">Kalman gain / foreground adaptation time.</param>
        /// <param name="gain2">Kalman gain / background adaptation time.</param>
        /// <param name="adaptMode">Threshold adaptation.</param>
        /// <param name="minDiff">Foreground / background threshold.</param>
        /// <param name="statNum">Number of statistic data sets.</param>
        /// <param name="confidenceC">Confidence constant.</param>
        /// <param name="timeC">Constant for decay time.</param>
        public static void GetBgEstiParams(
          HTuple bgEstiHandle,
          out HTuple syspar1,
          out HTuple syspar2,
          out HTuple gainMode,
          out HTuple gain1,
          out HTuple gain2,
          out HTuple adaptMode,
          out HTuple minDiff,
          out HTuple statNum,
          out HTuple confidenceC,
          out HTuple timeC)
        {
            IntPtr proc = HalconAPI.PreCall(2006);
            HalconAPI.Store(proc, 0, bgEstiHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(bgEstiHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out syspar1);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out syspar2);
            int err4 = HTuple.LoadNew(proc, 2, err3, out gainMode);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out gain1);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out gain2);
            int err7 = HTuple.LoadNew(proc, 5, err6, out adaptMode);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out minDiff);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.INTEGER, err8, out statNum);
            int err10 = HTuple.LoadNew(proc, 8, HTupleType.DOUBLE, err9, out confidenceC);
            int procResult = HTuple.LoadNew(proc, 9, HTupleType.DOUBLE, err10, out timeC);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Change the parameters of the data set.</summary>
        /// <param name="bgEstiHandle">ID of the BgEsti data set.</param>
        /// <param name="syspar1">1. system matrix parameter. Default: 0.7</param>
        /// <param name="syspar2">2. system matrix parameter. Default: 0.7</param>
        /// <param name="gainMode">Gain type. Default: "fixed"</param>
        /// <param name="gain1">Kalman gain / foreground adaptation time. Default: 0.002</param>
        /// <param name="gain2">Kalman gain / background adaptation time. Default: 0.02</param>
        /// <param name="adaptMode">Threshold adaptation. Default: "on"</param>
        /// <param name="minDiff">Foreground/background threshold. Default: 7.0</param>
        /// <param name="statNum">Number of statistic data sets. Default: 10</param>
        /// <param name="confidenceC">Confidence constant. Default: 3.25</param>
        /// <param name="timeC">Constant for decay time. Default: 15.0</param>
        public static void SetBgEstiParams(
          HTuple bgEstiHandle,
          HTuple syspar1,
          HTuple syspar2,
          HTuple gainMode,
          HTuple gain1,
          HTuple gain2,
          HTuple adaptMode,
          HTuple minDiff,
          HTuple statNum,
          HTuple confidenceC,
          HTuple timeC)
        {
            IntPtr proc = HalconAPI.PreCall(2007);
            HalconAPI.Store(proc, 0, bgEstiHandle);
            HalconAPI.Store(proc, 1, syspar1);
            HalconAPI.Store(proc, 2, syspar2);
            HalconAPI.Store(proc, 3, gainMode);
            HalconAPI.Store(proc, 4, gain1);
            HalconAPI.Store(proc, 5, gain2);
            HalconAPI.Store(proc, 6, adaptMode);
            HalconAPI.Store(proc, 7, minDiff);
            HalconAPI.Store(proc, 8, statNum);
            HalconAPI.Store(proc, 9, confidenceC);
            HalconAPI.Store(proc, 10, timeC);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(bgEstiHandle);
            HalconAPI.UnpinTuple(syspar1);
            HalconAPI.UnpinTuple(syspar2);
            HalconAPI.UnpinTuple(gainMode);
            HalconAPI.UnpinTuple(gain1);
            HalconAPI.UnpinTuple(gain2);
            HalconAPI.UnpinTuple(adaptMode);
            HalconAPI.UnpinTuple(minDiff);
            HalconAPI.UnpinTuple(statNum);
            HalconAPI.UnpinTuple(confidenceC);
            HalconAPI.UnpinTuple(timeC);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate and initialize a data set for the background estimation.</summary>
        /// <param name="initializeImage">initialization image.</param>
        /// <param name="syspar1">1. system matrix parameter. Default: 0.7</param>
        /// <param name="syspar2">2. system matrix parameter. Default: 0.7</param>
        /// <param name="gainMode">Gain type. Default: "fixed"</param>
        /// <param name="gain1">Kalman gain / foreground adaptation time. Default: 0.002</param>
        /// <param name="gain2">Kalman gain / background adaptation time. Default: 0.02</param>
        /// <param name="adaptMode">Threshold adaptation. Default: "on"</param>
        /// <param name="minDiff">Foreground/background threshold. Default: 7.0</param>
        /// <param name="statNum">Number of statistic data sets. Default: 10</param>
        /// <param name="confidenceC">Confidence constant. Default: 3.25</param>
        /// <param name="timeC">Constant for decay time. Default: 15.0</param>
        /// <param name="bgEstiHandle">ID of the BgEsti data set.</param>
        public static void CreateBgEsti(
          HObject initializeImage,
          HTuple syspar1,
          HTuple syspar2,
          HTuple gainMode,
          HTuple gain1,
          HTuple gain2,
          HTuple adaptMode,
          HTuple minDiff,
          HTuple statNum,
          HTuple confidenceC,
          HTuple timeC,
          out HTuple bgEstiHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2008);
            HalconAPI.Store(proc, 1, (HObjectBase)initializeImage);
            HalconAPI.Store(proc, 0, syspar1);
            HalconAPI.Store(proc, 1, syspar2);
            HalconAPI.Store(proc, 2, gainMode);
            HalconAPI.Store(proc, 3, gain1);
            HalconAPI.Store(proc, 4, gain2);
            HalconAPI.Store(proc, 5, adaptMode);
            HalconAPI.Store(proc, 6, minDiff);
            HalconAPI.Store(proc, 7, statNum);
            HalconAPI.Store(proc, 8, confidenceC);
            HalconAPI.Store(proc, 9, timeC);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(syspar1);
            HalconAPI.UnpinTuple(syspar2);
            HalconAPI.UnpinTuple(gainMode);
            HalconAPI.UnpinTuple(gain1);
            HalconAPI.UnpinTuple(gain2);
            HalconAPI.UnpinTuple(adaptMode);
            HalconAPI.UnpinTuple(minDiff);
            HalconAPI.UnpinTuple(statNum);
            HalconAPI.UnpinTuple(confidenceC);
            HalconAPI.UnpinTuple(timeC);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out bgEstiHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)initializeImage);
        }

        /// <summary>Delete all background estimation data sets.</summary>
        public static void CloseAllBgEsti()
        {
            IntPtr proc = HalconAPI.PreCall(2009);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Perform an action on I/O channels.</summary>
        /// <param name="IOChannelHandle">Handles of the opened I/O channels.</param>
        /// <param name="paramAction">Name of the action to perform.</param>
        /// <param name="paramArgument">List of arguments for the action. Default: []</param>
        /// <param name="genParamValue">List of values returned by the action.</param>
        public static void ControlIoChannel(
          HTuple IOChannelHandle,
          HTuple paramAction,
          HTuple paramArgument,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2010);
            HalconAPI.Store(proc, 0, IOChannelHandle);
            HalconAPI.Store(proc, 1, paramAction);
            HalconAPI.Store(proc, 2, paramArgument);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IOChannelHandle);
            HalconAPI.UnpinTuple(paramAction);
            HalconAPI.UnpinTuple(paramArgument);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a value to the specified I/O channels.</summary>
        /// <param name="IOChannelHandle">Handles of the opened I/O channels.</param>
        /// <param name="value">Write values.</param>
        /// <param name="status">Status of written values.</param>
        public static void WriteIoChannel(HTuple IOChannelHandle, HTuple value, out HTuple status)
        {
            IntPtr proc = HalconAPI.PreCall(2011);
            HalconAPI.Store(proc, 0, IOChannelHandle);
            HalconAPI.Store(proc, 1, value);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IOChannelHandle);
            HalconAPI.UnpinTuple(value);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out status);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a value from the specified I/O channels.</summary>
        /// <param name="IOChannelHandle">Handles of the opened I/O channels.</param>
        /// <param name="value">Read value.</param>
        /// <param name="status">Status of read value.</param>
        public static void ReadIoChannel(HTuple IOChannelHandle, out HTuple value, out HTuple status)
        {
            IntPtr proc = HalconAPI.PreCall(2012);
            HalconAPI.Store(proc, 0, IOChannelHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IOChannelHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out value);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out status);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set specific parameters of I/O channels.</summary>
        /// <param name="IOChannelHandle">Handles of the opened I/O channels.</param>
        /// <param name="genParamName">Parameter names. Default: []</param>
        /// <param name="genParamValue">Parameter values to set. Default: []</param>
        public static void SetIoChannelParam(
          HTuple IOChannelHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2013);
            HalconAPI.Store(proc, 0, IOChannelHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IOChannelHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query specific parameters of I/O channels.</summary>
        /// <param name="IOChannelHandle">Handles of the opened I/O channels.</param>
        /// <param name="genParamName">Parameter names. Default: "param_name"</param>
        /// <param name="genParamValue">Parameter values.</param>
        public static void GetIoChannelParam(
          HTuple IOChannelHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2014);
            HalconAPI.Store(proc, 0, IOChannelHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IOChannelHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close I/O channels.</summary>
        /// <param name="IOChannelHandle">Handles of the opened I/O channels.</param>
        public static void CloseIoChannel(HTuple IOChannelHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2015);
            HalconAPI.Store(proc, 0, IOChannelHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IOChannelHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open and configure I/O channels.</summary>
        /// <param name="IODeviceHandle">Handle of the opened I/O device.</param>
        /// <param name="IOChannelName">HALCON I/O channel names of the specified device.</param>
        /// <param name="genParamName">Parameter names. Default: []</param>
        /// <param name="genParamValue">Parameter values. Default: []</param>
        /// <param name="IOChannelHandle">Handles of the opened I/O channel.</param>
        public static void OpenIoChannel(
          HTuple IODeviceHandle,
          HTuple IOChannelName,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple IOChannelHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2016);
            HalconAPI.Store(proc, 0, IODeviceHandle);
            HalconAPI.Store(proc, 1, IOChannelName);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IODeviceHandle);
            HalconAPI.UnpinTuple(IOChannelName);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out IOChannelHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query information about channels of the specified I/O device. </summary>
        /// <param name="IODeviceHandle">Handle of the opened I/O device.</param>
        /// <param name="IOChannelName">Channel names to query.</param>
        /// <param name="query">Name of the query. Default: "param_name"</param>
        /// <param name="result">List of values (according to Query).</param>
        public static void QueryIoDevice(
          HTuple IODeviceHandle,
          HTuple IOChannelName,
          HTuple query,
          out HTuple result)
        {
            IntPtr proc = HalconAPI.PreCall(2017);
            HalconAPI.Store(proc, 0, IODeviceHandle);
            HalconAPI.Store(proc, 1, IOChannelName);
            HalconAPI.Store(proc, 2, query);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IODeviceHandle);
            HalconAPI.UnpinTuple(IOChannelName);
            HalconAPI.UnpinTuple(query);
            int procResult = HTuple.LoadNew(proc, 0, err, out result);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Perform an action on the I/O device.</summary>
        /// <param name="IODeviceHandle">Handle of the opened I/O device.</param>
        /// <param name="action">Name of the action to perform.</param>
        /// <param name="argument">List of arguments for the action. Default: []</param>
        /// <param name="result">List of result values returned by the action.</param>
        public static void ControlIoDevice(
          HTuple IODeviceHandle,
          HTuple action,
          HTuple argument,
          out HTuple result)
        {
            IntPtr proc = HalconAPI.PreCall(2018);
            HalconAPI.Store(proc, 0, IODeviceHandle);
            HalconAPI.Store(proc, 1, action);
            HalconAPI.Store(proc, 2, argument);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IODeviceHandle);
            HalconAPI.UnpinTuple(action);
            HalconAPI.UnpinTuple(argument);
            int procResult = HTuple.LoadNew(proc, 0, err, out result);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Configure a specific I/O device instance.</summary>
        /// <param name="IODeviceHandle">Handle of the opened I/O device.</param>
        /// <param name="genParamName">Parameter names. Default: []</param>
        /// <param name="genParamValue">Parameter values to set. Default: []</param>
        public static void SetIoDeviceParam(
          HTuple IODeviceHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2019);
            HalconAPI.Store(proc, 0, IODeviceHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IODeviceHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query settings of an I/O device instance. </summary>
        /// <param name="IODeviceHandle">Handle of the opened I/O device.</param>
        /// <param name="genParamName">Parameter names. Default: "param_name"</param>
        /// <param name="genParamValue">Parameter values.</param>
        public static void GetIoDeviceParam(
          HTuple IODeviceHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2020);
            HalconAPI.Store(proc, 0, IODeviceHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IODeviceHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close the specified I/O device. </summary>
        /// <param name="IODeviceHandle">Handle of the opened I/O device.</param>
        public static void CloseIoDevice(HTuple IODeviceHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2021);
            HalconAPI.Store(proc, 0, IODeviceHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IODeviceHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open and configure an I/O device. </summary>
        /// <param name="IOInterfaceName">HALCON I/O interface name. Default: []</param>
        /// <param name="IODeviceName">I/O device name. Default: []</param>
        /// <param name="genParamName">Dynamic parameter names. Default: []</param>
        /// <param name="genParamValue">Dynamic parameter values. Default: []</param>
        /// <param name="IODeviceHandle">Handle of the opened I/O device.</param>
        public static void OpenIoDevice(
          HTuple IOInterfaceName,
          HTuple IODeviceName,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple IODeviceHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2022);
            HalconAPI.Store(proc, 0, IOInterfaceName);
            HalconAPI.Store(proc, 1, IODeviceName);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IOInterfaceName);
            HalconAPI.UnpinTuple(IODeviceName);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out IODeviceHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Perform an action on the I/O interface.</summary>
        /// <param name="IOInterfaceName">HALCON I/O interface name. Default: []</param>
        /// <param name="action">Name of the action to perform.</param>
        /// <param name="argument">List of arguments for the action. Default: []</param>
        /// <param name="result">List of results returned by the action.</param>
        public static void ControlIoInterface(
          HTuple IOInterfaceName,
          HTuple action,
          HTuple argument,
          out HTuple result)
        {
            IntPtr proc = HalconAPI.PreCall(2023);
            HalconAPI.Store(proc, 0, IOInterfaceName);
            HalconAPI.Store(proc, 1, action);
            HalconAPI.Store(proc, 2, argument);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IOInterfaceName);
            HalconAPI.UnpinTuple(action);
            HalconAPI.UnpinTuple(argument);
            int procResult = HTuple.LoadNew(proc, 0, err, out result);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query information about the specified I/O device interface.</summary>
        /// <param name="IOInterfaceName">HALCON I/O interface name. Default: []</param>
        /// <param name="query">Parameter name of the query. Default: "io_device_names"</param>
        /// <param name="result">List of result values (according to Query).</param>
        public static void QueryIoInterface(HTuple IOInterfaceName, HTuple query, out HTuple result)
        {
            IntPtr proc = HalconAPI.PreCall(2024);
            HalconAPI.Store(proc, 0, IOInterfaceName);
            HalconAPI.Store(proc, 1, query);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(IOInterfaceName);
            HalconAPI.UnpinTuple(query);
            int procResult = HTuple.LoadNew(proc, 0, err, out result);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query specific parameters of an image acquisition device.</summary>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="param">Parameter of interest. Default: "revision"</param>
        /// <param name="value">Parameter value.</param>
        public static void GetFramegrabberParam(HTuple acqHandle, HTuple param, out HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(2025);
            HalconAPI.Store(proc, 0, acqHandle);
            HalconAPI.Store(proc, 1, param);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            HalconAPI.UnpinTuple(param);
            int procResult = HTuple.LoadNew(proc, 0, err, out value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set specific parameters of an image acquistion device.</summary>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="param">Parameter name.</param>
        /// <param name="value">Parameter value to be set.</param>
        public static void SetFramegrabberParam(HTuple acqHandle, HTuple param, HTuple value)
        {
            IntPtr proc = HalconAPI.PreCall(2026);
            HalconAPI.Store(proc, 0, acqHandle);
            HalconAPI.Store(proc, 1, param);
            HalconAPI.Store(proc, 2, value);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            HalconAPI.UnpinTuple(param);
            HalconAPI.UnpinTuple(value);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query callback function of an image acquisition device.</summary>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="callbackType">Callback type. Default: "transfer_end"</param>
        /// <param name="callbackFunction">Pointer to the callback function.</param>
        /// <param name="userContext">Pointer to user-specific context data.</param>
        public static void GetFramegrabberCallback(
          HTuple acqHandle,
          HTuple callbackType,
          out HTuple callbackFunction,
          out HTuple userContext)
        {
            IntPtr proc = HalconAPI.PreCall(2027);
            HalconAPI.Store(proc, 0, acqHandle);
            HalconAPI.Store(proc, 1, callbackType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            HalconAPI.UnpinTuple(callbackType);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out callbackFunction);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out userContext);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Register a callback function for an image acquisition device.</summary>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="callbackType">Callback type. Default: "transfer_end"</param>
        /// <param name="callbackFunction">Pointer to the callback function to be set.</param>
        /// <param name="userContext">Pointer to user-specific context data.</param>
        public static void SetFramegrabberCallback(
          HTuple acqHandle,
          HTuple callbackType,
          HTuple callbackFunction,
          HTuple userContext)
        {
            IntPtr proc = HalconAPI.PreCall(2028);
            HalconAPI.Store(proc, 0, acqHandle);
            HalconAPI.Store(proc, 1, callbackType);
            HalconAPI.Store(proc, 2, callbackFunction);
            HalconAPI.Store(proc, 3, userContext);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            HalconAPI.UnpinTuple(callbackType);
            HalconAPI.UnpinTuple(callbackFunction);
            HalconAPI.UnpinTuple(userContext);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Asynchronous grab of images and preprocessed image data from the specified image acquisition device.</summary>
        /// <param name="image">Grabbed image data.</param>
        /// <param name="region">Pre-processed image regions.</param>
        /// <param name="contours">Pre-processed XLD contours.</param>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="maxDelay">Maximum tolerated delay between the start of the asynchronous grab and the delivery of the image [ms]. Default: -1.0</param>
        /// <param name="data">Pre-processed control data.</param>
        public static void GrabDataAsync(
          out HObject image,
          out HObject region,
          out HObject contours,
          HTuple acqHandle,
          HTuple maxDelay,
          out HTuple data)
        {
            IntPtr proc = HalconAPI.PreCall(2029);
            HalconAPI.Store(proc, 0, acqHandle);
            HalconAPI.Store(proc, 1, maxDelay);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            HalconAPI.UnpinTuple(maxDelay);
            int err2 = HObject.LoadNew(proc, 1, err1, out image);
            int err3 = HObject.LoadNew(proc, 2, err2, out region);
            int err4 = HObject.LoadNew(proc, 3, err3, out contours);
            int procResult = HTuple.LoadNew(proc, 0, err4, out data);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Synchronous grab of images and preprocessed image data from the specified image acquisition device.</summary>
        /// <param name="image">Grabbed image data.</param>
        /// <param name="region">Preprocessed image regions.</param>
        /// <param name="contours">Preprocessed XLD contours.</param>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="data">Preprocessed control data.</param>
        public static void GrabData(
          out HObject image,
          out HObject region,
          out HObject contours,
          HTuple acqHandle,
          out HTuple data)
        {
            IntPtr proc = HalconAPI.PreCall(2030);
            HalconAPI.Store(proc, 0, acqHandle);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            int err2 = HObject.LoadNew(proc, 1, err1, out image);
            int err3 = HObject.LoadNew(proc, 2, err2, out region);
            int err4 = HObject.LoadNew(proc, 3, err3, out contours);
            int procResult = HTuple.LoadNew(proc, 0, err4, out data);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Asynchronous grab of an image from the specified image acquisition device.</summary>
        /// <param name="image">Grabbed image.</param>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="maxDelay">Maximum tolerated delay between the start of the asynchronous grab and the delivery of the image [ms]. Default: -1.0</param>
        public static void GrabImageAsync(out HObject image, HTuple acqHandle, HTuple maxDelay)
        {
            IntPtr proc = HalconAPI.PreCall(2031);
            HalconAPI.Store(proc, 0, acqHandle);
            HalconAPI.Store(proc, 1, maxDelay);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            HalconAPI.UnpinTuple(maxDelay);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Start an asynchronous grab from the specified image acquisition device.</summary>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="maxDelay">This parameter is obsolete and has no effect. Default: -1.0</param>
        public static void GrabImageStart(HTuple acqHandle, HTuple maxDelay)
        {
            IntPtr proc = HalconAPI.PreCall(2032);
            HalconAPI.Store(proc, 0, acqHandle);
            HalconAPI.Store(proc, 1, maxDelay);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            HalconAPI.UnpinTuple(maxDelay);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Synchronous grab of an image from the specified image acquisition device.</summary>
        /// <param name="image">Grabbed image.</param>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        public static void GrabImage(out HObject image, HTuple acqHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2033);
            HalconAPI.Store(proc, 0, acqHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            int procResult = HObject.LoadNew(proc, 1, err, out image);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query information about the specified image acquisition interface.</summary>
        /// <param name="name">HALCON image acquisition interface name, i.e., name of the corresponding DLL (Windows) or shared library (Linux/macOS). Default: "File"</param>
        /// <param name="query">Name of the chosen query. Default: "info_boards"</param>
        /// <param name="information">Textual information (according to Query).</param>
        /// <param name="valueList">List of values (according to Query).</param>
        public static void InfoFramegrabber(
          HTuple name,
          HTuple query,
          out HTuple information,
          out HTuple valueList)
        {
            IntPtr proc = HalconAPI.PreCall(2034);
            HalconAPI.Store(proc, 0, name);
            HalconAPI.Store(proc, 1, query);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(name);
            HalconAPI.UnpinTuple(query);
            int err2 = HTuple.LoadNew(proc, 0, err1, out information);
            int procResult = HTuple.LoadNew(proc, 1, err2, out valueList);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close all image acquisition devices.</summary>
        public static void CloseAllFramegrabbers()
        {
            IntPtr proc = HalconAPI.PreCall(2035);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Close specified image acquisition device.</summary>
        /// <param name="acqHandle">Handle of the image acquisition device to be closed.</param>
        public static void CloseFramegrabber(HTuple acqHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2036);
            HalconAPI.Store(proc, 0, acqHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Open and configure an image acquisition device.</summary>
        /// <param name="name">HALCON image acquisition interface name, i.e., name of the corresponding DLL (Windows) or shared library (Linux/macOS). Default: "File"</param>
        /// <param name="horizontalResolution">Desired horizontal resolution of image acquisition interface (absolute value or 1 for full resolution, 2 for half resolution, or 4 for quarter resolution). Default: 1</param>
        /// <param name="verticalResolution">Desired vertical resolution of image acquisition interface (absolute value or 1 for full resolution, 2 for half resolution, or 4 for quarter resolution). Default: 1</param>
        /// <param name="imageWidth">Width of desired image part (absolute value or 0 for HorizontalResolution - 2*StartColumn). Default: 0</param>
        /// <param name="imageHeight">Height of desired image part (absolute value or 0 for VerticalResolution - 2*StartRow). Default: 0</param>
        /// <param name="startRow">Line number of upper left corner of desired image part (or border height if ImageHeight = 0). Default: 0</param>
        /// <param name="startColumn">Column number of upper left corner of desired image part (or border width if ImageWidth = 0). Default: 0</param>
        /// <param name="field">Desired half image or full image. Default: "default"</param>
        /// <param name="bitsPerChannel">Number of transferred bits per pixel and image channel (-1: device-specific default value). Default: -1</param>
        /// <param name="colorSpace">Output color format of the grabbed images, typically 'gray' or 'raw' for single-channel or 'rgb' or 'yuv' for three-channel images ('default': device-specific default value). Default: "default"</param>
        /// <param name="generic">Generic parameter with device-specific meaning. Default: -1</param>
        /// <param name="externalTrigger">External triggering. Default: "default"</param>
        /// <param name="cameraType">Type of used camera ('default': device-specific default value). Default: "default"</param>
        /// <param name="device">Device the image acquisition device is connected to ('default': device-specific default value). Default: "default"</param>
        /// <param name="port">Port the image acquisition device is connected to (-1: device-specific default value). Default: -1</param>
        /// <param name="lineIn">Camera input line of multiplexer (-1: device-specific default value). Default: -1</param>
        /// <param name="acqHandle">Handle of the opened image acquisition device.</param>
        public static void OpenFramegrabber(
          HTuple name,
          HTuple horizontalResolution,
          HTuple verticalResolution,
          HTuple imageWidth,
          HTuple imageHeight,
          HTuple startRow,
          HTuple startColumn,
          HTuple field,
          HTuple bitsPerChannel,
          HTuple colorSpace,
          HTuple generic,
          HTuple externalTrigger,
          HTuple cameraType,
          HTuple device,
          HTuple port,
          HTuple lineIn,
          out HTuple acqHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2037);
            HalconAPI.Store(proc, 0, name);
            HalconAPI.Store(proc, 1, horizontalResolution);
            HalconAPI.Store(proc, 2, verticalResolution);
            HalconAPI.Store(proc, 3, imageWidth);
            HalconAPI.Store(proc, 4, imageHeight);
            HalconAPI.Store(proc, 5, startRow);
            HalconAPI.Store(proc, 6, startColumn);
            HalconAPI.Store(proc, 7, field);
            HalconAPI.Store(proc, 8, bitsPerChannel);
            HalconAPI.Store(proc, 9, colorSpace);
            HalconAPI.Store(proc, 10, generic);
            HalconAPI.Store(proc, 11, externalTrigger);
            HalconAPI.Store(proc, 12, cameraType);
            HalconAPI.Store(proc, 13, device);
            HalconAPI.Store(proc, 14, port);
            HalconAPI.Store(proc, 15, lineIn);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(name);
            HalconAPI.UnpinTuple(horizontalResolution);
            HalconAPI.UnpinTuple(verticalResolution);
            HalconAPI.UnpinTuple(imageWidth);
            HalconAPI.UnpinTuple(imageHeight);
            HalconAPI.UnpinTuple(startRow);
            HalconAPI.UnpinTuple(startColumn);
            HalconAPI.UnpinTuple(field);
            HalconAPI.UnpinTuple(bitsPerChannel);
            HalconAPI.UnpinTuple(colorSpace);
            HalconAPI.UnpinTuple(generic);
            HalconAPI.UnpinTuple(externalTrigger);
            HalconAPI.UnpinTuple(cameraType);
            HalconAPI.UnpinTuple(device);
            HalconAPI.UnpinTuple(port);
            HalconAPI.UnpinTuple(lineIn);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out acqHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query look-up table of the image acquisition device.</summary>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="imageRed">Red level of the LUT entries.</param>
        /// <param name="imageGreen">Green level of the LUT entries.</param>
        /// <param name="imageBlue">Blue level of the LUT entries.</param>
        public static void GetFramegrabberLut(
          HTuple acqHandle,
          out HTuple imageRed,
          out HTuple imageGreen,
          out HTuple imageBlue)
        {
            IntPtr proc = HalconAPI.PreCall(2038);
            HalconAPI.Store(proc, 0, acqHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out imageRed);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out imageGreen);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out imageBlue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set look-up table of the image acquisition device.</summary>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="imageRed">Red level of the LUT entries.</param>
        /// <param name="imageGreen">Green level of the LUT entries.</param>
        /// <param name="imageBlue">Blue level of the LUT entries.</param>
        public static void SetFramegrabberLut(
          HTuple acqHandle,
          HTuple imageRed,
          HTuple imageGreen,
          HTuple imageBlue)
        {
            IntPtr proc = HalconAPI.PreCall(2039);
            HalconAPI.Store(proc, 0, acqHandle);
            HalconAPI.Store(proc, 1, imageRed);
            HalconAPI.Store(proc, 2, imageGreen);
            HalconAPI.Store(proc, 3, imageBlue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(acqHandle);
            HalconAPI.UnpinTuple(imageRed);
            HalconAPI.UnpinTuple(imageGreen);
            HalconAPI.UnpinTuple(imageBlue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add a text label to a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="text">Text of the label. Default: "label"</param>
        /// <param name="referencePoint">Point of reference of the label.</param>
        /// <param name="position">Position of the label. Default: "top"</param>
        /// <param name="relatesTo">Indicates fixed or relative positioning. Default: "point"</param>
        /// <param name="labelIndex">Index of the new label in the 3D scene.</param>
        public static void AddScene3dLabel(
          HTuple scene3D,
          HTuple text,
          HTuple referencePoint,
          HTuple position,
          HTuple relatesTo,
          out HTuple labelIndex)
        {
            IntPtr proc = HalconAPI.PreCall(2040);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, text);
            HalconAPI.Store(proc, 2, referencePoint);
            HalconAPI.Store(proc, 3, position);
            HalconAPI.Store(proc, 4, relatesTo);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(text);
            HalconAPI.UnpinTuple(referencePoint);
            HalconAPI.UnpinTuple(position);
            HalconAPI.UnpinTuple(relatesTo);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out labelIndex);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Remove a text label from a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="labelIndex">Index of the text label to remove.</param>
        public static void RemoveScene3dLabel(HTuple scene3D, HTuple labelIndex)
        {
            IntPtr proc = HalconAPI.PreCall(2041);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, labelIndex);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(labelIndex);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters of a text label in a 3D scene.</summary>
        /// <param name="scene3D">Handle of the 3D scene.</param>
        /// <param name="labelIndex">Index of the text label.</param>
        /// <param name="genParamName">Names of the generic parameters. Default: "color"</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: "red"</param>
        public static void SetScene3dLabelParam(
          HTuple scene3D,
          HTuple labelIndex,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2042);
            HalconAPI.Store(proc, 0, scene3D);
            HalconAPI.Store(proc, 1, labelIndex);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(scene3D);
            HalconAPI.UnpinTuple(labelIndex);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Add training images to the texture inspection model.</summary>
        /// <param name="image">Image of flawless texture.</param>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        /// <param name="indices">Indices of the images that have been added to the texture inspection model.</param>
        public static void AddTextureInspectionModelImage(
          HObject image,
          HTuple textureInspectionModel,
          out HTuple indices)
        {
            IntPtr proc = HalconAPI.PreCall(2043);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, textureInspectionModel);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionModel);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out indices);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Inspection of the texture within an image.</summary>
        /// <param name="image">Image of the texture to be inspected.</param>
        /// <param name="noveltyRegion">Novelty regions.</param>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        /// <param name="textureInspectionResultID">Handle of the inspection results.</param>
        public static void ApplyTextureInspectionModel(
          HObject image,
          out HObject noveltyRegion,
          HTuple textureInspectionModel,
          out HTuple textureInspectionResultID)
        {
            IntPtr proc = HalconAPI.PreCall(2044);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, textureInspectionModel);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionModel);
            int err2 = HObject.LoadNew(proc, 1, err1, out noveltyRegion);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err2, out textureInspectionResultID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>bilateral filtering of an image.</summary>
        /// <param name="image">Image to be filtered.</param>
        /// <param name="imageJoint">Joint image.</param>
        /// <param name="imageBilateral">Filtered output image.</param>
        /// <param name="sigmaSpatial">Size of the Gaussian of the closeness function. Default: 3.0</param>
        /// <param name="sigmaRange">Size of the Gaussian of the similarity function. Default: 20.0</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        public static void BilateralFilter(
          HObject image,
          HObject imageJoint,
          out HObject imageBilateral,
          HTuple sigmaSpatial,
          HTuple sigmaRange,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2045);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)imageJoint);
            HalconAPI.Store(proc, 0, sigmaSpatial);
            HalconAPI.Store(proc, 1, sigmaRange);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigmaSpatial);
            HalconAPI.UnpinTuple(sigmaRange);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HObject.LoadNew(proc, 1, err, out imageBilateral);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)imageJoint);
        }

        /// <summary>Clear an CNN-based OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void ClearOcrClassCnn(HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2046);
            HalconAPI.Store(proc, 0, OCRHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a texture inspection model and free the allocated memory.</summary>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        public static void ClearTextureInspectionModel(HTuple textureInspectionModel)
        {
            IntPtr proc = HalconAPI.PreCall(2047);
            HalconAPI.Store(proc, 0, textureInspectionModel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a texture inspection result handle and free the allocated memory. </summary>
        /// <param name="textureInspectionResultID">Handle of the texture inspection results.</param>
        public static void ClearTextureInspectionResult(HTuple textureInspectionResultID)
        {
            IntPtr proc = HalconAPI.PreCall(2048);
            HalconAPI.Store(proc, 0, textureInspectionResultID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionResultID);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert image coordinates to window coordinates</summary>
        /// <param name="windowHandle">Window handle</param>
        /// <param name="rowImage">Row in image coordinates.</param>
        /// <param name="columnImage">Column in image coordinates.</param>
        /// <param name="rowWindow">Row (Y) in window coordinates.</param>
        /// <param name="columnWindow">Column (X) in window coordinates.</param>
        public static void ConvertCoordinatesImageToWindow(
          HTuple windowHandle,
          HTuple rowImage,
          HTuple columnImage,
          out HTuple rowWindow,
          out HTuple columnWindow)
        {
            IntPtr proc = HalconAPI.PreCall(2049);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rowImage);
            HalconAPI.Store(proc, 2, columnImage);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rowImage);
            HalconAPI.UnpinTuple(columnImage);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowWindow);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnWindow);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert window coordinates to image coordinates</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="rowWindow">Row (Y) in window coordinates.</param>
        /// <param name="columnWindow">Column (X) in window coordinates.</param>
        /// <param name="rowImage">Row in image coordinates.</param>
        /// <param name="columnImage">Column in image coordinates.</param>
        public static void ConvertCoordinatesWindowToImage(
          HTuple windowHandle,
          HTuple rowWindow,
          HTuple columnWindow,
          out HTuple rowImage,
          out HTuple columnImage)
        {
            IntPtr proc = HalconAPI.PreCall(2050);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, rowWindow);
            HalconAPI.Store(proc, 2, columnWindow);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(rowWindow);
            HalconAPI.UnpinTuple(columnWindow);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowImage);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnImage);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a texture inspection model.</summary>
        /// <param name="modelType">The type of the created texture inspection model. Default: "basic"</param>
        /// <param name="textureInspectionModel">Handle for using and accessing the texture inspection model.</param>
        public static void CreateTextureInspectionModel(
          HTuple modelType,
          out HTuple textureInspectionModel)
        {
            IntPtr proc = HalconAPI.PreCall(2051);
            HalconAPI.Store(proc, 0, modelType);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelType);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out textureInspectionModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized dual quaternion.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="dualQuaternion">Dual quaternion.</param>
        public static void DeserializeDualQuat(HTuple serializedItemHandle, out HTuple dualQuaternion)
        {
            IntPtr proc = HalconAPI.PreCall(2052);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out dualQuaternion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized CNN-based OCR classifier.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void DeserializeOcrClassCnn(HTuple serializedItemHandle, out HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2053);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a serialized texture inspection model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        public static void DeserializeTextureInspectionModel(
          HTuple serializedItemHandle,
          out HTuple textureInspectionModel)
        {
            IntPtr proc = HalconAPI.PreCall(2054);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out textureInspectionModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Display text in a window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="stringVal">A tuple of strings containing the text message to be displayed. Each value of the tuple will be displayed in a single line. Default: "hello"</param>
        /// <param name="coordSystem">If set to 'window', the text position is given with respect to the window coordinate system. If set to 'image', image coordinates are used (this may be useful in zoomed images). Default: "window"</param>
        /// <param name="row">The vertical text alignment or the row coordinate of the desired text position. Default: 12</param>
        /// <param name="column">The horizontal text alignment or the column coordinate of  the desired text position. Default: 12</param>
        /// <param name="color">A tuple of strings defining the colors of the texts. Default: "black"</param>
        /// <param name="genParamName">Generic parameter names. Default: []</param>
        /// <param name="genParamValue">Generic parameter values. Default: []</param>
        public static void DispText(
          HTuple windowHandle,
          HTuple stringVal,
          HTuple coordSystem,
          HTuple row,
          HTuple column,
          HTuple color,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2055);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, stringVal);
            HalconAPI.Store(proc, 2, coordSystem);
            HalconAPI.Store(proc, 3, row);
            HalconAPI.Store(proc, 4, column);
            HalconAPI.Store(proc, 5, color);
            HalconAPI.Store(proc, 6, genParamName);
            HalconAPI.Store(proc, 7, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(stringVal);
            HalconAPI.UnpinTuple(coordSystem);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(color);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Classify multiple characters with an CNN-based OCR classifier.</summary>
        /// <param name="character">Characters to be recognized.</param>
        /// <param name="image">Gray values of the characters.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="classVal">Result of classifying the characters with the CNN.</param>
        /// <param name="confidence">Confidence of the class of the characters.</param>
        public static void DoOcrMultiClassCnn(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          out HTuple classVal,
          out HTuple confidence)
        {
            IntPtr proc = HalconAPI.PreCall(2056);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classVal);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Classify a single character with an CNN-based OCR classifier.</summary>
        /// <param name="character">Character to be recognized.</param>
        /// <param name="image">Gray values of the character.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="num">Number of best classes to determine. Default: 1</param>
        /// <param name="classVal">Result of classifying the character with the CNN.</param>
        /// <param name="confidence">Confidence(s) of the class(es) of the character.</param>
        public static void DoOcrSingleClassCnn(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          HTuple num,
          out HTuple classVal,
          out HTuple confidence)
        {
            IntPtr proc = HalconAPI.PreCall(2057);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, num);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(num);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classVal);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Classify a related group of characters with an CNN-based OCR classifier.</summary>
        /// <param name="character">Characters to be recognized.</param>
        /// <param name="image">Gray values of the characters.</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="expression">Expression describing the allowed word structure.</param>
        /// <param name="numAlternatives">Number of classes per character considered for the internal word correction. Default: 3</param>
        /// <param name="numCorrections">Maximum number of corrected characters. Default: 2</param>
        /// <param name="classVal">Result of classifying the characters with the CNN.</param>
        /// <param name="confidence">Confidence of the class of the characters.</param>
        /// <param name="word">Word text after classification and correction.</param>
        /// <param name="score">Measure of similarity between corrected word and uncorrected classification results.</param>
        public static void DoOcrWordCnn(
          HObject character,
          HObject image,
          HTuple OCRHandle,
          HTuple expression,
          HTuple numAlternatives,
          HTuple numCorrections,
          out HTuple classVal,
          out HTuple confidence,
          out HTuple word,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(2058);
            HalconAPI.Store(proc, 1, (HObjectBase)character);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, expression);
            HalconAPI.Store(proc, 2, numAlternatives);
            HalconAPI.Store(proc, 3, numCorrections);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(expression);
            HalconAPI.UnpinTuple(numAlternatives);
            HalconAPI.UnpinTuple(numCorrections);
            int err2 = HTuple.LoadNew(proc, 0, err1, out classVal);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out confidence);
            int err4 = HTuple.LoadNew(proc, 2, err3, out word);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)character);
            GC.KeepAlive((object)image);
        }

        /// <summary>Multiply two dual quaternions.</summary>
        /// <param name="dualQuaternionLeft">Left dual quaternion.</param>
        /// <param name="dualQuaternionRight">Right dual quaternion.</param>
        /// <param name="dualQuaternionComposed">Product of the dual quaternions.</param>
        public static void DualQuatCompose(
          HTuple dualQuaternionLeft,
          HTuple dualQuaternionRight,
          out HTuple dualQuaternionComposed)
        {
            IntPtr proc = HalconAPI.PreCall(2059);
            HalconAPI.Store(proc, 0, dualQuaternionLeft);
            HalconAPI.Store(proc, 1, dualQuaternionRight);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dualQuaternionLeft);
            HalconAPI.UnpinTuple(dualQuaternionRight);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out dualQuaternionComposed);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Conjugate a dual quaternion.</summary>
        /// <param name="dualQuaternion">Dual quaternion.</param>
        /// <param name="dualQuaternionConjugate">Conjugate of the dual quaternion.</param>
        public static void DualQuatConjugate(HTuple dualQuaternion, out HTuple dualQuaternionConjugate)
        {
            IntPtr proc = HalconAPI.PreCall(2060);
            HalconAPI.Store(proc, 0, dualQuaternion);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dualQuaternion);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out dualQuaternionConjugate);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Interpolate two dual quaternions.</summary>
        /// <param name="dualQuaternionStart">Dual quaternion as the start point of the interpolation.</param>
        /// <param name="dualQuaternionEnd">Dual quaternion as the end point of the interpolation.</param>
        /// <param name="interpPos">Interpolation parameter. Default: 0.5</param>
        /// <param name="dualQuaternionInterpolated">Interpolated dual quaternion.</param>
        public static void DualQuatInterpolate(
          HTuple dualQuaternionStart,
          HTuple dualQuaternionEnd,
          HTuple interpPos,
          out HTuple dualQuaternionInterpolated)
        {
            IntPtr proc = HalconAPI.PreCall(2061);
            HalconAPI.Store(proc, 0, dualQuaternionStart);
            HalconAPI.Store(proc, 1, dualQuaternionEnd);
            HalconAPI.Store(proc, 2, interpPos);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dualQuaternionStart);
            HalconAPI.UnpinTuple(dualQuaternionEnd);
            HalconAPI.UnpinTuple(interpPos);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out dualQuaternionInterpolated);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Normalize a dual quaternion.</summary>
        /// <param name="dualQuaternion">Unit dual quaternion.</param>
        /// <param name="dualQuaternionNormalized">Normalized dual quaternion.</param>
        public static void DualQuatNormalize(HTuple dualQuaternion, out HTuple dualQuaternionNormalized)
        {
            IntPtr proc = HalconAPI.PreCall(2062);
            HalconAPI.Store(proc, 0, dualQuaternion);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dualQuaternion);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out dualQuaternionNormalized);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a unit dual quaternion into a homogeneous transformation matrix.</summary>
        /// <param name="dualQuaternion">Unit dual quaternion.</param>
        /// <param name="homMat3D">Transformation matrix.</param>
        public static void DualQuatToHomMat3d(HTuple dualQuaternion, out HTuple homMat3D)
        {
            IntPtr proc = HalconAPI.PreCall(2063);
            HalconAPI.Store(proc, 0, dualQuaternion);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dualQuaternion);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out homMat3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a dual quaternion to a 3D pose.</summary>
        /// <param name="dualQuaternion">Unit dual quaternion.</param>
        /// <param name="pose">3D pose.</param>
        public static void DualQuatToPose(HTuple dualQuaternion, out HTuple pose)
        {
            IntPtr proc = HalconAPI.PreCall(2064);
            HalconAPI.Store(proc, 0, dualQuaternion);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dualQuaternion);
            int procResult = HTuple.LoadNew(proc, 0, err, out pose);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a unit dual quaternion into a screw.</summary>
        /// <param name="dualQuaternion">Unit dual quaternion.</param>
        /// <param name="screwFormat">Format of the screw parameters. Default: "moment"</param>
        /// <param name="axisDirectionX">X component of the direction vector of the screw axis.</param>
        /// <param name="axisDirectionY">Y component of the direction vector of the screw axis.</param>
        /// <param name="axisDirectionZ">Z component of the direction vector of the screw axis.</param>
        /// <param name="axisMomentOrPointX">X component of the moment vector or a point on the screw axis.</param>
        /// <param name="axisMomentOrPointY">Y component of the moment vector or a point on the screw axis.</param>
        /// <param name="axisMomentOrPointZ">Z component of the moment vector or a point on the screw axis.</param>
        /// <param name="rotation">Rotation angle in radians.</param>
        /// <param name="translation">Translation.</param>
        public static void DualQuatToScrew(
          HTuple dualQuaternion,
          HTuple screwFormat,
          out HTuple axisDirectionX,
          out HTuple axisDirectionY,
          out HTuple axisDirectionZ,
          out HTuple axisMomentOrPointX,
          out HTuple axisMomentOrPointY,
          out HTuple axisMomentOrPointZ,
          out HTuple rotation,
          out HTuple translation)
        {
            IntPtr proc = HalconAPI.PreCall(2065);
            HalconAPI.Store(proc, 0, dualQuaternion);
            HalconAPI.Store(proc, 1, screwFormat);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dualQuaternion);
            HalconAPI.UnpinTuple(screwFormat);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out axisDirectionX);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out axisDirectionY);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out axisDirectionZ);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out axisMomentOrPointX);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out axisMomentOrPointY);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out axisMomentOrPointZ);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out rotation);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out translation);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Transform a 3D line with a unit dual quaternion.</summary>
        /// <param name="dualQuaternion">Unit dual quaternion representing the transformation.</param>
        /// <param name="lineFormat">Format of the line parameters. Default: "moment"</param>
        /// <param name="lineDirectionX">X component of the direction vector of the line.</param>
        /// <param name="lineDirectionY">Y component of the direction vector of the line.</param>
        /// <param name="lineDirectionZ">Z component of the direction vector of the line.</param>
        /// <param name="lineMomentOrPointX">X component of the moment vector or a point on the line.</param>
        /// <param name="lineMomentOrPointY">Y component of the moment vector or a point on the line.</param>
        /// <param name="lineMomentOrPointZ">Z component of the moment vector or a point on the line.</param>
        /// <param name="transLineDirectionX">X component of the direction vector of the transformed line.</param>
        /// <param name="transLineDirectionY">Y component of the direction vector of the transformed line.</param>
        /// <param name="transLineDirectionZ">Z component of the direction vector of the transformed line.</param>
        /// <param name="transLineMomentOrPointX">X component of the moment vector or a point on the transformed line.</param>
        /// <param name="transLineMomentOrPointY">Y component of the moment vector or a point on the transformed line.</param>
        /// <param name="transLineMomentOrPointZ">Z component of the moment vector or a point on the transformed line.</param>
        public static void DualQuatTransLine3d(
          HTuple dualQuaternion,
          HTuple lineFormat,
          HTuple lineDirectionX,
          HTuple lineDirectionY,
          HTuple lineDirectionZ,
          HTuple lineMomentOrPointX,
          HTuple lineMomentOrPointY,
          HTuple lineMomentOrPointZ,
          out HTuple transLineDirectionX,
          out HTuple transLineDirectionY,
          out HTuple transLineDirectionZ,
          out HTuple transLineMomentOrPointX,
          out HTuple transLineMomentOrPointY,
          out HTuple transLineMomentOrPointZ)
        {
            IntPtr proc = HalconAPI.PreCall(2066);
            HalconAPI.Store(proc, 0, dualQuaternion);
            HalconAPI.Store(proc, 1, lineFormat);
            HalconAPI.Store(proc, 2, lineDirectionX);
            HalconAPI.Store(proc, 3, lineDirectionY);
            HalconAPI.Store(proc, 4, lineDirectionZ);
            HalconAPI.Store(proc, 5, lineMomentOrPointX);
            HalconAPI.Store(proc, 6, lineMomentOrPointY);
            HalconAPI.Store(proc, 7, lineMomentOrPointZ);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dualQuaternion);
            HalconAPI.UnpinTuple(lineFormat);
            HalconAPI.UnpinTuple(lineDirectionX);
            HalconAPI.UnpinTuple(lineDirectionY);
            HalconAPI.UnpinTuple(lineDirectionZ);
            HalconAPI.UnpinTuple(lineMomentOrPointX);
            HalconAPI.UnpinTuple(lineMomentOrPointY);
            HalconAPI.UnpinTuple(lineMomentOrPointZ);
            int err2 = HTuple.LoadNew(proc, 0, err1, out transLineDirectionX);
            int err3 = HTuple.LoadNew(proc, 1, err2, out transLineDirectionY);
            int err4 = HTuple.LoadNew(proc, 2, err3, out transLineDirectionZ);
            int err5 = HTuple.LoadNew(proc, 3, err4, out transLineMomentOrPointX);
            int err6 = HTuple.LoadNew(proc, 4, err5, out transLineMomentOrPointY);
            int procResult = HTuple.LoadNew(proc, 5, err6, out transLineMomentOrPointZ);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find edges in a 3D object model.</summary>
        /// <param name="objectModel3D">Handle of the 3D object model whose edges should be computed.</param>
        /// <param name="minAmplitude">Edge threshold.</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="objectModel3DEdges">3D object model containing the edges.</param>
        public static void EdgesObjectModel3d(
          HTuple objectModel3D,
          HTuple minAmplitude,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple objectModel3DEdges)
        {
            IntPtr proc = HalconAPI.PreCall(2067);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, minAmplitude);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(minAmplitude);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DEdges);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Find the best matches of multiple NCC models.</summary>
        /// <param name="image">Input image in which the model should be found.</param>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.8</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "true"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public static void FindNccModels(
          HObject image,
          HTuple modelIDs,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score,
          out HTuple model)
        {
            IntPtr proc = HalconAPI.PreCall(2068);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, modelIDs);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, numMatches);
            HalconAPI.Store(proc, 5, maxOverlap);
            HalconAPI.Store(proc, 6, subPixel);
            HalconAPI.Store(proc, 7, numLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelIDs);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Find the best matches of a surface model in a 3D scene and images.</summary>
        /// <param name="image">Images of the scene.</param>
        /// <param name="surfaceModelID">Handle of the surface model.</param>
        /// <param name="objectModel3D">Handle of the 3D object model containing the scene.</param>
        /// <param name="relSamplingDistance">Scene sampling distance relative to the diameter of the surface model. Default: 0.05</param>
        /// <param name="keyPointFraction">Fraction of sampled scene points used as key points. Default: 0.2</param>
        /// <param name="minScore">Minimum score of the returned poses. Default: 0</param>
        /// <param name="returnResultHandle">Enable returning a result handle in SurfaceMatchingResultID. Default: "false"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="pose">3D pose of the surface model in the scene.</param>
        /// <param name="score">Score of the found instances of the surface model.</param>
        /// <param name="surfaceMatchingResultID">Handle of the matching result, if enabled in ReturnResultHandle.</param>
        public static void FindSurfaceModelImage(
          HObject image,
          HTuple surfaceModelID,
          HTuple objectModel3D,
          HTuple relSamplingDistance,
          HTuple keyPointFraction,
          HTuple minScore,
          HTuple returnResultHandle,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple pose,
          out HTuple score,
          out HTuple surfaceMatchingResultID)
        {
            IntPtr proc = HalconAPI.PreCall(2069);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, surfaceModelID);
            HalconAPI.Store(proc, 1, objectModel3D);
            HalconAPI.Store(proc, 2, relSamplingDistance);
            HalconAPI.Store(proc, 3, keyPointFraction);
            HalconAPI.Store(proc, 4, minScore);
            HalconAPI.Store(proc, 5, returnResultHandle);
            HalconAPI.Store(proc, 6, genParamName);
            HalconAPI.Store(proc, 7, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surfaceModelID);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(relSamplingDistance);
            HalconAPI.UnpinTuple(keyPointFraction);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(returnResultHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out score);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out surfaceMatchingResultID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Flush the contents of a window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        public static void FlushBuffer(HTuple windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2070);
            HalconAPI.Store(proc, 0, windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the region used to create an NCC model.</summary>
        /// <param name="modelRegion">Model region of the NCC model.</param>
        /// <param name="modelID">Handle of the model.</param>
        public static void GetNccModelRegion(out HObject modelRegion, HTuple modelID)
        {
            IntPtr proc = HalconAPI.PreCall(2071);
            HalconAPI.Store(proc, 0, modelID);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelID);
            int procResult = HObject.LoadNew(proc, 1, err, out modelRegion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters of a CNN-based OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="genParamName">A tuple of generic parameter names. Default: "characters"</param>
        /// <param name="genParamValue">A tuple of generic parameter values.</param>
        public static void GetParamsOcrClassCnn(
          HTuple OCRHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2072);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the current color in RGBA-coding.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="red">The current color's red value.</param>
        /// <param name="green">The current color's green value.</param>
        /// <param name="blue">The current color's blue value.</param>
        /// <param name="alpha">The current color's alpha value.</param>
        public static void GetRgba(
          HTuple windowHandle,
          out HTuple red,
          out HTuple green,
          out HTuple blue,
          out HTuple alpha)
        {
            IntPtr proc = HalconAPI.PreCall(2073);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out red);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out green);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out blue);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out alpha);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get intermediate 3D object model of a stereo reconstruction</summary>
        /// <param name="stereoModelID">Handle des Stereomodells.</param>
        /// <param name="genParamName">Namen der Modellparameter.</param>
        /// <param name="objectModel3D">Werte der Modellparameter.</param>
        public static void GetStereoModelObjectModel3d(
          HTuple stereoModelID,
          HTuple genParamName,
          out HTuple objectModel3D)
        {
            IntPtr proc = HalconAPI.PreCall(2074);
            HalconAPI.Store(proc, 0, stereoModelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stereoModelID);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3D);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the training images contained in a texture inspection model.</summary>
        /// <param name="imageOut">Training images contained in the texture inspection model.</param>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        public static void GetTextureInspectionModelImage(
          out HObject imageOut,
          HTuple textureInspectionModel)
        {
            IntPtr proc = HalconAPI.PreCall(2075);
            HalconAPI.Store(proc, 0, textureInspectionModel);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionModel);
            int procResult = HObject.LoadNew(proc, 1, err, out imageOut);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query parameters of a texture inspection model.</summary>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        /// <param name="genParamName">Name of the queried model parameter. Default: "novelty_threshold"</param>
        /// <param name="genParamValue">Value of the queried model parameter.</param>
        public static void GetTextureInspectionModelParam(
          HTuple textureInspectionModel,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2076);
            HalconAPI.Store(proc, 0, textureInspectionModel);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionModel);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query iconic results of a texture inspection.</summary>
        /// <param name="objectVal">Returned iconic object.</param>
        /// <param name="textureInspectionResultID">Handle of the texture inspection result.</param>
        /// <param name="resultName">Name of the iconic object to be returned. Default: "novelty_region"</param>
        public static void GetTextureInspectionResultObject(
          out HObject objectVal,
          HTuple textureInspectionResultID,
          HTuple resultName)
        {
            IntPtr proc = HalconAPI.PreCall(2077);
            HalconAPI.Store(proc, 0, textureInspectionResultID);
            HalconAPI.Store(proc, 1, resultName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionResultID);
            HalconAPI.UnpinTuple(resultName);
            int procResult = HObject.LoadNew(proc, 1, err, out objectVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Guided filtering of an image.</summary>
        /// <param name="image">Input image.</param>
        /// <param name="imageGuide">Guidance image.</param>
        /// <param name="imageGuided">Output image.</param>
        /// <param name="radius">Radius of the filtering operation. Default: 3</param>
        /// <param name="amplitude">Controls the influence of edges on the smoothing. Default: 20.0</param>
        public static void GuidedFilter(
          HObject image,
          HObject imageGuide,
          out HObject imageGuided,
          HTuple radius,
          HTuple amplitude)
        {
            IntPtr proc = HalconAPI.PreCall(2078);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 2, (HObjectBase)imageGuide);
            HalconAPI.Store(proc, 0, radius);
            HalconAPI.Store(proc, 1, amplitude);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(amplitude);
            int procResult = HObject.LoadNew(proc, 1, err, out imageGuided);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
            GC.KeepAlive((object)imageGuide);
        }

        /// <summary>Create an interleaved image from a multichannel image.</summary>
        /// <param name="multichannelImage">Input multichannel image.</param>
        /// <param name="interleavedImage">Output interleaved image.</param>
        /// <param name="pixelFormat">Target format for InterleavedImage. Default: "rgba"</param>
        /// <param name="rowBytes">Number of bytes in a row of the output image. Default: "match"</param>
        /// <param name="alpha">Alpha value for three channel input images. Default: 255</param>
        public static void InterleaveChannels(
          HObject multichannelImage,
          out HObject interleavedImage,
          HTuple pixelFormat,
          HTuple rowBytes,
          HTuple alpha)
        {
            IntPtr proc = HalconAPI.PreCall(2079);
            HalconAPI.Store(proc, 1, (HObjectBase)multichannelImage);
            HalconAPI.Store(proc, 0, pixelFormat);
            HalconAPI.Store(proc, 1, rowBytes);
            HalconAPI.Store(proc, 2, alpha);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pixelFormat);
            HalconAPI.UnpinTuple(rowBytes);
            HalconAPI.UnpinTuple(alpha);
            int procResult = HObject.LoadNew(proc, 1, err, out interleavedImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)multichannelImage);
        }

        /// <summary>Convert a 3D pose to a unit dual quaternion.</summary>
        /// <param name="pose">3D pose.</param>
        /// <param name="dualQuaternion">Unit dual quaternion.</param>
        public static void PoseToDualQuat(HTuple pose, out HTuple dualQuaternion)
        {
            IntPtr proc = HalconAPI.PreCall(2080);
            HalconAPI.Store(proc, 0, pose);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(pose);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out dualQuaternion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get the names of the parameters that can be used in get_params_ocr_class_cnn for a given CNN-based OCR classifier.</summary>
        /// <param name="OCRHandle">Handle of OCR classifier.</param>
        /// <param name="genParamName">Names of the generic parameters.</param>
        public static void QueryParamsOcrClassCnn(HTuple OCRHandle, out HTuple genParamName)
        {
            IntPtr proc = HalconAPI.PreCall(2081);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read an CNN-based OCR classifier from a file.</summary>
        /// <param name="fileName">File name. Default: "Universal_Rej.occ"</param>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        public static void ReadOcrClassCnn(HTuple fileName, out HTuple OCRHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2082);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out OCRHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a texture inspection model from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        public static void ReadTextureInspectionModel(
          HTuple fileName,
          out HTuple textureInspectionModel)
        {
            IntPtr proc = HalconAPI.PreCall(2083);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out textureInspectionModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Refine the pose of a surface model in a 3D scene and in images.</summary>
        /// <param name="image">Images of the scene.</param>
        /// <param name="surfaceModelID">Handle of the surface model.</param>
        /// <param name="objectModel3D">Handle of the 3D object model containing the scene.</param>
        /// <param name="initialPose">Initial pose of the surface model in the scene.</param>
        /// <param name="minScore">Minimum score of the returned poses. Default: 0</param>
        /// <param name="returnResultHandle">Enable returning a result handle in SurfaceMatchingResultID. Default: "false"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <param name="pose">3D pose of the surface model in the scene.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        /// <param name="surfaceMatchingResultID">Handle of the matching result, if enabled in ReturnResultHandle.</param>
        public static void RefineSurfaceModelPoseImage(
          HObject image,
          HTuple surfaceModelID,
          HTuple objectModel3D,
          HTuple initialPose,
          HTuple minScore,
          HTuple returnResultHandle,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple pose,
          out HTuple score,
          out HTuple surfaceMatchingResultID)
        {
            IntPtr proc = HalconAPI.PreCall(2084);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, surfaceModelID);
            HalconAPI.Store(proc, 1, objectModel3D);
            HalconAPI.Store(proc, 2, initialPose);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, returnResultHandle);
            HalconAPI.Store(proc, 5, genParamName);
            HalconAPI.Store(proc, 6, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surfaceModelID);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(initialPose);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(returnResultHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HTuple.LoadNew(proc, 0, err1, out pose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out score);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out surfaceMatchingResultID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Clear all or a user-defined subset of the images of a texture inspection model.</summary>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        /// <param name="indices">Indices of the images to be deleted from the texture inspection model.</param>
        /// <param name="remainingIndices">Indices of the images that remain in the texture inspection model.</param>
        public static void RemoveTextureInspectionModelImage(
          HTuple textureInspectionModel,
          HTuple indices,
          out HTuple remainingIndices)
        {
            IntPtr proc = HalconAPI.PreCall(2085);
            HalconAPI.Store(proc, 0, textureInspectionModel);
            HalconAPI.Store(proc, 1, indices);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionModel);
            HalconAPI.UnpinTuple(indices);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out remainingIndices);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Convert a screw into a dual quaternion.</summary>
        /// <param name="screwFormat">Format of the screw parameters. Default: "moment"</param>
        /// <param name="axisDirectionX">X component of the direction vector of the screw axis.</param>
        /// <param name="axisDirectionY">Y component of the direction vector of the screw axis.</param>
        /// <param name="axisDirectionZ">Z component of the direction vector of the screw axis.</param>
        /// <param name="axisMomentOrPointX">X component of the moment vector or a point on the screw axis.</param>
        /// <param name="axisMomentOrPointY">Y component of the moment vector or a point on the screw axis.</param>
        /// <param name="axisMomentOrPointZ">Z component of the moment vector or a point on the screw axis.</param>
        /// <param name="rotation">Rotation angle in radians.</param>
        /// <param name="translation">Translation.</param>
        /// <param name="dualQuaternion">Dual quaternion.</param>
        public static void ScrewToDualQuat(
          HTuple screwFormat,
          HTuple axisDirectionX,
          HTuple axisDirectionY,
          HTuple axisDirectionZ,
          HTuple axisMomentOrPointX,
          HTuple axisMomentOrPointY,
          HTuple axisMomentOrPointZ,
          HTuple rotation,
          HTuple translation,
          out HTuple dualQuaternion)
        {
            IntPtr proc = HalconAPI.PreCall(2086);
            HalconAPI.Store(proc, 0, screwFormat);
            HalconAPI.Store(proc, 1, axisDirectionX);
            HalconAPI.Store(proc, 2, axisDirectionY);
            HalconAPI.Store(proc, 3, axisDirectionZ);
            HalconAPI.Store(proc, 4, axisMomentOrPointX);
            HalconAPI.Store(proc, 5, axisMomentOrPointY);
            HalconAPI.Store(proc, 6, axisMomentOrPointZ);
            HalconAPI.Store(proc, 7, rotation);
            HalconAPI.Store(proc, 8, translation);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(screwFormat);
            HalconAPI.UnpinTuple(axisDirectionX);
            HalconAPI.UnpinTuple(axisDirectionY);
            HalconAPI.UnpinTuple(axisDirectionZ);
            HalconAPI.UnpinTuple(axisMomentOrPointX);
            HalconAPI.UnpinTuple(axisMomentOrPointY);
            HalconAPI.UnpinTuple(axisMomentOrPointZ);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(translation);
            int procResult = HTuple.LoadNew(proc, 0, err, out dualQuaternion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Segment image using Maximally Stable Extremal Regions (MSER).</summary>
        /// <param name="image">Input image.</param>
        /// <param name="MSERDark">Segmented dark MSERs.</param>
        /// <param name="MSERLight">Segmented light MSERs.</param>
        /// <param name="polarity">The polarity of the returned MSERs. Default: "both"</param>
        /// <param name="minArea">Minimal size of an MSER. Default: 10</param>
        /// <param name="maxArea">Maximal size of an MSER. Default: []</param>
        /// <param name="delta">Amount of thresholds for which a region needs to be stable. Default: 15</param>
        /// <param name="genParamName">List of generic parameter names. Default: []</param>
        /// <param name="genParamValue">List of generic parameter values. Default: []</param>
        public static void SegmentImageMser(
          HObject image,
          out HObject MSERDark,
          out HObject MSERLight,
          HTuple polarity,
          HTuple minArea,
          HTuple maxArea,
          HTuple delta,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2087);
            HalconAPI.Store(proc, 1, (HObjectBase)image);
            HalconAPI.Store(proc, 0, polarity);
            HalconAPI.Store(proc, 1, minArea);
            HalconAPI.Store(proc, 2, maxArea);
            HalconAPI.Store(proc, 3, delta);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(polarity);
            HalconAPI.UnpinTuple(minArea);
            HalconAPI.UnpinTuple(maxArea);
            HalconAPI.UnpinTuple(delta);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int err2 = HObject.LoadNew(proc, 1, err1, out MSERDark);
            int procResult = HObject.LoadNew(proc, 2, err2, out MSERLight);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)image);
        }

        /// <summary>Send an event to a buffer window signaling a mouse double click event.</summary>
        /// <param name="windowHandle">Window handle of the buffer window.</param>
        /// <param name="row">Row coordinate of the mouse cursor in the image coordinate system.</param>
        /// <param name="column">Column coordinate of the mouse cursor in the image coordinate system.</param>
        /// <param name="button">Mouse button(s) pressed.</param>
        /// <param name="processed">'true', if HALCON processed the event.</param>
        public static void SendMouseDoubleClickEvent(
          HTuple windowHandle,
          HTuple row,
          HTuple column,
          HTuple button,
          out HTuple processed)
        {
            IntPtr proc = HalconAPI.PreCall(2088);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, button);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(button);
            int procResult = HTuple.LoadNew(proc, 0, err, out processed);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Send an event to a window buffer signaling a mouse down event.</summary>
        /// <param name="windowHandle">Window handle of the buffer window.</param>
        /// <param name="row">Row coordinate of the mouse cursor in the image coordinate system.</param>
        /// <param name="column">Column coordinate of the mouse cursor in the image coordinate system.</param>
        /// <param name="button">Mouse button(s) pressed.</param>
        /// <param name="processed">'true', if HALCON processed the event.</param>
        public static void SendMouseDownEvent(
          HTuple windowHandle,
          HTuple row,
          HTuple column,
          HTuple button,
          out HTuple processed)
        {
            IntPtr proc = HalconAPI.PreCall(2089);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, button);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(button);
            int procResult = HTuple.LoadNew(proc, 0, err, out processed);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Send an event to a buffer window signaling a mouse drag event.</summary>
        /// <param name="windowHandle">Window handle of the buffer window.</param>
        /// <param name="row">Row coordinate of the mouse cursor in the image coordinate system.</param>
        /// <param name="column">Column coordinate of the mouse cursor in the image coordinate system.</param>
        /// <param name="button">Mouse button(s) pressed.</param>
        /// <param name="processed">'true', if HALCON processed the event.</param>
        public static void SendMouseDragEvent(
          HTuple windowHandle,
          HTuple row,
          HTuple column,
          HTuple button,
          out HTuple processed)
        {
            IntPtr proc = HalconAPI.PreCall(2090);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, button);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(button);
            int procResult = HTuple.LoadNew(proc, 0, err, out processed);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Send an event to a buffer window signaling a mouse up event.</summary>
        /// <param name="windowHandle">Window handle of the buffer window.</param>
        /// <param name="row">Row coordinate of the mouse cursor in the image coordinate system.</param>
        /// <param name="column">Column coordinate of the mouse cursor in the image coordinate system.</param>
        /// <param name="button">Mouse button(s) pressed.</param>
        /// <param name="processed">'true', if HALCON processed the event.</param>
        public static void SendMouseUpEvent(
          HTuple windowHandle,
          HTuple row,
          HTuple column,
          HTuple button,
          out HTuple processed)
        {
            IntPtr proc = HalconAPI.PreCall(2091);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.Store(proc, 3, button);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(button);
            int procResult = HTuple.LoadNew(proc, 0, err, out processed);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a dual quaternion.</summary>
        /// <param name="dualQuaternion">Dual quaternion.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeDualQuat(HTuple dualQuaternion, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2092);
            HalconAPI.Store(proc, 0, dualQuaternion);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(dualQuaternion);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a CNN-based OCR classifier</summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeOcrClassCnn(HTuple OCRHandle, out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2093);
            HalconAPI.Store(proc, 0, OCRHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(OCRHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a texture inspection model.</summary>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeTextureInspectionModel(
          HTuple textureInspectionModel,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2094);
            HalconAPI.Store(proc, 0, textureInspectionModel);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionModel);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Sets the callback for content updates in buffer window.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="callbackFunction">Callback for content updates.</param>
        /// <param name="callbackContext">Parameter to CallbackFunction.</param>
        public static void SetContentUpdateCallback(
          HTuple windowHandle,
          HTuple callbackFunction,
          HTuple callbackContext)
        {
            IntPtr proc = HalconAPI.PreCall(2095);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, callbackFunction);
            HalconAPI.Store(proc, 2, callbackContext);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(callbackFunction);
            HalconAPI.UnpinTuple(callbackContext);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the color definition via RGBA values.</summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="red">Red component of the color. Default: 255</param>
        /// <param name="green">Green component of the color. Default: 0</param>
        /// <param name="blue">Blue component of the color. Default: 0</param>
        /// <param name="alpha">Alpha component of the color. Default: 255</param>
        public static void SetRgba(
          HTuple windowHandle,
          HTuple red,
          HTuple green,
          HTuple blue,
          HTuple alpha)
        {
            IntPtr proc = HalconAPI.PreCall(2096);
            HalconAPI.Store(proc, 0, windowHandle);
            HalconAPI.Store(proc, 1, red);
            HalconAPI.Store(proc, 2, green);
            HalconAPI.Store(proc, 3, blue);
            HalconAPI.Store(proc, 4, alpha);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(windowHandle);
            HalconAPI.UnpinTuple(red);
            HalconAPI.UnpinTuple(green);
            HalconAPI.UnpinTuple(blue);
            HalconAPI.UnpinTuple(alpha);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters and properties of a surface model.</summary>
        /// <param name="surfaceModelID">Handle of the surface model.</param>
        /// <param name="genParamName">Name of the parameter. Default: "camera_parameter"</param>
        /// <param name="genParamValue">Value of the parameter.</param>
        public static void SetSurfaceModelParam(
          HTuple surfaceModelID,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2097);
            HalconAPI.Store(proc, 0, surfaceModelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(surfaceModelID);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters of a texture inspection model.</summary>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        /// <param name="genParamName">Name of the model parameter to be adjusted. Default: "gen_result_handle"</param>
        /// <param name="genParamValue">New value of the model parameter. Default: "true"</param>
        public static void SetTextureInspectionModelParam(
          HTuple textureInspectionModel,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2098);
            HalconAPI.Store(proc, 0, textureInspectionModel);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionModel);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Train a texture inspection model.</summary>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        public static void TrainTextureInspectionModel(HTuple textureInspectionModel)
        {
            IntPtr proc = HalconAPI.PreCall(2099);
            HalconAPI.Store(proc, 0, textureInspectionModel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a texture inspection model to a file.</summary>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteTextureInspectionModel(HTuple textureInspectionModel, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(2100);
            HalconAPI.Store(proc, 0, textureInspectionModel);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureInspectionModel);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Reconstruct a surface from several, differently illuminated images.</summary>
        /// <param name="images">The Images.</param>
        /// <param name="normalField">The NormalField.</param>
        /// <param name="gradient">The Gradient.</param>
        /// <param name="albedo">The Albedo.</param>
        /// <param name="resultType">The Result type. Default: "all"</param>
        public static void UncalibratedPhotometricStereo(
          HObject images,
          out HObject normalField,
          out HObject gradient,
          out HObject albedo,
          HTuple resultType)
        {
            IntPtr proc = HalconAPI.PreCall(2101);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, resultType);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(resultType);
            int err2 = HObject.LoadNew(proc, 1, err1, out normalField);
            int err3 = HObject.LoadNew(proc, 2, err2, out gradient);
            int procResult = HObject.LoadNew(proc, 3, err3, out albedo);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Infer the class affiliations for a set of images using the  deep-learning-based classifier.</summary>
        /// <param name="images">Tuple of input images.</param>
        /// <param name="DLClassifierHandle">Handle of the deep-learning-based classifier.</param>
        /// <param name="DLClassifierResultHandle">Handle of the deep learning classification  results.</param>
        public static void ApplyDlClassifier(
          HObject images,
          HTuple DLClassifierHandle,
          out HTuple DLClassifierResultHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2102);
            HalconAPI.Store(proc, 1, (HObjectBase)images);
            HalconAPI.Store(proc, 0, DLClassifierHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(DLClassifierHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out DLClassifierResultHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)images);
        }

        /// <summary>Clear a deep-learning-based classifier.</summary>
        /// <param name="DLClassifierHandle">Handle of the deep-learning-based classifier.</param>
        public static void ClearDlClassifier(HTuple DLClassifierHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2103);
            HalconAPI.Store(proc, 0, DLClassifierHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(DLClassifierHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear the handle containing the results of the deep-learning-based classification.</summary>
        /// <param name="DLClassifierResultHandle">Handle of the deep learning classification  results.</param>
        public static void ClearDlClassifierResult(HTuple DLClassifierResultHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2104);
            HalconAPI.Store(proc, 0, DLClassifierResultHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(DLClassifierResultHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear the handle of a deep-learning-based classifier training result.</summary>
        /// <param name="DLClassifierTrainResultHandle">Handle of the training results from the  deep-learning-based classifier.</param>
        public static void ClearDlClassifierTrainResult(HTuple DLClassifierTrainResultHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2105);
            HalconAPI.Store(proc, 0, DLClassifierTrainResultHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(DLClassifierTrainResultHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Clear a structured light model and free the allocated memory.</summary>
        /// <param name="structuredLightModel">Handle of the structured light model.</param>
        public static void ClearStructuredLightModel(HTuple structuredLightModel)
        {
            IntPtr proc = HalconAPI.PreCall(2106);
            HalconAPI.Store(proc, 0, structuredLightModel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(structuredLightModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Create a structured light model.</summary>
        /// <param name="modelType">The type of the created structured light model. Default: "deflectometry"</param>
        /// <param name="structuredLightModel">Handle for using and accessing the structured light model.</param>
        public static void CreateStructuredLightModel(HTuple modelType, out HTuple structuredLightModel)
        {
            IntPtr proc = HalconAPI.PreCall(2107);
            HalconAPI.Store(proc, 0, modelType);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(modelType);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out structuredLightModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Decode the camera images acquired with a structured light setup.</summary>
        /// <param name="cameraImages">Acquired camera images.</param>
        /// <param name="structuredLightModel">Handle of the structured light model.</param>
        public static void DecodeStructuredLightPattern(
          HObject cameraImages,
          HTuple structuredLightModel)
        {
            IntPtr proc = HalconAPI.PreCall(2108);
            HalconAPI.Store(proc, 1, (HObjectBase)cameraImages);
            HalconAPI.Store(proc, 0, structuredLightModel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(structuredLightModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)cameraImages);
        }

        /// <summary>Deserialize a deep-learning-based classifier.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="DLClassifierHandle">Handle of the deep-learning-based classifier.</param>
        public static void DeserializeDlClassifier(
          HTuple serializedItemHandle,
          out HTuple DLClassifierHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2109);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out DLClassifierHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Deserialize a structured light model.</summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        /// <param name="structuredLightModel">Handle of the structured light model.</param>
        public static void DeserializeStructuredLightModel(
          HTuple serializedItemHandle,
          out HTuple structuredLightModel)
        {
            IntPtr proc = HalconAPI.PreCall(2110);
            HalconAPI.Store(proc, 0, serializedItemHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(serializedItemHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out structuredLightModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Calculate the minimum distance between two contours and the points used for  the calculation.</summary>
        /// <param name="contour1">First input contour.</param>
        /// <param name="contour2">Second input contour.</param>
        /// <param name="mode">Distance calculation mode. Default: "fast_point_to_segment"</param>
        /// <param name="distanceMin">Minimum distance between the two contours.</param>
        /// <param name="row1">Row coordinate of the point on Contour1.</param>
        /// <param name="column1">Column coordinate of the point on Contour1.</param>
        /// <param name="row2">Row coordinate of the point on Contour2.</param>
        /// <param name="column2">Column coordinate of the point on Contour2.</param>
        public static void DistanceCcMinPoints(
          HObject contour1,
          HObject contour2,
          HTuple mode,
          out HTuple distanceMin,
          out HTuple row1,
          out HTuple column1,
          out HTuple row2,
          out HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(2111);
            HalconAPI.Store(proc, 1, (HObjectBase)contour1);
            HalconAPI.Store(proc, 2, (HObjectBase)contour2);
            HalconAPI.Store(proc, 0, mode);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mode);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out distanceMin);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out row1);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out column1);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out row2);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out column2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)contour1);
            GC.KeepAlive((object)contour2);
        }

        /// <summary>Fuse 3D object models into a surface.</summary>
        /// <param name="objectModel3D">Handles of the 3D object models.</param>
        /// <param name="boundingBox">The two opposite bound box corners.</param>
        /// <param name="resolution">Used resolution within the bounding box. Default: 1.0</param>
        /// <param name="surfaceTolerance">Distance of expected noise to surface. Default: 1.0</param>
        /// <param name="minThickness">Minimum thickness of the object in direction  of the surface normal. Default: 1.0</param>
        /// <param name="smoothing">Weight factor for data fidelity. Default: 1.0</param>
        /// <param name="normalDirection">Direction of normals of the input models. Default: "inwards"</param>
        /// <param name="genParamName">Name of the generic parameter. Default: []</param>
        /// <param name="genParamValue">Value of the generic parameter. Default: []</param>
        /// <param name="objectModel3DFusion">Handle of the fused 3D object model.</param>
        public static void FuseObjectModel3d(
          HTuple objectModel3D,
          HTuple boundingBox,
          HTuple resolution,
          HTuple surfaceTolerance,
          HTuple minThickness,
          HTuple smoothing,
          HTuple normalDirection,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple objectModel3DFusion)
        {
            IntPtr proc = HalconAPI.PreCall(2112);
            HalconAPI.Store(proc, 0, objectModel3D);
            HalconAPI.Store(proc, 1, boundingBox);
            HalconAPI.Store(proc, 2, resolution);
            HalconAPI.Store(proc, 3, surfaceTolerance);
            HalconAPI.Store(proc, 4, minThickness);
            HalconAPI.Store(proc, 5, smoothing);
            HalconAPI.Store(proc, 6, normalDirection);
            HalconAPI.Store(proc, 7, genParamName);
            HalconAPI.Store(proc, 8, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectModel3D);
            HalconAPI.UnpinTuple(boundingBox);
            HalconAPI.UnpinTuple(resolution);
            HalconAPI.UnpinTuple(surfaceTolerance);
            HalconAPI.UnpinTuple(minThickness);
            HalconAPI.UnpinTuple(smoothing);
            HalconAPI.UnpinTuple(normalDirection);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out objectModel3DFusion);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Generate the pattern images to be displayed in a structured light setup.</summary>
        /// <param name="patternImages">Generated pattern images.</param>
        /// <param name="structuredLightModel">Handle of the structured light model.</param>
        public static void GenStructuredLightPattern(
          out HObject patternImages,
          HTuple structuredLightModel)
        {
            IntPtr proc = HalconAPI.PreCall(2113);
            HalconAPI.Store(proc, 0, structuredLightModel);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(structuredLightModel);
            int procResult = HObject.LoadNew(proc, 1, err, out patternImages);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the parameters the deep-learning-based classifier.</summary>
        /// <param name="DLClassifierHandle">Handle of the deep-learning-based classifier.</param>
        /// <param name="genParamName">Name of the generic parameter. Default: "gpu"</param>
        /// <param name="genParamValue">Value of the generic parameter.</param>
        public static void GetDlClassifierParam(
          HTuple DLClassifierHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2114);
            HalconAPI.Store(proc, 0, DLClassifierHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(DLClassifierHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Retrieve classification results inferred by a deep-learning-based  classifier.</summary>
        /// <param name="DLClassifierResultHandle">Handle of the deep learning classification  results.</param>
        /// <param name="index">Index of the image in the batch. Default: "all"</param>
        /// <param name="genResultName">Name of the generic parameter. Default: "predicted_classes"</param>
        /// <param name="genResultValue">Value of the generic parameter, either the confidence  values, the class names or class indices.</param>
        public static void GetDlClassifierResult(
          HTuple DLClassifierResultHandle,
          HTuple index,
          HTuple genResultName,
          out HTuple genResultValue)
        {
            IntPtr proc = HalconAPI.PreCall(2115);
            HalconAPI.Store(proc, 0, DLClassifierResultHandle);
            HalconAPI.Store(proc, 1, index);
            HalconAPI.Store(proc, 2, genResultName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(DLClassifierResultHandle);
            HalconAPI.UnpinTuple(index);
            HalconAPI.UnpinTuple(genResultName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genResultValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Return the results for the single training step of a deep-learning-based  classifier.</summary>
        /// <param name="DLClassifierTrainResultHandle">Handle of the training results from the  deep-learning-based classifier.</param>
        /// <param name="genParamName">Name of the generic parameter. Default: "loss"</param>
        /// <param name="genParamValue">Value of the generic parameter.</param>
        public static void GetDlClassifierTrainResult(
          HTuple DLClassifierTrainResultHandle,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2116);
            HalconAPI.Store(proc, 0, DLClassifierTrainResultHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(DLClassifierTrainResultHandle);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Query parameters of a structured light model.</summary>
        /// <param name="structuredLightModel">Handle of the structured light model.</param>
        /// <param name="genParamName">Name of the queried model parameter. Default: "min_stripe_width"</param>
        /// <param name="genParamValue">Value of the queried model parameter.</param>
        public static void GetStructuredLightModelParam(
          HTuple structuredLightModel,
          HTuple genParamName,
          out HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2117);
            HalconAPI.Store(proc, 0, structuredLightModel);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(structuredLightModel);
            HalconAPI.UnpinTuple(genParamName);
            int procResult = HTuple.LoadNew(proc, 0, err, out genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Get (intermediate) iconic results of a structured light model.</summary>
        /// <param name="objectVal">Iconic result.</param>
        /// <param name="structuredLightModel">Handle of the structured light model.</param>
        /// <param name="objectName">Name of the iconic result to be returned.</param>
        public static void GetStructuredLightObject(
          out HObject objectVal,
          HTuple structuredLightModel,
          HTuple objectName)
        {
            IntPtr proc = HalconAPI.PreCall(2118);
            HalconAPI.Store(proc, 0, structuredLightModel);
            HalconAPI.Store(proc, 1, objectName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(structuredLightModel);
            HalconAPI.UnpinTuple(objectName);
            int procResult = HObject.LoadNew(proc, 1, err, out objectVal);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Compute the width, height, and aspect ratio of the surrounding rectangle parallel to the coordinate axes.</summary>
        /// <param name="regions">Regions to be examined.</param>
        /// <param name="height">Height of the surrounding rectangle of the region.</param>
        /// <param name="width">Width of the surrounding rectangle of the region.</param>
        /// <param name="ratio">Aspect ratio of the surrounding rectangle of the region.</param>
        public static void HeightWidthRatio(
          HObject regions,
          out HTuple height,
          out HTuple width,
          out HTuple ratio)
        {
            IntPtr proc = HalconAPI.PreCall(2119);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out height);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out width);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out ratio);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)regions);
        }

        /// <summary>Compute the width, height, and aspect ratio of the enclosing rectangle parallel to the coordinate axes of contours or polygons.</summary>
        /// <param name="XLD">Contours or polygons to be examined.</param>
        /// <param name="height">Height of the enclosing rectangle.</param>
        /// <param name="width">Width of the enclosing rectangle.</param>
        /// <param name="ratio">Aspect ratio of the enclosing rectangle.</param>
        public static void HeightWidthRatioXld(
          HObject XLD,
          out HTuple height,
          out HTuple width,
          out HTuple ratio)
        {
            IntPtr proc = HalconAPI.PreCall(2120);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out height);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out width);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out ratio);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)XLD);
        }

        /// <summary>Insert objects into an iconic object tuple.</summary>
        /// <param name="objects">Input object tuple.</param>
        /// <param name="objectsInsert">Object tuple to insert.</param>
        /// <param name="objectsExtended">Extended object tuple.</param>
        /// <param name="index">Index to insert objects.</param>
        public static void InsertObj(
          HObject objects,
          HObject objectsInsert,
          out HObject objectsExtended,
          HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(2121);
            HalconAPI.Store(proc, 1, (HObjectBase)objects);
            HalconAPI.Store(proc, 2, (HObjectBase)objectsInsert);
            HalconAPI.Store(proc, 0, index);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(index);
            int procResult = HObject.LoadNew(proc, 1, err, out objectsExtended);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects);
            GC.KeepAlive((object)objectsInsert);
        }

        /// <summary>Read a deep-learning-based classifier from a file.</summary>
        /// <param name="fileName">File name. Default: "pretrained_dl_classifier_compact.hdl"</param>
        /// <param name="DLClassifierHandle">Handle of the deep learning classifier.</param>
        public static void ReadDlClassifier(HTuple fileName, out HTuple DLClassifierHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2122);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out DLClassifierHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Read a structured light model from a file.</summary>
        /// <param name="fileName">File name.</param>
        /// <param name="structuredLightModel">Handle of the structured light model.</param>
        public static void ReadStructuredLightModel(HTuple fileName, out HTuple structuredLightModel)
        {
            IntPtr proc = HalconAPI.PreCall(2123);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out structuredLightModel);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Remove objects from an iconic object tuple.</summary>
        /// <param name="objects">Input object tuple.</param>
        /// <param name="objectsReduced">Remaining object tuple.</param>
        /// <param name="index">Indices of the objects to be removed.</param>
        public static void RemoveObj(HObject objects, out HObject objectsReduced, HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(2124);
            HalconAPI.Store(proc, 1, (HObjectBase)objects);
            HalconAPI.Store(proc, 0, index);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(index);
            int procResult = HObject.LoadNew(proc, 1, err, out objectsReduced);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects);
        }

        /// <summary>Replaces one or more elements of an iconic object tuple.</summary>
        /// <param name="objects">Iconic Input Object.</param>
        /// <param name="objectsReplace">Element(s) to replace.</param>
        /// <param name="replaced">Tuple with replaced elements.</param>
        /// <param name="index">Index/Indices of elements to be replaced.</param>
        public static void ReplaceObj(
          HObject objects,
          HObject objectsReplace,
          out HObject replaced,
          HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(2125);
            HalconAPI.Store(proc, 1, (HObjectBase)objects);
            HalconAPI.Store(proc, 2, (HObjectBase)objectsReplace);
            HalconAPI.Store(proc, 0, index);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(index);
            int procResult = HObject.LoadNew(proc, 1, err, out replaced);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)objects);
            GC.KeepAlive((object)objectsReplace);
        }

        /// <summary>Serialize a deep-learning-based classifier.</summary>
        /// <param name="DLClassifierHandle">Handle of the deep-learning-based classifier.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeDlClassifier(
          HTuple DLClassifierHandle,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2126);
            HalconAPI.Store(proc, 0, DLClassifierHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(DLClassifierHandle);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Serialize a structured light model.</summary>
        /// <param name="structuredLightModel">Handle of the structured light model.</param>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public static void SerializeStructuredLightModel(
          HTuple structuredLightModel,
          out HTuple serializedItemHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2127);
            HalconAPI.Store(proc, 0, structuredLightModel);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(structuredLightModel);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out serializedItemHandle);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set the parameters of the deep-learning-based classifier.</summary>
        /// <param name="DLClassifierHandle">Handle of the deep-learning-based classifier.</param>
        /// <param name="genParamName">Name of the generic parameter. Default: "classes"</param>
        /// <param name="genParamValue">Value of the generic parameter. Default: ["class_1","class_2","class_3"]</param>
        public static void SetDlClassifierParam(
          HTuple DLClassifierHandle,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2128);
            HalconAPI.Store(proc, 0, DLClassifierHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(DLClassifierHandle);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set a timeout for an operator. </summary>
        /// <param name="operatorName">Operator for which the timeout shall be set.</param>
        /// <param name="timeout">Timeout in seconds. Default: 1</param>
        /// <param name="mode">Timeout mode to be set. Default: "cancel"</param>
        public static void SetOperatorTimeout(HTuple operatorName, HTuple timeout, HTuple mode)
        {
            IntPtr proc = HalconAPI.PreCall(2129);
            HalconAPI.Store(proc, 0, operatorName);
            HalconAPI.Store(proc, 1, timeout);
            HalconAPI.Store(proc, 2, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(operatorName);
            HalconAPI.UnpinTuple(timeout);
            HalconAPI.UnpinTuple(mode);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Set parameters of a structured light model.</summary>
        /// <param name="structuredLightModel">Handle of the structured light model.</param>
        /// <param name="genParamName">Name of the model parameter to be adjusted. Default: "min_stripe_width"</param>
        /// <param name="genParamValue">New value of the model parameter. Default: 32</param>
        public static void SetStructuredLightModelParam(
          HTuple structuredLightModel,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2130);
            HalconAPI.Store(proc, 0, structuredLightModel);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(structuredLightModel);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Perform a training step of a deep-learning-based classifier on a batch of  images.</summary>
        /// <param name="batchImages">Images comprising the batch.</param>
        /// <param name="DLClassifierHandle">Handle of the deep-learning-based classifier.</param>
        /// <param name="batchLabels">Corresponding labels for each of the images. Default: []</param>
        /// <param name="DLClassifierTrainResultHandle">Handle of the training results from the  deep-learning-based classifier.</param>
        public static void TrainDlClassifierBatch(
          HObject batchImages,
          HTuple DLClassifierHandle,
          HTuple batchLabels,
          out HTuple DLClassifierTrainResultHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2131);
            HalconAPI.Store(proc, 1, (HObjectBase)batchImages);
            HalconAPI.Store(proc, 0, DLClassifierHandle);
            HalconAPI.Store(proc, 1, batchLabels);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(DLClassifierHandle);
            HalconAPI.UnpinTuple(batchLabels);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out DLClassifierTrainResultHandle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)batchImages);
        }

        /// <summary>Write a deep-learning-based classifier in a file.</summary>
        /// <param name="DLClassifierHandle">Handle of the deep-learning-based classifier.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteDlClassifier(HTuple DLClassifierHandle, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(2132);
            HalconAPI.Store(proc, 0, DLClassifierHandle);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(DLClassifierHandle);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }

        /// <summary>Write a structured light model to a file.</summary>
        /// <param name="structuredLightModel">Handle of the structured light model.</param>
        /// <param name="fileName">File name.</param>
        public static void WriteStructuredLightModel(HTuple structuredLightModel, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(2133);
            HalconAPI.Store(proc, 0, structuredLightModel);
            HalconAPI.Store(proc, 1, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(structuredLightModel);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
        }
    }
}
