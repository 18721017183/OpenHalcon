using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;

namespace HalconDotNet
{
    [Serializable]
    public class HImage : HObject, ISerializable, ICloneable
    {
        /// <summary>Create an uninitialized iconic object</summary>
        public HImage()
          : base(HObjectBase.UNDEF, false)
        {
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public HImage(IntPtr key)
          : this(key, true)
        {
            this.AssertObjectClass();
            GC.KeepAlive((object)this);
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public HImage(IntPtr key, bool copy)
          : base(key, copy)
        {
            this.AssertObjectClass();
            GC.KeepAlive((object)this);
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public HImage(HObject obj)
          : base(obj)
        {
            this.AssertObjectClass();
            GC.KeepAlive((object)this);
        }

        private void AssertObjectClass()
        {
            HalconAPI.AssertObjectClass(this.key, "image");
        }

        /// <summary>Returns the iconic object(s) at the specified index</summary>
        public HImage this[HTuple index]
        {
            get
            {
                return this.SelectObj(index);
            }
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static int LoadNew(IntPtr proc, int parIndex, int err, out HImage obj)
        {
            obj = new HImage(HObjectBase.UNDEF);
            return obj.Load(proc, parIndex, err);
        }

        /// <summary>
        ///   Create an image from a pointer to the pixels.
        ///   Modified instance represents: Created image with new image matrix.
        /// </summary>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        /// <param name="pixelPointer">Pointer to first gray value.</param>
        public HImage(string type, int width, int height, IntPtr pixelPointer)
        {
            IntPtr proc = HalconAPI.PreCall(606);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.StoreI(proc, 1, width);
            HalconAPI.StoreI(proc, 2, height);
            HalconAPI.StoreIP(proc, 3, pixelPointer);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Create an image with constant gray value.
        ///   Modified instance represents: Created image with new image matrix.
        /// </summary>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        public HImage(string type, int width, int height)
        {
            IntPtr proc = HalconAPI.PreCall(607);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.StoreI(proc, 1, width);
            HalconAPI.StoreI(proc, 2, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Read an image with different file formats.
        ///   Modified instance represents: Read image.
        /// </summary>
        /// <param name="fileName">Name of the image to be read. Default: "printer_chip/printer_chip_01"</param>
        public HImage(HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1658);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Read an image with different file formats.
        ///   Modified instance represents: Read image.
        /// </summary>
        /// <param name="fileName">Name of the image to be read. Default: "printer_chip/printer_chip_01"</param>
        public HImage(string fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1658);
            HalconAPI.StoreS(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
        {
            HSerializedItem hserializedItem = this.SerializeImage();
            byte[] numArray = (byte[])hserializedItem;
            hserializedItem.Dispose();
            info.AddValue("data", (object)numArray, typeof(byte[]));
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public HImage(SerializationInfo info, StreamingContext context)
        {
            HSerializedItem serializedItemHandle = new HSerializedItem((byte[])info.GetValue("data", typeof(byte[])));
            this.DeserializeImage(serializedItemHandle);
            serializedItemHandle.Dispose();
        }

        public new void Serialize(Stream stream)
        {
            this.SerializeImage().Serialize(stream);
        }

        public static HImage Deserialize(Stream stream)
        {
            HImage himage = new HImage();
            himage.DeserializeImage(HSerializedItem.Deserialize(stream));
            return himage;
        }

        object ICloneable.Clone()
        {
            return (object)this.Clone();
        }

        public HImage Clone()
        {
            HSerializedItem serializedItemHandle = this.SerializeImage();
            HImage himage = new HImage();
            himage.DeserializeImage(serializedItemHandle);
            serializedItemHandle.Dispose();
            return himage;
        }

        /// <summary>Inverts an image</summary>
        public static HImage operator -(HImage image)
        {
            return image.InvertImage();
        }

        /// <summary>Adds two images</summary>
        public static HImage operator +(HImage image1, HImage image2)
        {
            return image1.AddImage(image2, 1.0, 0.0);
        }

        /// <summary>Subtracts image2 from image1</summary>
        public static HImage operator -(HImage image1, HImage image2)
        {
            return image1.SubImage(image2, 1.0, 0.0);
        }

        /// <summary>Multiplies two images</summary>
        public static HImage operator *(HImage image1, HImage image2)
        {
            return image1.MultImage(image2, 1.0, 0.0);
        }

        /// <summary>Adds a constant gray value offset</summary>
        public static HImage operator +(HImage image, double add)
        {
            return image.ScaleImage(1.0, add);
        }

        /// <summary>Adds a constant gray value offset</summary>
        public static HImage operator +(double add, HImage image)
        {
            return image.ScaleImage(1.0, add);
        }

        /// <summary>Subtracts a constant gray value offset</summary>
        public static HImage operator -(HImage image, double sub)
        {
            return image.ScaleImage(1.0, -sub);
        }

        /// <summary>Scales an image by the specified factor</summary>
        public static HImage operator *(HImage image, double mult)
        {
            return image.ScaleImage(mult, 0.0);
        }

        /// <summary>Scales an image by the specified factor</summary>
        public static HImage operator *(double mult, HImage image)
        {
            return image.ScaleImage(mult, 0.0);
        }

        /// <summary>Scales an image by the specified divisor</summary>
        public static HImage operator /(HImage image, double div)
        {
            return image.ScaleImage(1.0 / div, 0.0);
        }

        /// <summary>Segment image using dynamic threshold</summary>
        public static HRegion operator >=(HImage image1, HImage image2)
        {
            return image1.DynThreshold(image2, 0.0, "light");
        }

        /// <summary>Segment image using dynamic threshold</summary>
        public static HRegion operator <=(HImage image1, HImage image2)
        {
            return image1.DynThreshold(image2, 0.0, "dark");
        }

        /// <summary>Segment image using constant threshold</summary>
        public static HRegion operator >=(HImage image, double threshold)
        {
            return image.Threshold(threshold, double.MaxValue);
        }

        /// <summary>Segment image using constant threshold</summary>
        public static HRegion operator <=(HImage image, double threshold)
        {
            return image.Threshold(double.MinValue, threshold);
        }

        /// <summary>Segment image using constant threshold</summary>
        public static HRegion operator >=(double threshold, HImage image)
        {
            return image.Threshold(double.MinValue, threshold);
        }

        /// <summary>Segment image using constant threshold</summary>
        public static HRegion operator <=(double threshold, HImage image)
        {
            return image.Threshold(threshold, double.MaxValue);
        }

        /// <summary>Reduces the domain of an image</summary>
        public static HImage operator &(HImage image, HRegion region)
        {
            return image.ReduceDomain(region);
        }

        /// <summary>Returns the domain of an image</summary>
        public static implicit operator HRegion(HImage image)
        {
            return image.GetDomain();
        }

        /// <summary>
        ///   Image restoration by Wiener filtering.
        ///   Instance represents: Corrupted image.
        /// </summary>
        /// <param name="psf">impulse response (PSF) of degradation (in spatial domain).</param>
        /// <param name="noiseRegion">Region for noise estimation.</param>
        /// <param name="maskWidth">Width of filter mask. Default: 3</param>
        /// <param name="maskHeight">Height of filter mask. Default: 3</param>
        /// <returns>Restored image.</returns>
        public HImage WienerFilterNi(
          HImage psf,
          HRegion noiseRegion,
          int maskWidth,
          int maskHeight)
        {
            IntPtr proc = HalconAPI.PreCall(75);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)psf);
            HalconAPI.Store(proc, 3, (HObjectBase)noiseRegion);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)psf);
            GC.KeepAlive((object)noiseRegion);
            return himage;
        }

        /// <summary>
        ///   Image restoration by Wiener filtering.
        ///   Instance represents: Corrupted image.
        /// </summary>
        /// <param name="psf">impulse response (PSF) of degradation (in spatial domain).</param>
        /// <param name="filteredImage">Smoothed version of corrupted image.</param>
        /// <returns>Restored image.</returns>
        public HImage WienerFilter(HImage psf, HImage filteredImage)
        {
            IntPtr proc = HalconAPI.PreCall(76);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)psf);
            HalconAPI.Store(proc, 3, (HObjectBase)filteredImage);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)psf);
            GC.KeepAlive((object)filteredImage);
            return himage;
        }

        /// <summary>
        ///   Generate an impulse response of a (linearly) motion blurring.
        ///   Modified instance represents: Impulse response of motion-blur.
        /// </summary>
        /// <param name="PSFwidth">Width of impulse response image. Default: 256</param>
        /// <param name="PSFheight">Height of impulse response image. Default: 256</param>
        /// <param name="blurring">Degree of motion-blur. Default: 20.0</param>
        /// <param name="angle">Angle between direction of motion and x-axis (anticlockwise). Default: 0</param>
        /// <param name="type">PSF prototype resp. type of motion. Default: 3</param>
        public void GenPsfMotion(int PSFwidth, int PSFheight, double blurring, int angle, int type)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(77);
            HalconAPI.StoreI(proc, 0, PSFwidth);
            HalconAPI.StoreI(proc, 1, PSFheight);
            HalconAPI.StoreD(proc, 2, blurring);
            HalconAPI.StoreI(proc, 3, angle);
            HalconAPI.StoreI(proc, 4, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Simulation of (linearly) motion blur.
        ///   Instance represents: image to be blurred.
        /// </summary>
        /// <param name="blurring">extent of blurring. Default: 20.0</param>
        /// <param name="angle">Angle between direction of motion and x-axis (anticlockwise). Default: 0</param>
        /// <param name="type">impulse response of motion blur. Default: 3</param>
        /// <returns>motion blurred image.</returns>
        public HImage SimulateMotion(double blurring, int angle, int type)
        {
            IntPtr proc = HalconAPI.PreCall(78);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, blurring);
            HalconAPI.StoreI(proc, 1, angle);
            HalconAPI.StoreI(proc, 2, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Generate an impulse response of an uniform out-of-focus blurring.
        ///   Modified instance represents: Impulse response of uniform out-of-focus blurring.
        /// </summary>
        /// <param name="PSFwidth">Width of result image. Default: 256</param>
        /// <param name="PSFheight">Height of result image. Default: 256</param>
        /// <param name="blurring">Degree of Blurring. Default: 5.0</param>
        public void GenPsfDefocus(int PSFwidth, int PSFheight, double blurring)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(79);
            HalconAPI.StoreI(proc, 0, PSFwidth);
            HalconAPI.StoreI(proc, 1, PSFheight);
            HalconAPI.StoreD(proc, 2, blurring);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Simulate an uniform out-of-focus blurring of an image.
        ///   Instance represents: Image to blur.
        /// </summary>
        /// <param name="blurring">Degree of blurring. Default: 5.0</param>
        /// <returns>Blurred image.</returns>
        public HImage SimulateDefocus(double blurring)
        {
            IntPtr proc = HalconAPI.PreCall(80);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, blurring);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compare an image to a variation model.
        ///   Instance represents: Image of the object to be compared.
        /// </summary>
        /// <param name="modelID">ID of the variation model.</param>
        /// <param name="mode">Method used for comparing the variation model. Default: "absolute"</param>
        /// <returns>Region containing the points that differ substantially from the model.</returns>
        public HRegion CompareExtVariationModel(HVariationModel modelID, string mode)
        {
            IntPtr proc = HalconAPI.PreCall(87);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreS(proc, 1, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
            return hregion;
        }

        /// <summary>
        ///   Compare an image to a variation model.
        ///   Instance represents: Image of the object to be compared.
        /// </summary>
        /// <param name="modelID">ID of the variation model.</param>
        /// <returns>Region containing the points that differ substantially from the model.</returns>
        public HRegion CompareVariationModel(HVariationModel modelID)
        {
            IntPtr proc = HalconAPI.PreCall(88);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
            return hregion;
        }

        /// <summary>
        ///   Train a variation model.
        ///   Instance represents: Images of the object to be trained.
        /// </summary>
        /// <param name="modelID">ID of the variation model.</param>
        public void TrainVariationModel(HVariationModel modelID)
        {
            IntPtr proc = HalconAPI.PreCall(91);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Compute a projective transformation matrix and the radial distortion coefficient between two images by finding correspondences between points based on known approximations of the projective transformation matrix and the radial distortion coefficient.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="grayMatchMethod">Gray value match metric. Default: "ncc"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="homMat2DGuide">Approximation of the homogeneous projective transformation matrix between the two images.</param>
        /// <param name="kappaGuide">Approximation of the radial distortion coefficient in the two images.</param>
        /// <param name="distanceTolerance">Tolerance for the matching search window. Default: 20.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 0.7</param>
        /// <param name="estimationMethod">Algorithm for the computation of the projective transformation matrix. Default: "gold_standard"</param>
        /// <param name="distanceThreshold">Threshold for transformation consistency check. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="kappa">Computed radial distortion coefficient.</param>
        /// <param name="error">Root-Mean-Square transformation error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed homogeneous projective transformation matrix.</returns>
        public HHomMat2D ProjMatchPointsDistortionRansacGuided(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          HHomMat2D homMat2DGuide,
          double kappaGuide,
          double distanceTolerance,
          HTuple matchThreshold,
          string estimationMethod,
          HTuple distanceThreshold,
          int randSeed,
          out double kappa,
          out double error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(256);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.Store(proc, 6, (HData)homMat2DGuide);
            HalconAPI.StoreD(proc, 7, kappaGuide);
            HalconAPI.StoreD(proc, 8, distanceTolerance);
            HalconAPI.Store(proc, 9, matchThreshold);
            HalconAPI.StoreS(proc, 10, estimationMethod);
            HalconAPI.Store(proc, 11, distanceThreshold);
            HalconAPI.StoreI(proc, 12, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple((HTuple)((HData)homMat2DGuide));
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(distanceThreshold);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out kappa);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute a projective transformation matrix and the radial distortion coefficient between two images by finding correspondences between points based on known approximations of the projective transformation matrix and the radial distortion coefficient.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="grayMatchMethod">Gray value match metric. Default: "ncc"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="homMat2DGuide">Approximation of the homogeneous projective transformation matrix between the two images.</param>
        /// <param name="kappaGuide">Approximation of the radial distortion coefficient in the two images.</param>
        /// <param name="distanceTolerance">Tolerance for the matching search window. Default: 20.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 0.7</param>
        /// <param name="estimationMethod">Algorithm for the computation of the projective transformation matrix. Default: "gold_standard"</param>
        /// <param name="distanceThreshold">Threshold for transformation consistency check. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="kappa">Computed radial distortion coefficient.</param>
        /// <param name="error">Root-Mean-Square transformation error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed homogeneous projective transformation matrix.</returns>
        public HHomMat2D ProjMatchPointsDistortionRansacGuided(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          HHomMat2D homMat2DGuide,
          double kappaGuide,
          double distanceTolerance,
          int matchThreshold,
          string estimationMethod,
          double distanceThreshold,
          int randSeed,
          out double kappa,
          out double error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(256);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.Store(proc, 6, (HData)homMat2DGuide);
            HalconAPI.StoreD(proc, 7, kappaGuide);
            HalconAPI.StoreD(proc, 8, distanceTolerance);
            HalconAPI.StoreI(proc, 9, matchThreshold);
            HalconAPI.StoreS(proc, 10, estimationMethod);
            HalconAPI.StoreD(proc, 11, distanceThreshold);
            HalconAPI.StoreI(proc, 12, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple((HTuple)((HData)homMat2DGuide));
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out kappa);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute a projective transformation matrix between two images and the radial distortion coefficient by automatically finding correspondences between points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="grayMatchMethod">Gray value match metric. Default: "ncc"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate offset of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate offset of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative rotation of the second image with respect to the first image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 0.7</param>
        /// <param name="estimationMethod">Algorithm for the computation of the projective transformation matrix. Default: "gold_standard"</param>
        /// <param name="distanceThreshold">Threshold for the transformation consistency check. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="kappa">Computed radial distortion coefficient.</param>
        /// <param name="error">Root-Mean-Square transformation error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed homogeneous projective transformation matrix.</returns>
        public HHomMat2D ProjMatchPointsDistortionRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          string estimationMethod,
          HTuple distanceThreshold,
          int randSeed,
          out double kappa,
          out double error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(257);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.StoreI(proc, 6, rowMove);
            HalconAPI.StoreI(proc, 7, colMove);
            HalconAPI.StoreI(proc, 8, rowTolerance);
            HalconAPI.StoreI(proc, 9, colTolerance);
            HalconAPI.Store(proc, 10, rotation);
            HalconAPI.Store(proc, 11, matchThreshold);
            HalconAPI.StoreS(proc, 12, estimationMethod);
            HalconAPI.Store(proc, 13, distanceThreshold);
            HalconAPI.StoreI(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(distanceThreshold);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out kappa);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute a projective transformation matrix between two images and the radial distortion coefficient by automatically finding correspondences between points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="grayMatchMethod">Gray value match metric. Default: "ncc"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate offset of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate offset of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative rotation of the second image with respect to the first image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 0.7</param>
        /// <param name="estimationMethod">Algorithm for the computation of the projective transformation matrix. Default: "gold_standard"</param>
        /// <param name="distanceThreshold">Threshold for the transformation consistency check. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="kappa">Computed radial distortion coefficient.</param>
        /// <param name="error">Root-Mean-Square transformation error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed homogeneous projective transformation matrix.</returns>
        public HHomMat2D ProjMatchPointsDistortionRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          double rotation,
          int matchThreshold,
          string estimationMethod,
          double distanceThreshold,
          int randSeed,
          out double kappa,
          out double error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(257);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.StoreI(proc, 6, rowMove);
            HalconAPI.StoreI(proc, 7, colMove);
            HalconAPI.StoreI(proc, 8, rowTolerance);
            HalconAPI.StoreI(proc, 9, colTolerance);
            HalconAPI.StoreD(proc, 10, rotation);
            HalconAPI.StoreI(proc, 11, matchThreshold);
            HalconAPI.StoreS(proc, 12, estimationMethod);
            HalconAPI.StoreD(proc, 13, distanceThreshold);
            HalconAPI.StoreI(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out kappa);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute a projective transformation matrix between two images by finding correspondences between points based on a known approximation of the projective transformation matrix.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="homMat2DGuide">Approximation of the Homogeneous projective transformation matrix between the two images.</param>
        /// <param name="distanceTolerance">Tolerance for the matching search window. Default: 20.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Transformation matrix estimation algorithm. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Threshold for transformation consistency check. Default: 0.2</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Homogeneous projective transformation matrix.</returns>
        public HHomMat2D ProjMatchPointsRansacGuided(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          HHomMat2D homMat2DGuide,
          double distanceTolerance,
          HTuple matchThreshold,
          string estimationMethod,
          double distanceThreshold,
          int randSeed,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(258);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.Store(proc, 6, (HData)homMat2DGuide);
            HalconAPI.StoreD(proc, 7, distanceTolerance);
            HalconAPI.Store(proc, 8, matchThreshold);
            HalconAPI.StoreS(proc, 9, estimationMethod);
            HalconAPI.StoreD(proc, 10, distanceThreshold);
            HalconAPI.StoreI(proc, 11, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple((HTuple)((HData)homMat2DGuide));
            HalconAPI.UnpinTuple(matchThreshold);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out points1);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute a projective transformation matrix between two images by finding correspondences between points based on a known approximation of the projective transformation matrix.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="homMat2DGuide">Approximation of the Homogeneous projective transformation matrix between the two images.</param>
        /// <param name="distanceTolerance">Tolerance for the matching search window. Default: 20.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Transformation matrix estimation algorithm. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Threshold for transformation consistency check. Default: 0.2</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Homogeneous projective transformation matrix.</returns>
        public HHomMat2D ProjMatchPointsRansacGuided(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          HHomMat2D homMat2DGuide,
          double distanceTolerance,
          int matchThreshold,
          string estimationMethod,
          double distanceThreshold,
          int randSeed,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(258);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.Store(proc, 6, (HData)homMat2DGuide);
            HalconAPI.StoreD(proc, 7, distanceTolerance);
            HalconAPI.StoreI(proc, 8, matchThreshold);
            HalconAPI.StoreS(proc, 9, estimationMethod);
            HalconAPI.StoreD(proc, 10, distanceThreshold);
            HalconAPI.StoreI(proc, 11, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple((HTuple)((HData)homMat2DGuide));
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out points1);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute a projective transformation matrix between two images by finding correspondences between points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 256</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 256</param>
        /// <param name="rotation">Range of rotation angles. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Transformation matrix estimation algorithm. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Threshold for transformation consistency check. Default: 0.2</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Homogeneous projective transformation matrix.</returns>
        public HHomMat2D ProjMatchPointsRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          string estimationMethod,
          double distanceThreshold,
          int randSeed,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(259);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.StoreI(proc, 6, rowMove);
            HalconAPI.StoreI(proc, 7, colMove);
            HalconAPI.StoreI(proc, 8, rowTolerance);
            HalconAPI.StoreI(proc, 9, colTolerance);
            HalconAPI.Store(proc, 10, rotation);
            HalconAPI.Store(proc, 11, matchThreshold);
            HalconAPI.StoreS(proc, 12, estimationMethod);
            HalconAPI.StoreD(proc, 13, distanceThreshold);
            HalconAPI.StoreI(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out points1);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute a projective transformation matrix between two images by finding correspondences between points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 256</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 256</param>
        /// <param name="rotation">Range of rotation angles. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Transformation matrix estimation algorithm. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Threshold for transformation consistency check. Default: 0.2</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Homogeneous projective transformation matrix.</returns>
        public HHomMat2D ProjMatchPointsRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          double rotation,
          int matchThreshold,
          string estimationMethod,
          double distanceThreshold,
          int randSeed,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(259);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.StoreI(proc, 6, rowMove);
            HalconAPI.StoreI(proc, 7, colMove);
            HalconAPI.StoreI(proc, 8, rowTolerance);
            HalconAPI.StoreI(proc, 9, colTolerance);
            HalconAPI.StoreD(proc, 10, rotation);
            HalconAPI.StoreI(proc, 11, matchThreshold);
            HalconAPI.StoreS(proc, 12, estimationMethod);
            HalconAPI.StoreD(proc, 13, distanceThreshold);
            HalconAPI.StoreI(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out points1);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Receive an image over a socket connection.
        ///   Modified instance represents: Received image.
        /// </summary>
        /// <param name="socket">Socket number.</param>
        public void ReceiveImage(HSocket socket)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(325);
            HalconAPI.Store(proc, 0, (HTool)socket);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)socket);
        }

        /// <summary>
        ///   Send an image over a socket connection.
        ///   Instance represents: Image to be sent.
        /// </summary>
        /// <param name="socket">Socket number.</param>
        public void SendImage(HSocket socket)
        {
            IntPtr proc = HalconAPI.PreCall(326);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)socket);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)socket);
        }

        /// <summary>
        ///   Compute the distance values for a rectified stereo image pair using multi-scanline optimization.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Score of the calculated disparity.</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: -30</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="surfaceSmoothing">Smoothing of surfaces. Default: 50</param>
        /// <param name="edgeSmoothing">Smoothing of edges. Default: 50</param>
        /// <param name="genParamName">Parameter name(s) for the multi-scanline algorithm. Default: []</param>
        /// <param name="genParamValue">Parameter value(s) for the multi-scanline algorithm. Default: []</param>
        /// <returns>Distance image.</returns>
        public HImage BinocularDistanceMs(
          HImage imageRect2,
          out HImage score,
          HCamPar camParamRect1,
          HCamPar camParamRect2,
          HPose relPoseRect,
          int minDisparity,
          int maxDisparity,
          int surfaceSmoothing,
          int edgeSmoothing,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(346);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, (HData)camParamRect1);
            HalconAPI.Store(proc, 1, (HData)camParamRect2);
            HalconAPI.Store(proc, 2, (HData)relPoseRect);
            HalconAPI.StoreI(proc, 3, minDisparity);
            HalconAPI.StoreI(proc, 4, maxDisparity);
            HalconAPI.StoreI(proc, 5, surfaceSmoothing);
            HalconAPI.StoreI(proc, 6, edgeSmoothing);
            HalconAPI.Store(proc, 7, genParamName);
            HalconAPI.Store(proc, 8, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect1));
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect2));
            HalconAPI.UnpinTuple((HTuple)((HData)relPoseRect));
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Compute the distance values for a rectified stereo image pair using multi-scanline optimization.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Score of the calculated disparity.</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: -30</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="surfaceSmoothing">Smoothing of surfaces. Default: 50</param>
        /// <param name="edgeSmoothing">Smoothing of edges. Default: 50</param>
        /// <param name="genParamName">Parameter name(s) for the multi-scanline algorithm. Default: []</param>
        /// <param name="genParamValue">Parameter value(s) for the multi-scanline algorithm. Default: []</param>
        /// <returns>Distance image.</returns>
        public HImage BinocularDistanceMs(
          HImage imageRect2,
          out HImage score,
          HCamPar camParamRect1,
          HCamPar camParamRect2,
          HPose relPoseRect,
          int minDisparity,
          int maxDisparity,
          int surfaceSmoothing,
          int edgeSmoothing,
          string genParamName,
          string genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(346);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, (HData)camParamRect1);
            HalconAPI.Store(proc, 1, (HData)camParamRect2);
            HalconAPI.Store(proc, 2, (HData)relPoseRect);
            HalconAPI.StoreI(proc, 3, minDisparity);
            HalconAPI.StoreI(proc, 4, maxDisparity);
            HalconAPI.StoreI(proc, 5, surfaceSmoothing);
            HalconAPI.StoreI(proc, 6, edgeSmoothing);
            HalconAPI.StoreS(proc, 7, genParamName);
            HalconAPI.StoreS(proc, 8, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect1));
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect2));
            HalconAPI.UnpinTuple((HTuple)((HData)relPoseRect));
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Compute the disparities of a rectified stereo image pair using multi-scanline optimization.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Score of the calculated disparity.</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: -30</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="surfaceSmoothing">Smoothing of surfaces. Default: 50</param>
        /// <param name="edgeSmoothing">Smoothing of edges. Default: 50</param>
        /// <param name="genParamName">Parameter name(s) for the multi-scanline algorithm. Default: []</param>
        /// <param name="genParamValue">Parameter value(s) for the multi-scanline algorithm. Default: []</param>
        /// <returns>Disparity map.</returns>
        public HImage BinocularDisparityMs(
          HImage imageRect2,
          out HImage score,
          int minDisparity,
          int maxDisparity,
          int surfaceSmoothing,
          int edgeSmoothing,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(347);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.StoreI(proc, 0, minDisparity);
            HalconAPI.StoreI(proc, 1, maxDisparity);
            HalconAPI.StoreI(proc, 2, surfaceSmoothing);
            HalconAPI.StoreI(proc, 3, edgeSmoothing);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Compute the disparities of a rectified stereo image pair using multi-scanline optimization.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Score of the calculated disparity.</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: -30</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="surfaceSmoothing">Smoothing of surfaces. Default: 50</param>
        /// <param name="edgeSmoothing">Smoothing of edges. Default: 50</param>
        /// <param name="genParamName">Parameter name(s) for the multi-scanline algorithm. Default: []</param>
        /// <param name="genParamValue">Parameter value(s) for the multi-scanline algorithm. Default: []</param>
        /// <returns>Disparity map.</returns>
        public HImage BinocularDisparityMs(
          HImage imageRect2,
          out HImage score,
          int minDisparity,
          int maxDisparity,
          int surfaceSmoothing,
          int edgeSmoothing,
          string genParamName,
          string genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(347);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.StoreI(proc, 0, minDisparity);
            HalconAPI.StoreI(proc, 1, maxDisparity);
            HalconAPI.StoreI(proc, 2, surfaceSmoothing);
            HalconAPI.StoreI(proc, 3, edgeSmoothing);
            HalconAPI.StoreS(proc, 4, genParamName);
            HalconAPI.StoreS(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Compute the distance values for a rectified stereo image pair using multigrid methods.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Score of the calculated disparity if CalculateScore is set to 'true'.</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <param name="grayConstancy">Weight of the gray value constancy in the data term. Default: 1.0</param>
        /// <param name="gradientConstancy">Weight of the gradient constancy in the data term. Default: 30.0</param>
        /// <param name="smoothness">Weight of the smoothness term in relation to the data term. Default: 5.0</param>
        /// <param name="initialGuess">Initial guess of the disparity. Default: 0.0</param>
        /// <param name="calculateScore">Should the quality measure be returned in Score? Default: "false"</param>
        /// <param name="MGParamName">Parameter name(s) for the multigrid algorithm. Default: "default_parameters"</param>
        /// <param name="MGParamValue">Parameter value(s) for the multigrid algorithm. Default: "fast_accurate"</param>
        /// <returns>Distance image.</returns>
        public HImage BinocularDistanceMg(
          HImage imageRect2,
          out HImage score,
          HCamPar camParamRect1,
          HCamPar camParamRect2,
          HPose relPoseRect,
          double grayConstancy,
          double gradientConstancy,
          double smoothness,
          double initialGuess,
          string calculateScore,
          HTuple MGParamName,
          HTuple MGParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(348);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, (HData)camParamRect1);
            HalconAPI.Store(proc, 1, (HData)camParamRect2);
            HalconAPI.Store(proc, 2, (HData)relPoseRect);
            HalconAPI.StoreD(proc, 3, grayConstancy);
            HalconAPI.StoreD(proc, 4, gradientConstancy);
            HalconAPI.StoreD(proc, 5, smoothness);
            HalconAPI.StoreD(proc, 6, initialGuess);
            HalconAPI.StoreS(proc, 7, calculateScore);
            HalconAPI.Store(proc, 8, MGParamName);
            HalconAPI.Store(proc, 9, MGParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect1));
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect2));
            HalconAPI.UnpinTuple((HTuple)((HData)relPoseRect));
            HalconAPI.UnpinTuple(MGParamName);
            HalconAPI.UnpinTuple(MGParamValue);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Compute the distance values for a rectified stereo image pair using multigrid methods.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Score of the calculated disparity if CalculateScore is set to 'true'.</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <param name="grayConstancy">Weight of the gray value constancy in the data term. Default: 1.0</param>
        /// <param name="gradientConstancy">Weight of the gradient constancy in the data term. Default: 30.0</param>
        /// <param name="smoothness">Weight of the smoothness term in relation to the data term. Default: 5.0</param>
        /// <param name="initialGuess">Initial guess of the disparity. Default: 0.0</param>
        /// <param name="calculateScore">Should the quality measure be returned in Score? Default: "false"</param>
        /// <param name="MGParamName">Parameter name(s) for the multigrid algorithm. Default: "default_parameters"</param>
        /// <param name="MGParamValue">Parameter value(s) for the multigrid algorithm. Default: "fast_accurate"</param>
        /// <returns>Distance image.</returns>
        public HImage BinocularDistanceMg(
          HImage imageRect2,
          out HImage score,
          HCamPar camParamRect1,
          HCamPar camParamRect2,
          HPose relPoseRect,
          double grayConstancy,
          double gradientConstancy,
          double smoothness,
          double initialGuess,
          string calculateScore,
          string MGParamName,
          string MGParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(348);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, (HData)camParamRect1);
            HalconAPI.Store(proc, 1, (HData)camParamRect2);
            HalconAPI.Store(proc, 2, (HData)relPoseRect);
            HalconAPI.StoreD(proc, 3, grayConstancy);
            HalconAPI.StoreD(proc, 4, gradientConstancy);
            HalconAPI.StoreD(proc, 5, smoothness);
            HalconAPI.StoreD(proc, 6, initialGuess);
            HalconAPI.StoreS(proc, 7, calculateScore);
            HalconAPI.StoreS(proc, 8, MGParamName);
            HalconAPI.StoreS(proc, 9, MGParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect1));
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect2));
            HalconAPI.UnpinTuple((HTuple)((HData)relPoseRect));
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Compute the disparities of a rectified stereo image pair using multigrid methods.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Score of the calculated disparity if CalculateScore is set to 'true'.</param>
        /// <param name="grayConstancy">Weight of the gray value constancy in the data term. Default: 1.0</param>
        /// <param name="gradientConstancy">Weight of the gradient constancy in the data term. Default: 30.0</param>
        /// <param name="smoothness">Weight of the smoothness term in relation to the data term. Default: 5.0</param>
        /// <param name="initialGuess">Initial guess of the disparity. Default: 0.0</param>
        /// <param name="calculateScore">Should the quality measure should be returned in Score? Default: "false"</param>
        /// <param name="MGParamName">Parameter name(s) for the multigrid algorithm. Default: "default_parameters"</param>
        /// <param name="MGParamValue">Parameter value(s) for the multigrid algorithm. Default: "fast_accurate"</param>
        /// <returns>Disparity map.</returns>
        public HImage BinocularDisparityMg(
          HImage imageRect2,
          out HImage score,
          double grayConstancy,
          double gradientConstancy,
          double smoothness,
          double initialGuess,
          string calculateScore,
          HTuple MGParamName,
          HTuple MGParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(349);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.StoreD(proc, 0, grayConstancy);
            HalconAPI.StoreD(proc, 1, gradientConstancy);
            HalconAPI.StoreD(proc, 2, smoothness);
            HalconAPI.StoreD(proc, 3, initialGuess);
            HalconAPI.StoreS(proc, 4, calculateScore);
            HalconAPI.Store(proc, 5, MGParamName);
            HalconAPI.Store(proc, 6, MGParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MGParamName);
            HalconAPI.UnpinTuple(MGParamValue);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Compute the disparities of a rectified stereo image pair using multigrid methods.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Score of the calculated disparity if CalculateScore is set to 'true'.</param>
        /// <param name="grayConstancy">Weight of the gray value constancy in the data term. Default: 1.0</param>
        /// <param name="gradientConstancy">Weight of the gradient constancy in the data term. Default: 30.0</param>
        /// <param name="smoothness">Weight of the smoothness term in relation to the data term. Default: 5.0</param>
        /// <param name="initialGuess">Initial guess of the disparity. Default: 0.0</param>
        /// <param name="calculateScore">Should the quality measure should be returned in Score? Default: "false"</param>
        /// <param name="MGParamName">Parameter name(s) for the multigrid algorithm. Default: "default_parameters"</param>
        /// <param name="MGParamValue">Parameter value(s) for the multigrid algorithm. Default: "fast_accurate"</param>
        /// <returns>Disparity map.</returns>
        public HImage BinocularDisparityMg(
          HImage imageRect2,
          out HImage score,
          double grayConstancy,
          double gradientConstancy,
          double smoothness,
          double initialGuess,
          string calculateScore,
          string MGParamName,
          string MGParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(349);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.StoreD(proc, 0, grayConstancy);
            HalconAPI.StoreD(proc, 1, gradientConstancy);
            HalconAPI.StoreD(proc, 2, smoothness);
            HalconAPI.StoreD(proc, 3, initialGuess);
            HalconAPI.StoreS(proc, 4, calculateScore);
            HalconAPI.StoreS(proc, 5, MGParamName);
            HalconAPI.StoreS(proc, 6, MGParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Compute the projective rectification of weakly calibrated binocular stereo images.
        ///   Modified instance represents: Image coding the rectification of the 1. image.
        /// </summary>
        /// <param name="FMatrix">Fundamental matrix.</param>
        /// <param name="covFMat">9x9 covariance matrix of the fundamental matrix. Default: []</param>
        /// <param name="width1">Width of the 1. image. Default: 512</param>
        /// <param name="height1">Height of the 1. image. Default: 512</param>
        /// <param name="width2">Width of the 2. image. Default: 512</param>
        /// <param name="height2">Height of the 2. image. Default: 512</param>
        /// <param name="subSampling">Subsampling factor. Default: 1</param>
        /// <param name="mapping">Type of mapping. Default: "no_map"</param>
        /// <param name="covFMatRect">9x9 covariance matrix of the rectified fundamental matrix.</param>
        /// <param name="h1">Projective transformation of the 1. image.</param>
        /// <param name="h2">Projective transformation of the 2. image.</param>
        /// <returns>Image coding the rectification of the 2. image.</returns>
        public HImage GenBinocularProjRectification(
          HHomMat2D FMatrix,
          HTuple covFMat,
          int width1,
          int height1,
          int width2,
          int height2,
          HTuple subSampling,
          string mapping,
          out HTuple covFMatRect,
          out HHomMat2D h1,
          out HHomMat2D h2)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(351);
            HalconAPI.Store(proc, 0, (HData)FMatrix);
            HalconAPI.Store(proc, 1, covFMat);
            HalconAPI.StoreI(proc, 2, width1);
            HalconAPI.StoreI(proc, 3, height1);
            HalconAPI.StoreI(proc, 4, width2);
            HalconAPI.StoreI(proc, 5, height2);
            HalconAPI.Store(proc, 6, subSampling);
            HalconAPI.StoreS(proc, 7, mapping);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)FMatrix));
            HalconAPI.UnpinTuple(covFMat);
            HalconAPI.UnpinTuple(subSampling);
            int err2 = this.Load(proc, 1, err1);
            HImage himage;
            int err3 = HImage.LoadNew(proc, 2, err2, out himage);
            int err4 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err3, out covFMatRect);
            int err5 = HHomMat2D.LoadNew(proc, 1, err4, out h1);
            int procResult = HHomMat2D.LoadNew(proc, 2, err5, out h2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute the projective rectification of weakly calibrated binocular stereo images.
        ///   Modified instance represents: Image coding the rectification of the 1. image.
        /// </summary>
        /// <param name="FMatrix">Fundamental matrix.</param>
        /// <param name="covFMat">9x9 covariance matrix of the fundamental matrix. Default: []</param>
        /// <param name="width1">Width of the 1. image. Default: 512</param>
        /// <param name="height1">Height of the 1. image. Default: 512</param>
        /// <param name="width2">Width of the 2. image. Default: 512</param>
        /// <param name="height2">Height of the 2. image. Default: 512</param>
        /// <param name="subSampling">Subsampling factor. Default: 1</param>
        /// <param name="mapping">Type of mapping. Default: "no_map"</param>
        /// <param name="covFMatRect">9x9 covariance matrix of the rectified fundamental matrix.</param>
        /// <param name="h1">Projective transformation of the 1. image.</param>
        /// <param name="h2">Projective transformation of the 2. image.</param>
        /// <returns>Image coding the rectification of the 2. image.</returns>
        public HImage GenBinocularProjRectification(
          HHomMat2D FMatrix,
          HTuple covFMat,
          int width1,
          int height1,
          int width2,
          int height2,
          int subSampling,
          string mapping,
          out HTuple covFMatRect,
          out HHomMat2D h1,
          out HHomMat2D h2)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(351);
            HalconAPI.Store(proc, 0, (HData)FMatrix);
            HalconAPI.Store(proc, 1, covFMat);
            HalconAPI.StoreI(proc, 2, width1);
            HalconAPI.StoreI(proc, 3, height1);
            HalconAPI.StoreI(proc, 4, width2);
            HalconAPI.StoreI(proc, 5, height2);
            HalconAPI.StoreI(proc, 6, subSampling);
            HalconAPI.StoreS(proc, 7, mapping);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)FMatrix));
            HalconAPI.UnpinTuple(covFMat);
            int err2 = this.Load(proc, 1, err1);
            HImage himage;
            int err3 = HImage.LoadNew(proc, 2, err2, out himage);
            int err4 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err3, out covFMatRect);
            int err5 = HHomMat2D.LoadNew(proc, 1, err4, out h1);
            int procResult = HHomMat2D.LoadNew(proc, 2, err5, out h2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute the fundamental matrix and the radial distortion coefficient for a pair of stereo images by automatically finding correspondences between image points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="grayMatchMethod">Gray value match metric. Default: "ncc"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate offset of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate offset of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative rotation of the second image with respect to the first image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 0.7</param>
        /// <param name="estimationMethod">Algorithm for the computation of the fundamental matrix and for special camera orientations. Default: "gold_standard"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="kappa">Computed radial distortion coefficient.</param>
        /// <param name="error">Root-Mean-Square epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed fundamental matrix.</returns>
        public HHomMat2D MatchFundamentalMatrixDistortionRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          string estimationMethod,
          HTuple distanceThreshold,
          int randSeed,
          out double kappa,
          out double error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(358);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.StoreI(proc, 6, rowMove);
            HalconAPI.StoreI(proc, 7, colMove);
            HalconAPI.StoreI(proc, 8, rowTolerance);
            HalconAPI.StoreI(proc, 9, colTolerance);
            HalconAPI.Store(proc, 10, rotation);
            HalconAPI.Store(proc, 11, matchThreshold);
            HalconAPI.StoreS(proc, 12, estimationMethod);
            HalconAPI.Store(proc, 13, distanceThreshold);
            HalconAPI.StoreI(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(distanceThreshold);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out kappa);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute the fundamental matrix and the radial distortion coefficient for a pair of stereo images by automatically finding correspondences between image points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Input points in image 1 (row coordinate).</param>
        /// <param name="cols1">Input points in image 1 (column coordinate).</param>
        /// <param name="rows2">Input points in image 2 (row coordinate).</param>
        /// <param name="cols2">Input points in image 2 (column coordinate).</param>
        /// <param name="grayMatchMethod">Gray value match metric. Default: "ncc"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate offset of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate offset of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative rotation of the second image with respect to the first image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 0.7</param>
        /// <param name="estimationMethod">Algorithm for the computation of the fundamental matrix and for special camera orientations. Default: "gold_standard"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="kappa">Computed radial distortion coefficient.</param>
        /// <param name="error">Root-Mean-Square epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed fundamental matrix.</returns>
        public HHomMat2D MatchFundamentalMatrixDistortionRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          double rotation,
          int matchThreshold,
          string estimationMethod,
          double distanceThreshold,
          int randSeed,
          out double kappa,
          out double error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(358);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.StoreI(proc, 6, rowMove);
            HalconAPI.StoreI(proc, 7, colMove);
            HalconAPI.StoreI(proc, 8, rowTolerance);
            HalconAPI.StoreI(proc, 9, colTolerance);
            HalconAPI.StoreD(proc, 10, rotation);
            HalconAPI.StoreI(proc, 11, matchThreshold);
            HalconAPI.StoreS(proc, 12, estimationMethod);
            HalconAPI.StoreD(proc, 13, distanceThreshold);
            HalconAPI.StoreI(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out kappa);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute the relative orientation between two cameras by automatically finding correspondences between image points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="camPar1">Parameters of the 1st camera.</param>
        /// <param name="camPar2">Parameters of the 2nd camera.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative orientation of the right image with respect to the left image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Algorithm for the computation of the relative pose and for special pose types. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="covRelPose">6x6 covariance matrix of the relative orientation.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed relative orientation of the cameras (3D pose).</returns>
        public HPose MatchRelPoseRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HCamPar camPar1,
          HCamPar camPar2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          string estimationMethod,
          HTuple distanceThreshold,
          int randSeed,
          out HTuple covRelPose,
          out HTuple error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(359);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, (HData)camPar1);
            HalconAPI.Store(proc, 5, (HData)camPar2);
            HalconAPI.StoreS(proc, 6, grayMatchMethod);
            HalconAPI.StoreI(proc, 7, maskSize);
            HalconAPI.StoreI(proc, 8, rowMove);
            HalconAPI.StoreI(proc, 9, colMove);
            HalconAPI.StoreI(proc, 10, rowTolerance);
            HalconAPI.StoreI(proc, 11, colTolerance);
            HalconAPI.Store(proc, 12, rotation);
            HalconAPI.Store(proc, 13, matchThreshold);
            HalconAPI.StoreS(proc, 14, estimationMethod);
            HalconAPI.Store(proc, 15, distanceThreshold);
            HalconAPI.StoreI(proc, 16, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple((HTuple)((HData)camPar1));
            HalconAPI.UnpinTuple((HTuple)((HData)camPar2));
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(distanceThreshold);
            HPose hpose;
            int err2 = HPose.LoadNew(proc, 0, err1, out hpose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covRelPose);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hpose;
        }

        /// <summary>
        ///   Compute the relative orientation between two cameras by automatically finding correspondences between image points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="camPar1">Parameters of the 1st camera.</param>
        /// <param name="camPar2">Parameters of the 2nd camera.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative orientation of the right image with respect to the left image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Algorithm for the computation of the relative pose and for special pose types. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="covRelPose">6x6 covariance matrix of the relative orientation.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed relative orientation of the cameras (3D pose).</returns>
        public HPose MatchRelPoseRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HCamPar camPar1,
          HCamPar camPar2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          double rotation,
          int matchThreshold,
          string estimationMethod,
          double distanceThreshold,
          int randSeed,
          out HTuple covRelPose,
          out double error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(359);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, (HData)camPar1);
            HalconAPI.Store(proc, 5, (HData)camPar2);
            HalconAPI.StoreS(proc, 6, grayMatchMethod);
            HalconAPI.StoreI(proc, 7, maskSize);
            HalconAPI.StoreI(proc, 8, rowMove);
            HalconAPI.StoreI(proc, 9, colMove);
            HalconAPI.StoreI(proc, 10, rowTolerance);
            HalconAPI.StoreI(proc, 11, colTolerance);
            HalconAPI.StoreD(proc, 12, rotation);
            HalconAPI.StoreI(proc, 13, matchThreshold);
            HalconAPI.StoreS(proc, 14, estimationMethod);
            HalconAPI.StoreD(proc, 15, distanceThreshold);
            HalconAPI.StoreI(proc, 16, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple((HTuple)((HData)camPar1));
            HalconAPI.UnpinTuple((HTuple)((HData)camPar2));
            HPose hpose;
            int err2 = HPose.LoadNew(proc, 0, err1, out hpose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covRelPose);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hpose;
        }

        /// <summary>
        ///   Compute the essential matrix for a pair of stereo images by automatically finding correspondences between image points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="camMat1">Camera matrix of the 1st camera.</param>
        /// <param name="camMat2">Camera matrix of the 2nd camera.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative orientation of the right image with respect to the left image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Algorithm for the computation of the essential matrix and for special camera orientations. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="covEMat">9x9 covariance matrix of the essential matrix.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed essential matrix.</returns>
        public HHomMat2D MatchEssentialMatrixRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HHomMat2D camMat1,
          HHomMat2D camMat2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          string estimationMethod,
          HTuple distanceThreshold,
          int randSeed,
          out HTuple covEMat,
          out HTuple error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(360);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, (HData)camMat1);
            HalconAPI.Store(proc, 5, (HData)camMat2);
            HalconAPI.StoreS(proc, 6, grayMatchMethod);
            HalconAPI.StoreI(proc, 7, maskSize);
            HalconAPI.StoreI(proc, 8, rowMove);
            HalconAPI.StoreI(proc, 9, colMove);
            HalconAPI.StoreI(proc, 10, rowTolerance);
            HalconAPI.StoreI(proc, 11, colTolerance);
            HalconAPI.Store(proc, 12, rotation);
            HalconAPI.Store(proc, 13, matchThreshold);
            HalconAPI.StoreS(proc, 14, estimationMethod);
            HalconAPI.Store(proc, 15, distanceThreshold);
            HalconAPI.StoreI(proc, 16, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple((HTuple)((HData)camMat1));
            HalconAPI.UnpinTuple((HTuple)((HData)camMat2));
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(distanceThreshold);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covEMat);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute the essential matrix for a pair of stereo images by automatically finding correspondences between image points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="camMat1">Camera matrix of the 1st camera.</param>
        /// <param name="camMat2">Camera matrix of the 2nd camera.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative orientation of the right image with respect to the left image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Algorithm for the computation of the essential matrix and for special camera orientations. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="covEMat">9x9 covariance matrix of the essential matrix.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed essential matrix.</returns>
        public HHomMat2D MatchEssentialMatrixRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          HHomMat2D camMat1,
          HHomMat2D camMat2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          double rotation,
          int matchThreshold,
          string estimationMethod,
          double distanceThreshold,
          int randSeed,
          out HTuple covEMat,
          out double error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(360);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.Store(proc, 4, (HData)camMat1);
            HalconAPI.Store(proc, 5, (HData)camMat2);
            HalconAPI.StoreS(proc, 6, grayMatchMethod);
            HalconAPI.StoreI(proc, 7, maskSize);
            HalconAPI.StoreI(proc, 8, rowMove);
            HalconAPI.StoreI(proc, 9, colMove);
            HalconAPI.StoreI(proc, 10, rowTolerance);
            HalconAPI.StoreI(proc, 11, colTolerance);
            HalconAPI.StoreD(proc, 12, rotation);
            HalconAPI.StoreI(proc, 13, matchThreshold);
            HalconAPI.StoreS(proc, 14, estimationMethod);
            HalconAPI.StoreD(proc, 15, distanceThreshold);
            HalconAPI.StoreI(proc, 16, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple((HTuple)((HData)camMat1));
            HalconAPI.UnpinTuple((HTuple)((HData)camMat2));
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covEMat);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute the fundamental matrix for a pair of stereo images by automatically finding correspondences between image points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative orientation of the right image with respect to the left image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Algorithm for the computation of the fundamental matrix and for special camera orientations. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="covFMat">9x9 covariance matrix of the fundamental matrix.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed fundamental matrix.</returns>
        public HHomMat2D MatchFundamentalMatrixRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          HTuple rotation,
          HTuple matchThreshold,
          string estimationMethod,
          HTuple distanceThreshold,
          int randSeed,
          out HTuple covFMat,
          out double error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(361);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.StoreI(proc, 6, rowMove);
            HalconAPI.StoreI(proc, 7, colMove);
            HalconAPI.StoreI(proc, 8, rowTolerance);
            HalconAPI.StoreI(proc, 9, colTolerance);
            HalconAPI.Store(proc, 10, rotation);
            HalconAPI.Store(proc, 11, matchThreshold);
            HalconAPI.StoreS(proc, 12, estimationMethod);
            HalconAPI.Store(proc, 13, distanceThreshold);
            HalconAPI.StoreI(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(matchThreshold);
            HalconAPI.UnpinTuple(distanceThreshold);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covFMat);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute the fundamental matrix for a pair of stereo images by automatically finding correspondences between image points.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="rows1">Row coordinates of characteristic points in image 1.</param>
        /// <param name="cols1">Column coordinates of characteristic points in image 1.</param>
        /// <param name="rows2">Row coordinates of characteristic points in image 2.</param>
        /// <param name="cols2">Column coordinates of characteristic points in image 2.</param>
        /// <param name="grayMatchMethod">Gray value comparison metric. Default: "ssd"</param>
        /// <param name="maskSize">Size of gray value masks. Default: 10</param>
        /// <param name="rowMove">Average row coordinate shift of corresponding points. Default: 0</param>
        /// <param name="colMove">Average column coordinate shift of corresponding points. Default: 0</param>
        /// <param name="rowTolerance">Half height of matching search window. Default: 200</param>
        /// <param name="colTolerance">Half width of matching search window. Default: 200</param>
        /// <param name="rotation">Estimate of the relative orientation of the right image with respect to the left image. Default: 0.0</param>
        /// <param name="matchThreshold">Threshold for gray value matching. Default: 10</param>
        /// <param name="estimationMethod">Algorithm for the computation of the fundamental matrix and for special camera orientations. Default: "normalized_dlt"</param>
        /// <param name="distanceThreshold">Maximal deviation of a point from its epipolar line. Default: 1</param>
        /// <param name="randSeed">Seed for the random number generator. Default: 0</param>
        /// <param name="covFMat">9x9 covariance matrix of the fundamental matrix.</param>
        /// <param name="error">Root-Mean-Square of the epipolar distance error.</param>
        /// <param name="points1">Indices of matched input points in image 1.</param>
        /// <param name="points2">Indices of matched input points in image 2.</param>
        /// <returns>Computed fundamental matrix.</returns>
        public HHomMat2D MatchFundamentalMatrixRansac(
          HImage image2,
          HTuple rows1,
          HTuple cols1,
          HTuple rows2,
          HTuple cols2,
          string grayMatchMethod,
          int maskSize,
          int rowMove,
          int colMove,
          int rowTolerance,
          int colTolerance,
          double rotation,
          int matchThreshold,
          string estimationMethod,
          double distanceThreshold,
          int randSeed,
          out HTuple covFMat,
          out double error,
          out HTuple points1,
          out HTuple points2)
        {
            IntPtr proc = HalconAPI.PreCall(361);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, rows1);
            HalconAPI.Store(proc, 1, cols1);
            HalconAPI.Store(proc, 2, rows2);
            HalconAPI.Store(proc, 3, cols2);
            HalconAPI.StoreS(proc, 4, grayMatchMethod);
            HalconAPI.StoreI(proc, 5, maskSize);
            HalconAPI.StoreI(proc, 6, rowMove);
            HalconAPI.StoreI(proc, 7, colMove);
            HalconAPI.StoreI(proc, 8, rowTolerance);
            HalconAPI.StoreI(proc, 9, colTolerance);
            HalconAPI.StoreD(proc, 10, rotation);
            HalconAPI.StoreI(proc, 11, matchThreshold);
            HalconAPI.StoreS(proc, 12, estimationMethod);
            HalconAPI.StoreD(proc, 13, distanceThreshold);
            HalconAPI.StoreI(proc, 14, randSeed);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rows1);
            HalconAPI.UnpinTuple(cols1);
            HalconAPI.UnpinTuple(rows2);
            HalconAPI.UnpinTuple(cols2);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covFMat);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out error);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out points1);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out points2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hhomMat2D;
        }

        /// <summary>
        ///   Compute the distance values for a rectified stereo image pair using correlation techniques.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Evaluation of a distance value.</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <param name="method">Matching function. Default: "ncc"</param>
        /// <param name="maskWidth">Width of the correlation window. Default: 11</param>
        /// <param name="maskHeight">Height of the correlation window. Default: 11</param>
        /// <param name="textureThresh">Variance threshold of textured image regions. Default: 0.0</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: 0</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="numLevels">Number of pyramid levels. Default: 1</param>
        /// <param name="scoreThresh">Threshold of the correlation function. Default: 0.0</param>
        /// <param name="filter">Downstream filters. Default: "none"</param>
        /// <param name="subDistance">Distance interpolation. Default: "none"</param>
        /// <returns>Distance image.</returns>
        public HImage BinocularDistance(
          HImage imageRect2,
          out HImage score,
          HCamPar camParamRect1,
          HCamPar camParamRect2,
          HPose relPoseRect,
          string method,
          int maskWidth,
          int maskHeight,
          HTuple textureThresh,
          int minDisparity,
          int maxDisparity,
          int numLevels,
          HTuple scoreThresh,
          HTuple filter,
          HTuple subDistance)
        {
            IntPtr proc = HalconAPI.PreCall(362);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, (HData)camParamRect1);
            HalconAPI.Store(proc, 1, (HData)camParamRect2);
            HalconAPI.Store(proc, 2, (HData)relPoseRect);
            HalconAPI.StoreS(proc, 3, method);
            HalconAPI.StoreI(proc, 4, maskWidth);
            HalconAPI.StoreI(proc, 5, maskHeight);
            HalconAPI.Store(proc, 6, textureThresh);
            HalconAPI.StoreI(proc, 7, minDisparity);
            HalconAPI.StoreI(proc, 8, maxDisparity);
            HalconAPI.StoreI(proc, 9, numLevels);
            HalconAPI.Store(proc, 10, scoreThresh);
            HalconAPI.Store(proc, 11, filter);
            HalconAPI.Store(proc, 12, subDistance);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect1));
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect2));
            HalconAPI.UnpinTuple((HTuple)((HData)relPoseRect));
            HalconAPI.UnpinTuple(textureThresh);
            HalconAPI.UnpinTuple(scoreThresh);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(subDistance);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Compute the distance values for a rectified stereo image pair using correlation techniques.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Evaluation of a distance value.</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <param name="method">Matching function. Default: "ncc"</param>
        /// <param name="maskWidth">Width of the correlation window. Default: 11</param>
        /// <param name="maskHeight">Height of the correlation window. Default: 11</param>
        /// <param name="textureThresh">Variance threshold of textured image regions. Default: 0.0</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: 0</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="numLevels">Number of pyramid levels. Default: 1</param>
        /// <param name="scoreThresh">Threshold of the correlation function. Default: 0.0</param>
        /// <param name="filter">Downstream filters. Default: "none"</param>
        /// <param name="subDistance">Distance interpolation. Default: "none"</param>
        /// <returns>Distance image.</returns>
        public HImage BinocularDistance(
          HImage imageRect2,
          out HImage score,
          HCamPar camParamRect1,
          HCamPar camParamRect2,
          HPose relPoseRect,
          string method,
          int maskWidth,
          int maskHeight,
          double textureThresh,
          int minDisparity,
          int maxDisparity,
          int numLevels,
          double scoreThresh,
          string filter,
          string subDistance)
        {
            IntPtr proc = HalconAPI.PreCall(362);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.Store(proc, 0, (HData)camParamRect1);
            HalconAPI.Store(proc, 1, (HData)camParamRect2);
            HalconAPI.Store(proc, 2, (HData)relPoseRect);
            HalconAPI.StoreS(proc, 3, method);
            HalconAPI.StoreI(proc, 4, maskWidth);
            HalconAPI.StoreI(proc, 5, maskHeight);
            HalconAPI.StoreD(proc, 6, textureThresh);
            HalconAPI.StoreI(proc, 7, minDisparity);
            HalconAPI.StoreI(proc, 8, maxDisparity);
            HalconAPI.StoreI(proc, 9, numLevels);
            HalconAPI.StoreD(proc, 10, scoreThresh);
            HalconAPI.StoreS(proc, 11, filter);
            HalconAPI.StoreS(proc, 12, subDistance);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect1));
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect2));
            HalconAPI.UnpinTuple((HTuple)((HData)relPoseRect));
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Compute the disparities of a rectified image pair using correlation techniques.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Evaluation of the disparity values.</param>
        /// <param name="method">Matching function. Default: "ncc"</param>
        /// <param name="maskWidth">Width of the correlation window. Default: 11</param>
        /// <param name="maskHeight">Height of the correlation window. Default: 11</param>
        /// <param name="textureThresh">Variance threshold of textured image regions. Default: 0.0</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: -30</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="numLevels">Number of pyramid levels. Default: 1</param>
        /// <param name="scoreThresh">Threshold of the correlation function. Default: 0.5</param>
        /// <param name="filter">Downstream filters. Default: "none"</param>
        /// <param name="subDisparity">Subpixel interpolation of disparities. Default: "none"</param>
        /// <returns>Disparity map.</returns>
        public HImage BinocularDisparity(
          HImage imageRect2,
          out HImage score,
          string method,
          int maskWidth,
          int maskHeight,
          HTuple textureThresh,
          int minDisparity,
          int maxDisparity,
          int numLevels,
          HTuple scoreThresh,
          HTuple filter,
          string subDisparity)
        {
            IntPtr proc = HalconAPI.PreCall(363);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.StoreS(proc, 0, method);
            HalconAPI.StoreI(proc, 1, maskWidth);
            HalconAPI.StoreI(proc, 2, maskHeight);
            HalconAPI.Store(proc, 3, textureThresh);
            HalconAPI.StoreI(proc, 4, minDisparity);
            HalconAPI.StoreI(proc, 5, maxDisparity);
            HalconAPI.StoreI(proc, 6, numLevels);
            HalconAPI.Store(proc, 7, scoreThresh);
            HalconAPI.Store(proc, 8, filter);
            HalconAPI.StoreS(proc, 9, subDisparity);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(textureThresh);
            HalconAPI.UnpinTuple(scoreThresh);
            HalconAPI.UnpinTuple(filter);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Compute the disparities of a rectified image pair using correlation techniques.
        ///   Instance represents: Rectified image of camera 1.
        /// </summary>
        /// <param name="imageRect2">Rectified image of camera 2.</param>
        /// <param name="score">Evaluation of the disparity values.</param>
        /// <param name="method">Matching function. Default: "ncc"</param>
        /// <param name="maskWidth">Width of the correlation window. Default: 11</param>
        /// <param name="maskHeight">Height of the correlation window. Default: 11</param>
        /// <param name="textureThresh">Variance threshold of textured image regions. Default: 0.0</param>
        /// <param name="minDisparity">Minimum of the expected disparities. Default: -30</param>
        /// <param name="maxDisparity">Maximum of the expected disparities. Default: 30</param>
        /// <param name="numLevels">Number of pyramid levels. Default: 1</param>
        /// <param name="scoreThresh">Threshold of the correlation function. Default: 0.5</param>
        /// <param name="filter">Downstream filters. Default: "none"</param>
        /// <param name="subDisparity">Subpixel interpolation of disparities. Default: "none"</param>
        /// <returns>Disparity map.</returns>
        public HImage BinocularDisparity(
          HImage imageRect2,
          out HImage score,
          string method,
          int maskWidth,
          int maskHeight,
          double textureThresh,
          int minDisparity,
          int maxDisparity,
          int numLevels,
          double scoreThresh,
          string filter,
          string subDisparity)
        {
            IntPtr proc = HalconAPI.PreCall(363);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2);
            HalconAPI.StoreS(proc, 0, method);
            HalconAPI.StoreI(proc, 1, maskWidth);
            HalconAPI.StoreI(proc, 2, maskHeight);
            HalconAPI.StoreD(proc, 3, textureThresh);
            HalconAPI.StoreI(proc, 4, minDisparity);
            HalconAPI.StoreI(proc, 5, maxDisparity);
            HalconAPI.StoreI(proc, 6, numLevels);
            HalconAPI.StoreD(proc, 7, scoreThresh);
            HalconAPI.StoreS(proc, 8, filter);
            HalconAPI.StoreS(proc, 9, subDisparity);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2);
            return himage;
        }

        /// <summary>
        ///   Transform a disparity image into 3D points in a rectified stereo system.
        ///   Instance represents: Disparity image.
        /// </summary>
        /// <param name="y">Y coordinates of the points in the rectified camera system 1.</param>
        /// <param name="z">Z coordinates of the points in the rectified camera system 1.</param>
        /// <param name="camParamRect1">Internal camera parameters of the rectified camera 1.</param>
        /// <param name="camParamRect2">Internal camera parameters of the rectified camera 2.</param>
        /// <param name="relPoseRect">Pose of the rectified camera 2 in relation to the rectified camera 1.</param>
        /// <returns>X coordinates of the points in the rectified camera system 1.</returns>
        public HImage DisparityImageToXyz(
          out HImage y,
          out HImage z,
          HCamPar camParamRect1,
          HCamPar camParamRect2,
          HPose relPoseRect)
        {
            IntPtr proc = HalconAPI.PreCall(365);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HData)camParamRect1);
            HalconAPI.Store(proc, 1, (HData)camParamRect2);
            HalconAPI.Store(proc, 2, (HData)relPoseRect);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect1));
            HalconAPI.UnpinTuple((HTuple)((HData)camParamRect2));
            HalconAPI.UnpinTuple((HTuple)((HData)relPoseRect));
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out y);
            int procResult = HImage.LoadNew(proc, 3, err3, out z);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Generate transformation maps that describe the mapping of the images of a binocular camera pair to a common rectified image plane.
        ///   Modified instance represents: Image containing the mapping data of camera 1.
        /// </summary>
        /// <param name="camParam1">Internal parameters of camera 1.</param>
        /// <param name="camParam2">Internal parameters of camera 2.</param>
        /// <param name="relPose">Point transformation from camera 2 to camera 1.</param>
        /// <param name="subSampling">Subsampling factor. Default: 1.0</param>
        /// <param name="method">Type of rectification. Default: "geometric"</param>
        /// <param name="mapType">Type of mapping. Default: "bilinear"</param>
        /// <param name="camParamRect1">Rectified internal parameters of camera 1.</param>
        /// <param name="camParamRect2">Rectified internal parameters of camera 2.</param>
        /// <param name="camPoseRect1">Point transformation from the rectified camera 1 to the original camera 1.</param>
        /// <param name="camPoseRect2">Point transformation from the rectified camera 1 to the original camera 1.</param>
        /// <param name="relPoseRect">Point transformation from the rectified camera 2 to the rectified camera 1.</param>
        /// <returns>Image containing the mapping data of camera 2.</returns>
        public HImage GenBinocularRectificationMap(
          HCamPar camParam1,
          HCamPar camParam2,
          HPose relPose,
          double subSampling,
          string method,
          string mapType,
          out HCamPar camParamRect1,
          out HCamPar camParamRect2,
          out HPose camPoseRect1,
          out HPose camPoseRect2,
          out HPose relPoseRect)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(369);
            HalconAPI.Store(proc, 0, (HData)camParam1);
            HalconAPI.Store(proc, 1, (HData)camParam2);
            HalconAPI.Store(proc, 2, (HData)relPose);
            HalconAPI.StoreD(proc, 3, subSampling);
            HalconAPI.StoreS(proc, 4, method);
            HalconAPI.StoreS(proc, 5, mapType);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParam1));
            HalconAPI.UnpinTuple((HTuple)((HData)camParam2));
            HalconAPI.UnpinTuple((HTuple)((HData)relPose));
            int err2 = this.Load(proc, 1, err1);
            HImage himage;
            int err3 = HImage.LoadNew(proc, 2, err2, out himage);
            int err4 = HCamPar.LoadNew(proc, 0, err3, out camParamRect1);
            int err5 = HCamPar.LoadNew(proc, 1, err4, out camParamRect2);
            int err6 = HPose.LoadNew(proc, 2, err5, out camPoseRect1);
            int err7 = HPose.LoadNew(proc, 3, err6, out camPoseRect2);
            int procResult = HPose.LoadNew(proc, 4, err7, out relPoseRect);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Get the iconic results of a measurement performed with the sheet-of light technique.
        ///   Modified instance represents: Desired measurement result.
        /// </summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model to be used.</param>
        /// <param name="resultName">Specify which result of the measurement shall be provided. Default: "disparity"</param>
        public void GetSheetOfLightResult(HSheetOfLightModel sheetOfLightModelID, HTuple resultName)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(381);
            HalconAPI.Store(proc, 0, (HTool)sheetOfLightModelID);
            HalconAPI.Store(proc, 1, resultName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(resultName);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)sheetOfLightModelID);
        }

        /// <summary>
        ///   Get the iconic results of a measurement performed with the sheet-of light technique.
        ///   Modified instance represents: Desired measurement result.
        /// </summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model to be used.</param>
        /// <param name="resultName">Specify which result of the measurement shall be provided. Default: "disparity"</param>
        public void GetSheetOfLightResult(HSheetOfLightModel sheetOfLightModelID, string resultName)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(381);
            HalconAPI.Store(proc, 0, (HTool)sheetOfLightModelID);
            HalconAPI.StoreS(proc, 1, resultName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)sheetOfLightModelID);
        }

        /// <summary>
        ///   Apply the calibration transformations to the input disparity image.
        ///   Instance represents: Height or range image to be calibrated.
        /// </summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        public void ApplySheetOfLightCalibration(HSheetOfLightModel sheetOfLightModelID)
        {
            IntPtr proc = HalconAPI.PreCall(382);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)sheetOfLightModelID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)sheetOfLightModelID);
        }

        /// <summary>
        ///   Set sheet of light profiles by measured disparities.
        ///   Instance represents: Disparity image that contains several profiles.
        /// </summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        /// <param name="movementPoses">Poses describing the movement of the scene under measurement between the previously processed profile image and the current profile image.</param>
        public void SetProfileSheetOfLight(HSheetOfLightModel sheetOfLightModelID, HTuple movementPoses)
        {
            IntPtr proc = HalconAPI.PreCall(383);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)sheetOfLightModelID);
            HalconAPI.Store(proc, 1, movementPoses);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(movementPoses);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)sheetOfLightModelID);
        }

        /// <summary>
        ///   Process the profile image provided as input and store the resulting disparity to the sheet-of-light model.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sheetOfLightModelID">Handle of the sheet-of-light model.</param>
        /// <param name="movementPose">Pose describing the movement of the scene under measurement between the previously processed profile image and the current profile image.</param>
        public void MeasureProfileSheetOfLight(
          HSheetOfLightModel sheetOfLightModelID,
          HTuple movementPose)
        {
            IntPtr proc = HalconAPI.PreCall(384);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)sheetOfLightModelID);
            HalconAPI.Store(proc, 1, movementPose);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(movementPose);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)sheetOfLightModelID);
        }

        /// <summary>
        ///   Shade a height field.
        ///   Instance represents: Height field to be shaded.
        /// </summary>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 0.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 0.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        /// <param name="shadows">Should shadows be calculated? Default: "false"</param>
        /// <returns>Shaded image.</returns>
        public HImage ShadeHeightField(
          HTuple slant,
          HTuple tilt,
          HTuple albedo,
          HTuple ambient,
          string shadows)
        {
            IntPtr proc = HalconAPI.PreCall(392);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, slant);
            HalconAPI.Store(proc, 1, tilt);
            HalconAPI.Store(proc, 2, albedo);
            HalconAPI.Store(proc, 3, ambient);
            HalconAPI.StoreS(proc, 4, shadows);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(slant);
            HalconAPI.UnpinTuple(tilt);
            HalconAPI.UnpinTuple(albedo);
            HalconAPI.UnpinTuple(ambient);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Shade a height field.
        ///   Instance represents: Height field to be shaded.
        /// </summary>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 0.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 0.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        /// <param name="shadows">Should shadows be calculated? Default: "false"</param>
        /// <returns>Shaded image.</returns>
        public HImage ShadeHeightField(
          double slant,
          double tilt,
          double albedo,
          double ambient,
          string shadows)
        {
            IntPtr proc = HalconAPI.PreCall(392);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, slant);
            HalconAPI.StoreD(proc, 1, tilt);
            HalconAPI.StoreD(proc, 2, albedo);
            HalconAPI.StoreD(proc, 3, ambient);
            HalconAPI.StoreS(proc, 4, shadows);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Estimate the albedo of a surface and the amount of ambient light.
        ///   Instance represents: Image for which albedo and ambient are to be estimated.
        /// </summary>
        /// <param name="ambient">Amount of ambient light.</param>
        /// <returns>Amount of light reflected by the surface.</returns>
        public HTuple EstimateAlAm(out HTuple ambient)
        {
            IntPtr proc = HalconAPI.PreCall(393);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out ambient);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Estimate the albedo of a surface and the amount of ambient light.
        ///   Instance represents: Image for which albedo and ambient are to be estimated.
        /// </summary>
        /// <param name="ambient">Amount of ambient light.</param>
        /// <returns>Amount of light reflected by the surface.</returns>
        public double EstimateAlAm(out double ambient)
        {
            IntPtr proc = HalconAPI.PreCall(393);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int err2 = HalconAPI.LoadD(proc, 0, err1, out doubleValue);
            int procResult = HalconAPI.LoadD(proc, 1, err2, out ambient);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return doubleValue;
        }

        /// <summary>
        ///   Estimate the slant of a light source and the albedo of a surface.
        ///   Instance represents: Image for which slant and albedo are to be estimated.
        /// </summary>
        /// <param name="albedo">Amount of light reflected by the surface.</param>
        /// <returns>Angle of the light sources and the positive z-axis (in degrees).</returns>
        public HTuple EstimateSlAlZc(out HTuple albedo)
        {
            IntPtr proc = HalconAPI.PreCall(394);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out albedo);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Estimate the slant of a light source and the albedo of a surface.
        ///   Instance represents: Image for which slant and albedo are to be estimated.
        /// </summary>
        /// <param name="albedo">Amount of light reflected by the surface.</param>
        /// <returns>Angle of the light sources and the positive z-axis (in degrees).</returns>
        public double EstimateSlAlZc(out double albedo)
        {
            IntPtr proc = HalconAPI.PreCall(394);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int err2 = HalconAPI.LoadD(proc, 0, err1, out doubleValue);
            int procResult = HalconAPI.LoadD(proc, 1, err2, out albedo);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return doubleValue;
        }

        /// <summary>
        ///   Estimate the slant of a light source and the albedo of a surface.
        ///   Instance represents: Image for which slant and albedo are to be estimated.
        /// </summary>
        /// <param name="albedo">Amount of light reflected by the surface.</param>
        /// <returns>Angle between the light sources and the positive z-axis (in degrees).</returns>
        public HTuple EstimateSlAlLr(out HTuple albedo)
        {
            IntPtr proc = HalconAPI.PreCall(395);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out albedo);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Estimate the slant of a light source and the albedo of a surface.
        ///   Instance represents: Image for which slant and albedo are to be estimated.
        /// </summary>
        /// <param name="albedo">Amount of light reflected by the surface.</param>
        /// <returns>Angle between the light sources and the positive z-axis (in degrees).</returns>
        public double EstimateSlAlLr(out double albedo)
        {
            IntPtr proc = HalconAPI.PreCall(395);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int err2 = HalconAPI.LoadD(proc, 0, err1, out doubleValue);
            int procResult = HalconAPI.LoadD(proc, 1, err2, out albedo);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return doubleValue;
        }

        /// <summary>
        ///   Estimate the tilt of a light source.
        ///   Instance represents: Image for which the tilt is to be estimated.
        /// </summary>
        /// <returns>Angle between the light source and the x-axis after projection into the xy-plane (in degrees).</returns>
        public HTuple EstimateTiltZc()
        {
            IntPtr proc = HalconAPI.PreCall(396);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Estimate the tilt of a light source.
        ///   Instance represents: Image for which the tilt is to be estimated.
        /// </summary>
        /// <returns>Angle between the light source and the x-axis after projection into the xy-plane (in degrees).</returns>
        public HTuple EstimateTiltLr()
        {
            IntPtr proc = HalconAPI.PreCall(397);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Reconstruct a surface from surface gradients.
        ///   Instance represents: The gradient field of the image.
        /// </summary>
        /// <param name="reconstructionMethod">Type of the reconstruction method. Default: "poisson"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <returns>Reconstructed height field.</returns>
        public HImage ReconstructHeightFieldFromGradient(
          string reconstructionMethod,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(398);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, reconstructionMethod);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Reconstruct a surface according to the photometric stereo technique.
        ///   Instance represents: Array with at least three input images with different directions of illumination.
        /// </summary>
        /// <param name="gradient">The gradient field of the surface.</param>
        /// <param name="albedo">The albedo of the surface.</param>
        /// <param name="slants">Angle between the camera and the direction of  illumination (in degrees). Default: 45.0</param>
        /// <param name="tilts">Angle of the direction of illumination within the object plane (in degrees). Default: 45.0</param>
        /// <param name="resultType">Types of the requested results. Default: "all"</param>
        /// <param name="reconstructionMethod">Type of the reconstruction method. Default: "poisson"</param>
        /// <param name="genParamName">Names of the generic parameters. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <returns>Reconstructed height field.</returns>
        public HImage PhotometricStereo(
          out HImage gradient,
          out HImage albedo,
          HTuple slants,
          HTuple tilts,
          HTuple resultType,
          string reconstructionMethod,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(399);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, slants);
            HalconAPI.Store(proc, 1, tilts);
            HalconAPI.Store(proc, 2, resultType);
            HalconAPI.StoreS(proc, 3, reconstructionMethod);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(slants);
            HalconAPI.UnpinTuple(tilts);
            HalconAPI.UnpinTuple(resultType);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out gradient);
            int procResult = HImage.LoadNew(proc, 3, err3, out albedo);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Reconstruct a surface from a gray value image.
        ///   Instance represents: Shaded input image.
        /// </summary>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 45.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 45.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        /// <returns>Reconstructed height field.</returns>
        public HImage SfsPentland(HTuple slant, HTuple tilt, HTuple albedo, HTuple ambient)
        {
            IntPtr proc = HalconAPI.PreCall(400);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, slant);
            HalconAPI.Store(proc, 1, tilt);
            HalconAPI.Store(proc, 2, albedo);
            HalconAPI.Store(proc, 3, ambient);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(slant);
            HalconAPI.UnpinTuple(tilt);
            HalconAPI.UnpinTuple(albedo);
            HalconAPI.UnpinTuple(ambient);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Reconstruct a surface from a gray value image.
        ///   Instance represents: Shaded input image.
        /// </summary>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 45.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 45.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        /// <returns>Reconstructed height field.</returns>
        public HImage SfsPentland(double slant, double tilt, double albedo, double ambient)
        {
            IntPtr proc = HalconAPI.PreCall(400);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, slant);
            HalconAPI.StoreD(proc, 1, tilt);
            HalconAPI.StoreD(proc, 2, albedo);
            HalconAPI.StoreD(proc, 3, ambient);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Reconstruct a surface from a gray value image.
        ///   Instance represents: Shaded input image.
        /// </summary>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 45.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 45.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        /// <returns>Reconstructed height field.</returns>
        public HImage SfsOrigLr(HTuple slant, HTuple tilt, HTuple albedo, HTuple ambient)
        {
            IntPtr proc = HalconAPI.PreCall(401);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, slant);
            HalconAPI.Store(proc, 1, tilt);
            HalconAPI.Store(proc, 2, albedo);
            HalconAPI.Store(proc, 3, ambient);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(slant);
            HalconAPI.UnpinTuple(tilt);
            HalconAPI.UnpinTuple(albedo);
            HalconAPI.UnpinTuple(ambient);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Reconstruct a surface from a gray value image.
        ///   Instance represents: Shaded input image.
        /// </summary>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 45.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 45.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        /// <returns>Reconstructed height field.</returns>
        public HImage SfsOrigLr(double slant, double tilt, double albedo, double ambient)
        {
            IntPtr proc = HalconAPI.PreCall(401);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, slant);
            HalconAPI.StoreD(proc, 1, tilt);
            HalconAPI.StoreD(proc, 2, albedo);
            HalconAPI.StoreD(proc, 3, ambient);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Reconstruct a surface from a gray value image.
        ///   Instance represents: Shaded input image.
        /// </summary>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 45.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 45.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        /// <returns>Reconstructed height field.</returns>
        public HImage SfsModLr(HTuple slant, HTuple tilt, HTuple albedo, HTuple ambient)
        {
            IntPtr proc = HalconAPI.PreCall(402);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, slant);
            HalconAPI.Store(proc, 1, tilt);
            HalconAPI.Store(proc, 2, albedo);
            HalconAPI.Store(proc, 3, ambient);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(slant);
            HalconAPI.UnpinTuple(tilt);
            HalconAPI.UnpinTuple(albedo);
            HalconAPI.UnpinTuple(ambient);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Reconstruct a surface from a gray value image.
        ///   Instance represents: Shaded input image.
        /// </summary>
        /// <param name="slant">Angle between the light source and the positive z-axis (in degrees). Default: 45.0</param>
        /// <param name="tilt">Angle between the light source and the x-axis after projection into the xy-plane (in degrees). Default: 45.0</param>
        /// <param name="albedo">Amount of light reflected by the surface. Default: 1.0</param>
        /// <param name="ambient">Amount of ambient light. Default: 0.0</param>
        /// <returns>Reconstructed height field.</returns>
        public HImage SfsModLr(double slant, double tilt, double albedo, double ambient)
        {
            IntPtr proc = HalconAPI.PreCall(402);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, slant);
            HalconAPI.StoreD(proc, 1, tilt);
            HalconAPI.StoreD(proc, 2, albedo);
            HalconAPI.StoreD(proc, 3, ambient);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Find text in an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="textModel">Text model specifying the text to be segmented.</param>
        /// <returns>Result of the segmentation.</returns>
        public HTextResult FindText(HTextModel textModel)
        {
            IntPtr proc = HalconAPI.PreCall(417);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)textModel);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTextResult htextResult;
            int procResult = HTextResult.LoadNew(proc, 0, err, out htextResult);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)textModel);
            return htextResult;
        }

        /// <summary>
        ///   Classify a byte image using a look-up table.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="classLUTHandle">Handle of the LUT classifier.</param>
        /// <returns>Segmented classes.</returns>
        public HRegion ClassifyImageClassLut(HClassLUT classLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(428);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)classLUTHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)classLUTHandle);
            return hregion;
        }

        /// <summary>
        ///   Classify an image with a k-Nearest-Neighbor classifier.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="distanceImage">Distance of the pixel's nearest neighbor.</param>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        /// <param name="rejectionThreshold">Threshold for the rejection of the classification. Default: 0.5</param>
        /// <returns>Segmented classes.</returns>
        public HRegion ClassifyImageClassKnn(
          out HImage distanceImage,
          HClassKnn KNNHandle,
          double rejectionThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(429);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)KNNHandle);
            HalconAPI.StoreD(proc, 1, rejectionThreshold);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HImage.LoadNew(proc, 2, err2, out distanceImage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)KNNHandle);
            return hregion;
        }

        /// <summary>
        ///   Add training samples from an image to the training data of a k-Nearest-Neighbor classifier.
        ///   Instance represents: Training image.
        /// </summary>
        /// <param name="classRegions">Regions of the classes to be trained.</param>
        /// <param name="KNNHandle">Handle of the k-NN classifier.</param>
        public void AddSamplesImageClassKnn(HRegion classRegions, HClassKnn KNNHandle)
        {
            IntPtr proc = HalconAPI.PreCall(430);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)classRegions);
            HalconAPI.Store(proc, 0, (HTool)KNNHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)classRegions);
            GC.KeepAlive((object)KNNHandle);
        }

        /// <summary>
        ///   Classify an image with a Gaussian Mixture Model.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="rejectionThreshold">Threshold for the rejection of the classification. Default: 0.5</param>
        /// <returns>Segmented classes.</returns>
        public HRegion ClassifyImageClassGmm(HClassGmm GMMHandle, double rejectionThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(431);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)GMMHandle);
            HalconAPI.StoreD(proc, 1, rejectionThreshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)GMMHandle);
            return hregion;
        }

        /// <summary>
        ///   Add training samples from an image to the training data of a Gaussian Mixture Model.
        ///   Instance represents: Training image.
        /// </summary>
        /// <param name="classRegions">Regions of the classes to be trained.</param>
        /// <param name="GMMHandle">GMM handle.</param>
        /// <param name="randomize">Standard deviation of the Gaussian noise added to the training data. Default: 0.0</param>
        public void AddSamplesImageClassGmm(
          HRegion classRegions,
          HClassGmm GMMHandle,
          double randomize)
        {
            IntPtr proc = HalconAPI.PreCall(432);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)classRegions);
            HalconAPI.Store(proc, 0, (HTool)GMMHandle);
            HalconAPI.StoreD(proc, 1, randomize);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)classRegions);
            GC.KeepAlive((object)GMMHandle);
        }

        /// <summary>
        ///   Classify an image with a support vector machine.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="SVMHandle">SVM handle.</param>
        /// <returns>Segmented classes.</returns>
        public HRegion ClassifyImageClassSvm(HClassSvm SVMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(433);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)SVMHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)SVMHandle);
            return hregion;
        }

        /// <summary>
        ///   Add training samples from an image to the training data of a support vector machine.
        ///   Instance represents: Training image.
        /// </summary>
        /// <param name="classRegions">Regions of the classes to be trained.</param>
        /// <param name="SVMHandle">SVM handle.</param>
        public void AddSamplesImageClassSvm(HRegion classRegions, HClassSvm SVMHandle)
        {
            IntPtr proc = HalconAPI.PreCall(434);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)classRegions);
            HalconAPI.Store(proc, 0, (HTool)SVMHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)classRegions);
            GC.KeepAlive((object)SVMHandle);
        }

        /// <summary>
        ///   Classify an image with a multilayer perceptron.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="MLPHandle">MLP handle.</param>
        /// <param name="rejectionThreshold">Threshold for the rejection of the classification. Default: 0.5</param>
        /// <returns>Segmented classes.</returns>
        public HRegion ClassifyImageClassMlp(HClassMlp MLPHandle, double rejectionThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(435);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)MLPHandle);
            HalconAPI.StoreD(proc, 1, rejectionThreshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)MLPHandle);
            return hregion;
        }

        /// <summary>
        ///   Add training samples from an image to the training data of a multilayer perceptron.
        ///   Instance represents: Training image.
        /// </summary>
        /// <param name="classRegions">Regions of the classes to be trained.</param>
        /// <param name="MLPHandle">MLP handle.</param>
        public void AddSamplesImageClassMlp(HRegion classRegions, HClassMlp MLPHandle)
        {
            IntPtr proc = HalconAPI.PreCall(436);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)classRegions);
            HalconAPI.Store(proc, 0, (HTool)MLPHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)classRegions);
            GC.KeepAlive((object)MLPHandle);
        }

        /// <summary>
        ///   Construct classes for class_ndim_norm.
        ///   Instance represents: Multi-channel training image.
        /// </summary>
        /// <param name="foreground">Foreground pixels to be trained.</param>
        /// <param name="background">Background pixels to be trained (rejection class).</param>
        /// <param name="metric">Metric to be used. Default: "euclid"</param>
        /// <param name="distance">Maximum cluster radius. Default: 10.0</param>
        /// <param name="minNumberPercent">The ratio of the number of pixels in a cluster to the total number of pixels (in percent) must be larger than MinNumberPercent (otherwise the cluster is not output). Default: 0.01</param>
        /// <param name="center">Coordinates of all cluster centers.</param>
        /// <param name="quality">Overlap of the rejection class with the classified objects (1: no overlap).</param>
        /// <returns>Cluster radii or half edge lengths.</returns>
        public HTuple LearnNdimNorm(
          HRegion foreground,
          HRegion background,
          string metric,
          HTuple distance,
          HTuple minNumberPercent,
          out HTuple center,
          out double quality)
        {
            IntPtr proc = HalconAPI.PreCall(437);
            this.Store(proc, 3);
            HalconAPI.Store(proc, 1, (HObjectBase)foreground);
            HalconAPI.Store(proc, 2, (HObjectBase)background);
            HalconAPI.StoreS(proc, 0, metric);
            HalconAPI.Store(proc, 1, distance);
            HalconAPI.Store(proc, 2, minNumberPercent);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distance);
            HalconAPI.UnpinTuple(minNumberPercent);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out center);
            int procResult = HalconAPI.LoadD(proc, 2, err3, out quality);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)foreground);
            GC.KeepAlive((object)background);
            return tuple;
        }

        /// <summary>
        ///   Construct classes for class_ndim_norm.
        ///   Instance represents: Multi-channel training image.
        /// </summary>
        /// <param name="foreground">Foreground pixels to be trained.</param>
        /// <param name="background">Background pixels to be trained (rejection class).</param>
        /// <param name="metric">Metric to be used. Default: "euclid"</param>
        /// <param name="distance">Maximum cluster radius. Default: 10.0</param>
        /// <param name="minNumberPercent">The ratio of the number of pixels in a cluster to the total number of pixels (in percent) must be larger than MinNumberPercent (otherwise the cluster is not output). Default: 0.01</param>
        /// <param name="center">Coordinates of all cluster centers.</param>
        /// <param name="quality">Overlap of the rejection class with the classified objects (1: no overlap).</param>
        /// <returns>Cluster radii or half edge lengths.</returns>
        public HTuple LearnNdimNorm(
          HRegion foreground,
          HRegion background,
          string metric,
          double distance,
          double minNumberPercent,
          out HTuple center,
          out double quality)
        {
            IntPtr proc = HalconAPI.PreCall(437);
            this.Store(proc, 3);
            HalconAPI.Store(proc, 1, (HObjectBase)foreground);
            HalconAPI.Store(proc, 2, (HObjectBase)background);
            HalconAPI.StoreS(proc, 0, metric);
            HalconAPI.StoreD(proc, 1, distance);
            HalconAPI.StoreD(proc, 2, minNumberPercent);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out center);
            int procResult = HalconAPI.LoadD(proc, 2, err3, out quality);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)foreground);
            GC.KeepAlive((object)background);
            return tuple;
        }

        /// <summary>
        ///   Train a classificator using a multi-channel image.
        ///   Instance represents: Multi-channel training image.
        /// </summary>
        /// <param name="foreground">Foreground pixels to be trained.</param>
        /// <param name="background">Background pixels to be trained (rejection class).</param>
        /// <param name="classifHandle">Handle of the classifier.</param>
        public void LearnNdimBox(HRegion foreground, HRegion background, HClassBox classifHandle)
        {
            IntPtr proc = HalconAPI.PreCall(438);
            this.Store(proc, 3);
            HalconAPI.Store(proc, 1, (HObjectBase)foreground);
            HalconAPI.Store(proc, 2, (HObjectBase)background);
            HalconAPI.Store(proc, 0, (HTool)classifHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)foreground);
            GC.KeepAlive((object)background);
            GC.KeepAlive((object)classifHandle);
        }

        /// <summary>
        ///   Classify pixels using hyper-cuboids.
        ///   Instance represents: Multi channel input image.
        /// </summary>
        /// <param name="classifHandle">Handle of the classifier.</param>
        /// <returns>Classification result.</returns>
        public HRegion ClassNdimBox(HClassBox classifHandle)
        {
            IntPtr proc = HalconAPI.PreCall(439);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)classifHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)classifHandle);
            return hregion;
        }

        /// <summary>
        ///   Classify pixels using hyper-spheres or hyper-cubes.
        ///   Instance represents: Multi channel input image.
        /// </summary>
        /// <param name="metric">Metric to be used. Default: "euclid"</param>
        /// <param name="singleMultiple">Return one region or one region for each cluster. Default: "single"</param>
        /// <param name="radius">Cluster radii or half edge lengths (returned by learn_ndim_norm).</param>
        /// <param name="center">Coordinates of the cluster centers (returned by learn_ndim_norm).</param>
        /// <returns>Classification result.</returns>
        public HRegion ClassNdimNorm(
          string metric,
          string singleMultiple,
          HTuple radius,
          HTuple center)
        {
            IntPtr proc = HalconAPI.PreCall(440);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, metric);
            HalconAPI.StoreS(proc, 1, singleMultiple);
            HalconAPI.Store(proc, 2, radius);
            HalconAPI.Store(proc, 3, center);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(radius);
            HalconAPI.UnpinTuple(center);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Classify pixels using hyper-spheres or hyper-cubes.
        ///   Instance represents: Multi channel input image.
        /// </summary>
        /// <param name="metric">Metric to be used. Default: "euclid"</param>
        /// <param name="singleMultiple">Return one region or one region for each cluster. Default: "single"</param>
        /// <param name="radius">Cluster radii or half edge lengths (returned by learn_ndim_norm).</param>
        /// <param name="center">Coordinates of the cluster centers (returned by learn_ndim_norm).</param>
        /// <returns>Classification result.</returns>
        public HRegion ClassNdimNorm(
          string metric,
          string singleMultiple,
          double radius,
          double center)
        {
            IntPtr proc = HalconAPI.PreCall(440);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, metric);
            HalconAPI.StoreS(proc, 1, singleMultiple);
            HalconAPI.StoreD(proc, 2, radius);
            HalconAPI.StoreD(proc, 3, center);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using two-dimensional pixel classification.
        ///   Instance represents: Input image (first channel).
        /// </summary>
        /// <param name="imageRow">Input image (second channel).</param>
        /// <param name="featureSpace">Region defining the feature space.</param>
        /// <returns>Classified regions.</returns>
        public HRegion Class2dimSup(HImage imageRow, HRegion featureSpace)
        {
            IntPtr proc = HalconAPI.PreCall(441);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRow);
            HalconAPI.Store(proc, 3, (HObjectBase)featureSpace);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRow);
            GC.KeepAlive((object)featureSpace);
            return hregion;
        }

        /// <summary>
        ///   Segment two images by clustering.
        ///   Instance represents: First input image.
        /// </summary>
        /// <param name="image2">Second input image.</param>
        /// <param name="threshold">Threshold (maximum distance to the cluster's center). Default: 15</param>
        /// <param name="numClasses">Number of classes (cluster centers). Default: 5</param>
        /// <returns>Classification result.</returns>
        public HRegion Class2dimUnsup(HImage image2, int threshold, int numClasses)
        {
            IntPtr proc = HalconAPI.PreCall(442);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.StoreI(proc, 0, threshold);
            HalconAPI.StoreI(proc, 1, numClasses);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return hregion;
        }

        /// <summary>
        ///   Compare two images pixel by pixel.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="pattern">Comparison image.</param>
        /// <param name="mode">Mode: return similar or different pixels. Default: "diff_outside"</param>
        /// <param name="diffLowerBound">Lower bound of the tolerated gray value difference. Default: -5</param>
        /// <param name="diffUpperBound">Upper bound of the tolerated gray value difference. Default: 5</param>
        /// <param name="grayOffset">Offset gray value subtracted from the input image. Default: 0</param>
        /// <param name="addRow">Row coordinate by which the comparison image is translated. Default: 0</param>
        /// <param name="addCol">Column coordinate by which the comparison image is translated. Default: 0</param>
        /// <returns>Points in which the two images are similar/different.</returns>
        public HRegion CheckDifference(
          HImage pattern,
          string mode,
          int diffLowerBound,
          int diffUpperBound,
          int grayOffset,
          int addRow,
          int addCol)
        {
            IntPtr proc = HalconAPI.PreCall(443);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)pattern);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.StoreI(proc, 1, diffLowerBound);
            HalconAPI.StoreI(proc, 2, diffUpperBound);
            HalconAPI.StoreI(proc, 3, grayOffset);
            HalconAPI.StoreI(proc, 4, addRow);
            HalconAPI.StoreI(proc, 5, addCol);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)pattern);
            return hregion;
        }

        /// <summary>
        ///   Perform a threshold segmentation for extracting characters.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="histoRegion">Region in which the histogram is computed.</param>
        /// <param name="sigma">Sigma for the Gaussian smoothing of the histogram. Default: 2.0</param>
        /// <param name="percent">Percentage for the gray value difference. Default: 95</param>
        /// <param name="threshold">Calculated threshold.</param>
        /// <returns>Dark regions (characters).</returns>
        public HRegion CharThreshold(
          HRegion histoRegion,
          double sigma,
          HTuple percent,
          out HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(444);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)histoRegion);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.Store(proc, 1, percent);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(percent);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err2, out threshold);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)histoRegion);
            return hregion;
        }

        /// <summary>
        ///   Perform a threshold segmentation for extracting characters.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="histoRegion">Region in which the histogram is computed.</param>
        /// <param name="sigma">Sigma for the Gaussian smoothing of the histogram. Default: 2.0</param>
        /// <param name="percent">Percentage for the gray value difference. Default: 95</param>
        /// <param name="threshold">Calculated threshold.</param>
        /// <returns>Dark regions (characters).</returns>
        public HRegion CharThreshold(
          HRegion histoRegion,
          double sigma,
          double percent,
          out int threshold)
        {
            IntPtr proc = HalconAPI.PreCall(444);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)histoRegion);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.StoreD(proc, 1, percent);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HalconAPI.LoadI(proc, 0, err2, out threshold);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)histoRegion);
            return hregion;
        }

        /// <summary>
        ///   Extract regions with equal gray values from an image.
        ///   Instance represents: Label image.
        /// </summary>
        /// <returns>Regions having a constant gray value.</returns>
        public HRegion LabelToRegion()
        {
            IntPtr proc = HalconAPI.PreCall(445);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Suppress non-maximum points on an edge.
        ///   Instance represents: Amplitude (gradient magnitude) image.
        /// </summary>
        /// <param name="mode">Select horizontal/vertical or undirected NMS. Default: "hvnms"</param>
        /// <returns>Image with thinned edge regions.</returns>
        public HImage NonmaxSuppressionAmp(string mode)
        {
            IntPtr proc = HalconAPI.PreCall(446);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Suppress non-maximum points on an edge using a direction image.
        ///   Instance represents: Amplitude (gradient magnitude) image.
        /// </summary>
        /// <param name="imgDir">Direction image.</param>
        /// <param name="mode">Select non-maximum-suppression or interpolating NMS. Default: "nms"</param>
        /// <returns>Image with thinned edge regions.</returns>
        public HImage NonmaxSuppressionDir(HImage imgDir, string mode)
        {
            IntPtr proc = HalconAPI.PreCall(447);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imgDir);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imgDir);
            return himage;
        }

        /// <summary>
        ///   Perform a hysteresis threshold operation on an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="low">Lower threshold for the gray values. Default: 30</param>
        /// <param name="high">Upper threshold for the gray values. Default: 60</param>
        /// <param name="maxLength">Maximum length of a path of "potential" points to reach a "secure" point. Default: 10</param>
        /// <returns>Segmented region.</returns>
        public HRegion HysteresisThreshold(HTuple low, HTuple high, int maxLength)
        {
            IntPtr proc = HalconAPI.PreCall(448);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, low);
            HalconAPI.Store(proc, 1, high);
            HalconAPI.StoreI(proc, 2, maxLength);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Perform a hysteresis threshold operation on an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="low">Lower threshold for the gray values. Default: 30</param>
        /// <param name="high">Upper threshold for the gray values. Default: 60</param>
        /// <param name="maxLength">Maximum length of a path of "potential" points to reach a "secure" point. Default: 10</param>
        /// <returns>Segmented region.</returns>
        public HRegion HysteresisThreshold(int low, int high, int maxLength)
        {
            IntPtr proc = HalconAPI.PreCall(448);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, low);
            HalconAPI.StoreI(proc, 1, high);
            HalconAPI.StoreI(proc, 2, maxLength);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using binary thresholding.
        ///   Instance represents: Input Image.
        /// </summary>
        /// <param name="method">Segmentation method. Default: "max_separability"</param>
        /// <param name="lightDark">Extract foreground or background? Default: "dark"</param>
        /// <param name="usedThreshold">Used threshold.</param>
        /// <returns>Segmented output region.</returns>
        public HRegion BinaryThreshold(
          string method,
          string lightDark,
          out HTuple usedThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(449);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, method);
            HalconAPI.StoreS(proc, 1, lightDark);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err2, out usedThreshold);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using binary thresholding.
        ///   Instance represents: Input Image.
        /// </summary>
        /// <param name="method">Segmentation method. Default: "max_separability"</param>
        /// <param name="lightDark">Extract foreground or background? Default: "dark"</param>
        /// <param name="usedThreshold">Used threshold.</param>
        /// <returns>Segmented output region.</returns>
        public HRegion BinaryThreshold(string method, string lightDark, out int usedThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(449);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, method);
            HalconAPI.StoreS(proc, 1, lightDark);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HalconAPI.LoadI(proc, 0, err2, out usedThreshold);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using local thresholding.
        ///   Instance represents: Input Image.
        /// </summary>
        /// <param name="method">Segmentation method. Default: "adapted_std_deviation"</param>
        /// <param name="lightDark">Extract foreground or background? Default: "dark"</param>
        /// <param name="genParamName">List of generic parameter names. Default: []</param>
        /// <param name="genParamValue">List of generic parameter values. Default: []</param>
        /// <returns>Segmented output region.</returns>
        public HRegion LocalThreshold(
          string method,
          string lightDark,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(450);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, method);
            HalconAPI.StoreS(proc, 1, lightDark);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using local thresholding.
        ///   Instance represents: Input Image.
        /// </summary>
        /// <param name="method">Segmentation method. Default: "adapted_std_deviation"</param>
        /// <param name="lightDark">Extract foreground or background? Default: "dark"</param>
        /// <param name="genParamName">List of generic parameter names. Default: []</param>
        /// <param name="genParamValue">List of generic parameter values. Default: []</param>
        /// <returns>Segmented output region.</returns>
        public HRegion LocalThreshold(
          string method,
          string lightDark,
          string genParamName,
          int genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(450);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, method);
            HalconAPI.StoreS(proc, 1, lightDark);
            HalconAPI.StoreS(proc, 2, genParamName);
            HalconAPI.StoreI(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Threshold an image by local mean and standard deviation analysis.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskWidth">Mask width for mean and deviation calculation. Default: 15</param>
        /// <param name="maskHeight">Mask height for mean and deviation calculation. Default: 15</param>
        /// <param name="stdDevScale">Factor for the standard deviation of the gray values. Default: 0.2</param>
        /// <param name="absThreshold">Minimum gray value difference from the mean. Default: 2</param>
        /// <param name="lightDark">Threshold type. Default: "dark"</param>
        /// <returns>Segmented regions.</returns>
        public HRegion VarThreshold(
          int maskWidth,
          int maskHeight,
          HTuple stdDevScale,
          HTuple absThreshold,
          string lightDark)
        {
            IntPtr proc = HalconAPI.PreCall(451);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.Store(proc, 2, stdDevScale);
            HalconAPI.Store(proc, 3, absThreshold);
            HalconAPI.StoreS(proc, 4, lightDark);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(stdDevScale);
            HalconAPI.UnpinTuple(absThreshold);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Threshold an image by local mean and standard deviation analysis.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskWidth">Mask width for mean and deviation calculation. Default: 15</param>
        /// <param name="maskHeight">Mask height for mean and deviation calculation. Default: 15</param>
        /// <param name="stdDevScale">Factor for the standard deviation of the gray values. Default: 0.2</param>
        /// <param name="absThreshold">Minimum gray value difference from the mean. Default: 2</param>
        /// <param name="lightDark">Threshold type. Default: "dark"</param>
        /// <returns>Segmented regions.</returns>
        public HRegion VarThreshold(
          int maskWidth,
          int maskHeight,
          double stdDevScale,
          double absThreshold,
          string lightDark)
        {
            IntPtr proc = HalconAPI.PreCall(451);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.StoreD(proc, 2, stdDevScale);
            HalconAPI.StoreD(proc, 3, absThreshold);
            HalconAPI.StoreS(proc, 4, lightDark);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using a local threshold.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="thresholdImage">Image containing the local thresholds.</param>
        /// <param name="offset">Offset applied to ThresholdImage. Default: 5.0</param>
        /// <param name="lightDark">Extract light, dark or similar areas? Default: "light"</param>
        /// <returns>Segmented regions.</returns>
        public HRegion DynThreshold(HImage thresholdImage, HTuple offset, string lightDark)
        {
            IntPtr proc = HalconAPI.PreCall(452);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)thresholdImage);
            HalconAPI.Store(proc, 0, offset);
            HalconAPI.StoreS(proc, 1, lightDark);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(offset);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)thresholdImage);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using a local threshold.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="thresholdImage">Image containing the local thresholds.</param>
        /// <param name="offset">Offset applied to ThresholdImage. Default: 5.0</param>
        /// <param name="lightDark">Extract light, dark or similar areas? Default: "light"</param>
        /// <returns>Segmented regions.</returns>
        public HRegion DynThreshold(HImage thresholdImage, double offset, string lightDark)
        {
            IntPtr proc = HalconAPI.PreCall(452);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)thresholdImage);
            HalconAPI.StoreD(proc, 0, offset);
            HalconAPI.StoreS(proc, 1, lightDark);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)thresholdImage);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using global threshold.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="minGray">Lower threshold for the gray values. Default: 128.0</param>
        /// <param name="maxGray">Upper threshold for the gray values. Default: 255.0</param>
        /// <returns>Segmented region.</returns>
        public HRegion Threshold(HTuple minGray, HTuple maxGray)
        {
            IntPtr proc = HalconAPI.PreCall(453);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, minGray);
            HalconAPI.Store(proc, 1, maxGray);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minGray);
            HalconAPI.UnpinTuple(maxGray);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using global threshold.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="minGray">Lower threshold for the gray values. Default: 128.0</param>
        /// <param name="maxGray">Upper threshold for the gray values. Default: 255.0</param>
        /// <returns>Segmented region.</returns>
        public HRegion Threshold(double minGray, double maxGray)
        {
            IntPtr proc = HalconAPI.PreCall(453);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, minGray);
            HalconAPI.StoreD(proc, 1, maxGray);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Extract level crossings from an image with subpixel accuracy.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="threshold">Threshold for the level crossings. Default: 128</param>
        /// <returns>Extracted level crossings.</returns>
        public HXLDCont ThresholdSubPix(HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(454);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(threshold);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Extract level crossings from an image with subpixel accuracy.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="threshold">Threshold for the level crossings. Default: 128</param>
        /// <returns>Extracted level crossings.</returns>
        public HXLDCont ThresholdSubPix(double threshold)
        {
            IntPtr proc = HalconAPI.PreCall(454);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Segment an image using regiongrowing for multi-channel images.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="metric">Metric for the distance of the feature vectors. Default: "2-norm"</param>
        /// <param name="minTolerance">Lower threshold for the features' distance. Default: 0.0</param>
        /// <param name="maxTolerance">Upper threshold for the features' distance. Default: 20.0</param>
        /// <param name="minSize">Minimum size of the output regions. Default: 30</param>
        /// <returns>Segmented regions.</returns>
        public HRegion RegiongrowingN(
          string metric,
          HTuple minTolerance,
          HTuple maxTolerance,
          int minSize)
        {
            IntPtr proc = HalconAPI.PreCall(455);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, metric);
            HalconAPI.Store(proc, 1, minTolerance);
            HalconAPI.Store(proc, 2, maxTolerance);
            HalconAPI.StoreI(proc, 3, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minTolerance);
            HalconAPI.UnpinTuple(maxTolerance);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using regiongrowing for multi-channel images.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="metric">Metric for the distance of the feature vectors. Default: "2-norm"</param>
        /// <param name="minTolerance">Lower threshold for the features' distance. Default: 0.0</param>
        /// <param name="maxTolerance">Upper threshold for the features' distance. Default: 20.0</param>
        /// <param name="minSize">Minimum size of the output regions. Default: 30</param>
        /// <returns>Segmented regions.</returns>
        public HRegion RegiongrowingN(
          string metric,
          double minTolerance,
          double maxTolerance,
          int minSize)
        {
            IntPtr proc = HalconAPI.PreCall(455);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, metric);
            HalconAPI.StoreD(proc, 1, minTolerance);
            HalconAPI.StoreD(proc, 2, maxTolerance);
            HalconAPI.StoreI(proc, 3, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using regiongrowing.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row">Vertical distance between tested pixels (height of the raster). Default: 3</param>
        /// <param name="column">Horizontal distance between tested pixels (height of the raster). Default: 3</param>
        /// <param name="tolerance">Points with a gray value difference less then or equal to tolerance are accumulated into the same object. Default: 6.0</param>
        /// <param name="minSize">Minimum size of the output regions. Default: 100</param>
        /// <returns>Segmented regions.</returns>
        public HRegion Regiongrowing(int row, int column, HTuple tolerance, int minSize)
        {
            IntPtr proc = HalconAPI.PreCall(456);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, row);
            HalconAPI.StoreI(proc, 1, column);
            HalconAPI.Store(proc, 2, tolerance);
            HalconAPI.StoreI(proc, 3, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(tolerance);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using regiongrowing.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row">Vertical distance between tested pixels (height of the raster). Default: 3</param>
        /// <param name="column">Horizontal distance between tested pixels (height of the raster). Default: 3</param>
        /// <param name="tolerance">Points with a gray value difference less then or equal to tolerance are accumulated into the same object. Default: 6.0</param>
        /// <param name="minSize">Minimum size of the output regions. Default: 100</param>
        /// <returns>Segmented regions.</returns>
        public HRegion Regiongrowing(int row, int column, double tolerance, int minSize)
        {
            IntPtr proc = HalconAPI.PreCall(456);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, row);
            HalconAPI.StoreI(proc, 1, column);
            HalconAPI.StoreD(proc, 2, tolerance);
            HalconAPI.StoreI(proc, 3, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Perform a regiongrowing using mean gray values.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="startRows">Row coordinates of the starting points. Default: []</param>
        /// <param name="startColumns">Column coordinates of the starting points. Default: []</param>
        /// <param name="tolerance">Maximum deviation from the mean. Default: 5.0</param>
        /// <param name="minSize">Minimum size of a region. Default: 100</param>
        /// <returns>Segmented regions.</returns>
        public HRegion RegiongrowingMean(
          HTuple startRows,
          HTuple startColumns,
          double tolerance,
          int minSize)
        {
            IntPtr proc = HalconAPI.PreCall(457);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, startRows);
            HalconAPI.Store(proc, 1, startColumns);
            HalconAPI.StoreD(proc, 2, tolerance);
            HalconAPI.StoreI(proc, 3, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(startRows);
            HalconAPI.UnpinTuple(startColumns);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Perform a regiongrowing using mean gray values.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="startRows">Row coordinates of the starting points. Default: []</param>
        /// <param name="startColumns">Column coordinates of the starting points. Default: []</param>
        /// <param name="tolerance">Maximum deviation from the mean. Default: 5.0</param>
        /// <param name="minSize">Minimum size of a region. Default: 100</param>
        /// <returns>Segmented regions.</returns>
        public HRegion RegiongrowingMean(
          int startRows,
          int startColumns,
          double tolerance,
          int minSize)
        {
            IntPtr proc = HalconAPI.PreCall(457);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, startRows);
            HalconAPI.StoreI(proc, 1, startColumns);
            HalconAPI.StoreD(proc, 2, tolerance);
            HalconAPI.StoreI(proc, 3, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image by "pouring water" over it.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="mode">Mode of operation. Default: "all"</param>
        /// <param name="minGray">All gray values smaller than this threshold are disregarded. Default: 0</param>
        /// <param name="maxGray">All gray values larger than this threshold are disregarded. Default: 255</param>
        /// <returns>Segmented regions.</returns>
        public HRegion Pouring(string mode, int minGray, int maxGray)
        {
            IntPtr proc = HalconAPI.PreCall(458);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.StoreI(proc, 1, minGray);
            HalconAPI.StoreI(proc, 2, maxGray);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Extract watershed basins from an image using a threshold.
        ///   Instance represents: Image to be segmented.
        /// </summary>
        /// <param name="threshold">Threshold for the watersheds. Default: 10</param>
        /// <returns>Segments found (dark basins).</returns>
        public HRegion WatershedsThreshold(HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(459);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(threshold);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Extract watershed basins from an image using a threshold.
        ///   Instance represents: Image to be segmented.
        /// </summary>
        /// <param name="threshold">Threshold for the watersheds. Default: 10</param>
        /// <returns>Segments found (dark basins).</returns>
        public HRegion WatershedsThreshold(int threshold)
        {
            IntPtr proc = HalconAPI.PreCall(459);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Extract watersheds and basins from an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="watersheds">Watersheds between the basins.</param>
        /// <returns>Segmented basins.</returns>
        public HRegion Watersheds(out HRegion watersheds)
        {
            IntPtr proc = HalconAPI.PreCall(460);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HRegion.LoadNew(proc, 2, err2, out watersheds);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Extract zero crossings from an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Zero crossings.</returns>
        public HRegion ZeroCrossing()
        {
            IntPtr proc = HalconAPI.PreCall(461);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Extract zero crossings from an image with subpixel accuracy.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Extracted zero crossings.</returns>
        public HXLDCont ZeroCrossingSubPix()
        {
            IntPtr proc = HalconAPI.PreCall(462);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Threshold operator for signed images.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="minSize">Regions smaller than MinSize are suppressed. Default: 20</param>
        /// <param name="minGray">Regions whose maximum absolute gray value is smaller than MinGray are suppressed. Default: 5.0</param>
        /// <param name="threshold">Regions that have a gray value smaller than Threshold (or larger than -Threshold) are suppressed. Default: 2.0</param>
        /// <returns>Positive and negative regions.</returns>
        public HRegion DualThreshold(int minSize, double minGray, double threshold)
        {
            IntPtr proc = HalconAPI.PreCall(463);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, minSize);
            HalconAPI.StoreD(proc, 1, minGray);
            HalconAPI.StoreD(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Expand a region starting at a given line.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="coordinate">Row or column coordinate. Default: 256</param>
        /// <param name="expandType">Stopping criterion. Default: "gradient"</param>
        /// <param name="rowColumn">Segmentation mode (row or column). Default: "row"</param>
        /// <param name="threshold">Threshold for the expansion. Default: 3.0</param>
        /// <returns>Extracted segments.</returns>
        public HRegion ExpandLine(
          int coordinate,
          string expandType,
          string rowColumn,
          HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(464);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, coordinate);
            HalconAPI.StoreS(proc, 1, expandType);
            HalconAPI.StoreS(proc, 2, rowColumn);
            HalconAPI.Store(proc, 3, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(threshold);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Expand a region starting at a given line.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="coordinate">Row or column coordinate. Default: 256</param>
        /// <param name="expandType">Stopping criterion. Default: "gradient"</param>
        /// <param name="rowColumn">Segmentation mode (row or column). Default: "row"</param>
        /// <param name="threshold">Threshold for the expansion. Default: 3.0</param>
        /// <returns>Extracted segments.</returns>
        public HRegion ExpandLine(
          int coordinate,
          string expandType,
          string rowColumn,
          double threshold)
        {
            IntPtr proc = HalconAPI.PreCall(464);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, coordinate);
            HalconAPI.StoreS(proc, 1, expandType);
            HalconAPI.StoreS(proc, 2, rowColumn);
            HalconAPI.StoreD(proc, 3, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Detect all local minima in an image.
        ///   Instance represents: Image to be processed.
        /// </summary>
        /// <returns>Extracted local minima as regions.</returns>
        public HRegion LocalMin()
        {
            IntPtr proc = HalconAPI.PreCall(465);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Detect all gray value lowlands.
        ///   Instance represents: Image to be processed.
        /// </summary>
        /// <returns>Extracted lowlands as regions (one region for each lowland).</returns>
        public HRegion Lowlands()
        {
            IntPtr proc = HalconAPI.PreCall(466);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Detect the centers of all gray value lowlands.
        ///   Instance represents: Image to be processed.
        /// </summary>
        /// <returns>Centers of gravity of the extracted lowlands as regions (one region for each lowland).</returns>
        public HRegion LowlandsCenter()
        {
            IntPtr proc = HalconAPI.PreCall(467);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Detect all local maxima in an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Extracted local maxima as a region.</returns>
        public HRegion LocalMax()
        {
            IntPtr proc = HalconAPI.PreCall(468);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Detect all gray value plateaus.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Extracted plateaus as regions (one region for each plateau).</returns>
        public HRegion Plateaus()
        {
            IntPtr proc = HalconAPI.PreCall(469);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Detect the centers of all gray value plateaus.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Centers of gravity of the extracted plateaus as regions (one region for each plateau).</returns>
        public HRegion PlateausCenter()
        {
            IntPtr proc = HalconAPI.PreCall(470);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using thresholds determined from its histogram.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigma">Sigma for the Gaussian smoothing of the histogram. Default: 2.0</param>
        /// <returns>Regions with gray values within the automatically determined intervals.</returns>
        public HRegion AutoThreshold(HTuple sigma)
        {
            IntPtr proc = HalconAPI.PreCall(472);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using thresholds determined from its histogram.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigma">Sigma for the Gaussian smoothing of the histogram. Default: 2.0</param>
        /// <returns>Regions with gray values within the automatically determined intervals.</returns>
        public HRegion AutoThreshold(double sigma)
        {
            IntPtr proc = HalconAPI.PreCall(472);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment an image using an automatically determined threshold.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Dark regions of the image.</returns>
        public HRegion BinThreshold()
        {
            IntPtr proc = HalconAPI.PreCall(473);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Fast thresholding of images using global thresholds.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="minGray">Lower threshold for the gray values. Default: 128</param>
        /// <param name="maxGray">Upper threshold for the gray values. Default: 255.0</param>
        /// <param name="minSize">Minimum size of objects to be extracted. Default: 20</param>
        /// <returns>Segmented regions.</returns>
        public HRegion FastThreshold(HTuple minGray, HTuple maxGray, int minSize)
        {
            IntPtr proc = HalconAPI.PreCall(474);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, minGray);
            HalconAPI.Store(proc, 1, maxGray);
            HalconAPI.StoreI(proc, 2, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minGray);
            HalconAPI.UnpinTuple(maxGray);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Fast thresholding of images using global thresholds.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="minGray">Lower threshold for the gray values. Default: 128</param>
        /// <param name="maxGray">Upper threshold for the gray values. Default: 255.0</param>
        /// <param name="minSize">Minimum size of objects to be extracted. Default: 20</param>
        /// <returns>Segmented regions.</returns>
        public HRegion FastThreshold(double minGray, double maxGray, int minSize)
        {
            IntPtr proc = HalconAPI.PreCall(474);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, minGray);
            HalconAPI.StoreD(proc, 1, maxGray);
            HalconAPI.StoreI(proc, 2, minSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Fill gaps between regions (depending on gray value or color) or split overlapping regions.
        ///   Instance represents: Image (possibly multi-channel) for gray value or color comparison.
        /// </summary>
        /// <param name="regions">Regions for which the gaps are to be closed, or which are to be separated.</param>
        /// <param name="forbiddenArea">Regions in which no expansion takes place.</param>
        /// <param name="iterations">Number of iterations. Default: "maximal"</param>
        /// <param name="mode">Expansion mode. Default: "image"</param>
        /// <param name="threshold">Maximum difference between the gray value or color at the region's border and a candidate for expansion. Default: 32</param>
        /// <returns>Expanded or separated regions.</returns>
        public HRegion ExpandGray(
          HRegion regions,
          HRegion forbiddenArea,
          HTuple iterations,
          string mode,
          HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(509);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 3, (HObjectBase)forbiddenArea);
            HalconAPI.Store(proc, 0, iterations);
            HalconAPI.StoreS(proc, 1, mode);
            HalconAPI.Store(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(threshold);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)forbiddenArea);
            return hregion;
        }

        /// <summary>
        ///   Fill gaps between regions (depending on gray value or color) or split overlapping regions.
        ///   Instance represents: Image (possibly multi-channel) for gray value or color comparison.
        /// </summary>
        /// <param name="regions">Regions for which the gaps are to be closed, or which are to be separated.</param>
        /// <param name="forbiddenArea">Regions in which no expansion takes place.</param>
        /// <param name="iterations">Number of iterations. Default: "maximal"</param>
        /// <param name="mode">Expansion mode. Default: "image"</param>
        /// <param name="threshold">Maximum difference between the gray value or color at the region's border and a candidate for expansion. Default: 32</param>
        /// <returns>Expanded or separated regions.</returns>
        public HRegion ExpandGray(
          HRegion regions,
          HRegion forbiddenArea,
          string iterations,
          string mode,
          int threshold)
        {
            IntPtr proc = HalconAPI.PreCall(509);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 3, (HObjectBase)forbiddenArea);
            HalconAPI.StoreS(proc, 0, iterations);
            HalconAPI.StoreS(proc, 1, mode);
            HalconAPI.StoreI(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)forbiddenArea);
            return hregion;
        }

        /// <summary>
        ///   Fill gaps between regions (depending on gray value or color) or split overlapping regions.
        ///   Instance represents: Image (possibly multi-channel) for gray value or color comparison.
        /// </summary>
        /// <param name="regions">Regions for which the gaps are to be closed, or which are to be separated.</param>
        /// <param name="forbiddenArea">Regions in which no expansion takes place.</param>
        /// <param name="iterations">Number of iterations. Default: "maximal"</param>
        /// <param name="mode">Expansion mode. Default: "image"</param>
        /// <param name="refGray">Reference gray value or color for comparison. Default: 128</param>
        /// <param name="threshold">Maximum difference between the reference gray value or color and a candidate for expansion. Default: 32</param>
        /// <returns>Expanded or separated regions.</returns>
        public HRegion ExpandGrayRef(
          HRegion regions,
          HRegion forbiddenArea,
          HTuple iterations,
          string mode,
          HTuple refGray,
          HTuple threshold)
        {
            IntPtr proc = HalconAPI.PreCall(510);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 3, (HObjectBase)forbiddenArea);
            HalconAPI.Store(proc, 0, iterations);
            HalconAPI.StoreS(proc, 1, mode);
            HalconAPI.Store(proc, 2, refGray);
            HalconAPI.Store(proc, 3, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(iterations);
            HalconAPI.UnpinTuple(refGray);
            HalconAPI.UnpinTuple(threshold);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)forbiddenArea);
            return hregion;
        }

        /// <summary>
        ///   Fill gaps between regions (depending on gray value or color) or split overlapping regions.
        ///   Instance represents: Image (possibly multi-channel) for gray value or color comparison.
        /// </summary>
        /// <param name="regions">Regions for which the gaps are to be closed, or which are to be separated.</param>
        /// <param name="forbiddenArea">Regions in which no expansion takes place.</param>
        /// <param name="iterations">Number of iterations. Default: "maximal"</param>
        /// <param name="mode">Expansion mode. Default: "image"</param>
        /// <param name="refGray">Reference gray value or color for comparison. Default: 128</param>
        /// <param name="threshold">Maximum difference between the reference gray value or color and a candidate for expansion. Default: 32</param>
        /// <returns>Expanded or separated regions.</returns>
        public HRegion ExpandGrayRef(
          HRegion regions,
          HRegion forbiddenArea,
          string iterations,
          string mode,
          int refGray,
          int threshold)
        {
            IntPtr proc = HalconAPI.PreCall(510);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 3, (HObjectBase)forbiddenArea);
            HalconAPI.StoreS(proc, 0, iterations);
            HalconAPI.StoreS(proc, 1, mode);
            HalconAPI.StoreI(proc, 2, refGray);
            HalconAPI.StoreI(proc, 3, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)forbiddenArea);
            return hregion;
        }

        /// <summary>
        ///   Calculate the difference of two object tuples.
        ///   Instance represents: Object tuple 1.
        /// </summary>
        /// <param name="objectsSub">Object tuple 2.</param>
        /// <returns>Objects from Objects that are not part of ObjectsSub.</returns>
        public HImage ObjDiff(HImage objectsSub)
        {
            IntPtr proc = HalconAPI.PreCall(573);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)objectsSub);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)objectsSub);
            return himage;
        }

        /// <summary>
        ///   Set single gray values in an image.
        ///   Instance represents: Image to be modified.
        /// </summary>
        /// <param name="row">Row coordinates of the pixels to be modified. Default: 0</param>
        /// <param name="column">Column coordinates of the pixels to be modified. Default: 0</param>
        /// <param name="grayval">Gray values to be used. Default: 255.0</param>
        public void SetGrayval(HTuple row, HTuple column, HTuple grayval)
        {
            IntPtr proc = HalconAPI.PreCall(574);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, grayval);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(grayval);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Set single gray values in an image.
        ///   Instance represents: Image to be modified.
        /// </summary>
        /// <param name="row">Row coordinates of the pixels to be modified. Default: 0</param>
        /// <param name="column">Column coordinates of the pixels to be modified. Default: 0</param>
        /// <param name="grayval">Gray values to be used. Default: 255.0</param>
        public void SetGrayval(int row, int column, double grayval)
        {
            IntPtr proc = HalconAPI.PreCall(574);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, row);
            HalconAPI.StoreI(proc, 1, column);
            HalconAPI.StoreD(proc, 2, grayval);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Paint XLD objects into an image.
        ///   Instance represents: Image in which the xld objects are to be painted.
        /// </summary>
        /// <param name="XLD">XLD objects to be painted into the input image.</param>
        /// <param name="grayval">Desired gray value of the xld object. Default: 255.0</param>
        /// <returns>Image containing the result.</returns>
        public HImage PaintXld(HXLD XLD, HTuple grayval)
        {
            IntPtr proc = HalconAPI.PreCall(575);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.Store(proc, 0, grayval);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(grayval);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)XLD);
            return himage;
        }

        /// <summary>
        ///   Paint XLD objects into an image.
        ///   Instance represents: Image in which the xld objects are to be painted.
        /// </summary>
        /// <param name="XLD">XLD objects to be painted into the input image.</param>
        /// <param name="grayval">Desired gray value of the xld object. Default: 255.0</param>
        /// <returns>Image containing the result.</returns>
        public HImage PaintXld(HXLD XLD, double grayval)
        {
            IntPtr proc = HalconAPI.PreCall(575);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)XLD);
            HalconAPI.StoreD(proc, 0, grayval);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)XLD);
            return himage;
        }

        /// <summary>
        ///   Paint regions into an image.
        ///   Instance represents: Image in which the regions are to be painted.
        /// </summary>
        /// <param name="region">Regions to be painted into the input image.</param>
        /// <param name="grayval">Desired gray values of the regions. Default: 255.0</param>
        /// <param name="type">Paint regions filled or as boundaries. Default: "fill"</param>
        /// <returns>Image containing the result.</returns>
        public HImage PaintRegion(HRegion region, HTuple grayval, string type)
        {
            IntPtr proc = HalconAPI.PreCall(576);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.Store(proc, 0, grayval);
            HalconAPI.StoreS(proc, 1, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(grayval);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return himage;
        }

        /// <summary>
        ///   Paint regions into an image.
        ///   Instance represents: Image in which the regions are to be painted.
        /// </summary>
        /// <param name="region">Regions to be painted into the input image.</param>
        /// <param name="grayval">Desired gray values of the regions. Default: 255.0</param>
        /// <param name="type">Paint regions filled or as boundaries. Default: "fill"</param>
        /// <returns>Image containing the result.</returns>
        public HImage PaintRegion(HRegion region, double grayval, string type)
        {
            IntPtr proc = HalconAPI.PreCall(576);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.StoreD(proc, 0, grayval);
            HalconAPI.StoreS(proc, 1, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return himage;
        }

        /// <summary>
        ///   Overpaint regions in an image.
        ///   Instance represents: Image in which the regions are to be painted.
        /// </summary>
        /// <param name="region">Regions to be painted into the input image.</param>
        /// <param name="grayval">Desired gray values of the regions. Default: 255.0</param>
        /// <param name="type">Paint regions filled or as boundaries. Default: "fill"</param>
        public void OverpaintRegion(HRegion region, HTuple grayval, string type)
        {
            IntPtr proc = HalconAPI.PreCall(577);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.Store(proc, 0, grayval);
            HalconAPI.StoreS(proc, 1, type);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(grayval);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
        }

        /// <summary>
        ///   Overpaint regions in an image.
        ///   Instance represents: Image in which the regions are to be painted.
        /// </summary>
        /// <param name="region">Regions to be painted into the input image.</param>
        /// <param name="grayval">Desired gray values of the regions. Default: 255.0</param>
        /// <param name="type">Paint regions filled or as boundaries. Default: "fill"</param>
        public void OverpaintRegion(HRegion region, double grayval, string type)
        {
            IntPtr proc = HalconAPI.PreCall(577);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.StoreD(proc, 0, grayval);
            HalconAPI.StoreS(proc, 1, type);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
        }

        /// <summary>
        ///   Create an image with a specified constant gray value.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="grayval">Gray value to be used for the output image. Default: 0</param>
        /// <returns>Image with constant gray value.</returns>
        public HImage GenImageProto(HTuple grayval)
        {
            IntPtr proc = HalconAPI.PreCall(578);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, grayval);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(grayval);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Create an image with a specified constant gray value.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="grayval">Gray value to be used for the output image. Default: 0</param>
        /// <returns>Image with constant gray value.</returns>
        public HImage GenImageProto(double grayval)
        {
            IntPtr proc = HalconAPI.PreCall(578);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, grayval);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Paint the gray values of an image into another image.
        ///   Instance represents: Input image containing the desired gray values.
        /// </summary>
        /// <param name="imageDestination">Input image to be painted over.</param>
        /// <returns>Result image.</returns>
        public HImage PaintGray(HImage imageDestination)
        {
            IntPtr proc = HalconAPI.PreCall(579);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageDestination);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageDestination);
            return himage;
        }

        /// <summary>
        ///   Overpaint the gray values of an image.
        ///   Instance represents: Input image to be painted over.
        /// </summary>
        /// <param name="imageSource">Input image containing the desired gray values.</param>
        public void OverpaintGray(HImage imageSource)
        {
            IntPtr proc = HalconAPI.PreCall(580);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageSource);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageSource);
        }

        /// <summary>
        ///   Copy an iconic object in the HALCON database.
        ///   Instance represents: Objects to be copied.
        /// </summary>
        /// <param name="index">Starting index of the objects to be copied. Default: 1</param>
        /// <param name="numObj">Number of objects to be copied or -1. Default: 1</param>
        /// <returns>Copied objects.</returns>
        public HImage CopyObj(int index, int numObj)
        {
            IntPtr proc = HalconAPI.PreCall(583);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, index);
            HalconAPI.StoreI(proc, 1, numObj);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Concatenate two iconic object tuples.
        ///   Instance represents: Object tuple 1.
        /// </summary>
        /// <param name="objects2">Object tuple 2.</param>
        /// <returns>Concatenated objects.</returns>
        public HImage ConcatObj(HImage objects2)
        {
            IntPtr proc = HalconAPI.PreCall(584);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)objects2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)objects2);
            return himage;
        }

        /// <summary>
        ///   Copy an image and allocate new memory for it.
        ///   Instance represents: Image to be copied.
        /// </summary>
        /// <returns>Copied image.</returns>
        public HImage CopyImage()
        {
            IntPtr proc = HalconAPI.PreCall(586);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Select objects from an object tuple.
        ///   Instance represents: Input objects.
        /// </summary>
        /// <param name="index">Indices of the objects to be selected. Default: 1</param>
        /// <returns>Selected objects.</returns>
        public HImage SelectObj(HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(587);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, index);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(index);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Select objects from an object tuple.
        ///   Instance represents: Input objects.
        /// </summary>
        /// <param name="index">Indices of the objects to be selected. Default: 1</param>
        /// <returns>Selected objects.</returns>
        public HImage SelectObj(int index)
        {
            IntPtr proc = HalconAPI.PreCall(587);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, index);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compare iconic objects regarding equality.
        ///   Instance represents: Reference objects.
        /// </summary>
        /// <param name="objects2">Test objects.</param>
        /// <param name="epsilon">Maximum allowed difference between two gray values or  coordinates etc. Default: 0.0</param>
        /// <returns>Boolean result value.</returns>
        public int CompareObj(HImage objects2, HTuple epsilon)
        {
            IntPtr proc = HalconAPI.PreCall(588);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)objects2);
            HalconAPI.Store(proc, 0, epsilon);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(epsilon);
            int intValue;
            int procResult = HalconAPI.LoadI(proc, 0, err, out intValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)objects2);
            return intValue;
        }

        /// <summary>
        ///   Compare iconic objects regarding equality.
        ///   Instance represents: Reference objects.
        /// </summary>
        /// <param name="objects2">Test objects.</param>
        /// <param name="epsilon">Maximum allowed difference between two gray values or  coordinates etc. Default: 0.0</param>
        /// <returns>Boolean result value.</returns>
        public int CompareObj(HImage objects2, double epsilon)
        {
            IntPtr proc = HalconAPI.PreCall(588);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)objects2);
            HalconAPI.StoreD(proc, 0, epsilon);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int intValue;
            int procResult = HalconAPI.LoadI(proc, 0, err, out intValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)objects2);
            return intValue;
        }

        /// <summary>
        ///   Compare image objects regarding equality.
        ///   Instance represents: Test objects.
        /// </summary>
        /// <param name="objects2">Comparative objects.</param>
        /// <returns>boolean result value.</returns>
        public int TestEqualObj(HImage objects2)
        {
            IntPtr proc = HalconAPI.PreCall(591);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)objects2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            int intValue;
            int procResult = HalconAPI.LoadI(proc, 0, err, out intValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)objects2);
            return intValue;
        }

        /// <summary>
        ///   Create a three-channel image from a pointer to the interleaved pixels.
        ///   Modified instance represents: Created image with new image matrix.
        /// </summary>
        /// <param name="pixelPointer">Pointer to interleaved pixels.</param>
        /// <param name="colorFormat">Format of the input pixels. Default: "rgb"</param>
        /// <param name="originalWidth">Width of input image. Default: 512</param>
        /// <param name="originalHeight">Height of input image. Default: 512</param>
        /// <param name="alignment">Reserved.</param>
        /// <param name="type">Pixel type of output image. Default: "byte"</param>
        /// <param name="imageWidth">Width of output image. Default: 0</param>
        /// <param name="imageHeight">Height of output image. Default: 0</param>
        /// <param name="startRow">Line number of upper left corner of desired image part. Default: 0</param>
        /// <param name="startColumn">Column number of upper left corner of desired image part. Default: 0</param>
        /// <param name="bitsPerChannel">Number of used bits per pixel and channel of the output image (-1: All bits are used). Default: -1</param>
        /// <param name="bitShift">Number of bits that the color values of the input pixels are shifted to the right (only uint2 images). Default: 0</param>
        public void GenImageInterleaved(
          IntPtr pixelPointer,
          string colorFormat,
          int originalWidth,
          int originalHeight,
          int alignment,
          string type,
          int imageWidth,
          int imageHeight,
          int startRow,
          int startColumn,
          int bitsPerChannel,
          int bitShift)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(595);
            HalconAPI.StoreIP(proc, 0, pixelPointer);
            HalconAPI.StoreS(proc, 1, colorFormat);
            HalconAPI.StoreI(proc, 2, originalWidth);
            HalconAPI.StoreI(proc, 3, originalHeight);
            HalconAPI.StoreI(proc, 4, alignment);
            HalconAPI.StoreS(proc, 5, type);
            HalconAPI.StoreI(proc, 6, imageWidth);
            HalconAPI.StoreI(proc, 7, imageHeight);
            HalconAPI.StoreI(proc, 8, startRow);
            HalconAPI.StoreI(proc, 9, startColumn);
            HalconAPI.StoreI(proc, 10, bitsPerChannel);
            HalconAPI.StoreI(proc, 11, bitShift);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Create an image from three pointers to the pixels (red/green/blue).
        ///   Modified instance represents: Created image with new image matrix.
        /// </summary>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        /// <param name="pixelPointerRed">Pointer to first red value (channel 1).</param>
        /// <param name="pixelPointerGreen">Pointer to first green value (channel 2).</param>
        /// <param name="pixelPointerBlue">Pointer to first blue value (channel 3).</param>
        public void GenImage3(
          string type,
          int width,
          int height,
          IntPtr pixelPointerRed,
          IntPtr pixelPointerGreen,
          IntPtr pixelPointerBlue)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(605);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.StoreI(proc, 1, width);
            HalconAPI.StoreI(proc, 2, height);
            HalconAPI.StoreIP(proc, 3, pixelPointerRed);
            HalconAPI.StoreIP(proc, 4, pixelPointerGreen);
            HalconAPI.StoreIP(proc, 5, pixelPointerBlue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Create an image from a pointer to the pixels.
        ///   Modified instance represents: Created image with new image matrix.
        /// </summary>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        /// <param name="pixelPointer">Pointer to first gray value.</param>
        public void GenImage1(string type, int width, int height, IntPtr pixelPointer)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(606);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.StoreI(proc, 1, width);
            HalconAPI.StoreI(proc, 2, height);
            HalconAPI.StoreIP(proc, 3, pixelPointer);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Create an image with constant gray value.
        ///   Modified instance represents: Created image with new image matrix.
        /// </summary>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        public void GenImageConst(string type, int width, int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(607);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.StoreI(proc, 1, width);
            HalconAPI.StoreI(proc, 2, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Create a gray value ramp.
        ///   Modified instance represents: Created image with new image matrix.
        /// </summary>
        /// <param name="alpha">Gradient in line direction. Default: 1.0</param>
        /// <param name="beta">Gradient in column direction. Default: 1.0</param>
        /// <param name="mean">Mean gray value. Default: 128</param>
        /// <param name="row">Line index of reference point. Default: 256</param>
        /// <param name="column">Column index of reference point. Default: 256</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        public void GenImageGrayRamp(
          double alpha,
          double beta,
          double mean,
          int row,
          int column,
          int width,
          int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(619);
            HalconAPI.StoreD(proc, 0, alpha);
            HalconAPI.StoreD(proc, 1, beta);
            HalconAPI.StoreD(proc, 2, mean);
            HalconAPI.StoreI(proc, 3, row);
            HalconAPI.StoreI(proc, 4, column);
            HalconAPI.StoreI(proc, 5, width);
            HalconAPI.StoreI(proc, 6, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Create a three-channel image from three pointers on the pixels with storage management.
        ///   Modified instance represents: Created HALCON image.
        /// </summary>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        /// <param name="pointerRed">Pointer to the first gray value of the first channel.</param>
        /// <param name="pointerGreen">Pointer to the first gray value of the second channel.</param>
        /// <param name="pointerBlue">Pointer to the first gray value of the third channel.</param>
        /// <param name="clearProc">Pointer to the procedure re-releasing the memory of the image when deleting the object. Default: 0</param>
        public void GenImage3Extern(
          string type,
          int width,
          int height,
          IntPtr pointerRed,
          IntPtr pointerGreen,
          IntPtr pointerBlue,
          IntPtr clearProc)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(620);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.StoreI(proc, 1, width);
            HalconAPI.StoreI(proc, 2, height);
            HalconAPI.StoreIP(proc, 3, pointerRed);
            HalconAPI.StoreIP(proc, 4, pointerGreen);
            HalconAPI.StoreIP(proc, 5, pointerBlue);
            HalconAPI.StoreIP(proc, 6, clearProc);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Create an image from a pointer on the pixels with storage management.
        ///   Modified instance represents: Created HALCON image.
        /// </summary>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        /// <param name="pixelPointer">Pointer to the first gray value.</param>
        /// <param name="clearProc">Pointer to the procedure re-releasing the memory of the image when deleting the object. Default: 0</param>
        public void GenImage1Extern(
          string type,
          int width,
          int height,
          IntPtr pixelPointer,
          IntPtr clearProc)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(621);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.StoreI(proc, 1, width);
            HalconAPI.StoreI(proc, 2, height);
            HalconAPI.StoreIP(proc, 3, pixelPointer);
            HalconAPI.StoreIP(proc, 4, clearProc);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Create an image with a rectangular domain from a pointer on the pixels (with storage management).
        ///   Modified instance represents: Created HALCON image.
        /// </summary>
        /// <param name="pixelPointer">Pointer to the first pixel.</param>
        /// <param name="width">Width of the image. Default: 512</param>
        /// <param name="height">Height of the image. Default: 512</param>
        /// <param name="verticalPitch">Distance (in bytes) between pixel m in row n and pixel m in row n+1 of the 'input image'.</param>
        /// <param name="horizontalBitPitch">Distance between two neighboring pixels in bits . Default: 8</param>
        /// <param name="bitsPerPixel">Number of used bits per pixel. Default: 8</param>
        /// <param name="doCopy">Copy image data. Default: "false"</param>
        /// <param name="clearProc">Pointer to the procedure releasing the memory of the image when deleting the object. Default: 0</param>
        public void GenImage1Rect(
          IntPtr pixelPointer,
          int width,
          int height,
          int verticalPitch,
          int horizontalBitPitch,
          int bitsPerPixel,
          string doCopy,
          IntPtr clearProc)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(622);
            HalconAPI.StoreIP(proc, 0, pixelPointer);
            HalconAPI.StoreI(proc, 1, width);
            HalconAPI.StoreI(proc, 2, height);
            HalconAPI.StoreI(proc, 3, verticalPitch);
            HalconAPI.StoreI(proc, 4, horizontalBitPitch);
            HalconAPI.StoreI(proc, 5, bitsPerPixel);
            HalconAPI.StoreS(proc, 6, doCopy);
            HalconAPI.StoreIP(proc, 7, clearProc);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Access to the image data pointer and the image data inside the smallest rectangle of the domain of the input image.
        ///   Instance represents: Input image (Himage).
        /// </summary>
        /// <param name="width">Width of the output image.</param>
        /// <param name="height">Height of the output image.</param>
        /// <param name="verticalPitch">Width(input image)*(HorizontalBitPitch/8).</param>
        /// <param name="horizontalBitPitch">Distance between two neighboring pixels in bits .</param>
        /// <param name="bitsPerPixel">Number of used bits per pixel.</param>
        /// <returns>Pointer to the image data.</returns>
        public IntPtr GetImagePointer1Rect(
          out int width,
          out int height,
          out int verticalPitch,
          out int horizontalBitPitch,
          out int bitsPerPixel)
        {
            IntPtr proc = HalconAPI.PreCall(623);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            IntPtr intPtrValue;
            int err2 = HalconAPI.LoadIP(proc, 0, err1, out intPtrValue);
            int err3 = HalconAPI.LoadI(proc, 1, err2, out width);
            int err4 = HalconAPI.LoadI(proc, 2, err3, out height);
            int err5 = HalconAPI.LoadI(proc, 3, err4, out verticalPitch);
            int err6 = HalconAPI.LoadI(proc, 4, err5, out horizontalBitPitch);
            int procResult = HalconAPI.LoadI(proc, 5, err6, out bitsPerPixel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return intPtrValue;
        }

        /// <summary>
        ///   Access the pointers of a colored image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="pointerRed">Pointer to the pixels of the first channel.</param>
        /// <param name="pointerGreen">Pointer to the pixels of the second channel.</param>
        /// <param name="pointerBlue">Pointer to the pixels of the third channel.</param>
        /// <param name="type">Type of image.</param>
        /// <param name="width">Width of image.</param>
        /// <param name="height">Height of image.</param>
        public void GetImagePointer3(
          out HTuple pointerRed,
          out HTuple pointerGreen,
          out HTuple pointerBlue,
          out HTuple type,
          out HTuple width,
          out HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(624);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out pointerRed);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out pointerGreen);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out pointerBlue);
            int err5 = HTuple.LoadNew(proc, 3, err4, out type);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out width);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Access the pointers of a colored image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="pointerRed">Pointer to the pixels of the first channel.</param>
        /// <param name="pointerGreen">Pointer to the pixels of the second channel.</param>
        /// <param name="pointerBlue">Pointer to the pixels of the third channel.</param>
        /// <param name="type">Type of image.</param>
        /// <param name="width">Width of image.</param>
        /// <param name="height">Height of image.</param>
        public void GetImagePointer3(
          out IntPtr pointerRed,
          out IntPtr pointerGreen,
          out IntPtr pointerBlue,
          out string type,
          out int width,
          out int height)
        {
            IntPtr proc = HalconAPI.PreCall(624);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HalconAPI.LoadIP(proc, 0, err1, out pointerRed);
            int err3 = HalconAPI.LoadIP(proc, 1, err2, out pointerGreen);
            int err4 = HalconAPI.LoadIP(proc, 2, err3, out pointerBlue);
            int err5 = HalconAPI.LoadS(proc, 3, err4, out type);
            int err6 = HalconAPI.LoadI(proc, 4, err5, out width);
            int procResult = HalconAPI.LoadI(proc, 5, err6, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Access the pointer of a channel.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="type">Type of image.</param>
        /// <param name="width">Width of image.</param>
        /// <param name="height">Height of image.</param>
        /// <returns>Pointer to the image data in the HALCON database.</returns>
        public HTuple GetImagePointer1(out HTuple type, out HTuple width, out HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(625);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, err2, out type);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out width);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Access the pointer of a channel.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="type">Type of image.</param>
        /// <param name="width">Width of image.</param>
        /// <param name="height">Height of image.</param>
        /// <returns>Pointer to the image data in the HALCON database.</returns>
        public IntPtr GetImagePointer1(out string type, out int width, out int height)
        {
            IntPtr proc = HalconAPI.PreCall(625);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            IntPtr intPtrValue;
            int err2 = HalconAPI.LoadIP(proc, 0, err1, out intPtrValue);
            int err3 = HalconAPI.LoadS(proc, 1, err2, out type);
            int err4 = HalconAPI.LoadI(proc, 2, err3, out width);
            int procResult = HalconAPI.LoadI(proc, 3, err4, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return intPtrValue;
        }

        /// <summary>
        ///   Return the type of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Type of image.</returns>
        public HTuple GetImageType()
        {
            IntPtr proc = HalconAPI.PreCall(626);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Return the size of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="width">Width of image.</param>
        /// <param name="height">Height of image.</param>
        public void GetImageSize(out HTuple width, out HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(627);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out width);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Return the size of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="width">Width of image.</param>
        /// <param name="height">Height of image.</param>
        public void GetImageSize(out int width, out int height)
        {
            IntPtr proc = HalconAPI.PreCall(627);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HalconAPI.LoadI(proc, 0, err1, out width);
            int procResult = HalconAPI.LoadI(proc, 1, err2, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Request time at which the image was created.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="second">Seconds (0..59).</param>
        /// <param name="minute">Minutes (0..59).</param>
        /// <param name="hour">Hours (0..23).</param>
        /// <param name="day">Day of the month (1..31).</param>
        /// <param name="YDay">Day of the year (1..366).</param>
        /// <param name="month">Month (1..12).</param>
        /// <param name="year">Year (xxxx).</param>
        /// <returns>Milliseconds (0..999).</returns>
        public int GetImageTime(
          out int second,
          out int minute,
          out int hour,
          out int day,
          out int YDay,
          out int month,
          out int year)
        {
            IntPtr proc = HalconAPI.PreCall(628);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            int intValue;
            int err2 = HalconAPI.LoadI(proc, 0, err1, out intValue);
            int err3 = HalconAPI.LoadI(proc, 1, err2, out second);
            int err4 = HalconAPI.LoadI(proc, 2, err3, out minute);
            int err5 = HalconAPI.LoadI(proc, 3, err4, out hour);
            int err6 = HalconAPI.LoadI(proc, 4, err5, out day);
            int err7 = HalconAPI.LoadI(proc, 5, err6, out YDay);
            int err8 = HalconAPI.LoadI(proc, 6, err7, out month);
            int procResult = HalconAPI.LoadI(proc, 7, err8, out year);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return intValue;
        }

        /// <summary>
        ///   Return gray values of an image at the positions given by tuples of rows and columns.
        ///   Instance represents: Image whose gray values are to be accessed.
        /// </summary>
        /// <param name="row">Row coordinates of positions. Default: 0</param>
        /// <param name="column">Column coordinates of positions. Default: 0</param>
        /// <param name="interpolation">Interpolation method. Default: "bilinear"</param>
        /// <returns>Gray values of the selected image coordinates.</returns>
        public HTuple GetGrayvalInterpolated(HTuple row, HTuple column, string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(629);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.StoreS(proc, 2, interpolation);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Return gray values of an image at the positions given by tuples of rows and columns.
        ///   Instance represents: Image whose gray values are to be accessed.
        /// </summary>
        /// <param name="row">Row coordinates of positions. Default: 0</param>
        /// <param name="column">Column coordinates of positions. Default: 0</param>
        /// <param name="interpolation">Interpolation method. Default: "bilinear"</param>
        /// <returns>Gray values of the selected image coordinates.</returns>
        public double GetGrayvalInterpolated(double row, double column, string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(629);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, row);
            HalconAPI.StoreD(proc, 1, column);
            HalconAPI.StoreS(proc, 2, interpolation);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int procResult = HalconAPI.LoadD(proc, 0, err, out doubleValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return doubleValue;
        }

        /// <summary>
        ///   Access the gray values of an image object.
        ///   Instance represents: Image whose gray value is to be accessed.
        /// </summary>
        /// <param name="row">Row coordinates of pixels to be viewed. Default: 0</param>
        /// <param name="column">Column coordinates of pixels to be viewed. Default: 0</param>
        /// <returns>Gray values of indicated pixels.</returns>
        public HTuple GetGrayval(HTuple row, HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(630);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Access the gray values of an image object.
        ///   Instance represents: Image whose gray value is to be accessed.
        /// </summary>
        /// <param name="row">Row coordinates of pixels to be viewed. Default: 0</param>
        /// <param name="column">Column coordinates of pixels to be viewed. Default: 0</param>
        /// <returns>Gray values of indicated pixels.</returns>
        public HTuple GetGrayval(int row, int column)
        {
            IntPtr proc = HalconAPI.PreCall(630);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, row);
            HalconAPI.StoreI(proc, 1, column);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Verification of a pattern using an OCV tool.
        ///   Instance represents: Characters to be verified.
        /// </summary>
        /// <param name="OCVHandle">Handle of the OCV tool.</param>
        /// <param name="patternName">Name of the character. Default: "a"</param>
        /// <param name="adaptPos">Adaption to vertical and horizontal translation. Default: "true"</param>
        /// <param name="adaptSize">Adaption to vertical and horizontal scaling of the size. Default: "true"</param>
        /// <param name="adaptAngle">Adaption to changes of the orientation (not implemented). Default: "false"</param>
        /// <param name="adaptGray">Adaption to additive and scaling gray value changes. Default: "true"</param>
        /// <param name="threshold">Minimum difference between objects. Default: 10</param>
        /// <returns>Evaluation of the character.</returns>
        public HTuple DoOcvSimple(
          HOCV OCVHandle,
          HTuple patternName,
          string adaptPos,
          string adaptSize,
          string adaptAngle,
          string adaptGray,
          double threshold)
        {
            IntPtr proc = HalconAPI.PreCall(638);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)OCVHandle);
            HalconAPI.Store(proc, 1, patternName);
            HalconAPI.StoreS(proc, 2, adaptPos);
            HalconAPI.StoreS(proc, 3, adaptSize);
            HalconAPI.StoreS(proc, 4, adaptAngle);
            HalconAPI.StoreS(proc, 5, adaptGray);
            HalconAPI.StoreD(proc, 6, threshold);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(patternName);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)OCVHandle);
            return tuple;
        }

        /// <summary>
        ///   Verification of a pattern using an OCV tool.
        ///   Instance represents: Characters to be verified.
        /// </summary>
        /// <param name="OCVHandle">Handle of the OCV tool.</param>
        /// <param name="patternName">Name of the character. Default: "a"</param>
        /// <param name="adaptPos">Adaption to vertical and horizontal translation. Default: "true"</param>
        /// <param name="adaptSize">Adaption to vertical and horizontal scaling of the size. Default: "true"</param>
        /// <param name="adaptAngle">Adaption to changes of the orientation (not implemented). Default: "false"</param>
        /// <param name="adaptGray">Adaption to additive and scaling gray value changes. Default: "true"</param>
        /// <param name="threshold">Minimum difference between objects. Default: 10</param>
        /// <returns>Evaluation of the character.</returns>
        public double DoOcvSimple(
          HOCV OCVHandle,
          string patternName,
          string adaptPos,
          string adaptSize,
          string adaptAngle,
          string adaptGray,
          double threshold)
        {
            IntPtr proc = HalconAPI.PreCall(638);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)OCVHandle);
            HalconAPI.StoreS(proc, 1, patternName);
            HalconAPI.StoreS(proc, 2, adaptPos);
            HalconAPI.StoreS(proc, 3, adaptSize);
            HalconAPI.StoreS(proc, 4, adaptAngle);
            HalconAPI.StoreS(proc, 5, adaptGray);
            HalconAPI.StoreD(proc, 6, threshold);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int procResult = HalconAPI.LoadD(proc, 0, err, out doubleValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)OCVHandle);
            return doubleValue;
        }

        /// <summary>
        ///   Training of an OCV tool.
        ///   Instance represents: Pattern to be trained.
        /// </summary>
        /// <param name="OCVHandle">Handle of the OCV tool to be trained.</param>
        /// <param name="name">Name(s) of the object(s) to analyse. Default: "a"</param>
        /// <param name="mode">Mode for training (only one mode implemented). Default: "single"</param>
        public void TraindOcvProj(HOCV OCVHandle, HTuple name, string mode)
        {
            IntPtr proc = HalconAPI.PreCall(639);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)OCVHandle);
            HalconAPI.Store(proc, 1, name);
            HalconAPI.StoreS(proc, 2, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(name);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)OCVHandle);
        }

        /// <summary>
        ///   Training of an OCV tool.
        ///   Instance represents: Pattern to be trained.
        /// </summary>
        /// <param name="OCVHandle">Handle of the OCV tool to be trained.</param>
        /// <param name="name">Name(s) of the object(s) to analyse. Default: "a"</param>
        /// <param name="mode">Mode for training (only one mode implemented). Default: "single"</param>
        public void TraindOcvProj(HOCV OCVHandle, string name, string mode)
        {
            IntPtr proc = HalconAPI.PreCall(639);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)OCVHandle);
            HalconAPI.StoreS(proc, 1, name);
            HalconAPI.StoreS(proc, 2, mode);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)OCVHandle);
        }

        /// <summary>
        ///   Compute the features of a character.
        ///   Instance represents: Input character.
        /// </summary>
        /// <param name="OCRHandle">Handle of the k-NN classifier.</param>
        /// <param name="transform">Should the feature vector be transformed with the preprocessing? Default: "true"</param>
        /// <returns>Feature vector of the character.</returns>
        public HTuple GetFeaturesOcrClassKnn(HOCRKnn OCRHandle, string transform)
        {
            IntPtr proc = HalconAPI.PreCall(656);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)OCRHandle);
            HalconAPI.StoreS(proc, 1, transform);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)OCRHandle);
            return tuple;
        }

        /// <summary>
        ///   Compute the features of a character.
        ///   Instance represents: Input character.
        /// </summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="transform">Should the feature vector be transformed with the preprocessing? Default: "true"</param>
        /// <returns>Feature vector of the character.</returns>
        public HTuple GetFeaturesOcrClassSvm(HOCRSvm OCRHandle, string transform)
        {
            IntPtr proc = HalconAPI.PreCall(678);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)OCRHandle);
            HalconAPI.StoreS(proc, 1, transform);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)OCRHandle);
            return tuple;
        }

        /// <summary>
        ///   Compute the features of a character.
        ///   Instance represents: Input character.
        /// </summary>
        /// <param name="OCRHandle">Handle of the OCR classifier.</param>
        /// <param name="transform">Should the feature vector be transformed with the preprocessing? Default: "true"</param>
        /// <returns>Feature vector of the character.</returns>
        public HTuple GetFeaturesOcrClassMlp(HOCRMlp OCRHandle, string transform)
        {
            IntPtr proc = HalconAPI.PreCall(696);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)OCRHandle);
            HalconAPI.StoreS(proc, 1, transform);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)OCRHandle);
            return tuple;
        }

        /// <summary>
        ///   Cut out an image area relative to the domain.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="top">Number of rows clipped at the top. Default: -1</param>
        /// <param name="left">Number of columns clipped at the left. Default: -1</param>
        /// <param name="bottom">Number of rows clipped at the bottom. Default: -1</param>
        /// <param name="right">Number of columns clipped at the right. Default: -1</param>
        /// <returns>Image area.</returns>
        public HImage CropDomainRel(int top, int left, int bottom, int right)
        {
            IntPtr proc = HalconAPI.PreCall(726);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, top);
            HalconAPI.StoreI(proc, 1, left);
            HalconAPI.StoreI(proc, 2, bottom);
            HalconAPI.StoreI(proc, 3, right);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Access the features which correspond to a character.
        ///   Instance represents: Characters to be trained.
        /// </summary>
        /// <param name="ocrHandle">ID of the desired OCR-classifier.</param>
        /// <returns>Feature vector.</returns>
        public HTuple OcrGetFeatures(HOCRBox ocrHandle)
        {
            IntPtr proc = HalconAPI.PreCall(727);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)ocrHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)ocrHandle);
            return tuple;
        }

        /// <summary>
        ///   Write characters into a training file.
        ///   Instance represents: Characters to be trained.
        /// </summary>
        /// <param name="classVal">Class (name) of the characters.</param>
        /// <param name="trainingFile">Name of the training file. Default: "train_ocr"</param>
        public void WriteOcrTrainfImage(HTuple classVal, string trainingFile)
        {
            IntPtr proc = HalconAPI.PreCall(729);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, classVal);
            HalconAPI.StoreS(proc, 1, trainingFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(classVal);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Write characters into a training file.
        ///   Instance represents: Characters to be trained.
        /// </summary>
        /// <param name="classVal">Class (name) of the characters.</param>
        /// <param name="trainingFile">Name of the training file. Default: "train_ocr"</param>
        public void WriteOcrTrainfImage(string classVal, string trainingFile)
        {
            IntPtr proc = HalconAPI.PreCall(729);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, classVal);
            HalconAPI.StoreS(proc, 1, trainingFile);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Read training specific characters from files and convert to images.
        ///   Modified instance represents: Images read from file.
        /// </summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="searchNames">Names of the characters to be extracted. Default: "0"</param>
        /// <returns>Names of the read characters.</returns>
        public HTuple ReadOcrTrainfSelect(HTuple trainingFile, HTuple searchNames)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(733);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.Store(proc, 1, searchNames);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            HalconAPI.UnpinTuple(searchNames);
            int err2 = this.Load(proc, 1, err1);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err2, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Read training specific characters from files and convert to images.
        ///   Modified instance represents: Images read from file.
        /// </summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <param name="searchNames">Names of the characters to be extracted. Default: "0"</param>
        /// <returns>Names of the read characters.</returns>
        public string ReadOcrTrainfSelect(string trainingFile, string searchNames)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(733);
            HalconAPI.StoreS(proc, 0, trainingFile);
            HalconAPI.StoreS(proc, 1, searchNames);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = this.Load(proc, 1, err1);
            string stringValue;
            int procResult = HalconAPI.LoadS(proc, 0, err2, out stringValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return stringValue;
        }

        /// <summary>
        ///   Read training characters from files and convert to images.
        ///   Modified instance represents: Images read from file.
        /// </summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <returns>Names of the read characters.</returns>
        public HTuple ReadOcrTrainf(HTuple trainingFile)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(734);
            HalconAPI.Store(proc, 0, trainingFile);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(trainingFile);
            int err2 = this.Load(proc, 1, err1);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err2, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Read training characters from files and convert to images.
        ///   Modified instance represents: Images read from file.
        /// </summary>
        /// <param name="trainingFile">Names of the training files. Default: ""</param>
        /// <returns>Names of the read characters.</returns>
        public HTuple ReadOcrTrainf(string trainingFile)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(734);
            HalconAPI.StoreS(proc, 0, trainingFile);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = this.Load(proc, 1, err1);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err2, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Perform a gray value bottom hat transformation on an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="SE">Structuring element.</param>
        /// <returns>Bottom hat image.</returns>
        public HImage GrayBothat(HImage SE)
        {
            IntPtr proc = HalconAPI.PreCall(780);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)SE);
            return himage;
        }

        /// <summary>
        ///   Perform a gray value top hat transformation on an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="SE">Structuring element.</param>
        /// <returns>Top hat image.</returns>
        public HImage GrayTophat(HImage SE)
        {
            IntPtr proc = HalconAPI.PreCall(781);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)SE);
            return himage;
        }

        /// <summary>
        ///   Perform a gray value closing on an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="SE">Structuring element.</param>
        /// <returns>Gray-closed image.</returns>
        public HImage GrayClosing(HImage SE)
        {
            IntPtr proc = HalconAPI.PreCall(782);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)SE);
            return himage;
        }

        /// <summary>
        ///   Perform a gray value opening on an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="SE">Structuring element.</param>
        /// <returns>Gray-opened image.</returns>
        public HImage GrayOpening(HImage SE)
        {
            IntPtr proc = HalconAPI.PreCall(783);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)SE);
            return himage;
        }

        /// <summary>
        ///   Perform a gray value dilation on an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="SE">Structuring element.</param>
        /// <returns>Gray-dilated image.</returns>
        public HImage GrayDilation(HImage SE)
        {
            IntPtr proc = HalconAPI.PreCall(784);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)SE);
            return himage;
        }

        /// <summary>
        ///   Perform a gray value erosion on an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="SE">Structuring element.</param>
        /// <returns>Gray-eroded image.</returns>
        public HImage GrayErosion(HImage SE)
        {
            IntPtr proc = HalconAPI.PreCall(785);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)SE);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)SE);
            return himage;
        }

        /// <summary>
        ///   Load a structuring element for gray morphology.
        ///   Modified instance represents: Generated structuring element.
        /// </summary>
        /// <param name="fileName">Name of the file containing the structuring element.</param>
        public void ReadGraySe(string fileName)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(786);
            HalconAPI.StoreS(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate ellipsoidal structuring elements for gray morphology.
        ///   Modified instance represents: Generated structuring element.
        /// </summary>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of the structuring element. Default: 5</param>
        /// <param name="height">Height of the structuring element. Default: 5</param>
        /// <param name="smax">Maximum gray value of the structuring element. Default: 0</param>
        public void GenDiscSe(string type, int width, int height, HTuple smax)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(787);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.StoreI(proc, 1, width);
            HalconAPI.StoreI(proc, 2, height);
            HalconAPI.Store(proc, 3, smax);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(smax);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate ellipsoidal structuring elements for gray morphology.
        ///   Modified instance represents: Generated structuring element.
        /// </summary>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="width">Width of the structuring element. Default: 5</param>
        /// <param name="height">Height of the structuring element. Default: 5</param>
        /// <param name="smax">Maximum gray value of the structuring element. Default: 0</param>
        public void GenDiscSe(string type, int width, int height, double smax)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(787);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.StoreI(proc, 1, width);
            HalconAPI.StoreI(proc, 2, height);
            HalconAPI.StoreD(proc, 3, smax);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Extracting points with a particular gray value along a rectangle or an annular arc.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of gaussian smoothing. Default: 1.0</param>
        /// <param name="threshold">Threshold. Default: 128.0</param>
        /// <param name="select">Selection of points. Default: "all"</param>
        /// <param name="rowThresh">Row coordinates of points with threshold value.</param>
        /// <param name="columnThresh">Column coordinates of points with threshold value.</param>
        /// <param name="distance">Distance between consecutive points.</param>
        public void MeasureThresh(
          HMeasure measureHandle,
          double sigma,
          double threshold,
          string select,
          out HTuple rowThresh,
          out HTuple columnThresh,
          out HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(825);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)measureHandle);
            HalconAPI.StoreD(proc, 1, sigma);
            HalconAPI.StoreD(proc, 2, threshold);
            HalconAPI.StoreS(proc, 3, select);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowThresh);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnThresh);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out distance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)measureHandle);
        }

        /// <summary>
        ///   Extract a gray value profile perpendicular to a rectangle or annular arc.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <returns>Gray value profile.</returns>
        public HTuple MeasureProjection(HMeasure measureHandle)
        {
            IntPtr proc = HalconAPI.PreCall(828);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)measureHandle);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)measureHandle);
            return tuple;
        }

        /// <summary>
        ///   Extract straight edge pairs perpendicular to a rectangle or an annular arc.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of Gaussian smoothing. Default: 1.0</param>
        /// <param name="ampThresh">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="fuzzyThresh">Minimum fuzzy value. Default: 0.5</param>
        /// <param name="transition">Select the first gray value transition of the edge pairs. Default: "all"</param>
        /// <param name="pairing">Constraint of pairing. Default: "no_restriction"</param>
        /// <param name="numPairs">Number of edge pairs. Default: 10</param>
        /// <param name="rowEdgeFirst">Row coordinate of the first edge.</param>
        /// <param name="columnEdgeFirst">Column coordinate of the first edge.</param>
        /// <param name="amplitudeFirst">Edge amplitude of the first edge (with sign).</param>
        /// <param name="rowEdgeSecond">Row coordinate of the second edge.</param>
        /// <param name="columnEdgeSecond">Column coordinate of the second edge.</param>
        /// <param name="amplitudeSecond">Edge amplitude of the second edge (with sign).</param>
        /// <param name="rowPairCenter">Row coordinate of the center of the edge pair.</param>
        /// <param name="columnPairCenter">Column coordinate of the center of the edge pair.</param>
        /// <param name="fuzzyScore">Fuzzy evaluation of the edge pair.</param>
        /// <param name="intraDistance">Distance between the edges of the edge pair.</param>
        public void FuzzyMeasurePairing(
          HMeasure measureHandle,
          double sigma,
          double ampThresh,
          double fuzzyThresh,
          string transition,
          string pairing,
          int numPairs,
          out HTuple rowEdgeFirst,
          out HTuple columnEdgeFirst,
          out HTuple amplitudeFirst,
          out HTuple rowEdgeSecond,
          out HTuple columnEdgeSecond,
          out HTuple amplitudeSecond,
          out HTuple rowPairCenter,
          out HTuple columnPairCenter,
          out HTuple fuzzyScore,
          out HTuple intraDistance)
        {
            IntPtr proc = HalconAPI.PreCall(832);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)measureHandle);
            HalconAPI.StoreD(proc, 1, sigma);
            HalconAPI.StoreD(proc, 2, ampThresh);
            HalconAPI.StoreD(proc, 3, fuzzyThresh);
            HalconAPI.StoreS(proc, 4, transition);
            HalconAPI.StoreS(proc, 5, pairing);
            HalconAPI.StoreI(proc, 6, numPairs);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowEdgeFirst);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnEdgeFirst);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out amplitudeFirst);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out rowEdgeSecond);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out columnEdgeSecond);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out amplitudeSecond);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out rowPairCenter);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out columnPairCenter);
            int err10 = HTuple.LoadNew(proc, 8, HTupleType.DOUBLE, err9, out fuzzyScore);
            int procResult = HTuple.LoadNew(proc, 9, HTupleType.DOUBLE, err10, out intraDistance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)measureHandle);
        }

        /// <summary>
        ///   Extract straight edge pairs perpendicular to a rectangle or an annular arc.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of Gaussian smoothing. Default: 1.0</param>
        /// <param name="ampThresh">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="fuzzyThresh">Minimum fuzzy value. Default: 0.5</param>
        /// <param name="transition">Select the first gray value transition of the edge pairs. Default: "all"</param>
        /// <param name="rowEdgeFirst">Row coordinate of the first edge point.</param>
        /// <param name="columnEdgeFirst">Column coordinate of the first edge point.</param>
        /// <param name="amplitudeFirst">Edge amplitude of the first edge (with sign).</param>
        /// <param name="rowEdgeSecond">Row coordinate of the second edge point.</param>
        /// <param name="columnEdgeSecond">Column coordinate of the second edge point.</param>
        /// <param name="amplitudeSecond">Edge amplitude of the second edge (with sign).</param>
        /// <param name="rowEdgeCenter">Row coordinate of the center of the edge pair.</param>
        /// <param name="columnEdgeCenter">Column coordinate of the center of the edge pair.</param>
        /// <param name="fuzzyScore">Fuzzy evaluation of the edge pair.</param>
        /// <param name="intraDistance">Distance between edges of an edge pair.</param>
        /// <param name="interDistance">Distance between consecutive edge pairs.</param>
        public void FuzzyMeasurePairs(
          HMeasure measureHandle,
          double sigma,
          double ampThresh,
          double fuzzyThresh,
          string transition,
          out HTuple rowEdgeFirst,
          out HTuple columnEdgeFirst,
          out HTuple amplitudeFirst,
          out HTuple rowEdgeSecond,
          out HTuple columnEdgeSecond,
          out HTuple amplitudeSecond,
          out HTuple rowEdgeCenter,
          out HTuple columnEdgeCenter,
          out HTuple fuzzyScore,
          out HTuple intraDistance,
          out HTuple interDistance)
        {
            IntPtr proc = HalconAPI.PreCall(833);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)measureHandle);
            HalconAPI.StoreD(proc, 1, sigma);
            HalconAPI.StoreD(proc, 2, ampThresh);
            HalconAPI.StoreD(proc, 3, fuzzyThresh);
            HalconAPI.StoreS(proc, 4, transition);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            HalconAPI.InitOCT(proc, 10);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowEdgeFirst);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnEdgeFirst);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out amplitudeFirst);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out rowEdgeSecond);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out columnEdgeSecond);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out amplitudeSecond);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out rowEdgeCenter);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out columnEdgeCenter);
            int err10 = HTuple.LoadNew(proc, 8, HTupleType.DOUBLE, err9, out fuzzyScore);
            int err11 = HTuple.LoadNew(proc, 9, HTupleType.DOUBLE, err10, out intraDistance);
            int procResult = HTuple.LoadNew(proc, 10, HTupleType.DOUBLE, err11, out interDistance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)measureHandle);
        }

        /// <summary>
        ///   Extract straight edges perpendicular to a rectangle or an annular arc.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of Gaussian smoothing. Default: 1.0</param>
        /// <param name="ampThresh">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="fuzzyThresh">Minimum fuzzy value. Default: 0.5</param>
        /// <param name="transition">Select light/dark or dark/light edges. Default: "all"</param>
        /// <param name="rowEdge">Row coordinate of the edge point.</param>
        /// <param name="columnEdge">Column coordinate of the edge point.</param>
        /// <param name="amplitude">Edge amplitude of the edge (with sign).</param>
        /// <param name="fuzzyScore">Fuzzy evaluation of the edges.</param>
        /// <param name="distance">Distance between consecutive edges.</param>
        public void FuzzyMeasurePos(
          HMeasure measureHandle,
          double sigma,
          double ampThresh,
          double fuzzyThresh,
          string transition,
          out HTuple rowEdge,
          out HTuple columnEdge,
          out HTuple amplitude,
          out HTuple fuzzyScore,
          out HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(834);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)measureHandle);
            HalconAPI.StoreD(proc, 1, sigma);
            HalconAPI.StoreD(proc, 2, ampThresh);
            HalconAPI.StoreD(proc, 3, fuzzyThresh);
            HalconAPI.StoreS(proc, 4, transition);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowEdge);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnEdge);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out amplitude);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out fuzzyScore);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out distance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)measureHandle);
        }

        /// <summary>
        ///   Extract straight edge pairs perpendicular to a rectangle or annular arc.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of gaussian smoothing. Default: 1.0</param>
        /// <param name="threshold">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="transition">Type of gray value transition that determines how edges are grouped to edge pairs. Default: "all"</param>
        /// <param name="select">Selection of edge pairs. Default: "all"</param>
        /// <param name="rowEdgeFirst">Row coordinate of the center of the first edge.</param>
        /// <param name="columnEdgeFirst">Column coordinate of the center of the first edge.</param>
        /// <param name="amplitudeFirst">Edge amplitude of the first edge (with sign).</param>
        /// <param name="rowEdgeSecond">Row coordinate of the center of the second edge.</param>
        /// <param name="columnEdgeSecond">Column coordinate of the center of the second edge.</param>
        /// <param name="amplitudeSecond">Edge amplitude of the second edge (with sign).</param>
        /// <param name="intraDistance">Distance between edges of an edge pair.</param>
        /// <param name="interDistance">Distance between consecutive edge pairs.</param>
        public void MeasurePairs(
          HMeasure measureHandle,
          double sigma,
          double threshold,
          string transition,
          string select,
          out HTuple rowEdgeFirst,
          out HTuple columnEdgeFirst,
          out HTuple amplitudeFirst,
          out HTuple rowEdgeSecond,
          out HTuple columnEdgeSecond,
          out HTuple amplitudeSecond,
          out HTuple intraDistance,
          out HTuple interDistance)
        {
            IntPtr proc = HalconAPI.PreCall(835);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)measureHandle);
            HalconAPI.StoreD(proc, 1, sigma);
            HalconAPI.StoreD(proc, 2, threshold);
            HalconAPI.StoreS(proc, 3, transition);
            HalconAPI.StoreS(proc, 4, select);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowEdgeFirst);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnEdgeFirst);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out amplitudeFirst);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out rowEdgeSecond);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out columnEdgeSecond);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out amplitudeSecond);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out intraDistance);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out interDistance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)measureHandle);
        }

        /// <summary>
        ///   Extract straight edges perpendicular to a rectangle or annular arc.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="measureHandle">Measure object handle.</param>
        /// <param name="sigma">Sigma of gaussian smoothing. Default: 1.0</param>
        /// <param name="threshold">Minimum edge amplitude. Default: 30.0</param>
        /// <param name="transition">Light/dark or dark/light edge. Default: "all"</param>
        /// <param name="select">Selection of end points. Default: "all"</param>
        /// <param name="rowEdge">Row coordinate of the center of the edge.</param>
        /// <param name="columnEdge">Column coordinate of the center of the edge.</param>
        /// <param name="amplitude">Edge amplitude of the edge (with sign).</param>
        /// <param name="distance">Distance between consecutive edges.</param>
        public void MeasurePos(
          HMeasure measureHandle,
          double sigma,
          double threshold,
          string transition,
          string select,
          out HTuple rowEdge,
          out HTuple columnEdge,
          out HTuple amplitude,
          out HTuple distance)
        {
            IntPtr proc = HalconAPI.PreCall(836);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)measureHandle);
            HalconAPI.StoreD(proc, 1, sigma);
            HalconAPI.StoreD(proc, 2, threshold);
            HalconAPI.StoreS(proc, 3, transition);
            HalconAPI.StoreS(proc, 4, select);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowEdge);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnEdge);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out amplitude);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out distance);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)measureHandle);
        }

        /// <summary>
        ///   Identify objects with a sample identifier.
        ///   Instance represents: Image showing the object to be identified.
        /// </summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="numResults">Number of suggested object indices. Default: 1</param>
        /// <param name="ratingThreshold">Rating threshold. Default: 0.0</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        /// <param name="rating">Rating value of the identified object.</param>
        /// <returns>Index of the identified object.</returns>
        public HTuple ApplySampleIdentifier(
          HSampleIdentifier sampleIdentifier,
          int numResults,
          double ratingThreshold,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple rating)
        {
            IntPtr proc = HalconAPI.PreCall(904);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)sampleIdentifier);
            HalconAPI.StoreI(proc, 1, numResults);
            HalconAPI.StoreD(proc, 2, ratingThreshold);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out rating);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)sampleIdentifier);
            return tuple;
        }

        /// <summary>
        ///   Identify objects with a sample identifier.
        ///   Instance represents: Image showing the object to be identified.
        /// </summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="numResults">Number of suggested object indices. Default: 1</param>
        /// <param name="ratingThreshold">Rating threshold. Default: 0.0</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        /// <param name="rating">Rating value of the identified object.</param>
        /// <returns>Index of the identified object.</returns>
        public int ApplySampleIdentifier(
          HSampleIdentifier sampleIdentifier,
          int numResults,
          double ratingThreshold,
          HTuple genParamName,
          HTuple genParamValue,
          out double rating)
        {
            IntPtr proc = HalconAPI.PreCall(904);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)sampleIdentifier);
            HalconAPI.StoreI(proc, 1, numResults);
            HalconAPI.StoreD(proc, 2, ratingThreshold);
            HalconAPI.Store(proc, 3, genParamName);
            HalconAPI.Store(proc, 4, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int intValue;
            int err2 = HalconAPI.LoadI(proc, 0, err1, out intValue);
            int procResult = HalconAPI.LoadD(proc, 1, err2, out rating);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)sampleIdentifier);
            return intValue;
        }

        /// <summary>
        ///   Add training data to an existing sample identifier.
        ///   Instance represents: Image that shows an object.
        /// </summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="objectIdx">Index of the object visible in the SampleImage.</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        /// <returns>Index of the object sample.</returns>
        public int AddSampleIdentifierTrainingData(
          HSampleIdentifier sampleIdentifier,
          HTuple objectIdx,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(912);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)sampleIdentifier);
            HalconAPI.Store(proc, 1, objectIdx);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectIdx);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int intValue;
            int procResult = HalconAPI.LoadI(proc, 0, err, out intValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)sampleIdentifier);
            return intValue;
        }

        /// <summary>
        ///   Add training data to an existing sample identifier.
        ///   Instance represents: Image that shows an object.
        /// </summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="objectIdx">Index of the object visible in the SampleImage.</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        /// <returns>Index of the object sample.</returns>
        public int AddSampleIdentifierTrainingData(
          HSampleIdentifier sampleIdentifier,
          int objectIdx,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(912);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)sampleIdentifier);
            HalconAPI.StoreI(proc, 1, objectIdx);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int intValue;
            int procResult = HalconAPI.LoadI(proc, 0, err, out intValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)sampleIdentifier);
            return intValue;
        }

        /// <summary>
        ///   Add preparation data to an existing sample identifier.
        ///   Instance represents: Image that shows an object.
        /// </summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="objectIdx">Index of the object visible in the SampleImage. Default: "unknown"</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        /// <returns>Index of the object sample.</returns>
        public int AddSampleIdentifierPreparationData(
          HSampleIdentifier sampleIdentifier,
          HTuple objectIdx,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(914);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)sampleIdentifier);
            HalconAPI.Store(proc, 1, objectIdx);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(objectIdx);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int intValue;
            int procResult = HalconAPI.LoadI(proc, 0, err, out intValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)sampleIdentifier);
            return intValue;
        }

        /// <summary>
        ///   Add preparation data to an existing sample identifier.
        ///   Instance represents: Image that shows an object.
        /// </summary>
        /// <param name="sampleIdentifier">Handle of the sample identifier.</param>
        /// <param name="objectIdx">Index of the object visible in the SampleImage. Default: "unknown"</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        /// <returns>Index of the object sample.</returns>
        public int AddSampleIdentifierPreparationData(
          HSampleIdentifier sampleIdentifier,
          int objectIdx,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(914);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)sampleIdentifier);
            HalconAPI.StoreI(proc, 1, objectIdx);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            int intValue;
            int procResult = HalconAPI.LoadI(proc, 0, err, out intValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)sampleIdentifier);
            return intValue;
        }

        /// <summary>
        ///   Determine the parameters of a shape model.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleMin">Minimum scale of the model. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the model. Default: 1.1</param>
        /// <param name="optimization">Kind of optimization. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="parameters">Parameters to be determined automatically. Default: "all"</param>
        /// <param name="parameterValue">Value of the automatically determined parameter.</param>
        /// <returns>Name of the automatically determined parameter.</returns>
        public HTuple DetermineShapeModelParams(
          HTuple numLevels,
          double angleStart,
          double angleExtent,
          HTuple scaleMin,
          HTuple scaleMax,
          string optimization,
          string metric,
          HTuple contrast,
          HTuple minContrast,
          HTuple parameters,
          out HTuple parameterValue)
        {
            IntPtr proc = HalconAPI.PreCall(923);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleMin);
            HalconAPI.Store(proc, 4, scaleMax);
            HalconAPI.StoreS(proc, 5, optimization);
            HalconAPI.StoreS(proc, 6, metric);
            HalconAPI.Store(proc, 7, contrast);
            HalconAPI.Store(proc, 8, minContrast);
            HalconAPI.Store(proc, 9, parameters);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(scaleMin);
            HalconAPI.UnpinTuple(scaleMax);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(parameters);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, err2, out parameterValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Determine the parameters of a shape model.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleMin">Minimum scale of the model. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the model. Default: 1.1</param>
        /// <param name="optimization">Kind of optimization. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="parameters">Parameters to be determined automatically. Default: "all"</param>
        /// <param name="parameterValue">Value of the automatically determined parameter.</param>
        /// <returns>Name of the automatically determined parameter.</returns>
        public HTuple DetermineShapeModelParams(
          int numLevels,
          double angleStart,
          double angleExtent,
          double scaleMin,
          double scaleMax,
          string optimization,
          string metric,
          int contrast,
          int minContrast,
          string parameters,
          out HTuple parameterValue)
        {
            IntPtr proc = HalconAPI.PreCall(923);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleMin);
            HalconAPI.StoreD(proc, 4, scaleMax);
            HalconAPI.StoreS(proc, 5, optimization);
            HalconAPI.StoreS(proc, 6, metric);
            HalconAPI.StoreI(proc, 7, contrast);
            HalconAPI.StoreI(proc, 8, minContrast);
            HalconAPI.StoreS(proc, 9, parameters);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, err2, out parameterValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Find the best matches of multiple anisotropically scaled shape models.
        ///   Instance represents: Input image in which the models should be found.
        /// </summary>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleRMin">Minimum scale of the models in the row direction. Default: 0.9</param>
        /// <param name="scaleRMax">Maximum scale of the models in the row direction. Default: 1.1</param>
        /// <param name="scaleCMin">Minimum scale of the models in the column direction. Default: 0.9</param>
        /// <param name="scaleCMax">Maximum scale of the models in the column direction. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="scaleR">Scale of the found instances of the models in the row direction.</param>
        /// <param name="scaleC">Scale of the found instances of the models in the column direction.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public void FindAnisoShapeModels(
          HShapeModel[] modelIDs,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple scaleRMin,
          HTuple scaleRMax,
          HTuple scaleCMin,
          HTuple scaleCMax,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          HTuple greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scaleR,
          out HTuple scaleC,
          out HTuple score,
          out HTuple model)
        {
            HTuple htuple = HTool.ConcatArray((HTool[])modelIDs);
            IntPtr proc = HalconAPI.PreCall(927);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, htuple);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleRMin);
            HalconAPI.Store(proc, 4, scaleRMax);
            HalconAPI.Store(proc, 5, scaleCMin);
            HalconAPI.Store(proc, 6, scaleCMax);
            HalconAPI.Store(proc, 7, minScore);
            HalconAPI.Store(proc, 8, numMatches);
            HalconAPI.Store(proc, 9, maxOverlap);
            HalconAPI.Store(proc, 10, subPixel);
            HalconAPI.Store(proc, 11, numLevels);
            HalconAPI.Store(proc, 12, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(htuple);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleRMin);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleCMin);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scaleR);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out scaleC);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out score);
            int procResult = HTuple.LoadNew(proc, 6, HTupleType.INTEGER, err7, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelIDs);
        }

        /// <summary>
        ///   Find the best matches of multiple anisotropically scaled shape models.
        ///   Instance represents: Input image in which the models should be found.
        /// </summary>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleRMin">Minimum scale of the models in the row direction. Default: 0.9</param>
        /// <param name="scaleRMax">Maximum scale of the models in the row direction. Default: 1.1</param>
        /// <param name="scaleCMin">Minimum scale of the models in the column direction. Default: 0.9</param>
        /// <param name="scaleCMax">Maximum scale of the models in the column direction. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="scaleR">Scale of the found instances of the models in the row direction.</param>
        /// <param name="scaleC">Scale of the found instances of the models in the column direction.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public void FindAnisoShapeModels(
          HShapeModel modelIDs,
          double angleStart,
          double angleExtent,
          double scaleRMin,
          double scaleRMax,
          double scaleCMin,
          double scaleCMax,
          double minScore,
          int numMatches,
          double maxOverlap,
          string subPixel,
          int numLevels,
          double greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scaleR,
          out HTuple scaleC,
          out HTuple score,
          out HTuple model)
        {
            IntPtr proc = HalconAPI.PreCall(927);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelIDs);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleRMin);
            HalconAPI.StoreD(proc, 4, scaleRMax);
            HalconAPI.StoreD(proc, 5, scaleCMin);
            HalconAPI.StoreD(proc, 6, scaleCMax);
            HalconAPI.StoreD(proc, 7, minScore);
            HalconAPI.StoreI(proc, 8, numMatches);
            HalconAPI.StoreD(proc, 9, maxOverlap);
            HalconAPI.StoreS(proc, 10, subPixel);
            HalconAPI.StoreI(proc, 11, numLevels);
            HalconAPI.StoreD(proc, 12, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scaleR);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out scaleC);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out score);
            int procResult = HTuple.LoadNew(proc, 6, HTupleType.INTEGER, err7, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelIDs);
        }

        /// <summary>
        ///   Find the best matches of multiple isotropically scaled shape models.
        ///   Instance represents: Input image in which the models should be found.
        /// </summary>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleMin">Minimum scale of the models. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the models. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="scale">Scale of the found instances of the models.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public void FindScaledShapeModels(
          HShapeModel[] modelIDs,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple scaleMin,
          HTuple scaleMax,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          HTuple greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scale,
          out HTuple score,
          out HTuple model)
        {
            HTuple htuple = HTool.ConcatArray((HTool[])modelIDs);
            IntPtr proc = HalconAPI.PreCall(928);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, htuple);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleMin);
            HalconAPI.Store(proc, 4, scaleMax);
            HalconAPI.Store(proc, 5, minScore);
            HalconAPI.Store(proc, 6, numMatches);
            HalconAPI.Store(proc, 7, maxOverlap);
            HalconAPI.Store(proc, 8, subPixel);
            HalconAPI.Store(proc, 9, numLevels);
            HalconAPI.Store(proc, 10, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(htuple);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleMin);
            HalconAPI.UnpinTuple(scaleMax);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scale);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out score);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelIDs);
        }

        /// <summary>
        ///   Find the best matches of multiple isotropically scaled shape models.
        ///   Instance represents: Input image in which the models should be found.
        /// </summary>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleMin">Minimum scale of the models. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the models. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="scale">Scale of the found instances of the models.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public void FindScaledShapeModels(
          HShapeModel modelIDs,
          double angleStart,
          double angleExtent,
          double scaleMin,
          double scaleMax,
          double minScore,
          int numMatches,
          double maxOverlap,
          string subPixel,
          int numLevels,
          double greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scale,
          out HTuple score,
          out HTuple model)
        {
            IntPtr proc = HalconAPI.PreCall(928);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelIDs);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleMin);
            HalconAPI.StoreD(proc, 4, scaleMax);
            HalconAPI.StoreD(proc, 5, minScore);
            HalconAPI.StoreI(proc, 6, numMatches);
            HalconAPI.StoreD(proc, 7, maxOverlap);
            HalconAPI.StoreS(proc, 8, subPixel);
            HalconAPI.StoreI(proc, 9, numLevels);
            HalconAPI.StoreD(proc, 10, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scale);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out score);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.INTEGER, err6, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelIDs);
        }

        /// <summary>
        ///   Find the best matches of multiple shape models.
        ///   Instance represents: Input image in which the models should be found.
        /// </summary>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public void FindShapeModels(
          HShapeModel[] modelIDs,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          HTuple greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score,
          out HTuple model)
        {
            HTuple htuple = HTool.ConcatArray((HTool[])modelIDs);
            IntPtr proc = HalconAPI.PreCall(929);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, htuple);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, numMatches);
            HalconAPI.Store(proc, 5, maxOverlap);
            HalconAPI.Store(proc, 6, subPixel);
            HalconAPI.Store(proc, 7, numLevels);
            HalconAPI.Store(proc, 8, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(htuple);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(greediness);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelIDs);
        }

        /// <summary>
        ///   Find the best matches of multiple shape models.
        ///   Instance represents: Input image in which the models should be found.
        /// </summary>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public void FindShapeModels(
          HShapeModel modelIDs,
          double angleStart,
          double angleExtent,
          double minScore,
          int numMatches,
          double maxOverlap,
          string subPixel,
          int numLevels,
          double greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score,
          out HTuple model)
        {
            IntPtr proc = HalconAPI.PreCall(929);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelIDs);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, minScore);
            HalconAPI.StoreI(proc, 4, numMatches);
            HalconAPI.StoreD(proc, 5, maxOverlap);
            HalconAPI.StoreS(proc, 6, subPixel);
            HalconAPI.StoreI(proc, 7, numLevels);
            HalconAPI.StoreD(proc, 8, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelIDs);
        }

        /// <summary>
        ///   Find the best matches of an anisotropically scaled shape model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleRMin">Minimum scale of the model in the row direction. Default: 0.9</param>
        /// <param name="scaleRMax">Maximum scale of the model in the row direction. Default: 1.1</param>
        /// <param name="scaleCMin">Minimum scale of the model in the column direction. Default: 0.9</param>
        /// <param name="scaleCMax">Maximum scale of the model in the column direction. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="scaleR">Scale of the found instances of the model in the row direction.</param>
        /// <param name="scaleC">Scale of the found instances of the model in the column direction.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public void FindAnisoShapeModel(
          HShapeModel modelID,
          double angleStart,
          double angleExtent,
          double scaleRMin,
          double scaleRMax,
          double scaleCMin,
          double scaleCMax,
          double minScore,
          int numMatches,
          double maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          double greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scaleR,
          out HTuple scaleC,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(930);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleRMin);
            HalconAPI.StoreD(proc, 4, scaleRMax);
            HalconAPI.StoreD(proc, 5, scaleCMin);
            HalconAPI.StoreD(proc, 6, scaleCMax);
            HalconAPI.StoreD(proc, 7, minScore);
            HalconAPI.StoreI(proc, 8, numMatches);
            HalconAPI.StoreD(proc, 9, maxOverlap);
            HalconAPI.Store(proc, 10, subPixel);
            HalconAPI.Store(proc, 11, numLevels);
            HalconAPI.StoreD(proc, 12, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scaleR);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out scaleC);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Find the best matches of an anisotropically scaled shape model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleRMin">Minimum scale of the model in the row direction. Default: 0.9</param>
        /// <param name="scaleRMax">Maximum scale of the model in the row direction. Default: 1.1</param>
        /// <param name="scaleCMin">Minimum scale of the model in the column direction. Default: 0.9</param>
        /// <param name="scaleCMax">Maximum scale of the model in the column direction. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="scaleR">Scale of the found instances of the model in the row direction.</param>
        /// <param name="scaleC">Scale of the found instances of the model in the column direction.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public void FindAnisoShapeModel(
          HShapeModel modelID,
          double angleStart,
          double angleExtent,
          double scaleRMin,
          double scaleRMax,
          double scaleCMin,
          double scaleCMax,
          double minScore,
          int numMatches,
          double maxOverlap,
          string subPixel,
          int numLevels,
          double greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scaleR,
          out HTuple scaleC,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(930);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleRMin);
            HalconAPI.StoreD(proc, 4, scaleRMax);
            HalconAPI.StoreD(proc, 5, scaleCMin);
            HalconAPI.StoreD(proc, 6, scaleCMax);
            HalconAPI.StoreD(proc, 7, minScore);
            HalconAPI.StoreI(proc, 8, numMatches);
            HalconAPI.StoreD(proc, 9, maxOverlap);
            HalconAPI.StoreS(proc, 10, subPixel);
            HalconAPI.StoreI(proc, 11, numLevels);
            HalconAPI.StoreD(proc, 12, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scaleR);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out scaleC);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Find the best matches of an isotropically scaled shape model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleMin">Minimum scale of the model. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the model. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="scale">Scale of the found instances of the model.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public void FindScaledShapeModel(
          HShapeModel modelID,
          double angleStart,
          double angleExtent,
          double scaleMin,
          double scaleMax,
          double minScore,
          int numMatches,
          double maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          double greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scale,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(931);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleMin);
            HalconAPI.StoreD(proc, 4, scaleMax);
            HalconAPI.StoreD(proc, 5, minScore);
            HalconAPI.StoreI(proc, 6, numMatches);
            HalconAPI.StoreD(proc, 7, maxOverlap);
            HalconAPI.Store(proc, 8, subPixel);
            HalconAPI.Store(proc, 9, numLevels);
            HalconAPI.StoreD(proc, 10, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scale);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Find the best matches of an isotropically scaled shape model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleMin">Minimum scale of the model. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the model. Default: 1.1</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="scale">Scale of the found instances of the model.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public void FindScaledShapeModel(
          HShapeModel modelID,
          double angleStart,
          double angleExtent,
          double scaleMin,
          double scaleMax,
          double minScore,
          int numMatches,
          double maxOverlap,
          string subPixel,
          int numLevels,
          double greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple scale,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(931);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleMin);
            HalconAPI.StoreD(proc, 4, scaleMax);
            HalconAPI.StoreD(proc, 5, minScore);
            HalconAPI.StoreI(proc, 6, numMatches);
            HalconAPI.StoreD(proc, 7, maxOverlap);
            HalconAPI.StoreS(proc, 8, subPixel);
            HalconAPI.StoreI(proc, 9, numLevels);
            HalconAPI.StoreD(proc, 10, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out scale);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Find the best matches of a shape model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public void FindShapeModel(
          HShapeModel modelID,
          double angleStart,
          double angleExtent,
          double minScore,
          int numMatches,
          double maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          double greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(932);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, minScore);
            HalconAPI.StoreI(proc, 4, numMatches);
            HalconAPI.StoreD(proc, 5, maxOverlap);
            HalconAPI.Store(proc, 6, subPixel);
            HalconAPI.Store(proc, 7, numLevels);
            HalconAPI.StoreD(proc, 8, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Find the best matches of a shape model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public void FindShapeModel(
          HShapeModel modelID,
          double angleStart,
          double angleExtent,
          double minScore,
          int numMatches,
          double maxOverlap,
          string subPixel,
          int numLevels,
          double greediness,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(932);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, minScore);
            HalconAPI.StoreI(proc, 4, numMatches);
            HalconAPI.StoreD(proc, 5, maxOverlap);
            HalconAPI.StoreS(proc, 6, subPixel);
            HalconAPI.StoreI(proc, 7, numLevels);
            HalconAPI.StoreD(proc, 8, greediness);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Set the metric of a shape model that was created from XLD contours.
        ///   Instance represents: Input image used for the determination of the polarity.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="homMat2D">Transformation matrix.</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        public void SetShapeModelMetric(HShapeModel modelID, HHomMat2D homMat2D, string metric)
        {
            IntPtr proc = HalconAPI.PreCall(933);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.Store(proc, 1, (HData)homMat2D);
            HalconAPI.StoreS(proc, 2, metric);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)homMat2D));
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>Set selected parameters of the shape model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="genParamName">Parameter names.</param>
        /// <param name="genParamValue">Parameter values.</param>
        public static void SetShapeModelParam(
          HShapeModel modelID,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(934);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Prepare an anisotropically scaled shape model for matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in the row direction. Default: 0.9</param>
        /// <param name="scaleRMax">Maximum scale of the pattern in the row direction. Default: 1.1</param>
        /// <param name="scaleRStep">Scale step length (resolution) in the row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in the column direction. Default: 0.9</param>
        /// <param name="scaleCMax">Maximum scale of the pattern in the column direction. Default: 1.1</param>
        /// <param name="scaleCStep">Scale step length (resolution) in the column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <returns>Handle of the model.</returns>
        public HShapeModel CreateAnisoShapeModel(
          HTuple numLevels,
          double angleStart,
          double angleExtent,
          HTuple angleStep,
          double scaleRMin,
          double scaleRMax,
          HTuple scaleRStep,
          double scaleCMin,
          double scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          string metric,
          HTuple contrast,
          HTuple minContrast)
        {
            IntPtr proc = HalconAPI.PreCall(938);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.StoreD(proc, 4, scaleRMin);
            HalconAPI.StoreD(proc, 5, scaleRMax);
            HalconAPI.Store(proc, 6, scaleRStep);
            HalconAPI.StoreD(proc, 7, scaleCMin);
            HalconAPI.StoreD(proc, 8, scaleCMax);
            HalconAPI.Store(proc, 9, scaleCStep);
            HalconAPI.Store(proc, 10, optimization);
            HalconAPI.StoreS(proc, 11, metric);
            HalconAPI.Store(proc, 12, contrast);
            HalconAPI.Store(proc, 13, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HShapeModel hshapeModel;
            int procResult = HShapeModel.LoadNew(proc, 0, err, out hshapeModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hshapeModel;
        }

        /// <summary>
        ///   Prepare an anisotropically scaled shape model for matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in the row direction. Default: 0.9</param>
        /// <param name="scaleRMax">Maximum scale of the pattern in the row direction. Default: 1.1</param>
        /// <param name="scaleRStep">Scale step length (resolution) in the row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in the column direction. Default: 0.9</param>
        /// <param name="scaleCMax">Maximum scale of the pattern in the column direction. Default: 1.1</param>
        /// <param name="scaleCStep">Scale step length (resolution) in the column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <returns>Handle of the model.</returns>
        public HShapeModel CreateAnisoShapeModel(
          int numLevels,
          double angleStart,
          double angleExtent,
          double angleStep,
          double scaleRMin,
          double scaleRMax,
          double scaleRStep,
          double scaleCMin,
          double scaleCMax,
          double scaleCStep,
          string optimization,
          string metric,
          int contrast,
          int minContrast)
        {
            IntPtr proc = HalconAPI.PreCall(938);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, angleStep);
            HalconAPI.StoreD(proc, 4, scaleRMin);
            HalconAPI.StoreD(proc, 5, scaleRMax);
            HalconAPI.StoreD(proc, 6, scaleRStep);
            HalconAPI.StoreD(proc, 7, scaleCMin);
            HalconAPI.StoreD(proc, 8, scaleCMax);
            HalconAPI.StoreD(proc, 9, scaleCStep);
            HalconAPI.StoreS(proc, 10, optimization);
            HalconAPI.StoreS(proc, 11, metric);
            HalconAPI.StoreI(proc, 12, contrast);
            HalconAPI.StoreI(proc, 13, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HShapeModel hshapeModel;
            int procResult = HShapeModel.LoadNew(proc, 0, err, out hshapeModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hshapeModel;
        }

        /// <summary>
        ///   Prepare an isotropically scaled shape model for matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleMin">Minimum scale of the pattern. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the pattern. Default: 1.1</param>
        /// <param name="scaleStep">Scale step length (resolution). Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <returns>Handle of the model.</returns>
        public HShapeModel CreateScaledShapeModel(
          HTuple numLevels,
          double angleStart,
          double angleExtent,
          HTuple angleStep,
          double scaleMin,
          double scaleMax,
          HTuple scaleStep,
          HTuple optimization,
          string metric,
          HTuple contrast,
          HTuple minContrast)
        {
            IntPtr proc = HalconAPI.PreCall(939);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.StoreD(proc, 4, scaleMin);
            HalconAPI.StoreD(proc, 5, scaleMax);
            HalconAPI.Store(proc, 6, scaleStep);
            HalconAPI.Store(proc, 7, optimization);
            HalconAPI.StoreS(proc, 8, metric);
            HalconAPI.Store(proc, 9, contrast);
            HalconAPI.Store(proc, 10, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HShapeModel hshapeModel;
            int procResult = HShapeModel.LoadNew(proc, 0, err, out hshapeModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hshapeModel;
        }

        /// <summary>
        ///   Prepare an isotropically scaled shape model for matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleMin">Minimum scale of the pattern. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the pattern. Default: 1.1</param>
        /// <param name="scaleStep">Scale step length (resolution). Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <returns>Handle of the model.</returns>
        public HShapeModel CreateScaledShapeModel(
          int numLevels,
          double angleStart,
          double angleExtent,
          double angleStep,
          double scaleMin,
          double scaleMax,
          double scaleStep,
          string optimization,
          string metric,
          int contrast,
          int minContrast)
        {
            IntPtr proc = HalconAPI.PreCall(939);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, angleStep);
            HalconAPI.StoreD(proc, 4, scaleMin);
            HalconAPI.StoreD(proc, 5, scaleMax);
            HalconAPI.StoreD(proc, 6, scaleStep);
            HalconAPI.StoreS(proc, 7, optimization);
            HalconAPI.StoreS(proc, 8, metric);
            HalconAPI.StoreI(proc, 9, contrast);
            HalconAPI.StoreI(proc, 10, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HShapeModel hshapeModel;
            int procResult = HShapeModel.LoadNew(proc, 0, err, out hshapeModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hshapeModel;
        }

        /// <summary>
        ///   Prepare a shape model for matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <returns>Handle of the model.</returns>
        public HShapeModel CreateShapeModel(
          HTuple numLevels,
          double angleStart,
          double angleExtent,
          HTuple angleStep,
          HTuple optimization,
          string metric,
          HTuple contrast,
          HTuple minContrast)
        {
            IntPtr proc = HalconAPI.PreCall(940);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.Store(proc, 4, optimization);
            HalconAPI.StoreS(proc, 5, metric);
            HalconAPI.Store(proc, 6, contrast);
            HalconAPI.Store(proc, 7, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HShapeModel hshapeModel;
            int procResult = HShapeModel.LoadNew(proc, 0, err, out hshapeModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hshapeModel;
        }

        /// <summary>
        ///   Prepare a shape model for matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="optimization">Kind of optimization and optionally method used for generating the model. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <returns>Handle of the model.</returns>
        public HShapeModel CreateShapeModel(
          int numLevels,
          double angleStart,
          double angleExtent,
          double angleStep,
          string optimization,
          string metric,
          int contrast,
          int minContrast)
        {
            IntPtr proc = HalconAPI.PreCall(940);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, angleStep);
            HalconAPI.StoreS(proc, 4, optimization);
            HalconAPI.StoreS(proc, 5, metric);
            HalconAPI.StoreI(proc, 6, contrast);
            HalconAPI.StoreI(proc, 7, minContrast);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HShapeModel hshapeModel;
            int procResult = HShapeModel.LoadNew(proc, 0, err, out hshapeModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hshapeModel;
        }

        /// <summary>
        ///   Create the representation of a shape model.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="modelRegions">Model region pyramid</param>
        /// <param name="numLevels">Number of pyramid levels. Default: 4</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the image and optionally minimum size of the object parts. Default: 30</param>
        /// <returns>Image pyramid of the input image</returns>
        public HImage InspectShapeModel(out HRegion modelRegions, int numLevels, HTuple contrast)
        {
            IntPtr proc = HalconAPI.PreCall(941);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, contrast);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(contrast);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HRegion.LoadNew(proc, 2, err2, out modelRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Create the representation of a shape model.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="modelRegions">Model region pyramid</param>
        /// <param name="numLevels">Number of pyramid levels. Default: 4</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the image and optionally minimum size of the object parts. Default: 30</param>
        /// <returns>Image pyramid of the input image</returns>
        public HImage InspectShapeModel(out HRegion modelRegions, int numLevels, int contrast)
        {
            IntPtr proc = HalconAPI.PreCall(941);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numLevels);
            HalconAPI.StoreI(proc, 1, contrast);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HRegion.LoadNew(proc, 2, err2, out modelRegions);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Find the best matches of a calibrated descriptor model in an image and return their 3D pose.
        ///   Instance represents: Input image where the model should be found.
        /// </summary>
        /// <param name="modelID">The handle to the descriptor model.</param>
        /// <param name="detectorParamName">The detector's parameter names. Default: []</param>
        /// <param name="detectorParamValue">Values of the detector's parameters. Default: []</param>
        /// <param name="descriptorParamName">The descriptor's parameter names. Default: []</param>
        /// <param name="descriptorParamValue">Values of the descriptor's parameters. Default: []</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.2</param>
        /// <param name="numMatches">Maximal number of found instances. Default: 1</param>
        /// <param name="camParam">Camera parameter (inner orientation) obtained from camera calibration.</param>
        /// <param name="scoreType">Score type to be evaluated in Score. Default: "num_points"</param>
        /// <param name="score">Score of the found instances according to the ScoreType input.</param>
        /// <returns>3D pose of the object.</returns>
        public HPose[] FindCalibDescriptorModel(
          HDescriptorModel modelID,
          HTuple detectorParamName,
          HTuple detectorParamValue,
          HTuple descriptorParamName,
          HTuple descriptorParamValue,
          HTuple minScore,
          int numMatches,
          HCamPar camParam,
          HTuple scoreType,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(948);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.Store(proc, 1, detectorParamName);
            HalconAPI.Store(proc, 2, detectorParamValue);
            HalconAPI.Store(proc, 3, descriptorParamName);
            HalconAPI.Store(proc, 4, descriptorParamValue);
            HalconAPI.Store(proc, 5, minScore);
            HalconAPI.StoreI(proc, 6, numMatches);
            HalconAPI.Store(proc, 7, (HData)camParam);
            HalconAPI.Store(proc, 8, scoreType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(detectorParamName);
            HalconAPI.UnpinTuple(detectorParamValue);
            HalconAPI.UnpinTuple(descriptorParamName);
            HalconAPI.UnpinTuple(descriptorParamValue);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple((HTuple)((HData)camParam));
            HalconAPI.UnpinTuple(scoreType);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            HPose[] hposeArray = HPose.SplitArray(tuple);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
            return hposeArray;
        }

        /// <summary>
        ///   Find the best matches of a calibrated descriptor model in an image and return their 3D pose.
        ///   Instance represents: Input image where the model should be found.
        /// </summary>
        /// <param name="modelID">The handle to the descriptor model.</param>
        /// <param name="detectorParamName">The detector's parameter names. Default: []</param>
        /// <param name="detectorParamValue">Values of the detector's parameters. Default: []</param>
        /// <param name="descriptorParamName">The descriptor's parameter names. Default: []</param>
        /// <param name="descriptorParamValue">Values of the descriptor's parameters. Default: []</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.2</param>
        /// <param name="numMatches">Maximal number of found instances. Default: 1</param>
        /// <param name="camParam">Camera parameter (inner orientation) obtained from camera calibration.</param>
        /// <param name="scoreType">Score type to be evaluated in Score. Default: "num_points"</param>
        /// <param name="score">Score of the found instances according to the ScoreType input.</param>
        /// <returns>3D pose of the object.</returns>
        public HPose FindCalibDescriptorModel(
          HDescriptorModel modelID,
          HTuple detectorParamName,
          HTuple detectorParamValue,
          HTuple descriptorParamName,
          HTuple descriptorParamValue,
          double minScore,
          int numMatches,
          HCamPar camParam,
          string scoreType,
          out double score)
        {
            IntPtr proc = HalconAPI.PreCall(948);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.Store(proc, 1, detectorParamName);
            HalconAPI.Store(proc, 2, detectorParamValue);
            HalconAPI.Store(proc, 3, descriptorParamName);
            HalconAPI.Store(proc, 4, descriptorParamValue);
            HalconAPI.StoreD(proc, 5, minScore);
            HalconAPI.StoreI(proc, 6, numMatches);
            HalconAPI.Store(proc, 7, (HData)camParam);
            HalconAPI.StoreS(proc, 8, scoreType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(detectorParamName);
            HalconAPI.UnpinTuple(detectorParamValue);
            HalconAPI.UnpinTuple(descriptorParamName);
            HalconAPI.UnpinTuple(descriptorParamValue);
            HalconAPI.UnpinTuple((HTuple)((HData)camParam));
            HPose hpose;
            int err2 = HPose.LoadNew(proc, 0, err1, out hpose);
            int procResult = HalconAPI.LoadD(proc, 1, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
            return hpose;
        }

        /// <summary>
        ///   Find the best matches of a descriptor model in an image.
        ///   Instance represents: Input image where the model should be found.
        /// </summary>
        /// <param name="modelID">The handle to the descriptor model.</param>
        /// <param name="detectorParamName">The detector's parameter names. Default: []</param>
        /// <param name="detectorParamValue">Values of the detector's parameters. Default: []</param>
        /// <param name="descriptorParamName">The descriptor's parameter names. Default: []</param>
        /// <param name="descriptorParamValue">Values of the descriptor's parameters. Default: []</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.2</param>
        /// <param name="numMatches">Maximal number of found instances. Default: 1</param>
        /// <param name="scoreType">Score type to be evaluated in Score. Default: "num_points"</param>
        /// <param name="score">Score of the found instances according to the ScoreType input.</param>
        /// <returns>Homography between model and found instance.</returns>
        public HHomMat2D[] FindUncalibDescriptorModel(
          HDescriptorModel modelID,
          HTuple detectorParamName,
          HTuple detectorParamValue,
          HTuple descriptorParamName,
          HTuple descriptorParamValue,
          HTuple minScore,
          int numMatches,
          HTuple scoreType,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(949);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.Store(proc, 1, detectorParamName);
            HalconAPI.Store(proc, 2, detectorParamValue);
            HalconAPI.Store(proc, 3, descriptorParamName);
            HalconAPI.Store(proc, 4, descriptorParamValue);
            HalconAPI.Store(proc, 5, minScore);
            HalconAPI.StoreI(proc, 6, numMatches);
            HalconAPI.Store(proc, 7, scoreType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(detectorParamName);
            HalconAPI.UnpinTuple(detectorParamValue);
            HalconAPI.UnpinTuple(descriptorParamName);
            HalconAPI.UnpinTuple(descriptorParamValue);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(scoreType);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            HHomMat2D[] hhomMat2DArray = HHomMat2D.SplitArray(tuple);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
            return hhomMat2DArray;
        }

        /// <summary>
        ///   Find the best matches of a descriptor model in an image.
        ///   Instance represents: Input image where the model should be found.
        /// </summary>
        /// <param name="modelID">The handle to the descriptor model.</param>
        /// <param name="detectorParamName">The detector's parameter names. Default: []</param>
        /// <param name="detectorParamValue">Values of the detector's parameters. Default: []</param>
        /// <param name="descriptorParamName">The descriptor's parameter names. Default: []</param>
        /// <param name="descriptorParamValue">Values of the descriptor's parameters. Default: []</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.2</param>
        /// <param name="numMatches">Maximal number of found instances. Default: 1</param>
        /// <param name="scoreType">Score type to be evaluated in Score. Default: "num_points"</param>
        /// <param name="score">Score of the found instances according to the ScoreType input.</param>
        /// <returns>Homography between model and found instance.</returns>
        public HHomMat2D FindUncalibDescriptorModel(
          HDescriptorModel modelID,
          HTuple detectorParamName,
          HTuple detectorParamValue,
          HTuple descriptorParamName,
          HTuple descriptorParamValue,
          double minScore,
          int numMatches,
          string scoreType,
          out double score)
        {
            IntPtr proc = HalconAPI.PreCall(949);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.Store(proc, 1, detectorParamName);
            HalconAPI.Store(proc, 2, detectorParamValue);
            HalconAPI.Store(proc, 3, descriptorParamName);
            HalconAPI.Store(proc, 4, descriptorParamValue);
            HalconAPI.StoreD(proc, 5, minScore);
            HalconAPI.StoreI(proc, 6, numMatches);
            HalconAPI.StoreS(proc, 7, scoreType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(detectorParamName);
            HalconAPI.UnpinTuple(detectorParamValue);
            HalconAPI.UnpinTuple(descriptorParamName);
            HalconAPI.UnpinTuple(descriptorParamValue);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int procResult = HalconAPI.LoadD(proc, 1, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
            return hhomMat2D;
        }

        /// <summary>
        ///   Create a descriptor model for calibrated perspective matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="camParam">The parameters of the internal orientation of the camera.</param>
        /// <param name="referencePose">The reference pose of the object in the reference image.</param>
        /// <param name="detectorType">The type of the detector. Default: "lepetit"</param>
        /// <param name="detectorParamName">The detector's parameter names. Default: []</param>
        /// <param name="detectorParamValue">Values of the detector's parameters. Default: []</param>
        /// <param name="descriptorParamName">The descriptor's parameter names. Default: []</param>
        /// <param name="descriptorParamValue">Values of the descriptor's parameters. Default: []</param>
        /// <param name="seed">The seed for the random number generator. Default: 42</param>
        /// <returns>The handle to the descriptor model.</returns>
        public HDescriptorModel CreateCalibDescriptorModel(
          HCamPar camParam,
          HPose referencePose,
          string detectorType,
          HTuple detectorParamName,
          HTuple detectorParamValue,
          HTuple descriptorParamName,
          HTuple descriptorParamValue,
          int seed)
        {
            IntPtr proc = HalconAPI.PreCall(952);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HData)camParam);
            HalconAPI.Store(proc, 1, (HData)referencePose);
            HalconAPI.StoreS(proc, 2, detectorType);
            HalconAPI.Store(proc, 3, detectorParamName);
            HalconAPI.Store(proc, 4, detectorParamValue);
            HalconAPI.Store(proc, 5, descriptorParamName);
            HalconAPI.Store(proc, 6, descriptorParamValue);
            HalconAPI.StoreI(proc, 7, seed);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParam));
            HalconAPI.UnpinTuple((HTuple)((HData)referencePose));
            HalconAPI.UnpinTuple(detectorParamName);
            HalconAPI.UnpinTuple(detectorParamValue);
            HalconAPI.UnpinTuple(descriptorParamName);
            HalconAPI.UnpinTuple(descriptorParamValue);
            HDescriptorModel hdescriptorModel;
            int procResult = HDescriptorModel.LoadNew(proc, 0, err, out hdescriptorModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hdescriptorModel;
        }

        /// <summary>
        ///   Prepare a descriptor model for interest point matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="detectorType">The type of the detector. Default: "lepetit"</param>
        /// <param name="detectorParamName">The detector's parameter names. Default: []</param>
        /// <param name="detectorParamValue">Values of the detector's parameters. Default: []</param>
        /// <param name="descriptorParamName">The descriptor's parameter names. Default: []</param>
        /// <param name="descriptorParamValue">Values of the descriptor's parameters. Default: []</param>
        /// <param name="seed">The seed for the random number generator. Default: 42</param>
        /// <returns>The handle to the descriptor model.</returns>
        public HDescriptorModel CreateUncalibDescriptorModel(
          string detectorType,
          HTuple detectorParamName,
          HTuple detectorParamValue,
          HTuple descriptorParamName,
          HTuple descriptorParamValue,
          int seed)
        {
            IntPtr proc = HalconAPI.PreCall(953);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, detectorType);
            HalconAPI.Store(proc, 1, detectorParamName);
            HalconAPI.Store(proc, 2, detectorParamValue);
            HalconAPI.Store(proc, 3, descriptorParamName);
            HalconAPI.Store(proc, 4, descriptorParamValue);
            HalconAPI.StoreI(proc, 5, seed);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(detectorParamName);
            HalconAPI.UnpinTuple(detectorParamValue);
            HalconAPI.UnpinTuple(descriptorParamName);
            HalconAPI.UnpinTuple(descriptorParamValue);
            HDescriptorModel hdescriptorModel;
            int procResult = HDescriptorModel.LoadNew(proc, 0, err, out hdescriptorModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hdescriptorModel;
        }

        /// <summary>
        ///   Determine the parameters of a deformable model.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleMin">Minimum scale of the model. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the model. Default: 1.1</param>
        /// <param name="optimization">Kind of optimization. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The general parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the general parameter. Default: []</param>
        /// <param name="parameters">Parameters to be determined automatically. Default: "all"</param>
        /// <param name="parameterValue">Value of the automatically determined parameter.</param>
        /// <returns>Name of the automatically determined parameter.</returns>
        public HTuple DetermineDeformableModelParams(
          HTuple numLevels,
          double angleStart,
          double angleExtent,
          HTuple scaleMin,
          HTuple scaleMax,
          string optimization,
          string metric,
          HTuple contrast,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue,
          HTuple parameters,
          out HTuple parameterValue)
        {
            IntPtr proc = HalconAPI.PreCall(962);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, scaleMin);
            HalconAPI.Store(proc, 4, scaleMax);
            HalconAPI.StoreS(proc, 5, optimization);
            HalconAPI.StoreS(proc, 6, metric);
            HalconAPI.Store(proc, 7, contrast);
            HalconAPI.Store(proc, 8, minContrast);
            HalconAPI.Store(proc, 9, genParamName);
            HalconAPI.Store(proc, 10, genParamValue);
            HalconAPI.Store(proc, 11, parameters);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(scaleMin);
            HalconAPI.UnpinTuple(scaleMax);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.UnpinTuple(parameters);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, err2, out parameterValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Determine the parameters of a deformable model.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleMin">Minimum scale of the model. Default: 0.9</param>
        /// <param name="scaleMax">Maximum scale of the model. Default: 1.1</param>
        /// <param name="optimization">Kind of optimization. Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The general parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the general parameter. Default: []</param>
        /// <param name="parameters">Parameters to be determined automatically. Default: "all"</param>
        /// <param name="parameterValue">Value of the automatically determined parameter.</param>
        /// <returns>Name of the automatically determined parameter.</returns>
        public HTuple DetermineDeformableModelParams(
          int numLevels,
          double angleStart,
          double angleExtent,
          double scaleMin,
          double scaleMax,
          string optimization,
          string metric,
          int contrast,
          int minContrast,
          HTuple genParamName,
          HTuple genParamValue,
          string parameters,
          out HTuple parameterValue)
        {
            IntPtr proc = HalconAPI.PreCall(962);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleMin);
            HalconAPI.StoreD(proc, 4, scaleMax);
            HalconAPI.StoreS(proc, 5, optimization);
            HalconAPI.StoreS(proc, 6, metric);
            HalconAPI.StoreI(proc, 7, contrast);
            HalconAPI.StoreI(proc, 8, minContrast);
            HalconAPI.Store(proc, 9, genParamName);
            HalconAPI.Store(proc, 10, genParamValue);
            HalconAPI.StoreS(proc, 11, parameters);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, err2, out parameterValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Find the best matches of a local deformable model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="vectorField">Vector field of the rectification transformation.</param>
        /// <param name="deformedContours">Contours of the found instances of the model.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="scaleRMin">Minimum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">Maximum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleCMin">Minimum scale of the model in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">Maximum scale of the model in column direction. Default: 1.0</param>
        /// <param name="minScore">Minumum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 1.0</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching. Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="resultType">Switch for requested iconic result. Default: []</param>
        /// <param name="genParamName">The general parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the general parameters. Default: []</param>
        /// <param name="score">Scores of the found instances of the model.</param>
        /// <param name="row">Row coordinates of the found instances of the model.</param>
        /// <param name="column">Column coordinates of the found instances of the model.</param>
        /// <returns>Rectified image of the found model.</returns>
        public HImage FindLocalDeformableModel(
          out HImage vectorField,
          out HXLDCont deformedContours,
          HDeformableModel modelID,
          double angleStart,
          double angleExtent,
          double scaleRMin,
          double scaleRMax,
          double scaleCMin,
          double scaleCMax,
          double minScore,
          int numMatches,
          double maxOverlap,
          int numLevels,
          double greediness,
          HTuple resultType,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple score,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(969);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleRMin);
            HalconAPI.StoreD(proc, 4, scaleRMax);
            HalconAPI.StoreD(proc, 5, scaleCMin);
            HalconAPI.StoreD(proc, 6, scaleCMax);
            HalconAPI.StoreD(proc, 7, minScore);
            HalconAPI.StoreI(proc, 8, numMatches);
            HalconAPI.StoreD(proc, 9, maxOverlap);
            HalconAPI.StoreI(proc, 10, numLevels);
            HalconAPI.StoreD(proc, 11, greediness);
            HalconAPI.Store(proc, 12, resultType);
            HalconAPI.Store(proc, 13, genParamName);
            HalconAPI.Store(proc, 14, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(resultType);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out vectorField);
            int err4 = HXLDCont.LoadNew(proc, 3, err3, out deformedContours);
            int err5 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err4, out score);
            int err6 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err5, out row);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err6, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
            return himage;
        }

        /// <summary>
        ///   Find the best matches of a calibrated deformable model in an image and return their 3D pose.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleRMin">Minimum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">Maximum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleCMin">Minimum scale of the model in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">Maximum scale of the model in column direction. Default: 1.0</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 1.0</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="genParamName">The general parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the general parameters. Default: []</param>
        /// <param name="covPose">6 standard deviations or 36 covariances of the pose parameters.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        /// <returns>Pose of the object.</returns>
        public HPose[] FindPlanarCalibDeformableModel(
          HDeformableModel modelID,
          double angleStart,
          double angleExtent,
          double scaleRMin,
          double scaleRMax,
          double scaleCMin,
          double scaleCMax,
          double minScore,
          int numMatches,
          double maxOverlap,
          HTuple numLevels,
          double greediness,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple covPose,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(970);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleRMin);
            HalconAPI.StoreD(proc, 4, scaleRMax);
            HalconAPI.StoreD(proc, 5, scaleCMin);
            HalconAPI.StoreD(proc, 6, scaleCMax);
            HalconAPI.StoreD(proc, 7, minScore);
            HalconAPI.StoreI(proc, 8, numMatches);
            HalconAPI.StoreD(proc, 9, maxOverlap);
            HalconAPI.Store(proc, 10, numLevels);
            HalconAPI.StoreD(proc, 11, greediness);
            HalconAPI.Store(proc, 12, genParamName);
            HalconAPI.Store(proc, 13, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covPose);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
            HPose[] hposeArray = HPose.SplitArray(tuple);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
            return hposeArray;
        }

        /// <summary>
        ///   Find the best matches of a calibrated deformable model in an image and return their 3D pose.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleRMin">Minimum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">Maximum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleCMin">Minimum scale of the model in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">Maximum scale of the model in column direction. Default: 1.0</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 1.0</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="genParamName">The general parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the general parameters. Default: []</param>
        /// <param name="covPose">6 standard deviations or 36 covariances of the pose parameters.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        /// <returns>Pose of the object.</returns>
        public HPose FindPlanarCalibDeformableModel(
          HDeformableModel modelID,
          double angleStart,
          double angleExtent,
          double scaleRMin,
          double scaleRMax,
          double scaleCMin,
          double scaleCMax,
          double minScore,
          int numMatches,
          double maxOverlap,
          int numLevels,
          double greediness,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple covPose,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(970);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleRMin);
            HalconAPI.StoreD(proc, 4, scaleRMax);
            HalconAPI.StoreD(proc, 5, scaleCMin);
            HalconAPI.StoreD(proc, 6, scaleCMax);
            HalconAPI.StoreD(proc, 7, minScore);
            HalconAPI.StoreI(proc, 8, numMatches);
            HalconAPI.StoreD(proc, 9, maxOverlap);
            HalconAPI.StoreI(proc, 10, numLevels);
            HalconAPI.StoreD(proc, 11, greediness);
            HalconAPI.Store(proc, 12, genParamName);
            HalconAPI.Store(proc, 13, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HPose hpose;
            int err2 = HPose.LoadNew(proc, 0, err1, out hpose);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covPose);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
            return hpose;
        }

        /// <summary>
        ///   Find the best matches of a planar projective invariant deformable model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleRMin">Minimum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">Maximum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleCMin">Minimum scale of the model in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">Maximum scale of the model in column direction. Default: 1.0</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 1.0</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="genParamName">The general parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the general parameters. Default: []</param>
        /// <param name="score">Score of the found instances of the model.</param>
        /// <returns>Homographies between model and found instances.</returns>
        public HHomMat2D[] FindPlanarUncalibDeformableModel(
          HDeformableModel modelID,
          double angleStart,
          double angleExtent,
          double scaleRMin,
          double scaleRMax,
          double scaleCMin,
          double scaleCMax,
          double minScore,
          int numMatches,
          double maxOverlap,
          HTuple numLevels,
          double greediness,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(971);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleRMin);
            HalconAPI.StoreD(proc, 4, scaleRMax);
            HalconAPI.StoreD(proc, 5, scaleCMin);
            HalconAPI.StoreD(proc, 6, scaleCMax);
            HalconAPI.StoreD(proc, 7, minScore);
            HalconAPI.StoreI(proc, 8, numMatches);
            HalconAPI.StoreD(proc, 9, maxOverlap);
            HalconAPI.Store(proc, 10, numLevels);
            HalconAPI.StoreD(proc, 11, greediness);
            HalconAPI.Store(proc, 12, genParamName);
            HalconAPI.Store(proc, 13, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            HHomMat2D[] hhomMat2DArray = HHomMat2D.SplitArray(tuple);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
            return hhomMat2DArray;
        }

        /// <summary>
        ///   Find the best matches of a planar projective invariant deformable model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.78</param>
        /// <param name="scaleRMin">Minimum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">Maximum scale of the model in row direction. Default: 1.0</param>
        /// <param name="scaleCMin">Minimum scale of the model in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">Maximum scale of the model in column direction. Default: 1.0</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 1.0</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="genParamName">The general parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the general parameters. Default: []</param>
        /// <param name="score">Score of the found instances of the model.</param>
        /// <returns>Homographies between model and found instances.</returns>
        public HHomMat2D FindPlanarUncalibDeformableModel(
          HDeformableModel modelID,
          double angleStart,
          double angleExtent,
          double scaleRMin,
          double scaleRMax,
          double scaleCMin,
          double scaleCMax,
          double minScore,
          int numMatches,
          double maxOverlap,
          int numLevels,
          double greediness,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(971);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, scaleRMin);
            HalconAPI.StoreD(proc, 4, scaleRMax);
            HalconAPI.StoreD(proc, 5, scaleCMin);
            HalconAPI.StoreD(proc, 6, scaleCMax);
            HalconAPI.StoreD(proc, 7, minScore);
            HalconAPI.StoreI(proc, 8, numMatches);
            HalconAPI.StoreD(proc, 9, maxOverlap);
            HalconAPI.StoreI(proc, 10, numLevels);
            HalconAPI.StoreD(proc, 11, greediness);
            HalconAPI.Store(proc, 12, genParamName);
            HalconAPI.Store(proc, 13, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HHomMat2D hhomMat2D;
            int err2 = HHomMat2D.LoadNew(proc, 0, err1, out hhomMat2D);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
            return hhomMat2D;
        }

        /// <summary>
        ///   Set the metric of a local deformable model that was created from XLD contours.
        ///   Instance represents: Input image used for the determination of the polarity.
        /// </summary>
        /// <param name="vectorField">Vector field of the local deformation.</param>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        public void SetLocalDeformableModelMetric(
          HImage vectorField,
          HDeformableModel modelID,
          string metric)
        {
            IntPtr proc = HalconAPI.PreCall(972);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)vectorField);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreS(proc, 1, metric);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)vectorField);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Set the metric of a planar calibrated deformable model that was created from XLD contours.
        ///   Instance represents: Input image used for the determination of the polarity.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="pose">Pose of the model in the image.</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        public void SetPlanarCalibDeformableModelMetric(
          HDeformableModel modelID,
          HPose pose,
          string metric)
        {
            IntPtr proc = HalconAPI.PreCall(973);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.Store(proc, 1, (HData)pose);
            HalconAPI.StoreS(proc, 2, metric);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)pose));
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Set the metric of a planar uncalibrated deformable model that was created from XLD contours.
        ///   Instance represents: Input image used for the determination of the polarity.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="homMat2D">Transformation matrix.</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        public void SetPlanarUncalibDeformableModelMetric(
          HDeformableModel modelID,
          HHomMat2D homMat2D,
          string metric)
        {
            IntPtr proc = HalconAPI.PreCall(974);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.Store(proc, 1, (HData)homMat2D);
            HalconAPI.StoreS(proc, 2, metric);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)homMat2D));
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Creates a deformable model for local, deformable matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "none"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Thresholds or hysteresis thresholds for the contrast of the object in the template image. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The generic parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <returns>Handle of the model.</returns>
        public HDeformableModel CreateLocalDeformableModel(
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          double scaleRMin,
          HTuple scaleRMax,
          HTuple scaleRStep,
          double scaleCMin,
          HTuple scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          string metric,
          HTuple contrast,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(978);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.StoreD(proc, 4, scaleRMin);
            HalconAPI.Store(proc, 5, scaleRMax);
            HalconAPI.Store(proc, 6, scaleRStep);
            HalconAPI.StoreD(proc, 7, scaleCMin);
            HalconAPI.Store(proc, 8, scaleCMax);
            HalconAPI.Store(proc, 9, scaleCStep);
            HalconAPI.Store(proc, 10, optimization);
            HalconAPI.StoreS(proc, 11, metric);
            HalconAPI.Store(proc, 12, contrast);
            HalconAPI.Store(proc, 13, minContrast);
            HalconAPI.Store(proc, 14, genParamName);
            HalconAPI.Store(proc, 15, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HDeformableModel hdeformableModel;
            int procResult = HDeformableModel.LoadNew(proc, 0, err, out hdeformableModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hdeformableModel;
        }

        /// <summary>
        ///   Creates a deformable model for local, deformable matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "none"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Thresholds or hysteresis thresholds for the contrast of the object in the template image. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The generic parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameters. Default: []</param>
        /// <returns>Handle of the model.</returns>
        public HDeformableModel CreateLocalDeformableModel(
          int numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          double angleStep,
          double scaleRMin,
          HTuple scaleRMax,
          double scaleRStep,
          double scaleCMin,
          HTuple scaleCMax,
          double scaleCStep,
          string optimization,
          string metric,
          HTuple contrast,
          int minContrast,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(978);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, angleStep);
            HalconAPI.StoreD(proc, 4, scaleRMin);
            HalconAPI.Store(proc, 5, scaleRMax);
            HalconAPI.StoreD(proc, 6, scaleRStep);
            HalconAPI.StoreD(proc, 7, scaleCMin);
            HalconAPI.Store(proc, 8, scaleCMax);
            HalconAPI.StoreD(proc, 9, scaleCStep);
            HalconAPI.StoreS(proc, 10, optimization);
            HalconAPI.StoreS(proc, 11, metric);
            HalconAPI.Store(proc, 12, contrast);
            HalconAPI.StoreI(proc, 13, minContrast);
            HalconAPI.Store(proc, 14, genParamName);
            HalconAPI.Store(proc, 15, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HDeformableModel hdeformableModel;
            int procResult = HDeformableModel.LoadNew(proc, 0, err, out hdeformableModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hdeformableModel;
        }

        /// <summary>
        ///   Create a deformable model for calibrated perspective matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="camParam">The parameters of the internal orientation of the camera.</param>
        /// <param name="referencePose">The reference pose of the object in the reference image.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in the column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "none"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Thresholds or hysteresis thresholds for the contrast of the object in the template image. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the parameters. Default: []</param>
        /// <returns>Handle of the model.</returns>
        public HDeformableModel CreatePlanarCalibDeformableModel(
          HCamPar camParam,
          HPose referencePose,
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          double scaleRMin,
          HTuple scaleRMax,
          HTuple scaleRStep,
          double scaleCMin,
          HTuple scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          string metric,
          HTuple contrast,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(979);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HData)camParam);
            HalconAPI.Store(proc, 1, (HData)referencePose);
            HalconAPI.Store(proc, 2, numLevels);
            HalconAPI.Store(proc, 3, angleStart);
            HalconAPI.Store(proc, 4, angleExtent);
            HalconAPI.Store(proc, 5, angleStep);
            HalconAPI.StoreD(proc, 6, scaleRMin);
            HalconAPI.Store(proc, 7, scaleRMax);
            HalconAPI.Store(proc, 8, scaleRStep);
            HalconAPI.StoreD(proc, 9, scaleCMin);
            HalconAPI.Store(proc, 10, scaleCMax);
            HalconAPI.Store(proc, 11, scaleCStep);
            HalconAPI.Store(proc, 12, optimization);
            HalconAPI.StoreS(proc, 13, metric);
            HalconAPI.Store(proc, 14, contrast);
            HalconAPI.Store(proc, 15, minContrast);
            HalconAPI.Store(proc, 16, genParamName);
            HalconAPI.Store(proc, 17, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParam));
            HalconAPI.UnpinTuple((HTuple)((HData)referencePose));
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HDeformableModel hdeformableModel;
            int procResult = HDeformableModel.LoadNew(proc, 0, err, out hdeformableModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hdeformableModel;
        }

        /// <summary>
        ///   Create a deformable model for calibrated perspective matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="camParam">The parameters of the internal orientation of the camera.</param>
        /// <param name="referencePose">The reference pose of the object in the reference image.</param>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in the column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "none"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Thresholds or hysteresis thresholds for the contrast of the object in the template image. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the parameters. Default: []</param>
        /// <returns>Handle of the model.</returns>
        public HDeformableModel CreatePlanarCalibDeformableModel(
          HCamPar camParam,
          HPose referencePose,
          int numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          double angleStep,
          double scaleRMin,
          HTuple scaleRMax,
          double scaleRStep,
          double scaleCMin,
          HTuple scaleCMax,
          double scaleCStep,
          string optimization,
          string metric,
          HTuple contrast,
          int minContrast,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(979);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HData)camParam);
            HalconAPI.Store(proc, 1, (HData)referencePose);
            HalconAPI.StoreI(proc, 2, numLevels);
            HalconAPI.Store(proc, 3, angleStart);
            HalconAPI.Store(proc, 4, angleExtent);
            HalconAPI.StoreD(proc, 5, angleStep);
            HalconAPI.StoreD(proc, 6, scaleRMin);
            HalconAPI.Store(proc, 7, scaleRMax);
            HalconAPI.StoreD(proc, 8, scaleRStep);
            HalconAPI.StoreD(proc, 9, scaleCMin);
            HalconAPI.Store(proc, 10, scaleCMax);
            HalconAPI.StoreD(proc, 11, scaleCStep);
            HalconAPI.StoreS(proc, 12, optimization);
            HalconAPI.StoreS(proc, 13, metric);
            HalconAPI.Store(proc, 14, contrast);
            HalconAPI.StoreI(proc, 15, minContrast);
            HalconAPI.Store(proc, 16, genParamName);
            HalconAPI.Store(proc, 17, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParam));
            HalconAPI.UnpinTuple((HTuple)((HData)referencePose));
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HDeformableModel hdeformableModel;
            int procResult = HDeformableModel.LoadNew(proc, 0, err, out hdeformableModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hdeformableModel;
        }

        /// <summary>
        ///   Creates a deformable model for uncalibrated, perspective matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "none"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Thresholds or hysteresis thresholds for the contrast of the object in the template image. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The generic parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameter. Default: []</param>
        /// <returns>Handle of the model.</returns>
        public HDeformableModel CreatePlanarUncalibDeformableModel(
          HTuple numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple angleStep,
          double scaleRMin,
          HTuple scaleRMax,
          HTuple scaleRStep,
          double scaleCMin,
          HTuple scaleCMax,
          HTuple scaleCStep,
          HTuple optimization,
          string metric,
          HTuple contrast,
          HTuple minContrast,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(980);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.StoreD(proc, 4, scaleRMin);
            HalconAPI.Store(proc, 5, scaleRMax);
            HalconAPI.Store(proc, 6, scaleRStep);
            HalconAPI.StoreD(proc, 7, scaleCMin);
            HalconAPI.Store(proc, 8, scaleCMax);
            HalconAPI.Store(proc, 9, scaleCStep);
            HalconAPI.Store(proc, 10, optimization);
            HalconAPI.StoreS(proc, 11, metric);
            HalconAPI.Store(proc, 12, contrast);
            HalconAPI.Store(proc, 13, minContrast);
            HalconAPI.Store(proc, 14, genParamName);
            HalconAPI.Store(proc, 15, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(angleStep);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleRStep);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(scaleCStep);
            HalconAPI.UnpinTuple(optimization);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HDeformableModel hdeformableModel;
            int procResult = HDeformableModel.LoadNew(proc, 0, err, out hdeformableModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hdeformableModel;
        }

        /// <summary>
        ///   Creates a deformable model for uncalibrated, perspective matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">This parameter is not used. Default: []</param>
        /// <param name="angleExtent">This parameter is not used. Default: []</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="scaleRMin">Minimum scale of the pattern in row direction. Default: 1.0</param>
        /// <param name="scaleRMax">This parameter is not used. Default: []</param>
        /// <param name="scaleRStep">Scale step length (resolution) in row direction. Default: "auto"</param>
        /// <param name="scaleCMin">Minimum scale of the pattern in column direction. Default: 1.0</param>
        /// <param name="scaleCMax">This parameter is not used. Default: []</param>
        /// <param name="scaleCStep">Scale step length (resolution) in column direction. Default: "auto"</param>
        /// <param name="optimization">Kind of optimization used for generating the model. Default: "none"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <param name="contrast">Thresholds or hysteresis thresholds for the contrast of the object in the template image. Default: "auto"</param>
        /// <param name="minContrast">Minimum contrast of the objects in the search images. Default: "auto"</param>
        /// <param name="genParamName">The generic parameter names. Default: []</param>
        /// <param name="genParamValue">Values of the generic parameter. Default: []</param>
        /// <returns>Handle of the model.</returns>
        public HDeformableModel CreatePlanarUncalibDeformableModel(
          int numLevels,
          HTuple angleStart,
          HTuple angleExtent,
          double angleStep,
          double scaleRMin,
          HTuple scaleRMax,
          double scaleRStep,
          double scaleCMin,
          HTuple scaleCMax,
          double scaleCStep,
          string optimization,
          string metric,
          HTuple contrast,
          int minContrast,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(980);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numLevels);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, angleStep);
            HalconAPI.StoreD(proc, 4, scaleRMin);
            HalconAPI.Store(proc, 5, scaleRMax);
            HalconAPI.StoreD(proc, 6, scaleRStep);
            HalconAPI.StoreD(proc, 7, scaleCMin);
            HalconAPI.Store(proc, 8, scaleCMax);
            HalconAPI.StoreD(proc, 9, scaleCStep);
            HalconAPI.StoreS(proc, 10, optimization);
            HalconAPI.StoreS(proc, 11, metric);
            HalconAPI.Store(proc, 12, contrast);
            HalconAPI.StoreI(proc, 13, minContrast);
            HalconAPI.Store(proc, 14, genParamName);
            HalconAPI.Store(proc, 15, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(scaleRMax);
            HalconAPI.UnpinTuple(scaleCMax);
            HalconAPI.UnpinTuple(contrast);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HDeformableModel hdeformableModel;
            int procResult = HDeformableModel.LoadNew(proc, 0, err, out hdeformableModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hdeformableModel;
        }

        /// <summary>
        ///   Find the best matches of an NCC model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.8</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy. Default: "true"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public void FindNccModel(
          HNCCModel modelID,
          double angleStart,
          double angleExtent,
          double minScore,
          int numMatches,
          double maxOverlap,
          string subPixel,
          HTuple numLevels,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(991);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, minScore);
            HalconAPI.StoreI(proc, 4, numMatches);
            HalconAPI.StoreD(proc, 5, maxOverlap);
            HalconAPI.StoreS(proc, 6, subPixel);
            HalconAPI.Store(proc, 7, numLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Find the best matches of an NCC model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="angleStart">Smallest rotation of the model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.8</param>
        /// <param name="numMatches">Number of instances of the model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the model to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy. Default: "true"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="row">Row coordinate of the found instances of the model.</param>
        /// <param name="column">Column coordinate of the found instances of the model.</param>
        /// <param name="angle">Rotation angle of the found instances of the model.</param>
        /// <param name="score">Score of the found instances of the model.</param>
        public void FindNccModel(
          HNCCModel modelID,
          double angleStart,
          double angleExtent,
          double minScore,
          int numMatches,
          double maxOverlap,
          string subPixel,
          int numLevels,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(991);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, minScore);
            HalconAPI.StoreI(proc, 4, numMatches);
            HalconAPI.StoreD(proc, 5, maxOverlap);
            HalconAPI.StoreS(proc, 6, subPixel);
            HalconAPI.StoreI(proc, 7, numLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>Set selected parameters of the NCC model.</summary>
        /// <param name="modelID">Handle of the model.</param>
        /// <param name="genParamName">Parameter names.</param>
        /// <param name="genParamValue">Parameter values.</param>
        public static void SetNccModelParam(
          HNCCModel modelID,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(992);
            HalconAPI.Store(proc, 0, (HTool)modelID);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)modelID);
        }

        /// <summary>
        ///   Prepare an NCC model for matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <returns>Handle of the model.</returns>
        public HNCCModel CreateNccModel(
          HTuple numLevels,
          double angleStart,
          double angleExtent,
          HTuple angleStep,
          string metric)
        {
            IntPtr proc = HalconAPI.PreCall(993);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, angleStep);
            HalconAPI.StoreS(proc, 4, metric);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(angleStep);
            HNCCModel hnccModel;
            int procResult = HNCCModel.LoadNew(proc, 0, err, out hnccModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hnccModel;
        }

        /// <summary>
        ///   Prepare an NCC model for matching.
        ///   Instance represents: Input image whose domain will be used to create the model.
        /// </summary>
        /// <param name="numLevels">Maximum number of pyramid levels. Default: "auto"</param>
        /// <param name="angleStart">Smallest rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="angleStep">Step length of the angles (resolution). Default: "auto"</param>
        /// <param name="metric">Match metric. Default: "use_polarity"</param>
        /// <returns>Handle of the model.</returns>
        public HNCCModel CreateNccModel(
          int numLevels,
          double angleStart,
          double angleExtent,
          double angleStep,
          string metric)
        {
            IntPtr proc = HalconAPI.PreCall(993);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numLevels);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, angleStep);
            HalconAPI.StoreS(proc, 4, metric);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HNCCModel hnccModel;
            int procResult = HNCCModel.LoadNew(proc, 0, err, out hnccModel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hnccModel;
        }

        /// <summary>
        ///   Find the best matches of a component model in an image.
        ///   Instance represents: Input image in which the component model should be found.
        /// </summary>
        /// <param name="componentModelID">Handle of the component model.</param>
        /// <param name="rootComponent">Index of the root component.</param>
        /// <param name="angleStartRoot">Smallest rotation of the root component Default: -0.39</param>
        /// <param name="angleExtentRoot">Extent of the rotation of the root component. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the component model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the component model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the component models to be found. Default: 0.5</param>
        /// <param name="ifRootNotFound">Behavior if the root component is missing. Default: "stop_search"</param>
        /// <param name="ifComponentNotFound">Behavior if a component is missing. Default: "prune_branch"</param>
        /// <param name="posePrediction">Pose prediction of components that are not found. Default: "none"</param>
        /// <param name="minScoreComp">Minimum score of the instances of the components to be found. Default: 0.5</param>
        /// <param name="subPixelComp">Subpixel accuracy of the component poses if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevelsComp">Number of pyramid levels for the components used in the matching (and lowest pyramid level to use if $|NumLevelsComp| = 2n$). Default: 0</param>
        /// <param name="greedinessComp">"Greediness" of the search heuristic for the components (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="modelEnd">End index of each found instance of the component model in the tuples describing the component matches.</param>
        /// <param name="score">Score of the found instances of the component model.</param>
        /// <param name="rowComp">Row coordinate of the found component matches.</param>
        /// <param name="columnComp">Column coordinate of the found component matches.</param>
        /// <param name="angleComp">Rotation angle of the found component matches.</param>
        /// <param name="scoreComp">Score of the found component matches.</param>
        /// <param name="modelComp">Index of the found components.</param>
        /// <returns>Start index of each found instance of the component model in the tuples describing the component matches.</returns>
        public HTuple FindComponentModel(
          HComponentModel componentModelID,
          HTuple rootComponent,
          HTuple angleStartRoot,
          HTuple angleExtentRoot,
          double minScore,
          int numMatches,
          double maxOverlap,
          string ifRootNotFound,
          string ifComponentNotFound,
          string posePrediction,
          HTuple minScoreComp,
          HTuple subPixelComp,
          HTuple numLevelsComp,
          HTuple greedinessComp,
          out HTuple modelEnd,
          out HTuple score,
          out HTuple rowComp,
          out HTuple columnComp,
          out HTuple angleComp,
          out HTuple scoreComp,
          out HTuple modelComp)
        {
            IntPtr proc = HalconAPI.PreCall(995);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)componentModelID);
            HalconAPI.Store(proc, 1, rootComponent);
            HalconAPI.Store(proc, 2, angleStartRoot);
            HalconAPI.Store(proc, 3, angleExtentRoot);
            HalconAPI.StoreD(proc, 4, minScore);
            HalconAPI.StoreI(proc, 5, numMatches);
            HalconAPI.StoreD(proc, 6, maxOverlap);
            HalconAPI.StoreS(proc, 7, ifRootNotFound);
            HalconAPI.StoreS(proc, 8, ifComponentNotFound);
            HalconAPI.StoreS(proc, 9, posePrediction);
            HalconAPI.Store(proc, 10, minScoreComp);
            HalconAPI.Store(proc, 11, subPixelComp);
            HalconAPI.Store(proc, 12, numLevelsComp);
            HalconAPI.Store(proc, 13, greedinessComp);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rootComponent);
            HalconAPI.UnpinTuple(angleStartRoot);
            HalconAPI.UnpinTuple(angleExtentRoot);
            HalconAPI.UnpinTuple(minScoreComp);
            HalconAPI.UnpinTuple(subPixelComp);
            HalconAPI.UnpinTuple(numLevelsComp);
            HalconAPI.UnpinTuple(greedinessComp);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out modelEnd);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out rowComp);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out columnComp);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out angleComp);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out scoreComp);
            int procResult = HTuple.LoadNew(proc, 7, HTupleType.INTEGER, err8, out modelComp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)componentModelID);
            return tuple;
        }

        /// <summary>
        ///   Find the best matches of a component model in an image.
        ///   Instance represents: Input image in which the component model should be found.
        /// </summary>
        /// <param name="componentModelID">Handle of the component model.</param>
        /// <param name="rootComponent">Index of the root component.</param>
        /// <param name="angleStartRoot">Smallest rotation of the root component Default: -0.39</param>
        /// <param name="angleExtentRoot">Extent of the rotation of the root component. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the component model to be found. Default: 0.5</param>
        /// <param name="numMatches">Number of instances of the component model to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the component models to be found. Default: 0.5</param>
        /// <param name="ifRootNotFound">Behavior if the root component is missing. Default: "stop_search"</param>
        /// <param name="ifComponentNotFound">Behavior if a component is missing. Default: "prune_branch"</param>
        /// <param name="posePrediction">Pose prediction of components that are not found. Default: "none"</param>
        /// <param name="minScoreComp">Minimum score of the instances of the components to be found. Default: 0.5</param>
        /// <param name="subPixelComp">Subpixel accuracy of the component poses if not equal to 'none'. Default: "least_squares"</param>
        /// <param name="numLevelsComp">Number of pyramid levels for the components used in the matching (and lowest pyramid level to use if $|NumLevelsComp| = 2n$). Default: 0</param>
        /// <param name="greedinessComp">"Greediness" of the search heuristic for the components (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="modelEnd">End index of each found instance of the component model in the tuples describing the component matches.</param>
        /// <param name="score">Score of the found instances of the component model.</param>
        /// <param name="rowComp">Row coordinate of the found component matches.</param>
        /// <param name="columnComp">Column coordinate of the found component matches.</param>
        /// <param name="angleComp">Rotation angle of the found component matches.</param>
        /// <param name="scoreComp">Score of the found component matches.</param>
        /// <param name="modelComp">Index of the found components.</param>
        /// <returns>Start index of each found instance of the component model in the tuples describing the component matches.</returns>
        public int FindComponentModel(
          HComponentModel componentModelID,
          int rootComponent,
          double angleStartRoot,
          double angleExtentRoot,
          double minScore,
          int numMatches,
          double maxOverlap,
          string ifRootNotFound,
          string ifComponentNotFound,
          string posePrediction,
          double minScoreComp,
          string subPixelComp,
          int numLevelsComp,
          double greedinessComp,
          out int modelEnd,
          out double score,
          out double rowComp,
          out double columnComp,
          out double angleComp,
          out double scoreComp,
          out int modelComp)
        {
            IntPtr proc = HalconAPI.PreCall(995);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)componentModelID);
            HalconAPI.StoreI(proc, 1, rootComponent);
            HalconAPI.StoreD(proc, 2, angleStartRoot);
            HalconAPI.StoreD(proc, 3, angleExtentRoot);
            HalconAPI.StoreD(proc, 4, minScore);
            HalconAPI.StoreI(proc, 5, numMatches);
            HalconAPI.StoreD(proc, 6, maxOverlap);
            HalconAPI.StoreS(proc, 7, ifRootNotFound);
            HalconAPI.StoreS(proc, 8, ifComponentNotFound);
            HalconAPI.StoreS(proc, 9, posePrediction);
            HalconAPI.StoreD(proc, 10, minScoreComp);
            HalconAPI.StoreS(proc, 11, subPixelComp);
            HalconAPI.StoreI(proc, 12, numLevelsComp);
            HalconAPI.StoreD(proc, 13, greedinessComp);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            int intValue;
            int err2 = HalconAPI.LoadI(proc, 0, err1, out intValue);
            int err3 = HalconAPI.LoadI(proc, 1, err2, out modelEnd);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out score);
            int err5 = HalconAPI.LoadD(proc, 3, err4, out rowComp);
            int err6 = HalconAPI.LoadD(proc, 4, err5, out columnComp);
            int err7 = HalconAPI.LoadD(proc, 5, err6, out angleComp);
            int err8 = HalconAPI.LoadD(proc, 6, err7, out scoreComp);
            int procResult = HalconAPI.LoadI(proc, 7, err8, out modelComp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)componentModelID);
            return intValue;
        }

        /// <summary>
        ///   Prepare a component model for matching based on explicitly specified components and relations.
        ///   Instance represents: Input image from which the shape models of the model components should be created.
        /// </summary>
        /// <param name="componentRegions">Input regions from which the shape models of the model components should be created.</param>
        /// <param name="variationRow">Variation of the model components in row direction.</param>
        /// <param name="variationColumn">Variation of the model components in column direction.</param>
        /// <param name="variationAngle">Angle variation of the model components.</param>
        /// <param name="angleStart">Smallest rotation of the component model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation of the component model. Default: 0.79</param>
        /// <param name="contrastLowComp">Lower hysteresis threshold for the contrast of the components in the model image. Default: "auto"</param>
        /// <param name="contrastHighComp">Upper hysteresis threshold for the contrast of the components in the model image. Default: "auto"</param>
        /// <param name="minSizeComp">Minimum size of the contour regions in the model. Default: "auto"</param>
        /// <param name="minContrastComp">Minimum contrast of the components in the search images. Default: "auto"</param>
        /// <param name="minScoreComp">Minimum score of the instances of the components to be found. Default: 0.5</param>
        /// <param name="numLevelsComp">Maximum number of pyramid levels for the components. Default: "auto"</param>
        /// <param name="angleStepComp">Step length of the angles (resolution) for the components. Default: "auto"</param>
        /// <param name="optimizationComp">Kind of optimization for the components. Default: "auto"</param>
        /// <param name="metricComp">Match metric used for the components. Default: "use_polarity"</param>
        /// <param name="pregenerationComp">Complete pregeneration of the shape models for the components if equal to 'true'. Default: "false"</param>
        /// <param name="rootRanking">Ranking of the model components expressing the suitability to act as the root component.</param>
        /// <returns>Handle of the component model.</returns>
        public HComponentModel CreateComponentModel(
          HRegion componentRegions,
          HTuple variationRow,
          HTuple variationColumn,
          HTuple variationAngle,
          double angleStart,
          double angleExtent,
          HTuple contrastLowComp,
          HTuple contrastHighComp,
          HTuple minSizeComp,
          HTuple minContrastComp,
          HTuple minScoreComp,
          HTuple numLevelsComp,
          HTuple angleStepComp,
          string optimizationComp,
          HTuple metricComp,
          HTuple pregenerationComp,
          out HTuple rootRanking)
        {
            IntPtr proc = HalconAPI.PreCall(1004);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)componentRegions);
            HalconAPI.Store(proc, 0, variationRow);
            HalconAPI.Store(proc, 1, variationColumn);
            HalconAPI.Store(proc, 2, variationAngle);
            HalconAPI.StoreD(proc, 3, angleStart);
            HalconAPI.StoreD(proc, 4, angleExtent);
            HalconAPI.Store(proc, 5, contrastLowComp);
            HalconAPI.Store(proc, 6, contrastHighComp);
            HalconAPI.Store(proc, 7, minSizeComp);
            HalconAPI.Store(proc, 8, minContrastComp);
            HalconAPI.Store(proc, 9, minScoreComp);
            HalconAPI.Store(proc, 10, numLevelsComp);
            HalconAPI.Store(proc, 11, angleStepComp);
            HalconAPI.StoreS(proc, 12, optimizationComp);
            HalconAPI.Store(proc, 13, metricComp);
            HalconAPI.Store(proc, 14, pregenerationComp);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(variationRow);
            HalconAPI.UnpinTuple(variationColumn);
            HalconAPI.UnpinTuple(variationAngle);
            HalconAPI.UnpinTuple(contrastLowComp);
            HalconAPI.UnpinTuple(contrastHighComp);
            HalconAPI.UnpinTuple(minSizeComp);
            HalconAPI.UnpinTuple(minContrastComp);
            HalconAPI.UnpinTuple(minScoreComp);
            HalconAPI.UnpinTuple(numLevelsComp);
            HalconAPI.UnpinTuple(angleStepComp);
            HalconAPI.UnpinTuple(metricComp);
            HalconAPI.UnpinTuple(pregenerationComp);
            HComponentModel hcomponentModel;
            int err2 = HComponentModel.LoadNew(proc, 0, err1, out hcomponentModel);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out rootRanking);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)componentRegions);
            return hcomponentModel;
        }

        /// <summary>
        ///   Prepare a component model for matching based on explicitly specified components and relations.
        ///   Instance represents: Input image from which the shape models of the model components should be created.
        /// </summary>
        /// <param name="componentRegions">Input regions from which the shape models of the model components should be created.</param>
        /// <param name="variationRow">Variation of the model components in row direction.</param>
        /// <param name="variationColumn">Variation of the model components in column direction.</param>
        /// <param name="variationAngle">Angle variation of the model components.</param>
        /// <param name="angleStart">Smallest rotation of the component model. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation of the component model. Default: 0.79</param>
        /// <param name="contrastLowComp">Lower hysteresis threshold for the contrast of the components in the model image. Default: "auto"</param>
        /// <param name="contrastHighComp">Upper hysteresis threshold for the contrast of the components in the model image. Default: "auto"</param>
        /// <param name="minSizeComp">Minimum size of the contour regions in the model. Default: "auto"</param>
        /// <param name="minContrastComp">Minimum contrast of the components in the search images. Default: "auto"</param>
        /// <param name="minScoreComp">Minimum score of the instances of the components to be found. Default: 0.5</param>
        /// <param name="numLevelsComp">Maximum number of pyramid levels for the components. Default: "auto"</param>
        /// <param name="angleStepComp">Step length of the angles (resolution) for the components. Default: "auto"</param>
        /// <param name="optimizationComp">Kind of optimization for the components. Default: "auto"</param>
        /// <param name="metricComp">Match metric used for the components. Default: "use_polarity"</param>
        /// <param name="pregenerationComp">Complete pregeneration of the shape models for the components if equal to 'true'. Default: "false"</param>
        /// <param name="rootRanking">Ranking of the model components expressing the suitability to act as the root component.</param>
        /// <returns>Handle of the component model.</returns>
        public HComponentModel CreateComponentModel(
          HRegion componentRegions,
          int variationRow,
          int variationColumn,
          double variationAngle,
          double angleStart,
          double angleExtent,
          int contrastLowComp,
          int contrastHighComp,
          int minSizeComp,
          int minContrastComp,
          double minScoreComp,
          int numLevelsComp,
          double angleStepComp,
          string optimizationComp,
          string metricComp,
          string pregenerationComp,
          out int rootRanking)
        {
            IntPtr proc = HalconAPI.PreCall(1004);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)componentRegions);
            HalconAPI.StoreI(proc, 0, variationRow);
            HalconAPI.StoreI(proc, 1, variationColumn);
            HalconAPI.StoreD(proc, 2, variationAngle);
            HalconAPI.StoreD(proc, 3, angleStart);
            HalconAPI.StoreD(proc, 4, angleExtent);
            HalconAPI.StoreI(proc, 5, contrastLowComp);
            HalconAPI.StoreI(proc, 6, contrastHighComp);
            HalconAPI.StoreI(proc, 7, minSizeComp);
            HalconAPI.StoreI(proc, 8, minContrastComp);
            HalconAPI.StoreD(proc, 9, minScoreComp);
            HalconAPI.StoreI(proc, 10, numLevelsComp);
            HalconAPI.StoreD(proc, 11, angleStepComp);
            HalconAPI.StoreS(proc, 12, optimizationComp);
            HalconAPI.StoreS(proc, 13, metricComp);
            HalconAPI.StoreS(proc, 14, pregenerationComp);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HComponentModel hcomponentModel;
            int err2 = HComponentModel.LoadNew(proc, 0, err1, out hcomponentModel);
            int procResult = HalconAPI.LoadI(proc, 1, err2, out rootRanking);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)componentRegions);
            return hcomponentModel;
        }

        /// <summary>
        ///   Adopt new parameters that are used to create the model components into the training result.
        ///   Instance represents: Training images that were used for training the model components.
        /// </summary>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        /// <param name="ambiguityCriterion">Criterion for solving the ambiguities. Default: "rigidity"</param>
        /// <param name="maxContourOverlap">Maximum contour overlap of the found initial components. Default: 0.2</param>
        /// <param name="clusterThreshold">Threshold for clustering the initial components. Default: 0.5</param>
        /// <returns>Contour regions of rigid model components.</returns>
        public HRegion ClusterModelComponents(
          HComponentTraining componentTrainingID,
          string ambiguityCriterion,
          double maxContourOverlap,
          double clusterThreshold)
        {
            IntPtr proc = HalconAPI.PreCall(1015);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)componentTrainingID);
            HalconAPI.StoreS(proc, 1, ambiguityCriterion);
            HalconAPI.StoreD(proc, 2, maxContourOverlap);
            HalconAPI.StoreD(proc, 3, clusterThreshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)componentTrainingID);
            return hregion;
        }

        /// <summary>
        ///   Train components and relations for the component-based matching.
        ///   Instance represents: Input image from which the shape models of the initial components should be created.
        /// </summary>
        /// <param name="initialComponents">Contour regions or enclosing regions of the initial components.</param>
        /// <param name="trainingImages">Training images that are used for training the model components.</param>
        /// <param name="contrastLow">Lower hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="contrastHigh">Upper hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="minSize">Minimum size of connected contour regions. Default: "auto"</param>
        /// <param name="minScore">Minimum score of the instances of the initial components to be found. Default: 0.5</param>
        /// <param name="searchRowTol">Search tolerance in row direction. Default: -1</param>
        /// <param name="searchColumnTol">Search tolerance in column direction. Default: -1</param>
        /// <param name="searchAngleTol">Angle search tolerance. Default: -1</param>
        /// <param name="trainingEmphasis">Decision whether the training emphasis should lie on a fast computation or on a high robustness. Default: "speed"</param>
        /// <param name="ambiguityCriterion">Criterion for solving ambiguous matches of the initial components in the training images. Default: "rigidity"</param>
        /// <param name="maxContourOverlap">Maximum contour overlap of the found initial components in a training image. Default: 0.2</param>
        /// <param name="clusterThreshold">Threshold for clustering the initial components. Default: 0.5</param>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        /// <returns>Contour regions of rigid model components.</returns>
        public HRegion TrainModelComponents(
          HRegion initialComponents,
          HImage trainingImages,
          HTuple contrastLow,
          HTuple contrastHigh,
          HTuple minSize,
          HTuple minScore,
          HTuple searchRowTol,
          HTuple searchColumnTol,
          HTuple searchAngleTol,
          string trainingEmphasis,
          string ambiguityCriterion,
          double maxContourOverlap,
          double clusterThreshold,
          out HComponentTraining componentTrainingID)
        {
            IntPtr proc = HalconAPI.PreCall(1017);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)initialComponents);
            HalconAPI.Store(proc, 3, (HObjectBase)trainingImages);
            HalconAPI.Store(proc, 0, contrastLow);
            HalconAPI.Store(proc, 1, contrastHigh);
            HalconAPI.Store(proc, 2, minSize);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, searchRowTol);
            HalconAPI.Store(proc, 5, searchColumnTol);
            HalconAPI.Store(proc, 6, searchAngleTol);
            HalconAPI.StoreS(proc, 7, trainingEmphasis);
            HalconAPI.StoreS(proc, 8, ambiguityCriterion);
            HalconAPI.StoreD(proc, 9, maxContourOverlap);
            HalconAPI.StoreD(proc, 10, clusterThreshold);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(contrastLow);
            HalconAPI.UnpinTuple(contrastHigh);
            HalconAPI.UnpinTuple(minSize);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(searchRowTol);
            HalconAPI.UnpinTuple(searchColumnTol);
            HalconAPI.UnpinTuple(searchAngleTol);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HComponentTraining.LoadNew(proc, 0, err2, out componentTrainingID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)initialComponents);
            GC.KeepAlive((object)trainingImages);
            return hregion;
        }

        /// <summary>
        ///   Train components and relations for the component-based matching.
        ///   Instance represents: Input image from which the shape models of the initial components should be created.
        /// </summary>
        /// <param name="initialComponents">Contour regions or enclosing regions of the initial components.</param>
        /// <param name="trainingImages">Training images that are used for training the model components.</param>
        /// <param name="contrastLow">Lower hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="contrastHigh">Upper hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="minSize">Minimum size of connected contour regions. Default: "auto"</param>
        /// <param name="minScore">Minimum score of the instances of the initial components to be found. Default: 0.5</param>
        /// <param name="searchRowTol">Search tolerance in row direction. Default: -1</param>
        /// <param name="searchColumnTol">Search tolerance in column direction. Default: -1</param>
        /// <param name="searchAngleTol">Angle search tolerance. Default: -1</param>
        /// <param name="trainingEmphasis">Decision whether the training emphasis should lie on a fast computation or on a high robustness. Default: "speed"</param>
        /// <param name="ambiguityCriterion">Criterion for solving ambiguous matches of the initial components in the training images. Default: "rigidity"</param>
        /// <param name="maxContourOverlap">Maximum contour overlap of the found initial components in a training image. Default: 0.2</param>
        /// <param name="clusterThreshold">Threshold for clustering the initial components. Default: 0.5</param>
        /// <param name="componentTrainingID">Handle of the training result.</param>
        /// <returns>Contour regions of rigid model components.</returns>
        public HRegion TrainModelComponents(
          HRegion initialComponents,
          HImage trainingImages,
          int contrastLow,
          int contrastHigh,
          int minSize,
          double minScore,
          int searchRowTol,
          int searchColumnTol,
          double searchAngleTol,
          string trainingEmphasis,
          string ambiguityCriterion,
          double maxContourOverlap,
          double clusterThreshold,
          out HComponentTraining componentTrainingID)
        {
            IntPtr proc = HalconAPI.PreCall(1017);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)initialComponents);
            HalconAPI.Store(proc, 3, (HObjectBase)trainingImages);
            HalconAPI.StoreI(proc, 0, contrastLow);
            HalconAPI.StoreI(proc, 1, contrastHigh);
            HalconAPI.StoreI(proc, 2, minSize);
            HalconAPI.StoreD(proc, 3, minScore);
            HalconAPI.StoreI(proc, 4, searchRowTol);
            HalconAPI.StoreI(proc, 5, searchColumnTol);
            HalconAPI.StoreD(proc, 6, searchAngleTol);
            HalconAPI.StoreS(proc, 7, trainingEmphasis);
            HalconAPI.StoreS(proc, 8, ambiguityCriterion);
            HalconAPI.StoreD(proc, 9, maxContourOverlap);
            HalconAPI.StoreD(proc, 10, clusterThreshold);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HComponentTraining.LoadNew(proc, 0, err2, out componentTrainingID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)initialComponents);
            GC.KeepAlive((object)trainingImages);
            return hregion;
        }

        /// <summary>
        ///   Extract the initial components of a component model.
        ///   Instance represents: Input image from which the initial components should be extracted.
        /// </summary>
        /// <param name="contrastLow">Lower hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="contrastHigh">Upper hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="minSize">Minimum size of the initial components. Default: "auto"</param>
        /// <param name="mode">Type of automatic segmentation. Default: "connection"</param>
        /// <param name="genericName">Names of optional control parameters. Default: []</param>
        /// <param name="genericValue">Values of optional control parameters. Default: []</param>
        /// <returns>Contour regions of initial components.</returns>
        public HRegion GenInitialComponents(
          HTuple contrastLow,
          HTuple contrastHigh,
          HTuple minSize,
          string mode,
          HTuple genericName,
          HTuple genericValue)
        {
            IntPtr proc = HalconAPI.PreCall(1018);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, contrastLow);
            HalconAPI.Store(proc, 1, contrastHigh);
            HalconAPI.Store(proc, 2, minSize);
            HalconAPI.StoreS(proc, 3, mode);
            HalconAPI.Store(proc, 4, genericName);
            HalconAPI.Store(proc, 5, genericValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(contrastLow);
            HalconAPI.UnpinTuple(contrastHigh);
            HalconAPI.UnpinTuple(minSize);
            HalconAPI.UnpinTuple(genericName);
            HalconAPI.UnpinTuple(genericValue);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Extract the initial components of a component model.
        ///   Instance represents: Input image from which the initial components should be extracted.
        /// </summary>
        /// <param name="contrastLow">Lower hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="contrastHigh">Upper hysteresis threshold for the contrast of the initial components in the image. Default: "auto"</param>
        /// <param name="minSize">Minimum size of the initial components. Default: "auto"</param>
        /// <param name="mode">Type of automatic segmentation. Default: "connection"</param>
        /// <param name="genericName">Names of optional control parameters. Default: []</param>
        /// <param name="genericValue">Values of optional control parameters. Default: []</param>
        /// <returns>Contour regions of initial components.</returns>
        public HRegion GenInitialComponents(
          int contrastLow,
          int contrastHigh,
          int minSize,
          string mode,
          string genericName,
          double genericValue)
        {
            IntPtr proc = HalconAPI.PreCall(1018);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, contrastLow);
            HalconAPI.StoreI(proc, 1, contrastHigh);
            HalconAPI.StoreI(proc, 2, minSize);
            HalconAPI.StoreS(proc, 3, mode);
            HalconAPI.StoreS(proc, 4, genericName);
            HalconAPI.StoreD(proc, 5, genericValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Find the best matches of a 3D shape model in an image.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="shapeModel3DID">Handle of the 3D shape model.</param>
        /// <param name="minScore">Minimum score of the instances of the model to be found. Default: 0.7</param>
        /// <param name="greediness">"Greediness" of the search heuristic (0: safe but slow; 1: fast but matches may be missed). Default: 0.9</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="genParamName">Names of (optional) parameters for controlling the behavior of the operator. Default: []</param>
        /// <param name="genParamValue">Values of the optional generic parameters. Default: []</param>
        /// <param name="covPose">6 standard deviations or 36 covariances of the pose parameters.</param>
        /// <param name="score">Score of the found instances of the 3D shape model.</param>
        /// <returns>3D pose of the 3D shape model.</returns>
        public HPose[] FindShapeModel3d(
          HShapeModel3D shapeModel3DID,
          double minScore,
          double greediness,
          HTuple numLevels,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple covPose,
          out HTuple score)
        {
            IntPtr proc = HalconAPI.PreCall(1058);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)shapeModel3DID);
            HalconAPI.StoreD(proc, 1, minScore);
            HalconAPI.StoreD(proc, 2, greediness);
            HalconAPI.Store(proc, 3, numLevels);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevels);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out covPose);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out score);
            HalconAPI.PostCall(proc, procResult);
            HPose[] hposeArray = HPose.SplitArray(tuple);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)shapeModel3DID);
            return hposeArray;
        }

        /// <summary>
        ///   Convert one-channel images into a multi-channel image
        ///   Instance represents: One-channel images to be combined into a one-channel image.
        /// </summary>
        /// <returns>Multi-channel image.</returns>
        public HImage ChannelsToImage()
        {
            IntPtr proc = HalconAPI.PreCall(1119);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convert a multi-channel image into One-channel images
        ///   Instance represents: Multi-channel image to be decomposed.
        /// </summary>
        /// <returns>Generated one-channel images.</returns>
        public HImage ImageToChannels()
        {
            IntPtr proc = HalconAPI.PreCall(1120);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convert 7 images into a seven-channel image.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="image3">Input image 3.</param>
        /// <param name="image4">Input image 4.</param>
        /// <param name="image5">Input image 5.</param>
        /// <param name="image6">Input image 6.</param>
        /// <param name="image7">Input image 7.</param>
        /// <returns>Multi-channel image.</returns>
        public HImage Compose7(
          HImage image2,
          HImage image3,
          HImage image4,
          HImage image5,
          HImage image6,
          HImage image7)
        {
            IntPtr proc = HalconAPI.PreCall(1121);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.Store(proc, 4, (HObjectBase)image4);
            HalconAPI.Store(proc, 5, (HObjectBase)image5);
            HalconAPI.Store(proc, 6, (HObjectBase)image6);
            HalconAPI.Store(proc, 7, (HObjectBase)image7);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
            GC.KeepAlive((object)image4);
            GC.KeepAlive((object)image5);
            GC.KeepAlive((object)image6);
            GC.KeepAlive((object)image7);
            return himage;
        }

        /// <summary>
        ///   Convert 6 images into a six-channel image.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="image3">Input image 3.</param>
        /// <param name="image4">Input image 4.</param>
        /// <param name="image5">Input image 5.</param>
        /// <param name="image6">Input image 6.</param>
        /// <returns>Multi-channel image.</returns>
        public HImage Compose6(
          HImage image2,
          HImage image3,
          HImage image4,
          HImage image5,
          HImage image6)
        {
            IntPtr proc = HalconAPI.PreCall(1122);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.Store(proc, 4, (HObjectBase)image4);
            HalconAPI.Store(proc, 5, (HObjectBase)image5);
            HalconAPI.Store(proc, 6, (HObjectBase)image6);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
            GC.KeepAlive((object)image4);
            GC.KeepAlive((object)image5);
            GC.KeepAlive((object)image6);
            return himage;
        }

        /// <summary>
        ///   Convert 5 images into a five-channel image.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="image3">Input image 3.</param>
        /// <param name="image4">Input image 4.</param>
        /// <param name="image5">Input image 5.</param>
        /// <returns>Multi-channel image.</returns>
        public HImage Compose5(HImage image2, HImage image3, HImage image4, HImage image5)
        {
            IntPtr proc = HalconAPI.PreCall(1123);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.Store(proc, 4, (HObjectBase)image4);
            HalconAPI.Store(proc, 5, (HObjectBase)image5);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
            GC.KeepAlive((object)image4);
            GC.KeepAlive((object)image5);
            return himage;
        }

        /// <summary>
        ///   Convert 4 images into a four-channel image.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="image3">Input image 3.</param>
        /// <param name="image4">Input image 4.</param>
        /// <returns>Multi-channel image.</returns>
        public HImage Compose4(HImage image2, HImage image3, HImage image4)
        {
            IntPtr proc = HalconAPI.PreCall(1124);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.Store(proc, 4, (HObjectBase)image4);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
            GC.KeepAlive((object)image4);
            return himage;
        }

        /// <summary>
        ///   Convert 3 images into a three-channel image.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="image3">Input image 3.</param>
        /// <returns>Multi-channel image.</returns>
        public HImage Compose3(HImage image2, HImage image3)
        {
            IntPtr proc = HalconAPI.PreCall(1125);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
            return himage;
        }

        /// <summary>
        ///   Convert two images into a two-channel image.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <returns>Multi-channel image.</returns>
        public HImage Compose2(HImage image2)
        {
            IntPtr proc = HalconAPI.PreCall(1126);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Convert a seven-channel image into seven images.
        ///   Instance represents: Multi-channel image.
        /// </summary>
        /// <param name="image2">Output image 2.</param>
        /// <param name="image3">Output image 3.</param>
        /// <param name="image4">Output image 4.</param>
        /// <param name="image5">Output image 5.</param>
        /// <param name="image6">Output image 6.</param>
        /// <param name="image7">Output image 7.</param>
        /// <returns>Output image 1.</returns>
        public HImage Decompose7(
          out HImage image2,
          out HImage image3,
          out HImage image4,
          out HImage image5,
          out HImage image6,
          out HImage image7)
        {
            IntPtr proc = HalconAPI.PreCall(1127);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out image2);
            int err4 = HImage.LoadNew(proc, 3, err3, out image3);
            int err5 = HImage.LoadNew(proc, 4, err4, out image4);
            int err6 = HImage.LoadNew(proc, 5, err5, out image5);
            int err7 = HImage.LoadNew(proc, 6, err6, out image6);
            int procResult = HImage.LoadNew(proc, 7, err7, out image7);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convert a six-channel image into six images.
        ///   Instance represents: Multi-channel image.
        /// </summary>
        /// <param name="image2">Output image 2.</param>
        /// <param name="image3">Output image 3.</param>
        /// <param name="image4">Output image 4.</param>
        /// <param name="image5">Output image 5.</param>
        /// <param name="image6">Output image 6.</param>
        /// <returns>Output image 1.</returns>
        public HImage Decompose6(
          out HImage image2,
          out HImage image3,
          out HImage image4,
          out HImage image5,
          out HImage image6)
        {
            IntPtr proc = HalconAPI.PreCall(1128);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out image2);
            int err4 = HImage.LoadNew(proc, 3, err3, out image3);
            int err5 = HImage.LoadNew(proc, 4, err4, out image4);
            int err6 = HImage.LoadNew(proc, 5, err5, out image5);
            int procResult = HImage.LoadNew(proc, 6, err6, out image6);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convert a five-channel image into five images.
        ///   Instance represents: Multi-channel image.
        /// </summary>
        /// <param name="image2">Output image 2.</param>
        /// <param name="image3">Output image 3.</param>
        /// <param name="image4">Output image 4.</param>
        /// <param name="image5">Output image 5.</param>
        /// <returns>Output image 1.</returns>
        public HImage Decompose5(
          out HImage image2,
          out HImage image3,
          out HImage image4,
          out HImage image5)
        {
            IntPtr proc = HalconAPI.PreCall(1129);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out image2);
            int err4 = HImage.LoadNew(proc, 3, err3, out image3);
            int err5 = HImage.LoadNew(proc, 4, err4, out image4);
            int procResult = HImage.LoadNew(proc, 5, err5, out image5);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convert a four-channel image into four images.
        ///   Instance represents: Multi-channel image.
        /// </summary>
        /// <param name="image2">Output image 2.</param>
        /// <param name="image3">Output image 3.</param>
        /// <param name="image4">Output image 4.</param>
        /// <returns>Output image 1.</returns>
        public HImage Decompose4(out HImage image2, out HImage image3, out HImage image4)
        {
            IntPtr proc = HalconAPI.PreCall(1130);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out image2);
            int err4 = HImage.LoadNew(proc, 3, err3, out image3);
            int procResult = HImage.LoadNew(proc, 4, err4, out image4);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convert a three-channel image into three images.
        ///   Instance represents: Multi-channel image.
        /// </summary>
        /// <param name="image2">Output image 2.</param>
        /// <param name="image3">Output image 3.</param>
        /// <returns>Output image 1.</returns>
        public HImage Decompose3(out HImage image2, out HImage image3)
        {
            IntPtr proc = HalconAPI.PreCall(1131);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out image2);
            int procResult = HImage.LoadNew(proc, 3, err3, out image3);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convert a two-channel image into two images.
        ///   Instance represents: Multi-channel image.
        /// </summary>
        /// <param name="image2">Output image 2.</param>
        /// <returns>Output image 1.</returns>
        public HImage Decompose2(out HImage image2)
        {
            IntPtr proc = HalconAPI.PreCall(1132);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out image2);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Count channels of image.
        ///   Instance represents: One- or multi-channel image.
        /// </summary>
        /// <returns>Number of channels.</returns>
        public HTuple CountChannels()
        {
            IntPtr proc = HalconAPI.PreCall(1133);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Append additional matrices (channels) to the image.
        ///   Instance represents: Multi-channel image.
        /// </summary>
        /// <param name="image">Image to be appended.</param>
        /// <returns>Image appended by Image.</returns>
        public HImage AppendChannel(HImage image)
        {
            IntPtr proc = HalconAPI.PreCall(1134);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image);
            return himage;
        }

        /// <summary>
        ///   Access a channel of a multi-channel image.
        ///   Instance represents: Multi-channel image.
        /// </summary>
        /// <param name="channel">Index of channel to be accessed. Default: 1</param>
        /// <returns>One channel of MultiChannelImage.</returns>
        public HImage AccessChannel(int channel)
        {
            IntPtr proc = HalconAPI.PreCall(1135);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, channel);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Tile multiple image objects into a large image with explicit positioning information.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="offsetRow">Row coordinate of the upper left corner of the input images in the output image. Default: 0</param>
        /// <param name="offsetCol">Column coordinate of the upper left corner of the input images in the output image. Default: 0</param>
        /// <param name="row1">Row coordinate of the upper left corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="col1">Column coordinate of the upper left corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="row2">Row coordinate of the lower right corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="col2">Column coordinate of the lower right corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="width">Width of the output image. Default: 512</param>
        /// <param name="height">Height of the output image. Default: 512</param>
        /// <returns>Tiled output image.</returns>
        public HImage TileImagesOffset(
          HTuple offsetRow,
          HTuple offsetCol,
          HTuple row1,
          HTuple col1,
          HTuple row2,
          HTuple col2,
          int width,
          int height)
        {
            IntPtr proc = HalconAPI.PreCall(1136);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, offsetRow);
            HalconAPI.Store(proc, 1, offsetCol);
            HalconAPI.Store(proc, 2, row1);
            HalconAPI.Store(proc, 3, col1);
            HalconAPI.Store(proc, 4, row2);
            HalconAPI.Store(proc, 5, col2);
            HalconAPI.StoreI(proc, 6, width);
            HalconAPI.StoreI(proc, 7, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(offsetRow);
            HalconAPI.UnpinTuple(offsetCol);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(col1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(col2);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Tile multiple image objects into a large image with explicit positioning information.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="offsetRow">Row coordinate of the upper left corner of the input images in the output image. Default: 0</param>
        /// <param name="offsetCol">Column coordinate of the upper left corner of the input images in the output image. Default: 0</param>
        /// <param name="row1">Row coordinate of the upper left corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="col1">Column coordinate of the upper left corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="row2">Row coordinate of the lower right corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="col2">Column coordinate of the lower right corner of the copied part of the respective input image. Default: -1</param>
        /// <param name="width">Width of the output image. Default: 512</param>
        /// <param name="height">Height of the output image. Default: 512</param>
        /// <returns>Tiled output image.</returns>
        public HImage TileImagesOffset(
          int offsetRow,
          int offsetCol,
          int row1,
          int col1,
          int row2,
          int col2,
          int width,
          int height)
        {
            IntPtr proc = HalconAPI.PreCall(1136);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, offsetRow);
            HalconAPI.StoreI(proc, 1, offsetCol);
            HalconAPI.StoreI(proc, 2, row1);
            HalconAPI.StoreI(proc, 3, col1);
            HalconAPI.StoreI(proc, 4, row2);
            HalconAPI.StoreI(proc, 5, col2);
            HalconAPI.StoreI(proc, 6, width);
            HalconAPI.StoreI(proc, 7, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Tile multiple image objects into a large image.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="numColumns">Number of columns to use for the output image. Default: 1</param>
        /// <param name="tileOrder">Order of the input images in the output image. Default: "vertical"</param>
        /// <returns>Tiled output image.</returns>
        public HImage TileImages(int numColumns, string tileOrder)
        {
            IntPtr proc = HalconAPI.PreCall(1137);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numColumns);
            HalconAPI.StoreS(proc, 1, tileOrder);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Tile multiple images into a large image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="numColumns">Number of columns to use for the output image. Default: 1</param>
        /// <param name="tileOrder">Order of the input images in the output image. Default: "vertical"</param>
        /// <returns>Tiled output image.</returns>
        public HImage TileChannels(int numColumns, string tileOrder)
        {
            IntPtr proc = HalconAPI.PreCall(1138);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numColumns);
            HalconAPI.StoreS(proc, 1, tileOrder);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Cut out of defined gray values.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Image area.</returns>
        public HImage CropDomain()
        {
            IntPtr proc = HalconAPI.PreCall(1139);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Cut out one or more rectangular image areas.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row1">Line index of upper left corner of image area. Default: 100</param>
        /// <param name="column1">Column index of upper left corner of image area. Default: 100</param>
        /// <param name="row2">Line index of lower right corner of image area. Default: 200</param>
        /// <param name="column2">Column index of lower right corner of image area. Default: 200</param>
        /// <returns>Image area.</returns>
        public HImage CropRectangle1(HTuple row1, HTuple column1, HTuple row2, HTuple column2)
        {
            IntPtr proc = HalconAPI.PreCall(1140);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, row1);
            HalconAPI.Store(proc, 1, column1);
            HalconAPI.Store(proc, 2, row2);
            HalconAPI.Store(proc, 3, column2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row1);
            HalconAPI.UnpinTuple(column1);
            HalconAPI.UnpinTuple(row2);
            HalconAPI.UnpinTuple(column2);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Cut out one or more rectangular image areas.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row1">Line index of upper left corner of image area. Default: 100</param>
        /// <param name="column1">Column index of upper left corner of image area. Default: 100</param>
        /// <param name="row2">Line index of lower right corner of image area. Default: 200</param>
        /// <param name="column2">Column index of lower right corner of image area. Default: 200</param>
        /// <returns>Image area.</returns>
        public HImage CropRectangle1(int row1, int column1, int row2, int column2)
        {
            IntPtr proc = HalconAPI.PreCall(1140);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, row1);
            HalconAPI.StoreI(proc, 1, column1);
            HalconAPI.StoreI(proc, 2, row2);
            HalconAPI.StoreI(proc, 3, column2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Cut out one or more rectangular image areas.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row">Line index of upper left corner of image area. Default: 100</param>
        /// <param name="column">Column index of upper left corner of image area. Default: 100</param>
        /// <param name="width">Width of new image. Default: 128</param>
        /// <param name="height">Height of new image. Default: 128</param>
        /// <returns>Image area.</returns>
        public HImage CropPart(HTuple row, HTuple column, HTuple width, HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1141);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, width);
            HalconAPI.Store(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(width);
            HalconAPI.UnpinTuple(height);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Cut out one or more rectangular image areas.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row">Line index of upper left corner of image area. Default: 100</param>
        /// <param name="column">Column index of upper left corner of image area. Default: 100</param>
        /// <param name="width">Width of new image. Default: 128</param>
        /// <param name="height">Height of new image. Default: 128</param>
        /// <returns>Image area.</returns>
        public HImage CropPart(int row, int column, int width, int height)
        {
            IntPtr proc = HalconAPI.PreCall(1141);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, row);
            HalconAPI.StoreI(proc, 1, column);
            HalconAPI.StoreI(proc, 2, width);
            HalconAPI.StoreI(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Change image size.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="width">Width of new image. Default: 512</param>
        /// <param name="height">Height of new image. Default: 512</param>
        /// <returns>Image with new format.</returns>
        public HImage ChangeFormat(int width, int height)
        {
            IntPtr proc = HalconAPI.PreCall(1142);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, width);
            HalconAPI.StoreI(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Change definition domain of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="newDomain">New definition domain.</param>
        /// <returns>Image with new definition domain.</returns>
        public HImage ChangeDomain(HRegion newDomain)
        {
            IntPtr proc = HalconAPI.PreCall(1143);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)newDomain);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)newDomain);
            return himage;
        }

        /// <summary>
        ///   Reduce the domain of an image to a rectangle.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row1">Line index of upper left corner of image area. Default: 100</param>
        /// <param name="column1">Column index of upper left corner of image area. Default: 100</param>
        /// <param name="row2">Line index of lower right corner of image area. Default: 200</param>
        /// <param name="column2">Column index of lower right corner of image area. Default: 200</param>
        /// <returns>Image with reduced definition domain.</returns>
        public HImage Rectangle1Domain(int row1, int column1, int row2, int column2)
        {
            IntPtr proc = HalconAPI.PreCall(1145);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, row1);
            HalconAPI.StoreI(proc, 1, column1);
            HalconAPI.StoreI(proc, 2, row2);
            HalconAPI.StoreI(proc, 3, column2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Reduce the domain of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="region">New definition domain.</param>
        /// <returns>Image with reduced definition domain.</returns>
        public HImage ReduceDomain(HRegion region)
        {
            IntPtr proc = HalconAPI.PreCall(1146);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return himage;
        }

        /// <summary>
        ///   Expand the domain of an image to maximum.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Image with maximum definition domain.</returns>
        public HImage FullDomain()
        {
            IntPtr proc = HalconAPI.PreCall(1147);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Get the domain of an image.
        ///   Instance represents: Input images.
        /// </summary>
        /// <returns>Definition domains of input images.</returns>
        public HRegion GetDomain()
        {
            IntPtr proc = HalconAPI.PreCall(1148);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Detect lines in edge images with the help of the Hough transform using local gradient direction and return them in normal form.
        ///   Instance represents: Image containing the edge direction. The edges are described by the image domain.
        /// </summary>
        /// <param name="lines">Regions of the input image that contributed to the local maxima.</param>
        /// <param name="directionUncertainty">Uncertainty of edge direction (in degrees). Default: 2</param>
        /// <param name="angleResolution">Resolution in the angle area (in 1/degrees). Default: 4</param>
        /// <param name="smoothing">Smoothing filter for hough image. Default: "mean"</param>
        /// <param name="filterSize">Required smoothing filter size. Default: 5</param>
        /// <param name="threshold">Threshold value in the Hough image. Default: 100</param>
        /// <param name="angleGap">Minimum distance of two maxima in the Hough image (direction: angle). Default: 5</param>
        /// <param name="distGap">Minimum distance of two maxima in the Hough image (direction: distance). Default: 5</param>
        /// <param name="genLines">Create line regions if 'true'. Default: "true"</param>
        /// <param name="angle">Angles (in radians) of the detected lines' normal vectors.</param>
        /// <param name="dist">Distance of the detected lines from the origin.</param>
        /// <returns>Hough transform.</returns>
        public HImage HoughLinesDir(
          out HRegion lines,
          int directionUncertainty,
          int angleResolution,
          string smoothing,
          int filterSize,
          int threshold,
          int angleGap,
          int distGap,
          string genLines,
          out HTuple angle,
          out HTuple dist)
        {
            IntPtr proc = HalconAPI.PreCall(1151);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, directionUncertainty);
            HalconAPI.StoreI(proc, 1, angleResolution);
            HalconAPI.StoreS(proc, 2, smoothing);
            HalconAPI.StoreI(proc, 3, filterSize);
            HalconAPI.StoreI(proc, 4, threshold);
            HalconAPI.StoreI(proc, 5, angleGap);
            HalconAPI.StoreI(proc, 6, distGap);
            HalconAPI.StoreS(proc, 7, genLines);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HRegion.LoadNew(proc, 2, err2, out lines);
            int err4 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err4, out dist);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute the Hough transform for lines using local gradient direction.
        ///   Instance represents: Image containing the edge direction. The edges must be described by the image domain.
        /// </summary>
        /// <param name="directionUncertainty">Uncertainty of the edge direction (in degrees). Default: 2</param>
        /// <param name="angleResolution">Resolution in the angle area (in 1/degrees). Default: 4</param>
        /// <returns>Hough transform.</returns>
        public HImage HoughLineTransDir(int directionUncertainty, int angleResolution)
        {
            IntPtr proc = HalconAPI.PreCall(1152);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, directionUncertainty);
            HalconAPI.StoreI(proc, 1, angleResolution);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Segment the rectification grid region in the image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="minContrast">Minimum contrast. Default: 8.0</param>
        /// <param name="radius">Radius of the circular structuring element. Default: 7.5</param>
        /// <returns>Output region containing the rectification grid.</returns>
        public HRegion FindRectificationGrid(HTuple minContrast, HTuple radius)
        {
            IntPtr proc = HalconAPI.PreCall(1156);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, minContrast);
            HalconAPI.Store(proc, 1, radius);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minContrast);
            HalconAPI.UnpinTuple(radius);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment the rectification grid region in the image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="minContrast">Minimum contrast. Default: 8.0</param>
        /// <param name="radius">Radius of the circular structuring element. Default: 7.5</param>
        /// <returns>Output region containing the rectification grid.</returns>
        public HRegion FindRectificationGrid(double minContrast, double radius)
        {
            IntPtr proc = HalconAPI.PreCall(1156);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, minContrast);
            HalconAPI.StoreD(proc, 1, radius);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Establish connections between the grid points of the rectification grid.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row">Row coordinates of the grid points.</param>
        /// <param name="column">Column coordinates of the grid points.</param>
        /// <param name="sigma">Size of the applied Gaussians. Default: 0.9</param>
        /// <param name="maxDist">Maximum distance of the connecting lines from the grid points. Default: 5.5</param>
        /// <returns>Output contours.</returns>
        public HXLD ConnectGridPoints(HTuple row, HTuple column, HTuple sigma, HTuple maxDist)
        {
            IntPtr proc = HalconAPI.PreCall(1158);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.Store(proc, 2, sigma);
            HalconAPI.Store(proc, 3, maxDist);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(maxDist);
            HXLD hxld;
            int procResult = HXLD.LoadNew(proc, 1, err, out hxld);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxld;
        }

        /// <summary>
        ///   Establish connections between the grid points of the rectification grid.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row">Row coordinates of the grid points.</param>
        /// <param name="column">Column coordinates of the grid points.</param>
        /// <param name="sigma">Size of the applied Gaussians. Default: 0.9</param>
        /// <param name="maxDist">Maximum distance of the connecting lines from the grid points. Default: 5.5</param>
        /// <returns>Output contours.</returns>
        public HXLD ConnectGridPoints(HTuple row, HTuple column, int sigma, double maxDist)
        {
            IntPtr proc = HalconAPI.PreCall(1158);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.StoreI(proc, 2, sigma);
            HalconAPI.StoreD(proc, 3, maxDist);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HXLD hxld;
            int procResult = HXLD.LoadNew(proc, 1, err, out hxld);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxld;
        }

        /// <summary>
        ///   Compute the mapping between the distorted image and the rectified image based upon the points of a regular grid.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="connectingLines">Input contours.</param>
        /// <param name="meshes">Output contours.</param>
        /// <param name="gridSpacing">Distance of the grid points in the rectified image.</param>
        /// <param name="rotation">Rotation to be applied to the point grid. Default: "auto"</param>
        /// <param name="row">Row coordinates of the grid points.</param>
        /// <param name="column">Column coordinates of the grid points.</param>
        /// <param name="mapType">Type of mapping. Default: "bilinear"</param>
        /// <returns>Image containing the mapping data.</returns>
        public HImage GenGridRectificationMap(
          HXLD connectingLines,
          out HXLD meshes,
          int gridSpacing,
          HTuple rotation,
          HTuple row,
          HTuple column,
          string mapType)
        {
            IntPtr proc = HalconAPI.PreCall(1159);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)connectingLines);
            HalconAPI.StoreI(proc, 0, gridSpacing);
            HalconAPI.Store(proc, 1, rotation);
            HalconAPI.Store(proc, 2, row);
            HalconAPI.Store(proc, 3, column);
            HalconAPI.StoreS(proc, 4, mapType);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rotation);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HXLD.LoadNew(proc, 2, err2, out meshes);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)connectingLines);
            return himage;
        }

        /// <summary>
        ///   Compute the mapping between the distorted image and the rectified image based upon the points of a regular grid.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="connectingLines">Input contours.</param>
        /// <param name="meshes">Output contours.</param>
        /// <param name="gridSpacing">Distance of the grid points in the rectified image.</param>
        /// <param name="rotation">Rotation to be applied to the point grid. Default: "auto"</param>
        /// <param name="row">Row coordinates of the grid points.</param>
        /// <param name="column">Column coordinates of the grid points.</param>
        /// <param name="mapType">Type of mapping. Default: "bilinear"</param>
        /// <returns>Image containing the mapping data.</returns>
        public HImage GenGridRectificationMap(
          HXLD connectingLines,
          out HXLD meshes,
          int gridSpacing,
          string rotation,
          HTuple row,
          HTuple column,
          string mapType)
        {
            IntPtr proc = HalconAPI.PreCall(1159);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)connectingLines);
            HalconAPI.StoreI(proc, 0, gridSpacing);
            HalconAPI.StoreS(proc, 1, rotation);
            HalconAPI.Store(proc, 2, row);
            HalconAPI.Store(proc, 3, column);
            HalconAPI.StoreS(proc, 4, mapType);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HXLD.LoadNew(proc, 2, err2, out meshes);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)connectingLines);
            return himage;
        }

        /// <summary>
        ///   Calculates image coordinates for a point in a 3D plot window.
        ///   Instance represents: Displayed image.
        /// </summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row coordinate in the window.</param>
        /// <param name="column">Column coordinate in the window.</param>
        /// <param name="imageRow">Row coordinate in the image.</param>
        /// <param name="imageColumn">Column coordinate in the image.</param>
        /// <param name="height">Height value.</param>
        public void UnprojectCoordinates(
          HWindow windowHandle,
          HTuple row,
          HTuple column,
          out int imageRow,
          out int imageColumn,
          out HTuple height)
        {
            IntPtr proc = HalconAPI.PreCall(1168);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)windowHandle);
            HalconAPI.Store(proc, 1, row);
            HalconAPI.Store(proc, 2, column);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            int err2 = HalconAPI.LoadI(proc, 0, err1, out imageRow);
            int err3 = HalconAPI.LoadI(proc, 1, err2, out imageColumn);
            int procResult = HTuple.LoadNew(proc, 2, err3, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)windowHandle);
        }

        /// <summary>
        ///   Calculates image coordinates for a point in a 3D plot window.
        ///   Instance represents: Displayed image.
        /// </summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="row">Row coordinate in the window.</param>
        /// <param name="column">Column coordinate in the window.</param>
        /// <param name="imageRow">Row coordinate in the image.</param>
        /// <param name="imageColumn">Column coordinate in the image.</param>
        /// <param name="height">Height value.</param>
        public void UnprojectCoordinates(
          HWindow windowHandle,
          double row,
          double column,
          out int imageRow,
          out int imageColumn,
          out int height)
        {
            IntPtr proc = HalconAPI.PreCall(1168);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)windowHandle);
            HalconAPI.StoreD(proc, 1, row);
            HalconAPI.StoreD(proc, 2, column);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HalconAPI.LoadI(proc, 0, err1, out imageRow);
            int err3 = HalconAPI.LoadI(proc, 1, err2, out imageColumn);
            int procResult = HalconAPI.LoadI(proc, 2, err3, out height);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)windowHandle);
        }

        /// <summary>
        ///   Write the window content in an image object.
        ///   Modified instance represents: Saved image.
        /// </summary>
        /// <param name="windowHandle">Window handle.</param>
        public void DumpWindowImage(HWindow windowHandle)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1184);
            HalconAPI.Store(proc, 0, (HTool)windowHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)windowHandle);
        }

        /// <summary>
        ///   Displays gray value images.
        ///   Instance represents: Gray value image to display.
        /// </summary>
        /// <param name="windowHandle">Window handle.</param>
        public void DispImage(HWindow windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1268);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)windowHandle);
        }

        /// <summary>
        ///   Displays images with several channels.
        ///   Instance represents: Multichannel images to be displayed.
        /// </summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="channel">Number of channel or the numbers of the RGB-channels Default: 1</param>
        public void DispChannel(HWindow windowHandle, HTuple channel)
        {
            IntPtr proc = HalconAPI.PreCall(1269);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)windowHandle);
            HalconAPI.Store(proc, 1, channel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(channel);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)windowHandle);
        }

        /// <summary>
        ///   Displays images with several channels.
        ///   Instance represents: Multichannel images to be displayed.
        /// </summary>
        /// <param name="windowHandle">Window handle.</param>
        /// <param name="channel">Number of channel or the numbers of the RGB-channels Default: 1</param>
        public void DispChannel(HWindow windowHandle, int channel)
        {
            IntPtr proc = HalconAPI.PreCall(1269);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)windowHandle);
            HalconAPI.StoreI(proc, 1, channel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)windowHandle);
        }

        /// <summary>
        ///   Displays a color (RGB) image
        ///   Instance represents: Color image to display.
        /// </summary>
        /// <param name="windowHandle">Window handle.</param>
        public void DispColor(HWindow windowHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1270);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)windowHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)windowHandle);
        }

        /// <summary>
        ///   Visualize images using gnuplot.
        ///   Instance represents: Image to be plotted.
        /// </summary>
        /// <param name="gnuplotFileID">Identifier for the gnuplot output stream.</param>
        /// <param name="samplesX">Number of samples in the x-direction. Default: 64</param>
        /// <param name="samplesY">Number of samples in the y-direction. Default: 64</param>
        /// <param name="viewRotX">Rotation of the plot about the x-axis. Default: 60</param>
        /// <param name="viewRotZ">Rotation of the plot about the z-axis. Default: 30</param>
        /// <param name="hidden3D">Plot the image with hidden surfaces removed. Default: "hidden3d"</param>
        public void GnuplotPlotImage(
          HGnuplot gnuplotFileID,
          int samplesX,
          int samplesY,
          HTuple viewRotX,
          HTuple viewRotZ,
          string hidden3D)
        {
            IntPtr proc = HalconAPI.PreCall(1297);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)gnuplotFileID);
            HalconAPI.StoreI(proc, 1, samplesX);
            HalconAPI.StoreI(proc, 2, samplesY);
            HalconAPI.Store(proc, 3, viewRotX);
            HalconAPI.Store(proc, 4, viewRotZ);
            HalconAPI.StoreS(proc, 5, hidden3D);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(viewRotX);
            HalconAPI.UnpinTuple(viewRotZ);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)gnuplotFileID);
        }

        /// <summary>
        ///   Visualize images using gnuplot.
        ///   Instance represents: Image to be plotted.
        /// </summary>
        /// <param name="gnuplotFileID">Identifier for the gnuplot output stream.</param>
        /// <param name="samplesX">Number of samples in the x-direction. Default: 64</param>
        /// <param name="samplesY">Number of samples in the y-direction. Default: 64</param>
        /// <param name="viewRotX">Rotation of the plot about the x-axis. Default: 60</param>
        /// <param name="viewRotZ">Rotation of the plot about the z-axis. Default: 30</param>
        /// <param name="hidden3D">Plot the image with hidden surfaces removed. Default: "hidden3d"</param>
        public void GnuplotPlotImage(
          HGnuplot gnuplotFileID,
          int samplesX,
          int samplesY,
          double viewRotX,
          double viewRotZ,
          string hidden3D)
        {
            IntPtr proc = HalconAPI.PreCall(1297);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)gnuplotFileID);
            HalconAPI.StoreI(proc, 1, samplesX);
            HalconAPI.StoreI(proc, 2, samplesY);
            HalconAPI.StoreD(proc, 3, viewRotX);
            HalconAPI.StoreD(proc, 4, viewRotZ);
            HalconAPI.StoreS(proc, 5, hidden3D);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)gnuplotFileID);
        }

        /// <summary>
        ///   Filter an image using a Laws texture filter.
        ///   Instance represents: Images to which the texture transformation is to be applied.
        /// </summary>
        /// <param name="filterTypes">Desired filter. Default: "el"</param>
        /// <param name="shift">Shift to reduce the gray value dynamics. Default: 2</param>
        /// <param name="filterSize">Size of the filter kernel. Default: 5</param>
        /// <returns>Texture images.</returns>
        public HImage TextureLaws(string filterTypes, int shift, int filterSize)
        {
            IntPtr proc = HalconAPI.PreCall(1402);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filterTypes);
            HalconAPI.StoreI(proc, 1, shift);
            HalconAPI.StoreI(proc, 2, filterSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the standard deviation of gray values within rectangular windows.
        ///   Instance represents: Image for which the standard deviation is to be calculated.
        /// </summary>
        /// <param name="width">Width of the mask in which the standard deviation is calculated. Default: 11</param>
        /// <param name="height">Height of the mask in which the standard deviation is calculated. Default: 11</param>
        /// <returns>Image containing the standard deviation.</returns>
        public HImage DeviationImage(int width, int height)
        {
            IntPtr proc = HalconAPI.PreCall(1403);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, width);
            HalconAPI.StoreI(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the entropy of gray values within a rectangular window.
        ///   Instance represents: Image for which the entropy is to be calculated.
        /// </summary>
        /// <param name="width">Width of the mask in which the entropy is calculated. Default: 9</param>
        /// <param name="height">Height of the mask in which the entropy is calculated. Default: 9</param>
        /// <returns>Entropy image.</returns>
        public HImage EntropyImage(int width, int height)
        {
            IntPtr proc = HalconAPI.PreCall(1404);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, width);
            HalconAPI.StoreI(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Perform an isotropic diffusion of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigma">Standard deviation of the Gauss distribution. Default: 1.0</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        /// <returns>Output image.</returns>
        public HImage IsotropicDiffusion(double sigma, int iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1405);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.StoreI(proc, 1, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Perform an anisotropic diffusion of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="mode">Diffusion coefficient as a function of the edge amplitude. Default: "weickert"</param>
        /// <param name="contrast">Contrast parameter. Default: 5.0</param>
        /// <param name="theta">Time step. Default: 1.0</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        /// <returns>Output image.</returns>
        public HImage AnisotropicDiffusion(
          string mode,
          double contrast,
          double theta,
          int iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1406);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.StoreD(proc, 1, contrast);
            HalconAPI.StoreD(proc, 2, theta);
            HalconAPI.StoreI(proc, 3, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Smooth an image using various filters.
        ///   Instance represents: Image to be smoothed.
        /// </summary>
        /// <param name="filter">Filter. Default: "deriche2"</param>
        /// <param name="alpha">Filterparameter: small values cause strong smoothing (vice versa by using bei 'gauss'). Default: 0.5</param>
        /// <returns>Smoothed image.</returns>
        public HImage SmoothImage(string filter, double alpha)
        {
            IntPtr proc = HalconAPI.PreCall(1407);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, alpha);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Non-linear smoothing with the sigma filter.
        ///   Instance represents: Image to be smoothed.
        /// </summary>
        /// <param name="maskHeight">Height of the mask (number of lines). Default: 5</param>
        /// <param name="maskWidth">Width of the mask (number of columns). Default: 5</param>
        /// <param name="sigma">Max. deviation to the average. Default: 3</param>
        /// <returns>Smoothed image.</returns>
        public HImage SigmaImage(int maskHeight, int maskWidth, int sigma)
        {
            IntPtr proc = HalconAPI.PreCall(1408);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskHeight);
            HalconAPI.StoreI(proc, 1, maskWidth);
            HalconAPI.StoreI(proc, 2, sigma);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the average of maximum and minimum inside any mask.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="mask">Filter mask.</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Filtered image.</returns>
        public HImage MidrangeImage(HRegion mask, HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1409);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)mask);
            HalconAPI.Store(proc, 0, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(margin);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)mask);
            return himage;
        }

        /// <summary>
        ///   Calculate the average of maximum and minimum inside any mask.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="mask">Filter mask.</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Filtered image.</returns>
        public HImage MidrangeImage(HRegion mask, string margin)
        {
            IntPtr proc = HalconAPI.PreCall(1409);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)mask);
            HalconAPI.StoreS(proc, 0, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)mask);
            return himage;
        }

        /// <summary>
        ///   Smooth an image with an arbitrary rank mask.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="mask">Image whose region serves as filter mask.</param>
        /// <param name="number">Number of averaged pixels. Typical value:       Surface(Mask) / 2. Default: 5</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Filtered output image.</returns>
        public HImage TrimmedMean(HRegion mask, int number, HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1410);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)mask);
            HalconAPI.StoreI(proc, 0, number);
            HalconAPI.Store(proc, 1, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(margin);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)mask);
            return himage;
        }

        /// <summary>
        ///   Smooth an image with an arbitrary rank mask.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="mask">Image whose region serves as filter mask.</param>
        /// <param name="number">Number of averaged pixels. Typical value:       Surface(Mask) / 2. Default: 5</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Filtered output image.</returns>
        public HImage TrimmedMean(HRegion mask, int number, string margin)
        {
            IntPtr proc = HalconAPI.PreCall(1410);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)mask);
            HalconAPI.StoreI(proc, 0, number);
            HalconAPI.StoreS(proc, 1, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)mask);
            return himage;
        }

        /// <summary>
        ///   Separated median filtering with rectangle masks.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="maskWidth">Width of rank mask. Default: 25</param>
        /// <param name="maskHeight">Height of rank mask. Default: 25</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Median filtered image.</returns>
        public HImage MedianSeparate(int maskWidth, int maskHeight, HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1411);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.Store(proc, 2, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(margin);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Separated median filtering with rectangle masks.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="maskWidth">Width of rank mask. Default: 25</param>
        /// <param name="maskHeight">Height of rank mask. Default: 25</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Median filtered image.</returns>
        public HImage MedianSeparate(int maskWidth, int maskHeight, string margin)
        {
            IntPtr proc = HalconAPI.PreCall(1411);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.StoreS(proc, 2, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute a median filter with rectangular masks.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="maskWidth">Width of the filter mask. Default: 15</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 15</param>
        /// <returns>Filtered image.</returns>
        public HImage MedianRect(int maskWidth, int maskHeight)
        {
            IntPtr proc = HalconAPI.PreCall(1412);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute a median filter with various masks.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="maskType">Filter mask type. Default: "circle"</param>
        /// <param name="radius">Radius of the filter mask. Default: 1</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Filtered image.</returns>
        public HImage MedianImage(string maskType, int radius, HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1413);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, maskType);
            HalconAPI.StoreI(proc, 1, radius);
            HalconAPI.Store(proc, 2, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(margin);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute a median filter with various masks.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="maskType">Filter mask type. Default: "circle"</param>
        /// <param name="radius">Radius of the filter mask. Default: 1</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Filtered image.</returns>
        public HImage MedianImage(string maskType, int radius, string margin)
        {
            IntPtr proc = HalconAPI.PreCall(1413);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, maskType);
            HalconAPI.StoreI(proc, 1, radius);
            HalconAPI.StoreS(proc, 2, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Weighted median filtering with different rank masks.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="maskType">Type of median mask. Default: "inner"</param>
        /// <param name="maskSize">mask size. Default: 3</param>
        /// <returns>Median filtered image.</returns>
        public HImage MedianWeighted(string maskType, int maskSize)
        {
            IntPtr proc = HalconAPI.PreCall(1414);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, maskType);
            HalconAPI.StoreI(proc, 1, maskSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute a rank filter with rectangular masks.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="maskWidth">Width of the filter mask. Default: 15</param>
        /// <param name="maskHeight">Height of the filter mask. Default: 15</param>
        /// <param name="rank">Rank of the output gray value. Default: 5</param>
        /// <returns>Filtered image.</returns>
        public HImage RankRect(int maskWidth, int maskHeight, int rank)
        {
            IntPtr proc = HalconAPI.PreCall(1415);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.StoreI(proc, 2, rank);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute a rank filter with arbitrary masks.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="mask">Filter mask.</param>
        /// <param name="rank">Rank of the output gray value. Default: 5</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Filtered image.</returns>
        public HImage RankImage(HRegion mask, int rank, HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1416);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)mask);
            HalconAPI.StoreI(proc, 0, rank);
            HalconAPI.Store(proc, 1, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(margin);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)mask);
            return himage;
        }

        /// <summary>
        ///   Compute a rank filter with arbitrary masks.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="mask">Filter mask.</param>
        /// <param name="rank">Rank of the output gray value. Default: 5</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Filtered image.</returns>
        public HImage RankImage(HRegion mask, int rank, string margin)
        {
            IntPtr proc = HalconAPI.PreCall(1416);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)mask);
            HalconAPI.StoreI(proc, 0, rank);
            HalconAPI.StoreS(proc, 1, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)mask);
            return himage;
        }

        /// <summary>
        ///   Opening, Median and Closing with circle or rectangle mask.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="maskType">Shape of the mask. Default: "circle"</param>
        /// <param name="radius">Radius of the filter mask. Default: 1</param>
        /// <param name="modePercent">Filter Mode: 0 corresponds to a gray value opening , 50 corresponds to a median and 100 to a gray values closing. Default: 10</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Filtered Image.</returns>
        public HImage DualRank(string maskType, int radius, int modePercent, HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1417);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, maskType);
            HalconAPI.StoreI(proc, 1, radius);
            HalconAPI.StoreI(proc, 2, modePercent);
            HalconAPI.Store(proc, 3, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(margin);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Opening, Median and Closing with circle or rectangle mask.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="maskType">Shape of the mask. Default: "circle"</param>
        /// <param name="radius">Radius of the filter mask. Default: 1</param>
        /// <param name="modePercent">Filter Mode: 0 corresponds to a gray value opening , 50 corresponds to a median and 100 to a gray values closing. Default: 10</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Filtered Image.</returns>
        public HImage DualRank(string maskType, int radius, int modePercent, string margin)
        {
            IntPtr proc = HalconAPI.PreCall(1417);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, maskType);
            HalconAPI.StoreI(proc, 1, radius);
            HalconAPI.StoreI(proc, 2, modePercent);
            HalconAPI.StoreS(proc, 3, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Smooth by averaging.
        ///   Instance represents: Image to be smoothed.
        /// </summary>
        /// <param name="maskWidth">Width of filter mask. Default: 9</param>
        /// <param name="maskHeight">Height of filter mask. Default: 9</param>
        /// <returns>Smoothed image.</returns>
        public HImage MeanImage(int maskWidth, int maskHeight)
        {
            IntPtr proc = HalconAPI.PreCall(1418);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Smooth an image using the binomial filter.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskWidth">Filter width. Default: 5</param>
        /// <param name="maskHeight">Filter height. Default: 5</param>
        /// <returns>Smoothed image.</returns>
        public HImage BinomialFilter(int maskWidth, int maskHeight)
        {
            IntPtr proc = HalconAPI.PreCall(1420);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Smooth an image using discrete Gaussian functions.
        ///   Instance represents: Image to be smoothed.
        /// </summary>
        /// <param name="size">Required filter size. Default: 5</param>
        /// <returns>Filtered image.</returns>
        public HImage GaussImage(int size)
        {
            IntPtr proc = HalconAPI.PreCall(1421);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, size);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Smooth using discrete gauss functions.
        ///   Instance represents: Image to be smoothed.
        /// </summary>
        /// <param name="size">Required filter size. Default: 5</param>
        /// <returns>Filtered image.</returns>
        public HImage GaussFilter(int size)
        {
            IntPtr proc = HalconAPI.PreCall(1422);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, size);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Smooth an image in the spatial domain to suppress noise.
        ///   Instance represents: Image to smooth.
        /// </summary>
        /// <param name="maskWidth">Width of filter mask. Default: 3</param>
        /// <param name="maskHeight">Height of filter mask. Default: 3</param>
        /// <param name="gap">Gap between local maximum/minimum and all other gray values of the neighborhood. Default: 1.0</param>
        /// <param name="mode">Replacement rule (1 = next minimum/maximum, 2 = average, 3 =median). Default: 3</param>
        /// <returns>Smoothed image.</returns>
        public HImage EliminateMinMax(int maskWidth, int maskHeight, double gap, int mode)
        {
            IntPtr proc = HalconAPI.PreCall(1423);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.StoreD(proc, 2, gap);
            HalconAPI.StoreI(proc, 3, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Interpolate 2 video half images.
        ///   Instance represents: Gray image consisting of two half images.
        /// </summary>
        /// <param name="mode">Instruction whether even or odd lines should be replaced/removed. Default: "odd"</param>
        /// <returns>Full image with interpolated/removed lines.</returns>
        public HImage FillInterlace(string mode)
        {
            IntPtr proc = HalconAPI.PreCall(1424);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Return gray values with given rank from multiple channels.
        ///   Instance represents: Multichannel gray image.
        /// </summary>
        /// <param name="rankIndex">Rank of the gray value images to return. Default: 2</param>
        /// <returns>Result of the rank function.</returns>
        public HImage RankN(int rankIndex)
        {
            IntPtr proc = HalconAPI.PreCall(1425);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, rankIndex);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Average gray values over several channels.
        ///   Instance represents: Multichannel gray image.
        /// </summary>
        /// <returns>Result of averaging.</returns>
        public HImage MeanN()
        {
            IntPtr proc = HalconAPI.PreCall(1426);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Replace values outside of thresholds with average value.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskWidth">Width of filter mask. Default: 3</param>
        /// <param name="maskHeight">Height of filter mask. Default: 3</param>
        /// <param name="minThresh">Minimum gray value. Default: 1</param>
        /// <param name="maxThresh">Maximum gray value. Default: 254</param>
        /// <returns>Smoothed image.</returns>
        public HImage EliminateSp(int maskWidth, int maskHeight, int minThresh, int maxThresh)
        {
            IntPtr proc = HalconAPI.PreCall(1427);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.StoreI(proc, 2, minThresh);
            HalconAPI.StoreI(proc, 3, maxThresh);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Suppress salt and pepper noise.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskWidth">Width of filter mask. Default: 3</param>
        /// <param name="maskHeight">Height of filter mask. Default: 3</param>
        /// <param name="minThresh">Minimum gray value. Default: 1</param>
        /// <param name="maxThresh">Maximum gray value. Default: 254</param>
        /// <returns>Smoothed image.</returns>
        public HImage MeanSp(int maskWidth, int maskHeight, int minThresh, int maxThresh)
        {
            IntPtr proc = HalconAPI.PreCall(1428);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.StoreI(proc, 2, minThresh);
            HalconAPI.StoreI(proc, 3, maxThresh);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Find corners using the Sojka operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskSize">Required filter size. Default: 9</param>
        /// <param name="sigmaW">Sigma of the weight function according to the distance to the corner candidate. Default: 2.5</param>
        /// <param name="sigmaD">Sigma of the weight function for the distance to the ideal gray value edge. Default: 0.75</param>
        /// <param name="minGrad">Threshold for the magnitude of the gradient. Default: 30.0</param>
        /// <param name="minApparentness">Threshold for Apparentness. Default: 90.0</param>
        /// <param name="minAngle">Threshold for the direction change in a corner point (radians). Default: 0.5</param>
        /// <param name="subpix">Subpixel precise calculation of the corner points. Default: "false"</param>
        /// <param name="row">Row coordinates of the detected corner points.</param>
        /// <param name="column">Column coordinates of the detected corner points.</param>
        public void PointsSojka(
          int maskSize,
          HTuple sigmaW,
          HTuple sigmaD,
          HTuple minGrad,
          HTuple minApparentness,
          double minAngle,
          string subpix,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1429);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskSize);
            HalconAPI.Store(proc, 1, sigmaW);
            HalconAPI.Store(proc, 2, sigmaD);
            HalconAPI.Store(proc, 3, minGrad);
            HalconAPI.Store(proc, 4, minApparentness);
            HalconAPI.StoreD(proc, 5, minAngle);
            HalconAPI.StoreS(proc, 6, subpix);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigmaW);
            HalconAPI.UnpinTuple(sigmaD);
            HalconAPI.UnpinTuple(minGrad);
            HalconAPI.UnpinTuple(minApparentness);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Find corners using the Sojka operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskSize">Required filter size. Default: 9</param>
        /// <param name="sigmaW">Sigma of the weight function according to the distance to the corner candidate. Default: 2.5</param>
        /// <param name="sigmaD">Sigma of the weight function for the distance to the ideal gray value edge. Default: 0.75</param>
        /// <param name="minGrad">Threshold for the magnitude of the gradient. Default: 30.0</param>
        /// <param name="minApparentness">Threshold for Apparentness. Default: 90.0</param>
        /// <param name="minAngle">Threshold for the direction change in a corner point (radians). Default: 0.5</param>
        /// <param name="subpix">Subpixel precise calculation of the corner points. Default: "false"</param>
        /// <param name="row">Row coordinates of the detected corner points.</param>
        /// <param name="column">Column coordinates of the detected corner points.</param>
        public void PointsSojka(
          int maskSize,
          double sigmaW,
          double sigmaD,
          double minGrad,
          double minApparentness,
          double minAngle,
          string subpix,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1429);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskSize);
            HalconAPI.StoreD(proc, 1, sigmaW);
            HalconAPI.StoreD(proc, 2, sigmaD);
            HalconAPI.StoreD(proc, 3, minGrad);
            HalconAPI.StoreD(proc, 4, minApparentness);
            HalconAPI.StoreD(proc, 5, minAngle);
            HalconAPI.StoreS(proc, 6, subpix);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Enhance circular dots in an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="diameter">Diameter of the dots to be enhanced. Default: 5</param>
        /// <param name="filterType">Enhance dark, light, or all dots. Default: "light"</param>
        /// <param name="pixelShift">Shift of the filter response. Default: 0</param>
        /// <returns>Output image.</returns>
        public HImage DotsImage(int diameter, string filterType, int pixelShift)
        {
            IntPtr proc = HalconAPI.PreCall(1430);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, diameter);
            HalconAPI.StoreS(proc, 1, filterType);
            HalconAPI.StoreI(proc, 2, pixelShift);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Subpixel precise detection of local minima in an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="filter">Method for the calculation of the partial derivatives. Default: "facet"</param>
        /// <param name="sigma">Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image.</param>
        /// <param name="threshold">Minimum absolute value of the eigenvalues of the Hessian matrix. Default: 5.0</param>
        /// <param name="row">Row coordinates of the detected minima.</param>
        /// <param name="column">Column coordinates of the detected minima.</param>
        public void LocalMinSubPix(
          string filter,
          double sigma,
          double threshold,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1431);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, sigma);
            HalconAPI.StoreD(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Subpixel precise detection of local maxima in an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="filter">Method for the calculation of the partial derivatives. Default: "facet"</param>
        /// <param name="sigma">Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image.</param>
        /// <param name="threshold">Minimum absolute value of the eigenvalues of the Hessian matrix. Default: 5.0</param>
        /// <param name="row">Row coordinates of the detected maxima.</param>
        /// <param name="column">Column coordinates of the detected maxima.</param>
        public void LocalMaxSubPix(
          string filter,
          double sigma,
          double threshold,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1432);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, sigma);
            HalconAPI.StoreD(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Subpixel precise detection of saddle points in an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="filter">Method for the calculation of the partial derivatives. Default: "facet"</param>
        /// <param name="sigma">Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image.</param>
        /// <param name="threshold">Minimum absolute value of the eigenvalues of the Hessian matrix. Default: 5.0</param>
        /// <param name="row">Row coordinates of the detected saddle points.</param>
        /// <param name="column">Column coordinates of the detected saddle points.</param>
        public void SaddlePointsSubPix(
          string filter,
          double sigma,
          double threshold,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1433);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, sigma);
            HalconAPI.StoreD(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Subpixel precise detection of critical points in an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="filter">Method for the calculation of the partial derivatives. Default: "facet"</param>
        /// <param name="sigma">Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image.</param>
        /// <param name="threshold">Minimum absolute value of the eigenvalues of the Hessian matrix. Default: 5.0</param>
        /// <param name="rowMin">Row coordinates of the detected minima.</param>
        /// <param name="columnMin">Column coordinates of the detected minima.</param>
        /// <param name="rowMax">Row coordinates of the detected maxima.</param>
        /// <param name="columnMax">Column coordinates of the detected maxima.</param>
        /// <param name="rowSaddle">Row coordinates of the detected saddle points.</param>
        /// <param name="columnSaddle">Column coordinates of the detected saddle points.</param>
        public void CriticalPointsSubPix(
          string filter,
          double sigma,
          double threshold,
          out HTuple rowMin,
          out HTuple columnMin,
          out HTuple rowMax,
          out HTuple columnMax,
          out HTuple rowSaddle,
          out HTuple columnSaddle)
        {
            IntPtr proc = HalconAPI.PreCall(1434);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, sigma);
            HalconAPI.StoreD(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowMin);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnMin);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out rowMax);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out columnMax);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out rowSaddle);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out columnSaddle);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Detect points of interest using the Harris operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigmaGrad">Amount of smoothing used for the calculation of the gradient. Default: 0.7</param>
        /// <param name="sigmaSmooth">Amount of smoothing used for the integration of the gradients. Default: 2.0</param>
        /// <param name="alpha">Weight of the squared trace of the squared gradient matrix. Default: 0.08</param>
        /// <param name="threshold">Minimum filter response for the points. Default: 1000.0</param>
        /// <param name="row">Row coordinates of the detected points.</param>
        /// <param name="column">Column coordinates of the detected points.</param>
        public void PointsHarris(
          double sigmaGrad,
          double sigmaSmooth,
          double alpha,
          HTuple threshold,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1435);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigmaGrad);
            HalconAPI.StoreD(proc, 1, sigmaSmooth);
            HalconAPI.StoreD(proc, 2, alpha);
            HalconAPI.Store(proc, 3, threshold);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(threshold);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Detect points of interest using the Harris operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigmaGrad">Amount of smoothing used for the calculation of the gradient. Default: 0.7</param>
        /// <param name="sigmaSmooth">Amount of smoothing used for the integration of the gradients. Default: 2.0</param>
        /// <param name="alpha">Weight of the squared trace of the squared gradient matrix. Default: 0.08</param>
        /// <param name="threshold">Minimum filter response for the points. Default: 1000.0</param>
        /// <param name="row">Row coordinates of the detected points.</param>
        /// <param name="column">Column coordinates of the detected points.</param>
        public void PointsHarris(
          double sigmaGrad,
          double sigmaSmooth,
          double alpha,
          double threshold,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1435);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigmaGrad);
            HalconAPI.StoreD(proc, 1, sigmaSmooth);
            HalconAPI.StoreD(proc, 2, alpha);
            HalconAPI.StoreD(proc, 3, threshold);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Detect points of interest using the binomial approximation of the Harris operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskSizeGrad">Amount of binomial smoothing used for the calculation of the gradient. Default: 5</param>
        /// <param name="maskSizeSmooth">Amount of smoothing used for the integration of the gradients. Default: 15</param>
        /// <param name="alpha">Weight of the squared trace of the squared gradient matrix. Default: 0.08</param>
        /// <param name="threshold">Minimum filter response for the points. Default: 1000.0</param>
        /// <param name="subpix">Turn on or off subpixel refinement. Default: "on"</param>
        /// <param name="row">Row coordinates of the detected points.</param>
        /// <param name="column">Column coordinates of the detected points.</param>
        public void PointsHarrisBinomial(
          int maskSizeGrad,
          int maskSizeSmooth,
          double alpha,
          HTuple threshold,
          string subpix,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1436);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskSizeGrad);
            HalconAPI.StoreI(proc, 1, maskSizeSmooth);
            HalconAPI.StoreD(proc, 2, alpha);
            HalconAPI.Store(proc, 3, threshold);
            HalconAPI.StoreS(proc, 4, subpix);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(threshold);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Detect points of interest using the binomial approximation of the Harris operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskSizeGrad">Amount of binomial smoothing used for the calculation of the gradient. Default: 5</param>
        /// <param name="maskSizeSmooth">Amount of smoothing used for the integration of the gradients. Default: 15</param>
        /// <param name="alpha">Weight of the squared trace of the squared gradient matrix. Default: 0.08</param>
        /// <param name="threshold">Minimum filter response for the points. Default: 1000.0</param>
        /// <param name="subpix">Turn on or off subpixel refinement. Default: "on"</param>
        /// <param name="row">Row coordinates of the detected points.</param>
        /// <param name="column">Column coordinates of the detected points.</param>
        public void PointsHarrisBinomial(
          int maskSizeGrad,
          int maskSizeSmooth,
          double alpha,
          double threshold,
          string subpix,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1436);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskSizeGrad);
            HalconAPI.StoreI(proc, 1, maskSizeSmooth);
            HalconAPI.StoreD(proc, 2, alpha);
            HalconAPI.StoreD(proc, 3, threshold);
            HalconAPI.StoreS(proc, 4, subpix);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Detect points of interest using the Lepetit operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="radius">Radius of the circle. Default: 3</param>
        /// <param name="checkNeighbor">Number of checked neighbors on the circle. Default: 1</param>
        /// <param name="minCheckNeighborDiff">Threshold of grayvalue difference to each circle point. Default: 15</param>
        /// <param name="minScore">Threshold of grayvalue difference to all circle points. Default: 30</param>
        /// <param name="subpix">Subpixel accuracy of point coordinates. Default: "interpolation"</param>
        /// <param name="row">Row-coordinates of the detected points.</param>
        /// <param name="column">Column-coordinates of the detected points.</param>
        public void PointsLepetit(
          int radius,
          int checkNeighbor,
          int minCheckNeighborDiff,
          int minScore,
          string subpix,
          out HTuple row,
          out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1437);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, radius);
            HalconAPI.StoreI(proc, 1, checkNeighbor);
            HalconAPI.StoreI(proc, 2, minCheckNeighborDiff);
            HalconAPI.StoreI(proc, 3, minScore);
            HalconAPI.StoreS(proc, 4, subpix);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, err1, out row);
            int procResult = HTuple.LoadNew(proc, 1, err2, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Detect points of interest using the Foerstner operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigmaGrad">Amount of smoothing used for the calculation of the gradient. If Smoothing is 'mean', SigmaGrad is ignored. Default: 1.0</param>
        /// <param name="sigmaInt">Amount of smoothing used for the integration of the gradients. Default: 2.0</param>
        /// <param name="sigmaPoints">Amount of smoothing used in the optimization functions. Default: 3.0</param>
        /// <param name="threshInhom">Threshold for the segmentation of inhomogeneous image areas. Default: 200</param>
        /// <param name="threshShape">Threshold for the segmentation of point areas. Default: 0.3</param>
        /// <param name="smoothing">Used smoothing method. Default: "gauss"</param>
        /// <param name="eliminateDoublets">Elimination of multiply detected points. Default: "false"</param>
        /// <param name="rowJunctions">Row coordinates of the detected junction points.</param>
        /// <param name="columnJunctions">Column coordinates of the detected junction points.</param>
        /// <param name="coRRJunctions">Row part of the covariance matrix of the detected junction points.</param>
        /// <param name="coRCJunctions">Mixed part of the covariance matrix of the detected junction points.</param>
        /// <param name="coCCJunctions">Column part of the covariance matrix of the detected junction points.</param>
        /// <param name="rowArea">Row coordinates of the detected area points.</param>
        /// <param name="columnArea">Column coordinates of the detected area points.</param>
        /// <param name="coRRArea">Row part of the covariance matrix of the detected area points.</param>
        /// <param name="coRCArea">Mixed part of the covariance matrix of the detected area points.</param>
        /// <param name="coCCArea">Column part of the covariance matrix of the detected area points.</param>
        public void PointsFoerstner(
          HTuple sigmaGrad,
          HTuple sigmaInt,
          HTuple sigmaPoints,
          HTuple threshInhom,
          double threshShape,
          string smoothing,
          string eliminateDoublets,
          out HTuple rowJunctions,
          out HTuple columnJunctions,
          out HTuple coRRJunctions,
          out HTuple coRCJunctions,
          out HTuple coCCJunctions,
          out HTuple rowArea,
          out HTuple columnArea,
          out HTuple coRRArea,
          out HTuple coRCArea,
          out HTuple coCCArea)
        {
            IntPtr proc = HalconAPI.PreCall(1438);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, sigmaGrad);
            HalconAPI.Store(proc, 1, sigmaInt);
            HalconAPI.Store(proc, 2, sigmaPoints);
            HalconAPI.Store(proc, 3, threshInhom);
            HalconAPI.StoreD(proc, 4, threshShape);
            HalconAPI.StoreS(proc, 5, smoothing);
            HalconAPI.StoreS(proc, 6, eliminateDoublets);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigmaGrad);
            HalconAPI.UnpinTuple(sigmaInt);
            HalconAPI.UnpinTuple(sigmaPoints);
            HalconAPI.UnpinTuple(threshInhom);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowJunctions);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnJunctions);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out coRRJunctions);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out coRCJunctions);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out coCCJunctions);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out rowArea);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out columnArea);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out coRRArea);
            int err10 = HTuple.LoadNew(proc, 8, HTupleType.DOUBLE, err9, out coRCArea);
            int procResult = HTuple.LoadNew(proc, 9, HTupleType.DOUBLE, err10, out coCCArea);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Detect points of interest using the Foerstner operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigmaGrad">Amount of smoothing used for the calculation of the gradient. If Smoothing is 'mean', SigmaGrad is ignored. Default: 1.0</param>
        /// <param name="sigmaInt">Amount of smoothing used for the integration of the gradients. Default: 2.0</param>
        /// <param name="sigmaPoints">Amount of smoothing used in the optimization functions. Default: 3.0</param>
        /// <param name="threshInhom">Threshold for the segmentation of inhomogeneous image areas. Default: 200</param>
        /// <param name="threshShape">Threshold for the segmentation of point areas. Default: 0.3</param>
        /// <param name="smoothing">Used smoothing method. Default: "gauss"</param>
        /// <param name="eliminateDoublets">Elimination of multiply detected points. Default: "false"</param>
        /// <param name="rowJunctions">Row coordinates of the detected junction points.</param>
        /// <param name="columnJunctions">Column coordinates of the detected junction points.</param>
        /// <param name="coRRJunctions">Row part of the covariance matrix of the detected junction points.</param>
        /// <param name="coRCJunctions">Mixed part of the covariance matrix of the detected junction points.</param>
        /// <param name="coCCJunctions">Column part of the covariance matrix of the detected junction points.</param>
        /// <param name="rowArea">Row coordinates of the detected area points.</param>
        /// <param name="columnArea">Column coordinates of the detected area points.</param>
        /// <param name="coRRArea">Row part of the covariance matrix of the detected area points.</param>
        /// <param name="coRCArea">Mixed part of the covariance matrix of the detected area points.</param>
        /// <param name="coCCArea">Column part of the covariance matrix of the detected area points.</param>
        public void PointsFoerstner(
          double sigmaGrad,
          double sigmaInt,
          double sigmaPoints,
          double threshInhom,
          double threshShape,
          string smoothing,
          string eliminateDoublets,
          out HTuple rowJunctions,
          out HTuple columnJunctions,
          out HTuple coRRJunctions,
          out HTuple coRCJunctions,
          out HTuple coCCJunctions,
          out HTuple rowArea,
          out HTuple columnArea,
          out HTuple coRRArea,
          out HTuple coRCArea,
          out HTuple coCCArea)
        {
            IntPtr proc = HalconAPI.PreCall(1438);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigmaGrad);
            HalconAPI.StoreD(proc, 1, sigmaInt);
            HalconAPI.StoreD(proc, 2, sigmaPoints);
            HalconAPI.StoreD(proc, 3, threshInhom);
            HalconAPI.StoreD(proc, 4, threshShape);
            HalconAPI.StoreS(proc, 5, smoothing);
            HalconAPI.StoreS(proc, 6, eliminateDoublets);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            HalconAPI.InitOCT(proc, 7);
            HalconAPI.InitOCT(proc, 8);
            HalconAPI.InitOCT(proc, 9);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out rowJunctions);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out columnJunctions);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out coRRJunctions);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out coRCJunctions);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out coCCJunctions);
            int err7 = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out rowArea);
            int err8 = HTuple.LoadNew(proc, 6, HTupleType.DOUBLE, err7, out columnArea);
            int err9 = HTuple.LoadNew(proc, 7, HTupleType.DOUBLE, err8, out coRRArea);
            int err10 = HTuple.LoadNew(proc, 8, HTupleType.DOUBLE, err9, out coRCArea);
            int procResult = HTuple.LoadNew(proc, 9, HTupleType.DOUBLE, err10, out coCCArea);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Estimate the image noise from a single image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="method">Method to estimate the image noise. Default: "foerstner"</param>
        /// <param name="percent">Percentage of used image points. Default: 20</param>
        /// <returns>Standard deviation of the image noise.</returns>
        public HTuple EstimateNoise(string method, HTuple percent)
        {
            IntPtr proc = HalconAPI.PreCall(1439);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, method);
            HalconAPI.Store(proc, 1, percent);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(percent);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Estimate the image noise from a single image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="method">Method to estimate the image noise. Default: "foerstner"</param>
        /// <param name="percent">Percentage of used image points. Default: 20</param>
        /// <returns>Standard deviation of the image noise.</returns>
        public double EstimateNoise(string method, double percent)
        {
            IntPtr proc = HalconAPI.PreCall(1439);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, method);
            HalconAPI.StoreD(proc, 1, percent);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int procResult = HalconAPI.LoadD(proc, 0, err, out doubleValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return doubleValue;
        }

        /// <summary>
        ///   Determine the noise distribution of an image.
        ///   Instance represents: Corresponding image.
        /// </summary>
        /// <param name="constRegion">Region from which the noise distribution is to be estimated.</param>
        /// <param name="filterSize">Size of the mean filter. Default: 21</param>
        /// <returns>Noise distribution of all input regions.</returns>
        public HTuple NoiseDistributionMean(HRegion constRegion, int filterSize)
        {
            IntPtr proc = HalconAPI.PreCall(1440);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)constRegion);
            HalconAPI.StoreI(proc, 0, filterSize);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)constRegion);
            return tuple;
        }

        /// <summary>
        ///   Add noise to an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="amp">Maximum noise amplitude. Default: 60.0</param>
        /// <returns>Noisy image.</returns>
        public HImage AddNoiseWhite(double amp)
        {
            IntPtr proc = HalconAPI.PreCall(1441);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, amp);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Add noise to an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="distribution">Noise distribution.</param>
        /// <returns>Noisy image.</returns>
        public HImage AddNoiseDistribution(HTuple distribution)
        {
            IntPtr proc = HalconAPI.PreCall(1442);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, distribution);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(distribution);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate standard deviation over several channels.
        ///   Instance represents: Multichannel gray image.
        /// </summary>
        /// <returns>Result of calculation.</returns>
        public HImage DeviationN()
        {
            IntPtr proc = HalconAPI.PreCall(1445);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Perform an inpainting by texture propagation.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="region">Inpainting region.</param>
        /// <param name="maskSize">Size of the inpainting blocks. Default: 9</param>
        /// <param name="searchSize">Size of the search window. Default: 30</param>
        /// <param name="anisotropy">Influence of the edge amplitude on the inpainting order. Default: 1.0</param>
        /// <param name="postIteration">Post-iteration for artifact reduction. Default: "none"</param>
        /// <param name="smoothness">Gray value tolerance for post-iteration. Default: 1.0</param>
        /// <returns>Output image.</returns>
        public HImage InpaintingTexture(
          HRegion region,
          int maskSize,
          int searchSize,
          double anisotropy,
          string postIteration,
          double smoothness)
        {
            IntPtr proc = HalconAPI.PreCall(1446);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.StoreI(proc, 0, maskSize);
            HalconAPI.StoreI(proc, 1, searchSize);
            HalconAPI.StoreD(proc, 2, anisotropy);
            HalconAPI.StoreS(proc, 3, postIteration);
            HalconAPI.StoreD(proc, 4, smoothness);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return himage;
        }

        /// <summary>
        ///   Perform an inpainting by coherence transport.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="region">Inpainting region.</param>
        /// <param name="epsilon">Radius of the pixel neighborhood. Default: 5.0</param>
        /// <param name="kappa">Sharpness parameter in percent. Default: 25.0</param>
        /// <param name="sigma">Pre-smoothing parameter. Default: 1.41</param>
        /// <param name="rho">Smoothing parameter for the direction estimation. Default: 4.0</param>
        /// <param name="channelCoefficients">Channel weights. Default: 1</param>
        /// <returns>Output image.</returns>
        public HImage InpaintingCt(
          HRegion region,
          double epsilon,
          double kappa,
          double sigma,
          double rho,
          HTuple channelCoefficients)
        {
            IntPtr proc = HalconAPI.PreCall(1447);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.StoreD(proc, 0, epsilon);
            HalconAPI.StoreD(proc, 1, kappa);
            HalconAPI.StoreD(proc, 2, sigma);
            HalconAPI.StoreD(proc, 3, rho);
            HalconAPI.Store(proc, 4, channelCoefficients);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(channelCoefficients);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return himage;
        }

        /// <summary>
        ///   Perform an inpainting by coherence transport.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="region">Inpainting region.</param>
        /// <param name="epsilon">Radius of the pixel neighborhood. Default: 5.0</param>
        /// <param name="kappa">Sharpness parameter in percent. Default: 25.0</param>
        /// <param name="sigma">Pre-smoothing parameter. Default: 1.41</param>
        /// <param name="rho">Smoothing parameter for the direction estimation. Default: 4.0</param>
        /// <param name="channelCoefficients">Channel weights. Default: 1</param>
        /// <returns>Output image.</returns>
        public HImage InpaintingCt(
          HRegion region,
          double epsilon,
          double kappa,
          double sigma,
          double rho,
          double channelCoefficients)
        {
            IntPtr proc = HalconAPI.PreCall(1447);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.StoreD(proc, 0, epsilon);
            HalconAPI.StoreD(proc, 1, kappa);
            HalconAPI.StoreD(proc, 2, sigma);
            HalconAPI.StoreD(proc, 3, rho);
            HalconAPI.StoreD(proc, 4, channelCoefficients);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return himage;
        }

        /// <summary>
        ///   Perform an inpainting by smoothing of level lines.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="region">Inpainting region.</param>
        /// <param name="sigma">Smoothing for derivative operator. Default: 0.5</param>
        /// <param name="theta">Time step. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        /// <returns>Output image.</returns>
        public HImage InpaintingMcf(HRegion region, double sigma, double theta, int iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1448);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.StoreD(proc, 1, theta);
            HalconAPI.StoreI(proc, 2, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return himage;
        }

        /// <summary>
        ///   Perform an inpainting by coherence enhancing diffusion.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="region">Inpainting region.</param>
        /// <param name="sigma">Smoothing for derivative operator. Default: 0.5</param>
        /// <param name="rho">Smoothing for diffusion coefficients. Default: 3.0</param>
        /// <param name="theta">Time step. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        /// <returns>Output image.</returns>
        public HImage InpaintingCed(
          HRegion region,
          double sigma,
          double rho,
          double theta,
          int iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1449);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.StoreD(proc, 1, rho);
            HalconAPI.StoreD(proc, 2, theta);
            HalconAPI.StoreI(proc, 3, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return himage;
        }

        /// <summary>
        ///   Perform an inpainting by anisotropic diffusion.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="region">Inpainting region.</param>
        /// <param name="mode">Type of edge sharpening algorithm. Default: "weickert"</param>
        /// <param name="contrast">Contrast parameter. Default: 5.0</param>
        /// <param name="theta">Step size. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        /// <param name="rho">Smoothing coefficient for edge information. Default: 3.0</param>
        /// <returns>Output image.</returns>
        public HImage InpaintingAniso(
          HRegion region,
          string mode,
          double contrast,
          double theta,
          int iterations,
          double rho)
        {
            IntPtr proc = HalconAPI.PreCall(1450);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.StoreD(proc, 1, contrast);
            HalconAPI.StoreD(proc, 2, theta);
            HalconAPI.StoreI(proc, 3, iterations);
            HalconAPI.StoreD(proc, 4, rho);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return himage;
        }

        /// <summary>
        ///   Perform a harmonic interpolation on an image region.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="region">Inpainting region.</param>
        /// <param name="precision">Computational accuracy. Default: 0.001</param>
        /// <returns>Output image.</returns>
        public HImage HarmonicInterpolation(HRegion region, double precision)
        {
            IntPtr proc = HalconAPI.PreCall(1451);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.StoreD(proc, 0, precision);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return himage;
        }

        /// <summary>
        ///   Expand the domain of an image and set the gray values in the expanded domain.
        ///   Instance represents: Input image with domain to be expanded.
        /// </summary>
        /// <param name="expansionRange">Radius of the gray value expansion, measured in pixels. Default: 2</param>
        /// <returns>Output image with new gray values in the expanded domain.</returns>
        public HImage ExpandDomainGray(int expansionRange)
        {
            IntPtr proc = HalconAPI.PreCall(1452);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, expansionRange);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute the topographic primal sketch of an image.
        ///   Instance represents: Image for which the topographic primal sketch is to be computed.
        /// </summary>
        /// <returns>Label image containing the 11 classes.</returns>
        public HImage TopographicSketch()
        {
            IntPtr proc = HalconAPI.PreCall(1453);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute an affine transformation of the color values of a multichannel image.
        ///   Instance represents: Multichannel input image.
        /// </summary>
        /// <param name="transMat">Transformation matrix for the color values.</param>
        /// <returns>Multichannel output image.</returns>
        public HImage LinearTransColor(HTuple transMat)
        {
            IntPtr proc = HalconAPI.PreCall(1454);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, transMat);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(transMat);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute the transformation matrix of the principal component analysis of multichannel images.
        ///   Instance represents: Multichannel input image.
        /// </summary>
        /// <param name="transInv">Transformation matrix for the computation of the inverse PCA.</param>
        /// <param name="mean">Mean gray value of the channels.</param>
        /// <param name="cov">Covariance matrix of the channels.</param>
        /// <param name="infoPerComp">Information content of the transformed channels.</param>
        /// <returns>Transformation matrix for the computation of the PCA.</returns>
        public HTuple GenPrincipalCompTrans(
          out HTuple transInv,
          out HTuple mean,
          out HTuple cov,
          out HTuple infoPerComp)
        {
            IntPtr proc = HalconAPI.PreCall(1455);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out transInv);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out mean);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out cov);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out infoPerComp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Compute the principal components of multichannel images.
        ///   Instance represents: Multichannel input image.
        /// </summary>
        /// <param name="infoPerComp">Information content of each output channel.</param>
        /// <returns>Multichannel output image.</returns>
        public HImage PrincipalComp(out HTuple infoPerComp)
        {
            IntPtr proc = HalconAPI.PreCall(1456);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err2, out infoPerComp);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Determine the fuzzy entropy of regions.
        ///   Instance represents: Input image containing the fuzzy membership values.
        /// </summary>
        /// <param name="regions">Regions for which the fuzzy entropy is to be calculated.</param>
        /// <param name="apar">Start of the fuzzy function. Default: 0</param>
        /// <param name="cpar">End of the fuzzy function. Default: 255</param>
        /// <returns>Fuzzy entropy of a region.</returns>
        public HTuple FuzzyEntropy(HRegion regions, int apar, int cpar)
        {
            IntPtr proc = HalconAPI.PreCall(1457);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreI(proc, 0, apar);
            HalconAPI.StoreI(proc, 1, cpar);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Calculate the fuzzy perimeter of a region.
        ///   Instance represents: Input image containing the fuzzy membership values.
        /// </summary>
        /// <param name="regions">Regions for which the fuzzy perimeter is to be calculated.</param>
        /// <param name="apar">Start of the fuzzy function. Default: 0</param>
        /// <param name="cpar">End of the fuzzy function. Default: 255</param>
        /// <returns>Fuzzy perimeter of a region.</returns>
        public HTuple FuzzyPerimeter(HRegion regions, int apar, int cpar)
        {
            IntPtr proc = HalconAPI.PreCall(1458);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreI(proc, 0, apar);
            HalconAPI.StoreI(proc, 1, cpar);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Perform a grayvalue closing with a selected mask.
        ///   Instance represents: Image for which the minimum gray values are to be calculated.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        /// <returns>Image containing the minimum gray values.</returns>
        public HImage GrayClosingShape(HTuple maskHeight, HTuple maskWidth, string maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1459);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.StoreS(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Perform a grayvalue closing with a selected mask.
        ///   Instance represents: Image for which the minimum gray values are to be calculated.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        /// <returns>Image containing the minimum gray values.</returns>
        public HImage GrayClosingShape(double maskHeight, double maskWidth, string maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1459);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, maskHeight);
            HalconAPI.StoreD(proc, 1, maskWidth);
            HalconAPI.StoreS(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Perform a gray value opening with a selected mask.
        ///   Instance represents: Image for which the minimum gray values are to be calculated.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        /// <returns>Image containing the minimum gray values.</returns>
        public HImage GrayOpeningShape(HTuple maskHeight, HTuple maskWidth, string maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1460);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.StoreS(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Perform a gray value opening with a selected mask.
        ///   Instance represents: Image for which the minimum gray values are to be calculated.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        /// <returns>Image containing the minimum gray values.</returns>
        public HImage GrayOpeningShape(double maskHeight, double maskWidth, string maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1460);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, maskHeight);
            HalconAPI.StoreD(proc, 1, maskWidth);
            HalconAPI.StoreS(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Determine the minimum gray value within a selected mask.
        ///   Instance represents: Image for which the minimum gray values are to be calculated.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        /// <returns>Image containing the minimum gray values.</returns>
        public HImage GrayErosionShape(HTuple maskHeight, HTuple maskWidth, string maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1461);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.StoreS(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Determine the minimum gray value within a selected mask.
        ///   Instance represents: Image for which the minimum gray values are to be calculated.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        /// <returns>Image containing the minimum gray values.</returns>
        public HImage GrayErosionShape(double maskHeight, double maskWidth, string maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1461);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, maskHeight);
            HalconAPI.StoreD(proc, 1, maskWidth);
            HalconAPI.StoreS(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Determine the maximum gray value within a selected mask.
        ///   Instance represents: Image for which the maximum gray values are to be calculated.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        /// <returns>Image containing the maximum gray values.</returns>
        public HImage GrayDilationShape(HTuple maskHeight, HTuple maskWidth, string maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1462);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, maskHeight);
            HalconAPI.Store(proc, 1, maskWidth);
            HalconAPI.StoreS(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskHeight);
            HalconAPI.UnpinTuple(maskWidth);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Determine the maximum gray value within a selected mask.
        ///   Instance represents: Image for which the maximum gray values are to be calculated.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <param name="maskShape">Shape of the mask. Default: "octagon"</param>
        /// <returns>Image containing the maximum gray values.</returns>
        public HImage GrayDilationShape(double maskHeight, double maskWidth, string maskShape)
        {
            IntPtr proc = HalconAPI.PreCall(1462);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, maskHeight);
            HalconAPI.StoreD(proc, 1, maskWidth);
            HalconAPI.StoreS(proc, 2, maskShape);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Determine the gray value range within a rectangle.
        ///   Instance represents: Image for which the gray value range is to be calculated.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <returns>Image containing the gray value range.</returns>
        public HImage GrayRangeRect(int maskHeight, int maskWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1463);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskHeight);
            HalconAPI.StoreI(proc, 1, maskWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Perform a gray value closing with a rectangular mask.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <returns>Gray-closed image.</returns>
        public HImage GrayClosingRect(int maskHeight, int maskWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1464);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskHeight);
            HalconAPI.StoreI(proc, 1, maskWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Perform a gray value opening with a rectangular mask.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <returns>Gray-opened image.</returns>
        public HImage GrayOpeningRect(int maskHeight, int maskWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1465);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskHeight);
            HalconAPI.StoreI(proc, 1, maskWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Determine the minimum gray value within a rectangle.
        ///   Instance represents: Image for which the minimum gray values are to be calculated.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <returns>Image containing the minimum gray values.</returns>
        public HImage GrayErosionRect(int maskHeight, int maskWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1466);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskHeight);
            HalconAPI.StoreI(proc, 1, maskWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Determine the maximum gray value within a rectangle.
        ///   Instance represents: Image for which the maximum gray values are to be calculated.
        /// </summary>
        /// <param name="maskHeight">Height of the filter mask. Default: 11</param>
        /// <param name="maskWidth">Width of the filter mask. Default: 11</param>
        /// <returns>Image containing the maximum gray values.</returns>
        public HImage GrayDilationRect(int maskHeight, int maskWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1467);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskHeight);
            HalconAPI.StoreI(proc, 1, maskWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Thinning of gray value images.
        ///   Instance represents: Image to be thinned.
        /// </summary>
        /// <returns>Thinned image.</returns>
        public HImage GraySkeleton()
        {
            IntPtr proc = HalconAPI.PreCall(1468);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Transform an image with a gray-value look-up-table
        ///   Instance represents: Image whose gray values are to be transformed.
        /// </summary>
        /// <param name="lut">Table containing the transformation.</param>
        /// <returns>Transformed image.</returns>
        public HImage LutTrans(HTuple lut)
        {
            IntPtr proc = HalconAPI.PreCall(1469);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, lut);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(lut);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the correlation between an image and an arbitrary filter mask
        ///   Instance represents: Images for which the correlation will be calculated.
        /// </summary>
        /// <param name="filterMask">Filter mask as file name or tuple. Default: "sobel"</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Result of the correlation.</returns>
        public HImage ConvolImage(HTuple filterMask, HTuple margin)
        {
            IntPtr proc = HalconAPI.PreCall(1470);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, filterMask);
            HalconAPI.Store(proc, 1, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filterMask);
            HalconAPI.UnpinTuple(margin);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the correlation between an image and an arbitrary filter mask
        ///   Instance represents: Images for which the correlation will be calculated.
        /// </summary>
        /// <param name="filterMask">Filter mask as file name or tuple. Default: "sobel"</param>
        /// <param name="margin">Border treatment. Default: "mirrored"</param>
        /// <returns>Result of the correlation.</returns>
        public HImage ConvolImage(string filterMask, string margin)
        {
            IntPtr proc = HalconAPI.PreCall(1470);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filterMask);
            HalconAPI.StoreS(proc, 1, margin);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convert the type of an image.
        ///   Instance represents: Image whose image type is to be changed.
        /// </summary>
        /// <param name="newType">Desired image type (i.e., type of the gray values). Default: "byte"</param>
        /// <returns>Converted image.</returns>
        public HImage ConvertImageType(string newType)
        {
            IntPtr proc = HalconAPI.PreCall(1471);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, newType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convert two real-valued images into a vector field image.
        ///   Instance represents: Vector component in the row direction.
        /// </summary>
        /// <param name="col">Vector component in the column direction.</param>
        /// <param name="type">Semantic kind of the vector field. Default: "vector_field_relative"</param>
        /// <returns>Displacement vector field.</returns>
        public HImage RealToVectorField(HImage col, string type)
        {
            IntPtr proc = HalconAPI.PreCall(1472);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)col);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)col);
            return himage;
        }

        /// <summary>
        ///   Convert a vector field image into two real-valued images.
        ///   Instance represents: Vector field.
        /// </summary>
        /// <param name="col">Vector component in the column direction.</param>
        /// <returns>Vector component in the row direction.</returns>
        public HImage VectorFieldToReal(out HImage col)
        {
            IntPtr proc = HalconAPI.PreCall(1473);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out col);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convert two real images into a complex image.
        ///   Instance represents: Real part.
        /// </summary>
        /// <param name="imageImaginary">Imaginary part.</param>
        /// <returns>Complex image.</returns>
        public HImage RealToComplex(HImage imageImaginary)
        {
            IntPtr proc = HalconAPI.PreCall(1474);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageImaginary);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageImaginary);
            return himage;
        }

        /// <summary>
        ///   Convert a complex image into two real images.
        ///   Instance represents: Complex image.
        /// </summary>
        /// <param name="imageImaginary">Imaginary part.</param>
        /// <returns>Real part.</returns>
        public HImage ComplexToReal(out HImage imageImaginary)
        {
            IntPtr proc = HalconAPI.PreCall(1475);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out imageImaginary);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Paint regions with their average gray value.
        ///   Instance represents: original gray-value image.
        /// </summary>
        /// <param name="regions">Input regions.</param>
        /// <returns>Result image with painted regions.</returns>
        public HImage RegionToMean(HRegion regions)
        {
            IntPtr proc = HalconAPI.PreCall(1476);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return himage;
        }

        /// <summary>
        ///   Calculate the lowest possible gray value on an arbitrary path to the image border for each point in the image.
        ///   Instance represents: Image being processed.
        /// </summary>
        /// <returns>Result image.</returns>
        public HImage GrayInside()
        {
            IntPtr proc = HalconAPI.PreCall(1477);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Symmetry of gray values along a row.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskSize">Extension of search area. Default: 40</param>
        /// <param name="direction">Angle of test direction. Default: 0.0</param>
        /// <param name="exponent">Exponent for weighting. Default: 0.5</param>
        /// <returns>Symmetry image.</returns>
        public HImage Symmetry(int maskSize, double direction, double exponent)
        {
            IntPtr proc = HalconAPI.PreCall(1478);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskSize);
            HalconAPI.StoreD(proc, 1, direction);
            HalconAPI.StoreD(proc, 2, exponent);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Selection of gray values of a multi-channel image using an index image.
        ///   Instance represents: Multi-channel gray value image.
        /// </summary>
        /// <param name="indexImage">Image, where pixel values are interpreted as channel index.</param>
        /// <returns>Resulting image.</returns>
        public HImage SelectGrayvaluesFromChannels(HImage indexImage)
        {
            IntPtr proc = HalconAPI.PreCall(1479);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)indexImage);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)indexImage);
            return himage;
        }

        /// <summary>
        ///   Extract depth using multiple focus levels.
        ///   Instance represents: Multichannel gray image consisting of multiple focus levels.
        /// </summary>
        /// <param name="confidence">Confidence of depth estimation.</param>
        /// <param name="filter">Filter used to find sharp pixels. Default: "highpass"</param>
        /// <param name="selection">Method used to find sharp pixels. Default: "next_maximum"</param>
        /// <returns>Depth image.</returns>
        public HImage DepthFromFocus(out HImage confidence, HTuple filter, HTuple selection)
        {
            IntPtr proc = HalconAPI.PreCall(1480);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, filter);
            HalconAPI.Store(proc, 1, selection);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filter);
            HalconAPI.UnpinTuple(selection);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out confidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Extract depth using multiple focus levels.
        ///   Instance represents: Multichannel gray image consisting of multiple focus levels.
        /// </summary>
        /// <param name="confidence">Confidence of depth estimation.</param>
        /// <param name="filter">Filter used to find sharp pixels. Default: "highpass"</param>
        /// <param name="selection">Method used to find sharp pixels. Default: "next_maximum"</param>
        /// <returns>Depth image.</returns>
        public HImage DepthFromFocus(out HImage confidence, string filter, string selection)
        {
            IntPtr proc = HalconAPI.PreCall(1480);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreS(proc, 1, selection);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out confidence);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute the uncalibrated scene flow between two stereo image pairs.
        ///   Instance represents: Input image 1 at time @f$t_{1}$t_1.
        /// </summary>
        /// <param name="imageRect2T1">Input image 2 at time @f$t_{1}$t_1.</param>
        /// <param name="imageRect1T2">Input image 1 at time @f$t_{2}$t_2.</param>
        /// <param name="imageRect2T2">Input image 2 at time @f$t_{2}$t_2.</param>
        /// <param name="disparity">Disparity between input images 1 and 2 at time @f$t_{1}$t_1.</param>
        /// <param name="disparityChange">Estimated change in disparity.</param>
        /// <param name="smoothingFlow">Weight of the regularization term relative to the data term (derivatives of the optical flow). Default: 40.0</param>
        /// <param name="smoothingDisparity">Weight of the regularization term relative to the data term (derivatives of the disparity change). Default: 40.0</param>
        /// <param name="genParamName">Parameter name(s) for the algorithm. Default: "default_parameters"</param>
        /// <param name="genParamValue">Parameter value(s) for the algorithm. Default: "accurate"</param>
        /// <returns>Estimated optical flow.</returns>
        public HImage SceneFlowUncalib(
          HImage imageRect2T1,
          HImage imageRect1T2,
          HImage imageRect2T2,
          HImage disparity,
          out HImage disparityChange,
          HTuple smoothingFlow,
          HTuple smoothingDisparity,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1482);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2T1);
            HalconAPI.Store(proc, 3, (HObjectBase)imageRect1T2);
            HalconAPI.Store(proc, 4, (HObjectBase)imageRect2T2);
            HalconAPI.Store(proc, 5, (HObjectBase)disparity);
            HalconAPI.Store(proc, 0, smoothingFlow);
            HalconAPI.Store(proc, 1, smoothingDisparity);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(smoothingFlow);
            HalconAPI.UnpinTuple(smoothingDisparity);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out disparityChange);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2T1);
            GC.KeepAlive((object)imageRect1T2);
            GC.KeepAlive((object)imageRect2T2);
            GC.KeepAlive((object)disparity);
            return himage;
        }

        /// <summary>
        ///   Compute the uncalibrated scene flow between two stereo image pairs.
        ///   Instance represents: Input image 1 at time @f$t_{1}$t_1.
        /// </summary>
        /// <param name="imageRect2T1">Input image 2 at time @f$t_{1}$t_1.</param>
        /// <param name="imageRect1T2">Input image 1 at time @f$t_{2}$t_2.</param>
        /// <param name="imageRect2T2">Input image 2 at time @f$t_{2}$t_2.</param>
        /// <param name="disparity">Disparity between input images 1 and 2 at time @f$t_{1}$t_1.</param>
        /// <param name="disparityChange">Estimated change in disparity.</param>
        /// <param name="smoothingFlow">Weight of the regularization term relative to the data term (derivatives of the optical flow). Default: 40.0</param>
        /// <param name="smoothingDisparity">Weight of the regularization term relative to the data term (derivatives of the disparity change). Default: 40.0</param>
        /// <param name="genParamName">Parameter name(s) for the algorithm. Default: "default_parameters"</param>
        /// <param name="genParamValue">Parameter value(s) for the algorithm. Default: "accurate"</param>
        /// <returns>Estimated optical flow.</returns>
        public HImage SceneFlowUncalib(
          HImage imageRect2T1,
          HImage imageRect1T2,
          HImage imageRect2T2,
          HImage disparity,
          out HImage disparityChange,
          double smoothingFlow,
          double smoothingDisparity,
          string genParamName,
          string genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1482);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageRect2T1);
            HalconAPI.Store(proc, 3, (HObjectBase)imageRect1T2);
            HalconAPI.Store(proc, 4, (HObjectBase)imageRect2T2);
            HalconAPI.Store(proc, 5, (HObjectBase)disparity);
            HalconAPI.StoreD(proc, 0, smoothingFlow);
            HalconAPI.StoreD(proc, 1, smoothingDisparity);
            HalconAPI.StoreS(proc, 2, genParamName);
            HalconAPI.StoreS(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out disparityChange);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageRect2T1);
            GC.KeepAlive((object)imageRect1T2);
            GC.KeepAlive((object)imageRect2T2);
            GC.KeepAlive((object)disparity);
            return himage;
        }

        /// <summary>
        ///   Unwarp an image using a vector field.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="vectorField">Input vector field.</param>
        /// <returns>Unwarped image.</returns>
        public HImage UnwarpImageVectorField(HImage vectorField)
        {
            IntPtr proc = HalconAPI.PreCall(1483);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)vectorField);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)vectorField);
            return himage;
        }

        /// <summary>
        ///   Convolve a vector field with derivatives of the Gaussian.
        ///   Instance represents: Input vector field.
        /// </summary>
        /// <param name="sigma">Sigma of the Gaussian. Default: 1.0</param>
        /// <param name="component">Component to be calculated. Default: "mean_curvature"</param>
        /// <returns>Filtered result images.</returns>
        public HImage DerivateVectorField(HTuple sigma, string component)
        {
            IntPtr proc = HalconAPI.PreCall(1484);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.StoreS(proc, 1, component);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convolve a vector field with derivatives of the Gaussian.
        ///   Instance represents: Input vector field.
        /// </summary>
        /// <param name="sigma">Sigma of the Gaussian. Default: 1.0</param>
        /// <param name="component">Component to be calculated. Default: "mean_curvature"</param>
        /// <returns>Filtered result images.</returns>
        public HImage DerivateVectorField(double sigma, string component)
        {
            IntPtr proc = HalconAPI.PreCall(1484);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.StoreS(proc, 1, component);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute the length of the vectors of a vector field.
        ///   Instance represents: Input vector field
        /// </summary>
        /// <param name="mode">Mode for computing the length of the vectors. Default: "length"</param>
        /// <returns>Length of the vectors of the vector field.</returns>
        public HImage VectorFieldLength(string mode)
        {
            IntPtr proc = HalconAPI.PreCall(1485);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute the optical flow between two images.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="imageT2">Input image 2.</param>
        /// <param name="algorithm">Algorithm for computing the optical flow. Default: "fdrig"</param>
        /// <param name="smoothingSigma">Standard deviation for initial Gaussian smoothing. Default: 0.8</param>
        /// <param name="integrationSigma">Standard deviation of the integration filter. Default: 1.0</param>
        /// <param name="flowSmoothness">Weight of the smoothing term relative to the data term. Default: 20.0</param>
        /// <param name="gradientConstancy">Weight of the gradient constancy relative to the gray value constancy. Default: 5.0</param>
        /// <param name="MGParamName">Parameter name(s) for the multigrid algorithm. Default: "default_parameters"</param>
        /// <param name="MGParamValue">Parameter value(s) for the multigrid algorithm. Default: "accurate"</param>
        /// <returns>Optical flow.</returns>
        public HImage OpticalFlowMg(
          HImage imageT2,
          string algorithm,
          double smoothingSigma,
          double integrationSigma,
          double flowSmoothness,
          double gradientConstancy,
          HTuple MGParamName,
          HTuple MGParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1486);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageT2);
            HalconAPI.StoreS(proc, 0, algorithm);
            HalconAPI.StoreD(proc, 1, smoothingSigma);
            HalconAPI.StoreD(proc, 2, integrationSigma);
            HalconAPI.StoreD(proc, 3, flowSmoothness);
            HalconAPI.StoreD(proc, 4, gradientConstancy);
            HalconAPI.Store(proc, 5, MGParamName);
            HalconAPI.Store(proc, 6, MGParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(MGParamName);
            HalconAPI.UnpinTuple(MGParamValue);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageT2);
            return himage;
        }

        /// <summary>
        ///   Compute the optical flow between two images.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="imageT2">Input image 2.</param>
        /// <param name="algorithm">Algorithm for computing the optical flow. Default: "fdrig"</param>
        /// <param name="smoothingSigma">Standard deviation for initial Gaussian smoothing. Default: 0.8</param>
        /// <param name="integrationSigma">Standard deviation of the integration filter. Default: 1.0</param>
        /// <param name="flowSmoothness">Weight of the smoothing term relative to the data term. Default: 20.0</param>
        /// <param name="gradientConstancy">Weight of the gradient constancy relative to the gray value constancy. Default: 5.0</param>
        /// <param name="MGParamName">Parameter name(s) for the multigrid algorithm. Default: "default_parameters"</param>
        /// <param name="MGParamValue">Parameter value(s) for the multigrid algorithm. Default: "accurate"</param>
        /// <returns>Optical flow.</returns>
        public HImage OpticalFlowMg(
          HImage imageT2,
          string algorithm,
          double smoothingSigma,
          double integrationSigma,
          double flowSmoothness,
          double gradientConstancy,
          string MGParamName,
          string MGParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(1486);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageT2);
            HalconAPI.StoreS(proc, 0, algorithm);
            HalconAPI.StoreD(proc, 1, smoothingSigma);
            HalconAPI.StoreD(proc, 2, integrationSigma);
            HalconAPI.StoreD(proc, 3, flowSmoothness);
            HalconAPI.StoreD(proc, 4, gradientConstancy);
            HalconAPI.StoreS(proc, 5, MGParamName);
            HalconAPI.StoreS(proc, 6, MGParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageT2);
            return himage;
        }

        /// <summary>
        ///   Matching a template and an image in a resolution pyramid.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="imageTemplate">The domain of this image will be matched with Image.</param>
        /// <param name="mode">Desired matching criterion. Default: "dfd"</param>
        /// <param name="level">Startlevel in the resolution pyramid (highest resolution: Level 0). Default: 1</param>
        /// <param name="threshold">Threshold to determine the "region of interest". Default: 30</param>
        /// <returns>Result image and result region: values of the matching criterion within the determined "region of interest".</returns>
        public HImage ExhaustiveMatchMg(
          HImage imageTemplate,
          string mode,
          int level,
          int threshold)
        {
            IntPtr proc = HalconAPI.PreCall(1487);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageTemplate);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.StoreI(proc, 1, level);
            HalconAPI.StoreI(proc, 2, threshold);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageTemplate);
            return himage;
        }

        /// <summary>
        ///   Preparing a pattern for template matching with rotation.
        ///   Instance represents: Input image whose domain will be processed for the pattern matching.
        /// </summary>
        /// <param name="numLevel">Maximal number of pyramid levels. Default: 4</param>
        /// <param name="angleStart">Smallest Rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtend">Maximum positive Extension of AngleStart. Default: 0.79</param>
        /// <param name="angleStep">Step rate (angle precision) of matching. Default: 0.0982</param>
        /// <param name="optimize">Kind of optimizing. Default: "sort"</param>
        /// <param name="grayValues">Kind of grayvalues. Default: "original"</param>
        /// <returns>Template number.</returns>
        public HTemplate CreateTemplateRot(
          int numLevel,
          double angleStart,
          double angleExtend,
          double angleStep,
          string optimize,
          string grayValues)
        {
            IntPtr proc = HalconAPI.PreCall(1488);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, numLevel);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtend);
            HalconAPI.StoreD(proc, 3, angleStep);
            HalconAPI.StoreS(proc, 4, optimize);
            HalconAPI.StoreS(proc, 5, grayValues);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTemplate htemplate;
            int procResult = HTemplate.LoadNew(proc, 0, err, out htemplate);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return htemplate;
        }

        /// <summary>
        ///   Preparing a pattern for template matching.
        ///   Instance represents: Input image whose domain will be processed for the pattern matching.
        /// </summary>
        /// <param name="firstError">Not yet in use. Default: 255</param>
        /// <param name="numLevel">Maximal number of pyramid levels. Default: 4</param>
        /// <param name="optimize">Kind of optimizing. Default: "sort"</param>
        /// <param name="grayValues">Kind of grayvalues. Default: "original"</param>
        /// <returns>Template number.</returns>
        public HTemplate CreateTemplate(
          int firstError,
          int numLevel,
          string optimize,
          string grayValues)
        {
            IntPtr proc = HalconAPI.PreCall(1489);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, firstError);
            HalconAPI.StoreI(proc, 1, numLevel);
            HalconAPI.StoreS(proc, 2, optimize);
            HalconAPI.StoreS(proc, 3, grayValues);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTemplate htemplate;
            int procResult = HTemplate.LoadNew(proc, 0, err, out htemplate);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return htemplate;
        }

        /// <summary>
        ///   Adapting a template to the size of an image.
        ///   Instance represents: Image which determines the size of the later matching.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        public void AdaptTemplate(HTemplate templateID)
        {
            IntPtr proc = HalconAPI.PreCall(1498);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
        }

        /// <summary>
        ///   Searching all good grayvalue matches in a pyramid.
        ///   Instance represents: Input image inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximal average difference of the grayvalues. Default: 30.0</param>
        /// <param name="numLevel">Number of levels in the pyramid. Default: 3</param>
        /// <returns>All points which have an error below a certain threshold.</returns>
        public HRegion FastMatchMg(HTemplate templateID, double maxError, HTuple numLevel)
        {
            IntPtr proc = HalconAPI.PreCall(1499);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, maxError);
            HalconAPI.Store(proc, 2, numLevel);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(numLevel);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
            return hregion;
        }

        /// <summary>
        ///   Searching all good grayvalue matches in a pyramid.
        ///   Instance represents: Input image inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximal average difference of the grayvalues. Default: 30.0</param>
        /// <param name="numLevel">Number of levels in the pyramid. Default: 3</param>
        /// <returns>All points which have an error below a certain threshold.</returns>
        public HRegion FastMatchMg(HTemplate templateID, double maxError, int numLevel)
        {
            IntPtr proc = HalconAPI.PreCall(1499);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, maxError);
            HalconAPI.StoreI(proc, 2, numLevel);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
            return hregion;
        }

        /// <summary>
        ///   Searching the best grayvalue matches in a pre generated pyramid.
        ///   Instance represents: Image pyramid inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximal average difference of the grayvalues. Default: 30.0</param>
        /// <param name="subPixel">Exactness in subpixels in case of 'true'. Default: "false"</param>
        /// <param name="numLevels">Number of the used resolution levels. Default: 3</param>
        /// <param name="whichLevels">Resolution level up to which the method "best match" is used. Default: "original"</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="error">Average divergence of the grayvalues in the best match.</param>
        public void BestMatchPreMg(
          HTemplate templateID,
          double maxError,
          string subPixel,
          int numLevels,
          HTuple whichLevels,
          out double row,
          out double column,
          out double error)
        {
            IntPtr proc = HalconAPI.PreCall(1500);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, maxError);
            HalconAPI.StoreS(proc, 2, subPixel);
            HalconAPI.StoreI(proc, 3, numLevels);
            HalconAPI.Store(proc, 4, whichLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(whichLevels);
            int err2 = HalconAPI.LoadD(proc, 0, err1, out row);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out column);
            int procResult = HalconAPI.LoadD(proc, 2, err3, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
        }

        /// <summary>
        ///   Searching the best grayvalue matches in a pre generated pyramid.
        ///   Instance represents: Image pyramid inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximal average difference of the grayvalues. Default: 30.0</param>
        /// <param name="subPixel">Exactness in subpixels in case of 'true'. Default: "false"</param>
        /// <param name="numLevels">Number of the used resolution levels. Default: 3</param>
        /// <param name="whichLevels">Resolution level up to which the method "best match" is used. Default: "original"</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="error">Average divergence of the grayvalues in the best match.</param>
        public void BestMatchPreMg(
          HTemplate templateID,
          double maxError,
          string subPixel,
          int numLevels,
          int whichLevels,
          out double row,
          out double column,
          out double error)
        {
            IntPtr proc = HalconAPI.PreCall(1500);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, maxError);
            HalconAPI.StoreS(proc, 2, subPixel);
            HalconAPI.StoreI(proc, 3, numLevels);
            HalconAPI.StoreI(proc, 4, whichLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HalconAPI.LoadD(proc, 0, err1, out row);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out column);
            int procResult = HalconAPI.LoadD(proc, 2, err3, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
        }

        /// <summary>
        ///   Searching the best grayvalue matches in a pyramid.
        ///   Instance represents: Input image inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximal average difference of the grayvalues. Default: 30.0</param>
        /// <param name="subPixel">Exactness in subpixels in case of 'true'. Default: "false"</param>
        /// <param name="numLevels">Number of the used resolution levels. Default: 4</param>
        /// <param name="whichLevels">Resolution level up to which the method "best match" is used. Default: 2</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="error">Average divergence of the grayvalues in the best match.</param>
        public void BestMatchMg(
          HTemplate templateID,
          double maxError,
          string subPixel,
          int numLevels,
          HTuple whichLevels,
          out double row,
          out double column,
          out double error)
        {
            IntPtr proc = HalconAPI.PreCall(1501);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, maxError);
            HalconAPI.StoreS(proc, 2, subPixel);
            HalconAPI.StoreI(proc, 3, numLevels);
            HalconAPI.Store(proc, 4, whichLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(whichLevels);
            int err2 = HalconAPI.LoadD(proc, 0, err1, out row);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out column);
            int procResult = HalconAPI.LoadD(proc, 2, err3, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
        }

        /// <summary>
        ///   Searching the best grayvalue matches in a pyramid.
        ///   Instance represents: Input image inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximal average difference of the grayvalues. Default: 30.0</param>
        /// <param name="subPixel">Exactness in subpixels in case of 'true'. Default: "false"</param>
        /// <param name="numLevels">Number of the used resolution levels. Default: 4</param>
        /// <param name="whichLevels">Resolution level up to which the method "best match" is used. Default: 2</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="error">Average divergence of the grayvalues in the best match.</param>
        public void BestMatchMg(
          HTemplate templateID,
          double maxError,
          string subPixel,
          int numLevels,
          int whichLevels,
          out double row,
          out double column,
          out double error)
        {
            IntPtr proc = HalconAPI.PreCall(1501);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, maxError);
            HalconAPI.StoreS(proc, 2, subPixel);
            HalconAPI.StoreI(proc, 3, numLevels);
            HalconAPI.StoreI(proc, 4, whichLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HalconAPI.LoadD(proc, 0, err1, out row);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out column);
            int procResult = HalconAPI.LoadD(proc, 2, err3, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
        }

        /// <summary>
        ///   Searching all good matches of a template and an image.
        ///   Instance represents: Input image inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximal average difference of the grayvalues. Default: 20.0</param>
        /// <returns>All points whose error lies below a certain threshold.</returns>
        public HRegion FastMatch(HTemplate templateID, double maxError)
        {
            IntPtr proc = HalconAPI.PreCall(1502);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, maxError);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
            return hregion;
        }

        /// <summary>
        ///   Searching the best matching of a template and a pyramid with rotation.
        ///   Instance represents: Input image inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="angleStart">Smallest Rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtend">Maximum positive Extension of AngleStart. Default: 0.79</param>
        /// <param name="maxError">Maximum average difference of the grayvalues. Default: 40.0</param>
        /// <param name="subPixel">Subpixel accuracy in case of 'true'. Default: "false"</param>
        /// <param name="numLevels">Number of the used resolution levels. Default: 3</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="angle">Rotation angle of pattern.</param>
        /// <param name="error">Average divergence of the grayvalues of the best match.</param>
        public void BestMatchRotMg(
          HTemplate templateID,
          double angleStart,
          double angleExtend,
          double maxError,
          string subPixel,
          int numLevels,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1503);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtend);
            HalconAPI.StoreD(proc, 3, maxError);
            HalconAPI.StoreS(proc, 4, subPixel);
            HalconAPI.StoreI(proc, 5, numLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
        }

        /// <summary>
        ///   Searching the best matching of a template and a pyramid with rotation.
        ///   Instance represents: Input image inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="angleStart">Smallest Rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtend">Maximum positive Extension of AngleStart. Default: 0.79</param>
        /// <param name="maxError">Maximum average difference of the grayvalues. Default: 40.0</param>
        /// <param name="subPixel">Subpixel accuracy in case of 'true'. Default: "false"</param>
        /// <param name="numLevels">Number of the used resolution levels. Default: 3</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="angle">Rotation angle of pattern.</param>
        /// <param name="error">Average divergence of the grayvalues of the best match.</param>
        public void BestMatchRotMg(
          HTemplate templateID,
          double angleStart,
          double angleExtend,
          double maxError,
          string subPixel,
          int numLevels,
          out double row,
          out double column,
          out double angle,
          out double error)
        {
            IntPtr proc = HalconAPI.PreCall(1503);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtend);
            HalconAPI.StoreD(proc, 3, maxError);
            HalconAPI.StoreS(proc, 4, subPixel);
            HalconAPI.StoreI(proc, 5, numLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HalconAPI.LoadD(proc, 0, err1, out row);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out column);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out angle);
            int procResult = HalconAPI.LoadD(proc, 3, err4, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
        }

        /// <summary>
        ///   Searching the best matching of a template and an image with rotation.
        ///   Instance represents: Input image inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="angleStart">Smallest Rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtend">Maximum positive Extension of AngleStart. Default: 0.79</param>
        /// <param name="maxError">Maximum average difference of the grayvalues. Default: 30.0</param>
        /// <param name="subPixel">Subpixel accuracy in case of 'true'. Default: "false"</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="angle">Rotation angle of pattern.</param>
        /// <param name="error">Average divergence of the grayvalues of the best match.</param>
        public void BestMatchRot(
          HTemplate templateID,
          double angleStart,
          double angleExtend,
          double maxError,
          string subPixel,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1504);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtend);
            HalconAPI.StoreD(proc, 3, maxError);
            HalconAPI.StoreS(proc, 4, subPixel);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
        }

        /// <summary>
        ///   Searching the best matching of a template and an image with rotation.
        ///   Instance represents: Input image inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="angleStart">Smallest Rotation of the pattern. Default: -0.39</param>
        /// <param name="angleExtend">Maximum positive Extension of AngleStart. Default: 0.79</param>
        /// <param name="maxError">Maximum average difference of the grayvalues. Default: 30.0</param>
        /// <param name="subPixel">Subpixel accuracy in case of 'true'. Default: "false"</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="angle">Rotation angle of pattern.</param>
        /// <param name="error">Average divergence of the grayvalues of the best match.</param>
        public void BestMatchRot(
          HTemplate templateID,
          double angleStart,
          double angleExtend,
          double maxError,
          string subPixel,
          out double row,
          out double column,
          out double angle,
          out double error)
        {
            IntPtr proc = HalconAPI.PreCall(1504);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtend);
            HalconAPI.StoreD(proc, 3, maxError);
            HalconAPI.StoreS(proc, 4, subPixel);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HalconAPI.LoadD(proc, 0, err1, out row);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out column);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out angle);
            int procResult = HalconAPI.LoadD(proc, 3, err4, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
        }

        /// <summary>
        ///   Searching the best matching of a template and an image.
        ///   Instance represents: Input image inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximum average difference of the grayvalues. Default: 20.0</param>
        /// <param name="subPixel">Subpixel accuracy in case of 'true'. Default: "false"</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="error">Average divergence of the grayvalues of the best match.</param>
        public void BestMatch(
          HTemplate templateID,
          double maxError,
          string subPixel,
          out HTuple row,
          out HTuple column,
          out HTuple error)
        {
            IntPtr proc = HalconAPI.PreCall(1505);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, maxError);
            HalconAPI.StoreS(proc, 2, subPixel);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
        }

        /// <summary>
        ///   Searching the best matching of a template and an image.
        ///   Instance represents: Input image inside of which the pattern has to be found.
        /// </summary>
        /// <param name="templateID">Template number.</param>
        /// <param name="maxError">Maximum average difference of the grayvalues. Default: 20.0</param>
        /// <param name="subPixel">Subpixel accuracy in case of 'true'. Default: "false"</param>
        /// <param name="row">Row position of the best match.</param>
        /// <param name="column">Column position of the best match.</param>
        /// <param name="error">Average divergence of the grayvalues of the best match.</param>
        public void BestMatch(
          HTemplate templateID,
          double maxError,
          string subPixel,
          out double row,
          out double column,
          out double error)
        {
            IntPtr proc = HalconAPI.PreCall(1505);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)templateID);
            HalconAPI.StoreD(proc, 1, maxError);
            HalconAPI.StoreS(proc, 2, subPixel);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HalconAPI.LoadD(proc, 0, err1, out row);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out column);
            int procResult = HalconAPI.LoadD(proc, 2, err3, out error);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)templateID);
        }

        /// <summary>
        ///   Matching of a template and an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="regionOfInterest">Area to be searched in the input image.</param>
        /// <param name="imageTemplate">This area  will be "matched" by Image within the RegionOfInterest.</param>
        /// <param name="mode">Desired matching criterion. Default: "dfd"</param>
        /// <returns>Result image: values of the matching criterion.</returns>
        public HImage ExhaustiveMatch(
          HRegion regionOfInterest,
          HImage imageTemplate,
          string mode)
        {
            IntPtr proc = HalconAPI.PreCall(1506);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)regionOfInterest);
            HalconAPI.Store(proc, 3, (HObjectBase)imageTemplate);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regionOfInterest);
            GC.KeepAlive((object)imageTemplate);
            return himage;
        }

        /// <summary>
        ///   Searching corners in images.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="size">Desired filtersize of the graymask. Default: 3</param>
        /// <param name="weight">Weighting. Default: 0.04</param>
        /// <returns>Result of the filtering.</returns>
        public HImage CornerResponse(int size, double weight)
        {
            IntPtr proc = HalconAPI.PreCall(1507);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, size);
            HalconAPI.StoreD(proc, 1, weight);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculating a Gauss pyramid.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="mode">Kind of filtermask. Default: "weighted"</param>
        /// <param name="scale">Factor for scaling down. Default: 0.5</param>
        /// <returns>Output images.</returns>
        public HImage GenGaussPyramid(string mode, double scale)
        {
            IntPtr proc = HalconAPI.PreCall(1508);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.StoreD(proc, 1, scale);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculating the monotony operation.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Result of the monotony operator.</returns>
        public HImage Monotony()
        {
            IntPtr proc = HalconAPI.PreCall(1509);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Edge extraction using bandpass filters.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="filterType">Filter type: currently only 'lines' is supported. Default: "lines"</param>
        /// <returns>Bandpass-filtered images.</returns>
        public HImage BandpassImage(string filterType)
        {
            IntPtr proc = HalconAPI.PreCall(1510);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filterType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect color lines and their width.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigma">Amount of Gaussian smoothing to be applied. Default: 1.5</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 3</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 8</param>
        /// <param name="extractWidth">Should the line width be extracted? Default: "true"</param>
        /// <param name="completeJunctions">Should junctions be added where they cannot be extracted? Default: "true"</param>
        /// <returns>Extracted lines.</returns>
        public HXLDCont LinesColor(
          HTuple sigma,
          HTuple low,
          HTuple high,
          string extractWidth,
          string completeJunctions)
        {
            IntPtr proc = HalconAPI.PreCall(1511);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, low);
            HalconAPI.Store(proc, 2, high);
            HalconAPI.StoreS(proc, 3, extractWidth);
            HalconAPI.StoreS(proc, 4, completeJunctions);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Detect color lines and their width.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigma">Amount of Gaussian smoothing to be applied. Default: 1.5</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 3</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 8</param>
        /// <param name="extractWidth">Should the line width be extracted? Default: "true"</param>
        /// <param name="completeJunctions">Should junctions be added where they cannot be extracted? Default: "true"</param>
        /// <returns>Extracted lines.</returns>
        public HXLDCont LinesColor(
          double sigma,
          double low,
          double high,
          string extractWidth,
          string completeJunctions)
        {
            IntPtr proc = HalconAPI.PreCall(1511);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.StoreD(proc, 1, low);
            HalconAPI.StoreD(proc, 2, high);
            HalconAPI.StoreS(proc, 3, extractWidth);
            HalconAPI.StoreS(proc, 4, completeJunctions);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Detect lines and their width.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigma">Amount of Gaussian smoothing to be applied. Default: 1.5</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 3</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 8</param>
        /// <param name="lightDark">Extract bright or dark lines. Default: "light"</param>
        /// <param name="extractWidth">Should the line width be extracted? Default: "true"</param>
        /// <param name="lineModel">Line model used to correct the line position and width. Default: "bar-shaped"</param>
        /// <param name="completeJunctions">Should junctions be added where they cannot be extracted? Default: "true"</param>
        /// <returns>Extracted lines.</returns>
        public HXLDCont LinesGauss(
          HTuple sigma,
          HTuple low,
          HTuple high,
          string lightDark,
          string extractWidth,
          string lineModel,
          string completeJunctions)
        {
            IntPtr proc = HalconAPI.PreCall(1512);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.Store(proc, 1, low);
            HalconAPI.Store(proc, 2, high);
            HalconAPI.StoreS(proc, 3, lightDark);
            HalconAPI.StoreS(proc, 4, extractWidth);
            HalconAPI.StoreS(proc, 5, lineModel);
            HalconAPI.StoreS(proc, 6, completeJunctions);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Detect lines and their width.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigma">Amount of Gaussian smoothing to be applied. Default: 1.5</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 3</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 8</param>
        /// <param name="lightDark">Extract bright or dark lines. Default: "light"</param>
        /// <param name="extractWidth">Should the line width be extracted? Default: "true"</param>
        /// <param name="lineModel">Line model used to correct the line position and width. Default: "bar-shaped"</param>
        /// <param name="completeJunctions">Should junctions be added where they cannot be extracted? Default: "true"</param>
        /// <returns>Extracted lines.</returns>
        public HXLDCont LinesGauss(
          double sigma,
          double low,
          double high,
          string lightDark,
          string extractWidth,
          string lineModel,
          string completeJunctions)
        {
            IntPtr proc = HalconAPI.PreCall(1512);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.StoreD(proc, 1, low);
            HalconAPI.StoreD(proc, 2, high);
            HalconAPI.StoreS(proc, 3, lightDark);
            HalconAPI.StoreS(proc, 4, extractWidth);
            HalconAPI.StoreS(proc, 5, lineModel);
            HalconAPI.StoreS(proc, 6, completeJunctions);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Detection of lines using the facet model.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskSize">Size of the facet model mask. Default: 5</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 3</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 8</param>
        /// <param name="lightDark">Extract bright or dark lines. Default: "light"</param>
        /// <returns>Extracted lines.</returns>
        public HXLDCont LinesFacet(int maskSize, HTuple low, HTuple high, string lightDark)
        {
            IntPtr proc = HalconAPI.PreCall(1513);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskSize);
            HalconAPI.Store(proc, 1, low);
            HalconAPI.Store(proc, 2, high);
            HalconAPI.StoreS(proc, 3, lightDark);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Detection of lines using the facet model.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="maskSize">Size of the facet model mask. Default: 5</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 3</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 8</param>
        /// <param name="lightDark">Extract bright or dark lines. Default: "light"</param>
        /// <returns>Extracted lines.</returns>
        public HXLDCont LinesFacet(int maskSize, double low, double high, string lightDark)
        {
            IntPtr proc = HalconAPI.PreCall(1513);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskSize);
            HalconAPI.StoreD(proc, 1, low);
            HalconAPI.StoreD(proc, 2, high);
            HalconAPI.StoreS(proc, 3, lightDark);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Store a filter mask in the spatial domain as a real-image.
        ///   Modified instance represents: Filter in the spatial domain.
        /// </summary>
        /// <param name="filterMask">Filter mask as file name or tuple. Default: "gauss"</param>
        /// <param name="scale">Scaling factor. Default: 1.0</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenFilterMask(HTuple filterMask, double scale, int width, int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1514);
            HalconAPI.Store(proc, 0, filterMask);
            HalconAPI.StoreD(proc, 1, scale);
            HalconAPI.StoreI(proc, 2, width);
            HalconAPI.StoreI(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(filterMask);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Store a filter mask in the spatial domain as a real-image.
        ///   Modified instance represents: Filter in the spatial domain.
        /// </summary>
        /// <param name="filterMask">Filter mask as file name or tuple. Default: "gauss"</param>
        /// <param name="scale">Scaling factor. Default: 1.0</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenFilterMask(string filterMask, double scale, int width, int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1514);
            HalconAPI.StoreS(proc, 0, filterMask);
            HalconAPI.StoreD(proc, 1, scale);
            HalconAPI.StoreI(proc, 2, width);
            HalconAPI.StoreI(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate a mean filter in the frequency domain.
        ///   Modified instance represents: Mean filter as image in the frequency domain.
        /// </summary>
        /// <param name="maskShape">Shape of the filter mask in the spatial domain. Default: "ellipse"</param>
        /// <param name="diameter1">Diameter of the mean filter in the principal direction of the filter in the spatial domain. Default: 11.0</param>
        /// <param name="diameter2">Diameter of the mean filter perpendicular to the principal direction of the filter in the spatial domain. Default: 11.0</param>
        /// <param name="phi">Principal direction of the filter in the spatial domain. Default: 0.0</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenMeanFilter(
          string maskShape,
          double diameter1,
          double diameter2,
          double phi,
          string norm,
          string mode,
          int width,
          int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1515);
            HalconAPI.StoreS(proc, 0, maskShape);
            HalconAPI.StoreD(proc, 1, diameter1);
            HalconAPI.StoreD(proc, 2, diameter2);
            HalconAPI.StoreD(proc, 3, phi);
            HalconAPI.StoreS(proc, 4, norm);
            HalconAPI.StoreS(proc, 5, mode);
            HalconAPI.StoreI(proc, 6, width);
            HalconAPI.StoreI(proc, 7, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate a Gaussian filter in the frequency domain.
        ///   Modified instance represents: Gaussian filter as image in the frequency domain.
        /// </summary>
        /// <param name="sigma1">Standard deviation of the Gaussian in the principal direction of the filter in the spatial domain. Default: 1.0</param>
        /// <param name="sigma2">Standard deviation of the Gaussian perpendicular to the principal direction of the filter in the spatial domain. Default: 1.0</param>
        /// <param name="phi">Principal direction of the filter in the spatial domain. Default: 0.0</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenGaussFilter(
          double sigma1,
          double sigma2,
          double phi,
          string norm,
          string mode,
          int width,
          int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1516);
            HalconAPI.StoreD(proc, 0, sigma1);
            HalconAPI.StoreD(proc, 1, sigma2);
            HalconAPI.StoreD(proc, 2, phi);
            HalconAPI.StoreS(proc, 3, norm);
            HalconAPI.StoreS(proc, 4, mode);
            HalconAPI.StoreI(proc, 5, width);
            HalconAPI.StoreI(proc, 6, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate a derivative filter in the frequency domain.
        ///   Modified instance represents: Derivative filter as image in the frequency domain.
        /// </summary>
        /// <param name="derivative">Derivative to be computed. Default: "x"</param>
        /// <param name="exponent">Exponent used in the reverse transform. Default: 1</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenDerivativeFilter(
          string derivative,
          int exponent,
          string norm,
          string mode,
          int width,
          int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1517);
            HalconAPI.StoreS(proc, 0, derivative);
            HalconAPI.StoreI(proc, 1, exponent);
            HalconAPI.StoreS(proc, 2, norm);
            HalconAPI.StoreS(proc, 3, mode);
            HalconAPI.StoreI(proc, 4, width);
            HalconAPI.StoreI(proc, 5, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate a bandpass filter with Gaussian or sinusoidal shape.
        ///   Modified instance represents: Bandpass filter as image in the frequency domain.
        /// </summary>
        /// <param name="frequency">Distance of the filter's maximum from the DC term. Default: 0.1</param>
        /// <param name="sigma">Bandwidth of the filter (standard deviation). Default: 0.01</param>
        /// <param name="type">Filter type. Default: "sin"</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenStdBandpass(
          double frequency,
          double sigma,
          string type,
          string norm,
          string mode,
          int width,
          int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1518);
            HalconAPI.StoreD(proc, 0, frequency);
            HalconAPI.StoreD(proc, 1, sigma);
            HalconAPI.StoreS(proc, 2, type);
            HalconAPI.StoreS(proc, 3, norm);
            HalconAPI.StoreS(proc, 4, mode);
            HalconAPI.StoreI(proc, 5, width);
            HalconAPI.StoreI(proc, 6, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate a bandpass filter with sinusoidal shape.
        ///   Modified instance represents: Bandpass filter as image in the frequency domain.
        /// </summary>
        /// <param name="frequency">Distance of the filter's maximum from the DC term. Default: 0.1</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenSinBandpass(double frequency, string norm, string mode, int width, int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1519);
            HalconAPI.StoreD(proc, 0, frequency);
            HalconAPI.StoreS(proc, 1, norm);
            HalconAPI.StoreS(proc, 2, mode);
            HalconAPI.StoreI(proc, 3, width);
            HalconAPI.StoreI(proc, 4, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate an ideal band filter.
        ///   Modified instance represents: Band filter in the frequency domain.
        /// </summary>
        /// <param name="minFrequency">Minimum frequency. Default: 0.1</param>
        /// <param name="maxFrequency">Maximum frequency. Default: 0.2</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenBandfilter(
          double minFrequency,
          double maxFrequency,
          string norm,
          string mode,
          int width,
          int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1520);
            HalconAPI.StoreD(proc, 0, minFrequency);
            HalconAPI.StoreD(proc, 1, maxFrequency);
            HalconAPI.StoreS(proc, 2, norm);
            HalconAPI.StoreS(proc, 3, mode);
            HalconAPI.StoreI(proc, 4, width);
            HalconAPI.StoreI(proc, 5, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate an ideal bandpass filter.
        ///   Modified instance represents: Bandpass filter in the frequency domain.
        /// </summary>
        /// <param name="minFrequency">Minimum frequency. Default: 0.1</param>
        /// <param name="maxFrequency">Maximum frequency. Default: 0.2</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenBandpass(
          double minFrequency,
          double maxFrequency,
          string norm,
          string mode,
          int width,
          int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1521);
            HalconAPI.StoreD(proc, 0, minFrequency);
            HalconAPI.StoreD(proc, 1, maxFrequency);
            HalconAPI.StoreS(proc, 2, norm);
            HalconAPI.StoreS(proc, 3, mode);
            HalconAPI.StoreI(proc, 4, width);
            HalconAPI.StoreI(proc, 5, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate an ideal lowpass filter.
        ///   Modified instance represents: Lowpass filter in the frequency domain.
        /// </summary>
        /// <param name="frequency">Cutoff frequency. Default: 0.1</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenLowpass(double frequency, string norm, string mode, int width, int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1522);
            HalconAPI.StoreD(proc, 0, frequency);
            HalconAPI.StoreS(proc, 1, norm);
            HalconAPI.StoreS(proc, 2, mode);
            HalconAPI.StoreI(proc, 3, width);
            HalconAPI.StoreI(proc, 4, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate an ideal highpass filter.
        ///   Modified instance represents: Highpass filter in the frequency domain.
        /// </summary>
        /// <param name="frequency">Cutoff frequency. Default: 0.1</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenHighpass(double frequency, string norm, string mode, int width, int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1523);
            HalconAPI.StoreD(proc, 0, frequency);
            HalconAPI.StoreS(proc, 1, norm);
            HalconAPI.StoreS(proc, 2, mode);
            HalconAPI.StoreI(proc, 3, width);
            HalconAPI.StoreI(proc, 4, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Return the power spectrum of a complex image.
        ///   Instance represents: Input image in frequency domain.
        /// </summary>
        /// <returns>Power spectrum of the input image.</returns>
        public HImage PowerLn()
        {
            IntPtr proc = HalconAPI.PreCall(1524);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Return the power spectrum of a complex image.
        ///   Instance represents: Input image in frequency domain.
        /// </summary>
        /// <returns>Power spectrum of the input image.</returns>
        public HImage PowerReal()
        {
            IntPtr proc = HalconAPI.PreCall(1525);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Return the power spectrum of a complex image.
        ///   Instance represents: Input image in frequency domain.
        /// </summary>
        /// <returns>Power spectrum of the input image.</returns>
        public HImage PowerByte()
        {
            IntPtr proc = HalconAPI.PreCall(1526);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Return the phase of a complex image in degrees.
        ///   Instance represents: Input image in frequency domain.
        /// </summary>
        /// <returns>Phase of the image in degrees.</returns>
        public HImage PhaseDeg()
        {
            IntPtr proc = HalconAPI.PreCall(1527);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Return the phase of a complex image in radians.
        ///   Instance represents: Input image in frequency domain.
        /// </summary>
        /// <returns>Phase of the image in radians.</returns>
        public HImage PhaseRad()
        {
            IntPtr proc = HalconAPI.PreCall(1528);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the energy of a two-channel image.
        ///   Instance represents: 1st channel of input image (usually: Gabor image).
        /// </summary>
        /// <param name="imageHilbert">2nd channel of input image (usually: Hilbert image).</param>
        /// <returns>Image containing the local energy.</returns>
        public HImage EnergyGabor(HImage imageHilbert)
        {
            IntPtr proc = HalconAPI.PreCall(1529);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageHilbert);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageHilbert);
            return himage;
        }

        /// <summary>
        ///   Convolve an image with a Gabor filter in the frequency domain.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="gaborFilter">Gabor/Hilbert-Filter.</param>
        /// <param name="imageResultHilbert">Result of the Hilbert filter.</param>
        /// <returns>Result of the Gabor filter.</returns>
        public HImage ConvolGabor(HImage gaborFilter, out HImage imageResultHilbert)
        {
            IntPtr proc = HalconAPI.PreCall(1530);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)gaborFilter);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out imageResultHilbert);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)gaborFilter);
            return himage;
        }

        /// <summary>
        ///   Generate a Gabor filter.
        ///   Modified instance represents: Gabor and Hilbert filter.
        /// </summary>
        /// <param name="angle">Angle range, inversely proportional to the range of orientations. Default: 1.4</param>
        /// <param name="frequency">Distance of the center of the filter to the DC term. Default: 0.4</param>
        /// <param name="bandwidth">Bandwidth range, inversely proportional to the range of frequencies being passed. Default: 1.0</param>
        /// <param name="orientation">Angle of the principal orientation. Default: 1.5</param>
        /// <param name="norm">Normalizing factor of the filter. Default: "none"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="width">Width of the image (filter). Default: 512</param>
        /// <param name="height">Height of the image (filter). Default: 512</param>
        public void GenGabor(
          double angle,
          double frequency,
          double bandwidth,
          double orientation,
          string norm,
          string mode,
          int width,
          int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1531);
            HalconAPI.StoreD(proc, 0, angle);
            HalconAPI.StoreD(proc, 1, frequency);
            HalconAPI.StoreD(proc, 2, bandwidth);
            HalconAPI.StoreD(proc, 3, orientation);
            HalconAPI.StoreS(proc, 4, norm);
            HalconAPI.StoreS(proc, 5, mode);
            HalconAPI.StoreI(proc, 6, width);
            HalconAPI.StoreI(proc, 7, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Compute the phase correlation of two images in the frequency domain.
        ///   Instance represents: Fourier-transformed input image 1.
        /// </summary>
        /// <param name="imageFFT2">Fourier-transformed input image 2.</param>
        /// <returns>Phase correlation of the input images in the frequency domain.</returns>
        public HImage PhaseCorrelationFft(HImage imageFFT2)
        {
            IntPtr proc = HalconAPI.PreCall(1532);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageFFT2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageFFT2);
            return himage;
        }

        /// <summary>
        ///   Compute the correlation of two images in the frequency domain.
        ///   Instance represents: Fourier-transformed input image 1.
        /// </summary>
        /// <param name="imageFFT2">Fourier-transformed input image 2.</param>
        /// <returns>Correlation of the input images in the frequency domain.</returns>
        public HImage CorrelationFft(HImage imageFFT2)
        {
            IntPtr proc = HalconAPI.PreCall(1533);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageFFT2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageFFT2);
            return himage;
        }

        /// <summary>
        ///   Convolve an image with a filter in the frequency domain.
        ///   Instance represents: Complex input image.
        /// </summary>
        /// <param name="imageFilter">Filter in frequency domain.</param>
        /// <returns>Result of applying the filter.</returns>
        public HImage ConvolFft(HImage imageFilter)
        {
            IntPtr proc = HalconAPI.PreCall(1534);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageFilter);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageFilter);
            return himage;
        }

        /// <summary>
        ///   Compute the real-valued fast Fourier transform of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="direction">Calculate forward or reverse transform. Default: "to_freq"</param>
        /// <param name="norm">Normalizing factor of the transform. Default: "sqrt"</param>
        /// <param name="resultType">Image type of the output image. Default: "complex"</param>
        /// <param name="width">Width of the image for which the runtime should be optimized. Default: 512</param>
        /// <returns>Fourier-transformed image.</returns>
        public HImage RftGeneric(string direction, string norm, string resultType, int width)
        {
            IntPtr proc = HalconAPI.PreCall(1541);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, direction);
            HalconAPI.StoreS(proc, 1, norm);
            HalconAPI.StoreS(proc, 2, resultType);
            HalconAPI.StoreI(proc, 3, width);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute the inverse fast Fourier transform of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Inverse-Fourier-transformed image.</returns>
        public HImage FftImageInv()
        {
            IntPtr proc = HalconAPI.PreCall(1542);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute the fast Fourier transform of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Fourier-transformed image.</returns>
        public HImage FftImage()
        {
            IntPtr proc = HalconAPI.PreCall(1543);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Compute the fast Fourier transform of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="direction">Calculate forward or reverse transform. Default: "to_freq"</param>
        /// <param name="exponent">Sign of the exponent. Default: -1</param>
        /// <param name="norm">Normalizing factor of the transform. Default: "sqrt"</param>
        /// <param name="mode">Location of the DC term in the frequency domain. Default: "dc_center"</param>
        /// <param name="resultType">Image type of the output image. Default: "complex"</param>
        /// <returns>Fourier-transformed image.</returns>
        public HImage FftGeneric(
          string direction,
          int exponent,
          string norm,
          string mode,
          string resultType)
        {
            IntPtr proc = HalconAPI.PreCall(1544);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, direction);
            HalconAPI.StoreI(proc, 1, exponent);
            HalconAPI.StoreS(proc, 2, norm);
            HalconAPI.StoreS(proc, 3, mode);
            HalconAPI.StoreS(proc, 4, resultType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Apply a shock filter to an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="theta">Time step. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        /// <param name="mode">Type of edge detector. Default: "canny"</param>
        /// <param name="sigma">Smoothing of edge detector. Default: 1.0</param>
        /// <returns>Output image.</returns>
        public HImage ShockFilter(double theta, int iterations, string mode, double sigma)
        {
            IntPtr proc = HalconAPI.PreCall(1545);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, theta);
            HalconAPI.StoreI(proc, 1, iterations);
            HalconAPI.StoreS(proc, 2, mode);
            HalconAPI.StoreD(proc, 3, sigma);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Apply the mean curvature flow to an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigma">Smoothing parameter for derivative operator. Default: 0.5</param>
        /// <param name="theta">Time step. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        /// <returns>Output image.</returns>
        public HImage MeanCurvatureFlow(double sigma, double theta, int iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1546);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.StoreD(proc, 1, theta);
            HalconAPI.StoreI(proc, 2, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Perform a coherence enhancing diffusion of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigma">Smoothing for derivative operator. Default: 0.5</param>
        /// <param name="rho">Smoothing for diffusion coefficients. Default: 3.0</param>
        /// <param name="theta">Time step. Default: 0.5</param>
        /// <param name="iterations">Number of iterations. Default: 10</param>
        /// <returns>Output image.</returns>
        public HImage CoherenceEnhancingDiff(
          double sigma,
          double rho,
          double theta,
          int iterations)
        {
            IntPtr proc = HalconAPI.PreCall(1547);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.StoreD(proc, 1, rho);
            HalconAPI.StoreD(proc, 2, theta);
            HalconAPI.StoreI(proc, 3, iterations);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Histogram linearization of images
        ///   Instance represents: Image to be enhanced.
        /// </summary>
        /// <returns>Image with linearized gray values.</returns>
        public HImage EquHistoImage()
        {
            IntPtr proc = HalconAPI.PreCall(1548);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Illuminate image.
        ///   Instance represents: Image to be enhanced.
        /// </summary>
        /// <param name="maskWidth">Width of low pass mask. Default: 101</param>
        /// <param name="maskHeight">Height of low pass mask. Default: 101</param>
        /// <param name="factor">Scales the "`correction gray value"' added to the original gray values. Default: 0.7</param>
        /// <returns>"`Illuminated"' image.</returns>
        public HImage Illuminate(int maskWidth, int maskHeight, double factor)
        {
            IntPtr proc = HalconAPI.PreCall(1549);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.StoreD(proc, 2, factor);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Enhance contrast of the image.
        ///   Instance represents: Image to be enhanced.
        /// </summary>
        /// <param name="maskWidth">Width of low pass mask. Default: 7</param>
        /// <param name="maskHeight">Height of the low pass mask. Default: 7</param>
        /// <param name="factor">Intensity of contrast emphasis. Default: 1.0</param>
        /// <returns>contrast enhanced image.</returns>
        public HImage Emphasize(int maskWidth, int maskHeight, double factor)
        {
            IntPtr proc = HalconAPI.PreCall(1550);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, maskWidth);
            HalconAPI.StoreI(proc, 1, maskHeight);
            HalconAPI.StoreD(proc, 2, factor);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Maximum gray value spreading in the value range 0 to 255.
        ///   Instance represents: Image to be scaled.
        /// </summary>
        /// <returns>contrast enhanced image.</returns>
        public HImage ScaleImageMax()
        {
            IntPtr proc = HalconAPI.PreCall(1551);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude and direction) using the Robinson operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="imageEdgeDir">Edge direction image.</param>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage RobinsonDir(out HImage imageEdgeDir)
        {
            IntPtr proc = HalconAPI.PreCall(1552);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out imageEdgeDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude) using the Robinson operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage RobinsonAmp()
        {
            IntPtr proc = HalconAPI.PreCall(1553);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude and direction) using the Kirsch operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="imageEdgeDir">Edge direction image.</param>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage KirschDir(out HImage imageEdgeDir)
        {
            IntPtr proc = HalconAPI.PreCall(1554);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out imageEdgeDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude) using the Kirsch operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage KirschAmp()
        {
            IntPtr proc = HalconAPI.PreCall(1555);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude and direction) using the Frei-Chen operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="imageEdgeDir">Edge direction image.</param>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage FreiDir(out HImage imageEdgeDir)
        {
            IntPtr proc = HalconAPI.PreCall(1556);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out imageEdgeDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude) using the Frei-Chen operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage FreiAmp()
        {
            IntPtr proc = HalconAPI.PreCall(1557);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude and direction) using the Prewitt operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="imageEdgeDir">Edge direction image.</param>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage PrewittDir(out HImage imageEdgeDir)
        {
            IntPtr proc = HalconAPI.PreCall(1558);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out imageEdgeDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude) using the Prewitt operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage PrewittAmp()
        {
            IntPtr proc = HalconAPI.PreCall(1559);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude) using the Sobel operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="filterType">Filter type. Default: "sum_abs"</param>
        /// <param name="size">Size of filter mask. Default: 3</param>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage SobelAmp(string filterType, HTuple size)
        {
            IntPtr proc = HalconAPI.PreCall(1560);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filterType);
            HalconAPI.Store(proc, 1, size);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(size);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude) using the Sobel operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="filterType">Filter type. Default: "sum_abs"</param>
        /// <param name="size">Size of filter mask. Default: 3</param>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage SobelAmp(string filterType, int size)
        {
            IntPtr proc = HalconAPI.PreCall(1560);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filterType);
            HalconAPI.StoreI(proc, 1, size);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude and direction) using the Sobel operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="edgeDirection">Edge direction image.</param>
        /// <param name="filterType">Filter type. Default: "sum_abs"</param>
        /// <param name="size">Size of filter mask. Default: 3</param>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage SobelDir(out HImage edgeDirection, string filterType, HTuple size)
        {
            IntPtr proc = HalconAPI.PreCall(1561);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filterType);
            HalconAPI.Store(proc, 1, size);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(size);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out edgeDirection);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges (amplitude and direction) using the Sobel operator.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="edgeDirection">Edge direction image.</param>
        /// <param name="filterType">Filter type. Default: "sum_abs"</param>
        /// <param name="size">Size of filter mask. Default: 3</param>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage SobelDir(out HImage edgeDirection, string filterType, int size)
        {
            IntPtr proc = HalconAPI.PreCall(1561);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filterType);
            HalconAPI.StoreI(proc, 1, size);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out edgeDirection);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect edges using the Roberts filter.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="filterType">Filter type. Default: "gradient_sum"</param>
        /// <returns>Roberts-filtered result images.</returns>
        public HImage Roberts(string filterType)
        {
            IntPtr proc = HalconAPI.PreCall(1562);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filterType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the Laplace operator by using finite differences.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="resultType">Type of the result image, whereas for byte and uint2 the absolute value is used. Default: "absolute"</param>
        /// <param name="maskSize">Size of filter mask. Default: 3</param>
        /// <param name="filterMask">Filter mask used in the Laplace operator Default: "n_4"</param>
        /// <returns>Laplace-filtered result image.</returns>
        public HImage Laplace(string resultType, HTuple maskSize, string filterMask)
        {
            IntPtr proc = HalconAPI.PreCall(1563);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, resultType);
            HalconAPI.Store(proc, 1, maskSize);
            HalconAPI.StoreS(proc, 2, filterMask);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maskSize);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the Laplace operator by using finite differences.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="resultType">Type of the result image, whereas for byte and uint2 the absolute value is used. Default: "absolute"</param>
        /// <param name="maskSize">Size of filter mask. Default: 3</param>
        /// <param name="filterMask">Filter mask used in the Laplace operator Default: "n_4"</param>
        /// <returns>Laplace-filtered result image.</returns>
        public HImage Laplace(string resultType, int maskSize, string filterMask)
        {
            IntPtr proc = HalconAPI.PreCall(1563);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, resultType);
            HalconAPI.StoreI(proc, 1, maskSize);
            HalconAPI.StoreS(proc, 2, filterMask);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Extract high frequency components from an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="width">Width of the filter mask. Default: 9</param>
        /// <param name="height">Height of the filter mask. Default: 9</param>
        /// <returns>High-pass-filtered result image.</returns>
        public HImage HighpassImage(int width, int height)
        {
            IntPtr proc = HalconAPI.PreCall(1564);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, width);
            HalconAPI.StoreI(proc, 1, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Extract subpixel precise color edges using Deriche, Shen, or Canny filters.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="filter">Edge operator to be applied. Default: "canny"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 1.0</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 20</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 40</param>
        /// <returns>Extracted edges.</returns>
        public HXLDCont EdgesColorSubPix(string filter, double alpha, HTuple low, HTuple high)
        {
            IntPtr proc = HalconAPI.PreCall(1566);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, alpha);
            HalconAPI.Store(proc, 2, low);
            HalconAPI.Store(proc, 3, high);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Extract subpixel precise color edges using Deriche, Shen, or Canny filters.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="filter">Edge operator to be applied. Default: "canny"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 1.0</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 20</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 40</param>
        /// <returns>Extracted edges.</returns>
        public HXLDCont EdgesColorSubPix(string filter, double alpha, double low, double high)
        {
            IntPtr proc = HalconAPI.PreCall(1566);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, alpha);
            HalconAPI.StoreD(proc, 2, low);
            HalconAPI.StoreD(proc, 3, high);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Extract color edges using Canny, Deriche, or Shen filters.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="imaDir">Edge direction image.</param>
        /// <param name="filter">Edge operator to be applied. Default: "canny"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 1.0</param>
        /// <param name="NMS">Non-maximum suppression ('none', if not desired). Default: "nms"</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation (negative if no thresholding is desired). Default: 20</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation (negative if no thresholding is desired). Default: 40</param>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage EdgesColor(
          out HImage imaDir,
          string filter,
          double alpha,
          string NMS,
          int low,
          int high)
        {
            IntPtr proc = HalconAPI.PreCall(1567);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, alpha);
            HalconAPI.StoreS(proc, 2, NMS);
            HalconAPI.StoreI(proc, 3, low);
            HalconAPI.StoreI(proc, 4, high);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out imaDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Extract sub-pixel precise edges using Deriche, Lanser, Shen, or Canny filters.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="filter">Edge operator to be applied. Default: "canny"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 1.0</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 20</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 40</param>
        /// <returns>Extracted edges.</returns>
        public HXLDCont EdgesSubPix(string filter, double alpha, HTuple low, HTuple high)
        {
            IntPtr proc = HalconAPI.PreCall(1568);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, alpha);
            HalconAPI.Store(proc, 2, low);
            HalconAPI.Store(proc, 3, high);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Extract sub-pixel precise edges using Deriche, Lanser, Shen, or Canny filters.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="filter">Edge operator to be applied. Default: "canny"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 1.0</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation. Default: 20</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation. Default: 40</param>
        /// <returns>Extracted edges.</returns>
        public HXLDCont EdgesSubPix(string filter, double alpha, int low, int high)
        {
            IntPtr proc = HalconAPI.PreCall(1568);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, alpha);
            HalconAPI.StoreI(proc, 2, low);
            HalconAPI.StoreI(proc, 3, high);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HXLDCont hxldCont;
            int procResult = HXLDCont.LoadNew(proc, 1, err, out hxldCont);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hxldCont;
        }

        /// <summary>
        ///   Extract edges using Deriche, Lanser, Shen, or Canny filters.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="imaDir">Edge direction image.</param>
        /// <param name="filter">Edge operator to be applied. Default: "canny"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 1.0</param>
        /// <param name="NMS">Non-maximum suppression ('none', if not desired). Default: "nms"</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation (negative, if no thresholding is desired). Default: 20</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation (negative, if no thresholding is desired). Default: 40</param>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage EdgesImage(
          out HImage imaDir,
          string filter,
          double alpha,
          string NMS,
          HTuple low,
          HTuple high)
        {
            IntPtr proc = HalconAPI.PreCall(1569);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, alpha);
            HalconAPI.StoreS(proc, 2, NMS);
            HalconAPI.Store(proc, 3, low);
            HalconAPI.Store(proc, 4, high);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(low);
            HalconAPI.UnpinTuple(high);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out imaDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Extract edges using Deriche, Lanser, Shen, or Canny filters.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="imaDir">Edge direction image.</param>
        /// <param name="filter">Edge operator to be applied. Default: "canny"</param>
        /// <param name="alpha">Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny'). Default: 1.0</param>
        /// <param name="NMS">Non-maximum suppression ('none', if not desired). Default: "nms"</param>
        /// <param name="low">Lower threshold for the hysteresis threshold operation (negative, if no thresholding is desired). Default: 20</param>
        /// <param name="high">Upper threshold for the hysteresis threshold operation (negative, if no thresholding is desired). Default: 40</param>
        /// <returns>Edge amplitude (gradient magnitude) image.</returns>
        public HImage EdgesImage(
          out HImage imaDir,
          string filter,
          double alpha,
          string NMS,
          int low,
          int high)
        {
            IntPtr proc = HalconAPI.PreCall(1569);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, filter);
            HalconAPI.StoreD(proc, 1, alpha);
            HalconAPI.StoreS(proc, 2, NMS);
            HalconAPI.StoreI(proc, 3, low);
            HalconAPI.StoreI(proc, 4, high);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HImage.LoadNew(proc, 2, err2, out imaDir);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convolve an image with derivatives of the Gaussian.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="sigma">Sigma of the Gaussian. Default: 1.0</param>
        /// <param name="component">Derivative or feature to be calculated. Default: "x"</param>
        /// <returns>Filtered result images.</returns>
        public HImage DerivateGauss(HTuple sigma, string component)
        {
            IntPtr proc = HalconAPI.PreCall(1570);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.StoreS(proc, 1, component);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convolve an image with derivatives of the Gaussian.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="sigma">Sigma of the Gaussian. Default: 1.0</param>
        /// <param name="component">Derivative or feature to be calculated. Default: "x"</param>
        /// <returns>Filtered result images.</returns>
        public HImage DerivateGauss(double sigma, string component)
        {
            IntPtr proc = HalconAPI.PreCall(1570);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.StoreS(proc, 1, component);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   LoG-Operator (Laplace of Gaussian).
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigma">Smoothing parameter of the Gaussian. Default: 2.0</param>
        /// <returns>Laplace filtered image.</returns>
        public HImage LaplaceOfGauss(HTuple sigma)
        {
            IntPtr proc = HalconAPI.PreCall(1571);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, sigma);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sigma);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   LoG-Operator (Laplace of Gaussian).
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sigma">Smoothing parameter of the Gaussian. Default: 2.0</param>
        /// <returns>Laplace filtered image.</returns>
        public HImage LaplaceOfGauss(double sigma)
        {
            IntPtr proc = HalconAPI.PreCall(1571);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Approximate the LoG operator (Laplace of Gaussian).
        ///   Instance represents: Input image
        /// </summary>
        /// <param name="sigma">Smoothing parameter of the Laplace operator to approximate. Default: 3.0</param>
        /// <param name="sigFactor">Ratio of the standard deviations used (Marr recommends 1.6). Default: 1.6</param>
        /// <returns>LoG image.</returns>
        public HImage DiffOfGauss(double sigma, double sigFactor)
        {
            IntPtr proc = HalconAPI.PreCall(1572);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, sigma);
            HalconAPI.StoreD(proc, 1, sigFactor);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Detect straight edge segments.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="sobelSize">Mask size of the Sobel operator. Default: 5</param>
        /// <param name="minAmplitude">Minimum edge strength. Default: 32</param>
        /// <param name="maxDistance">Maximum distance of the approximating line to its original edge. Default: 3</param>
        /// <param name="minLength">Minimum length of to resulting line segments. Default: 10</param>
        /// <param name="beginRow">Row coordinate of the line segments' start points.</param>
        /// <param name="beginCol">Column coordinate of the line segments' start points.</param>
        /// <param name="endRow">Row coordinate of the line segments' end points.</param>
        /// <param name="endCol">Column coordinate of the line segments' end points.</param>
        public void DetectEdgeSegments(
          int sobelSize,
          int minAmplitude,
          int maxDistance,
          int minLength,
          out HTuple beginRow,
          out HTuple beginCol,
          out HTuple endRow,
          out HTuple endCol)
        {
            IntPtr proc = HalconAPI.PreCall(1575);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, sobelSize);
            HalconAPI.StoreI(proc, 1, minAmplitude);
            HalconAPI.StoreI(proc, 2, maxDistance);
            HalconAPI.StoreI(proc, 3, minLength);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out beginRow);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.INTEGER, err2, out beginCol);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.INTEGER, err3, out endRow);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.INTEGER, err4, out endCol);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>Release the look-up-table needed for color space transformation.</summary>
        /// <param name="colorTransLUTHandle">Handle of the look-up-table handle for the color space transformation.</param>
        public static void ClearColorTransLut(HColorTransLUT colorTransLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1577);
            HalconAPI.Store(proc, 0, (HTool)colorTransLUTHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)colorTransLUTHandle);
        }

        /// <summary>
        ///   Color space transformation using pre-generated look-up-table.
        ///   Instance represents: Input image (channel 2).
        /// </summary>
        /// <param name="image2">Input image (channel 2).</param>
        /// <param name="image3">Input image (channel 3).</param>
        /// <param name="imageResult2">Color-transformed output image (channel 2).</param>
        /// <param name="imageResult3">Color-transformed output image (channel 3).</param>
        /// <param name="colorTransLUTHandle">Handle of the look-up-table for the color space transformation.</param>
        /// <returns>Color-transformed output image (channel 1).</returns>
        public HImage ApplyColorTransLut(
          HImage image2,
          HImage image3,
          out HImage imageResult2,
          out HImage imageResult3,
          HColorTransLUT colorTransLUTHandle)
        {
            IntPtr proc = HalconAPI.PreCall(1578);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 3, (HObjectBase)image3);
            HalconAPI.Store(proc, 0, (HTool)colorTransLUTHandle);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out imageResult2);
            int procResult = HImage.LoadNew(proc, 3, err3, out imageResult3);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            GC.KeepAlive((object)image3);
            GC.KeepAlive((object)colorTransLUTHandle);
            return himage;
        }

        /// <summary>Creates the look-up-table for transformation of an image from the RGB color space to an arbitrary color space.</summary>
        /// <param name="colorSpace">Color space of the output image. Default: "hsv"</param>
        /// <param name="transDirection">Direction of color space transformation. Default: "from_rgb"</param>
        /// <param name="numBits">Number of bits of the input image. Default: 8</param>
        /// <returns>Handle of the look-up-table for color space transformation.</returns>
        public static HColorTransLUT CreateColorTransLut(
          string colorSpace,
          string transDirection,
          int numBits)
        {
            IntPtr proc = HalconAPI.PreCall(1579);
            HalconAPI.StoreS(proc, 0, colorSpace);
            HalconAPI.StoreS(proc, 1, transDirection);
            HalconAPI.StoreI(proc, 2, numBits);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HColorTransLUT hcolorTransLut;
            int procResult = HColorTransLUT.LoadNew(proc, 0, err, out hcolorTransLut);
            HalconAPI.PostCall(proc, procResult);
            return hcolorTransLut;
        }

        /// <summary>
        ///   Convert a single-channel color filter array image into an RGB image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="CFAType">Color filter array type. Default: "bayer_gb"</param>
        /// <param name="interpolation">Interpolation type. Default: "bilinear"</param>
        /// <returns>Output image.</returns>
        public HImage CfaToRgb(string CFAType, string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1580);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, CFAType);
            HalconAPI.StoreS(proc, 1, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Transform an RGB image into a gray scale image.
        ///   Instance represents: Three-channel RBG image.
        /// </summary>
        /// <returns>Gray scale image.</returns>
        public HImage Rgb1ToGray()
        {
            IntPtr proc = HalconAPI.PreCall(1581);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Transform an RGB image to a gray scale image.
        ///   Instance represents: Input image (red channel).
        /// </summary>
        /// <param name="imageGreen">Input image (green channel).</param>
        /// <param name="imageBlue">Input image (blue channel).</param>
        /// <returns>Gray scale image.</returns>
        public HImage Rgb3ToGray(HImage imageGreen, HImage imageBlue)
        {
            IntPtr proc = HalconAPI.PreCall(1582);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageGreen);
            HalconAPI.Store(proc, 3, (HObjectBase)imageBlue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageGreen);
            GC.KeepAlive((object)imageBlue);
            return himage;
        }

        /// <summary>
        ///   Transform an image from the RGB color space to an arbitrary color space.
        ///   Instance represents: Input image (red channel).
        /// </summary>
        /// <param name="imageGreen">Input image (green channel).</param>
        /// <param name="imageBlue">Input image (blue channel).</param>
        /// <param name="imageResult2">Color-transformed output image (channel 1).</param>
        /// <param name="imageResult3">Color-transformed output image (channel 1).</param>
        /// <param name="colorSpace">Color space of the output image. Default: "hsv"</param>
        /// <returns>Color-transformed output image (channel 1).</returns>
        public HImage TransFromRgb(
          HImage imageGreen,
          HImage imageBlue,
          out HImage imageResult2,
          out HImage imageResult3,
          string colorSpace)
        {
            IntPtr proc = HalconAPI.PreCall(1583);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageGreen);
            HalconAPI.Store(proc, 3, (HObjectBase)imageBlue);
            HalconAPI.StoreS(proc, 0, colorSpace);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out imageResult2);
            int procResult = HImage.LoadNew(proc, 3, err3, out imageResult3);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageGreen);
            GC.KeepAlive((object)imageBlue);
            return himage;
        }

        /// <summary>
        ///   Transform an image from an arbitrary color space to the RGB color space.
        ///   Instance represents: Input image (channel 1).
        /// </summary>
        /// <param name="imageInput2">Input image (channel 2).</param>
        /// <param name="imageInput3">Input image (channel 3).</param>
        /// <param name="imageGreen">Green channel.</param>
        /// <param name="imageBlue">Blue channel.</param>
        /// <param name="colorSpace">Color space of the input image. Default: "hsv"</param>
        /// <returns>Red channel.</returns>
        public HImage TransToRgb(
          HImage imageInput2,
          HImage imageInput3,
          out HImage imageGreen,
          out HImage imageBlue,
          string colorSpace)
        {
            IntPtr proc = HalconAPI.PreCall(1584);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageInput2);
            HalconAPI.Store(proc, 3, (HObjectBase)imageInput3);
            HalconAPI.StoreS(proc, 0, colorSpace);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out imageGreen);
            int procResult = HImage.LoadNew(proc, 3, err3, out imageBlue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageInput2);
            GC.KeepAlive((object)imageInput3);
            return himage;
        }

        /// <summary>
        ///   Logical "AND" of each pixel using a bit mask.
        ///   Instance represents: Input image(s).
        /// </summary>
        /// <param name="bitMask">Bit field Default: 128</param>
        /// <returns>Result image(s) by combination with mask.</returns>
        public HImage BitMask(int bitMask)
        {
            IntPtr proc = HalconAPI.PreCall(1585);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, bitMask);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Extract a bit from the pixels.
        ///   Instance represents: Input image(s).
        /// </summary>
        /// <param name="bit">Bit to be selected. Default: 8</param>
        /// <returns>Result image(s) by extraction.</returns>
        public HImage BitSlice(int bit)
        {
            IntPtr proc = HalconAPI.PreCall(1586);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, bit);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Right shift of all pixels of the image.
        ///   Instance represents: Input image(s).
        /// </summary>
        /// <param name="shift">shift value Default: 3</param>
        /// <returns>Result image(s) by shift operation.</returns>
        public HImage BitRshift(int shift)
        {
            IntPtr proc = HalconAPI.PreCall(1587);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, shift);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Left shift of all pixels of the image.
        ///   Instance represents: Input image(s).
        /// </summary>
        /// <param name="shift">Shift value. Default: 3</param>
        /// <returns>Result image(s) by shift operation.</returns>
        public HImage BitLshift(int shift)
        {
            IntPtr proc = HalconAPI.PreCall(1588);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, shift);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Complement all bits of the pixels.
        ///   Instance represents: Input image(s).
        /// </summary>
        /// <returns>Result image(s) by complement operation.</returns>
        public HImage BitNot()
        {
            IntPtr proc = HalconAPI.PreCall(1589);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Bit-by-bit XOR of all pixels of the input images.
        ///   Instance represents: Input image(s) 1.
        /// </summary>
        /// <param name="image2">Input image(s) 2.</param>
        /// <returns>Result image(s) by XOR-operation.</returns>
        public HImage BitXor(HImage image2)
        {
            IntPtr proc = HalconAPI.PreCall(1590);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Bit-by-bit OR of all pixels of the input images.
        ///   Instance represents: Input image(s) 1.
        /// </summary>
        /// <param name="image2">Input image(s) 2.</param>
        /// <returns>Result image(s) by OR-operation.</returns>
        public HImage BitOr(HImage image2)
        {
            IntPtr proc = HalconAPI.PreCall(1591);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Bit-by-bit AND of all pixels of the input images.
        ///   Instance represents: Input image(s) 1.
        /// </summary>
        /// <param name="image2">Input image(s) 2.</param>
        /// <returns>Result image(s) by AND-operation.</returns>
        public HImage BitAnd(HImage image2)
        {
            IntPtr proc = HalconAPI.PreCall(1592);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Perform a gamma encoding or decoding of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="gamma">Gamma coefficient of the exponential part of the transformation. Default: 0.416666666667</param>
        /// <param name="offset">Offset of the exponential part of the transformation. Default: 0.055</param>
        /// <param name="threshold">Gray value for which the transformation switches from linear to exponential. Default: 0.0031308</param>
        /// <param name="maxGray">Maximum gray value of the input image type. Default: 255.0</param>
        /// <param name="encode">If 'true', perform a gamma encoding, otherwise a gamma decoding. Default: "true"</param>
        /// <returns>Output image.</returns>
        public HImage GammaImage(
          double gamma,
          double offset,
          double threshold,
          HTuple maxGray,
          string encode)
        {
            IntPtr proc = HalconAPI.PreCall(1593);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, gamma);
            HalconAPI.StoreD(proc, 1, offset);
            HalconAPI.StoreD(proc, 2, threshold);
            HalconAPI.Store(proc, 3, maxGray);
            HalconAPI.StoreS(proc, 4, encode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(maxGray);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Perform a gamma encoding or decoding of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="gamma">Gamma coefficient of the exponential part of the transformation. Default: 0.416666666667</param>
        /// <param name="offset">Offset of the exponential part of the transformation. Default: 0.055</param>
        /// <param name="threshold">Gray value for which the transformation switches from linear to exponential. Default: 0.0031308</param>
        /// <param name="maxGray">Maximum gray value of the input image type. Default: 255.0</param>
        /// <param name="encode">If 'true', perform a gamma encoding, otherwise a gamma decoding. Default: "true"</param>
        /// <returns>Output image.</returns>
        public HImage GammaImage(
          double gamma,
          double offset,
          double threshold,
          double maxGray,
          string encode)
        {
            IntPtr proc = HalconAPI.PreCall(1593);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, gamma);
            HalconAPI.StoreD(proc, 1, offset);
            HalconAPI.StoreD(proc, 2, threshold);
            HalconAPI.StoreD(proc, 3, maxGray);
            HalconAPI.StoreS(proc, 4, encode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Raise an image to a power.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="exponent">Power to which the gray values are raised. Default: 2</param>
        /// <returns>Output image.</returns>
        public HImage PowImage(HTuple exponent)
        {
            IntPtr proc = HalconAPI.PreCall(1594);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, exponent);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(exponent);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Raise an image to a power.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="exponent">Power to which the gray values are raised. Default: 2</param>
        /// <returns>Output image.</returns>
        public HImage PowImage(double exponent)
        {
            IntPtr proc = HalconAPI.PreCall(1594);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, exponent);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the exponentiation of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="baseVal">Base of the exponentiation. Default: "e"</param>
        /// <returns>Output image.</returns>
        public HImage ExpImage(HTuple baseVal)
        {
            IntPtr proc = HalconAPI.PreCall(1595);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, baseVal);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(baseVal);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the exponentiation of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="baseVal">Base of the exponentiation. Default: "e"</param>
        /// <returns>Output image.</returns>
        public HImage ExpImage(string baseVal)
        {
            IntPtr proc = HalconAPI.PreCall(1595);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, baseVal);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the logarithm of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="baseVal">Base of the logarithm. Default: "e"</param>
        /// <returns>Output image.</returns>
        public HImage LogImage(HTuple baseVal)
        {
            IntPtr proc = HalconAPI.PreCall(1596);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, baseVal);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(baseVal);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the logarithm of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="baseVal">Base of the logarithm. Default: "e"</param>
        /// <returns>Output image.</returns>
        public HImage LogImage(string baseVal)
        {
            IntPtr proc = HalconAPI.PreCall(1596);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, baseVal);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the arctangent of two images.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="imageX">Input image 2.</param>
        /// <returns>Output image.</returns>
        public HImage Atan2Image(HImage imageX)
        {
            IntPtr proc = HalconAPI.PreCall(1597);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageX);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageX);
            return himage;
        }

        /// <summary>
        ///   Calculate the arctangent of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Output image.</returns>
        public HImage AtanImage()
        {
            IntPtr proc = HalconAPI.PreCall(1598);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the arccosine of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Output image.</returns>
        public HImage AcosImage()
        {
            IntPtr proc = HalconAPI.PreCall(1599);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the arcsine of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Output image.</returns>
        public HImage AsinImage()
        {
            IntPtr proc = HalconAPI.PreCall(1600);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the tangent of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Output image.</returns>
        public HImage TanImage()
        {
            IntPtr proc = HalconAPI.PreCall(1601);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the cosine of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Output image.</returns>
        public HImage CosImage()
        {
            IntPtr proc = HalconAPI.PreCall(1602);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the sine of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Output image.</returns>
        public HImage SinImage()
        {
            IntPtr proc = HalconAPI.PreCall(1603);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the absolute difference of two images.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="mult">Scale factor. Default: 1.0</param>
        /// <returns>Absolute value of the difference of the input images.</returns>
        public HImage AbsDiffImage(HImage image2, HTuple mult)
        {
            IntPtr proc = HalconAPI.PreCall(1604);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Calculate the absolute difference of two images.
        ///   Instance represents: Input image 1.
        /// </summary>
        /// <param name="image2">Input image 2.</param>
        /// <param name="mult">Scale factor. Default: 1.0</param>
        /// <returns>Absolute value of the difference of the input images.</returns>
        public HImage AbsDiffImage(HImage image2, double mult)
        {
            IntPtr proc = HalconAPI.PreCall(1604);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.StoreD(proc, 0, mult);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Calculate the square root of an image.
        ///   Instance represents: Input image
        /// </summary>
        /// <returns>Output image</returns>
        public HImage SqrtImage()
        {
            IntPtr proc = HalconAPI.PreCall(1605);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Subtract two images.
        ///   Instance represents: Minuend(s).
        /// </summary>
        /// <param name="imageSubtrahend">Subtrahend(s).</param>
        /// <param name="mult">Correction factor. Default: 1.0</param>
        /// <param name="add">Correction value. Default: 128.0</param>
        /// <returns>Result image(s) by the subtraction.</returns>
        public HImage SubImage(HImage imageSubtrahend, HTuple mult, HTuple add)
        {
            IntPtr proc = HalconAPI.PreCall(1606);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageSubtrahend);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.Store(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            HalconAPI.UnpinTuple(add);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageSubtrahend);
            return himage;
        }

        /// <summary>
        ///   Subtract two images.
        ///   Instance represents: Minuend(s).
        /// </summary>
        /// <param name="imageSubtrahend">Subtrahend(s).</param>
        /// <param name="mult">Correction factor. Default: 1.0</param>
        /// <param name="add">Correction value. Default: 128.0</param>
        /// <returns>Result image(s) by the subtraction.</returns>
        public HImage SubImage(HImage imageSubtrahend, double mult, double add)
        {
            IntPtr proc = HalconAPI.PreCall(1606);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageSubtrahend);
            HalconAPI.StoreD(proc, 0, mult);
            HalconAPI.StoreD(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageSubtrahend);
            return himage;
        }

        /// <summary>
        ///   Scale the gray values of an image.
        ///   Instance represents: Image(s) whose gray values are to be scaled.
        /// </summary>
        /// <param name="mult">Scale factor. Default: 0.01</param>
        /// <param name="add">Offset. Default: 0</param>
        /// <returns>Result image(s) by the scale.</returns>
        public HImage ScaleImage(HTuple mult, HTuple add)
        {
            IntPtr proc = HalconAPI.PreCall(1607);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.Store(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            HalconAPI.UnpinTuple(add);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Scale the gray values of an image.
        ///   Instance represents: Image(s) whose gray values are to be scaled.
        /// </summary>
        /// <param name="mult">Scale factor. Default: 0.01</param>
        /// <param name="add">Offset. Default: 0</param>
        /// <returns>Result image(s) by the scale.</returns>
        public HImage ScaleImage(double mult, double add)
        {
            IntPtr proc = HalconAPI.PreCall(1607);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, mult);
            HalconAPI.StoreD(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Divide two images.
        ///   Instance represents: Image(s) 1.
        /// </summary>
        /// <param name="image2">Image(s) 2.</param>
        /// <param name="mult">Factor for gray range adaption. Default: 255</param>
        /// <param name="add">Value for gray range adaption. Default: 0</param>
        /// <returns>Result image(s) by the division.</returns>
        public HImage DivImage(HImage image2, HTuple mult, HTuple add)
        {
            IntPtr proc = HalconAPI.PreCall(1608);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.Store(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            HalconAPI.UnpinTuple(add);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Divide two images.
        ///   Instance represents: Image(s) 1.
        /// </summary>
        /// <param name="image2">Image(s) 2.</param>
        /// <param name="mult">Factor for gray range adaption. Default: 255</param>
        /// <param name="add">Value for gray range adaption. Default: 0</param>
        /// <returns>Result image(s) by the division.</returns>
        public HImage DivImage(HImage image2, double mult, double add)
        {
            IntPtr proc = HalconAPI.PreCall(1608);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.StoreD(proc, 0, mult);
            HalconAPI.StoreD(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Multiply two images.
        ///   Instance represents: Image(s) 1.
        /// </summary>
        /// <param name="image2">Image(s) 2.</param>
        /// <param name="mult">Factor for gray range adaption. Default: 0.005</param>
        /// <param name="add">Value for gray range adaption. Default: 0</param>
        /// <returns>Result image(s) by the product.</returns>
        public HImage MultImage(HImage image2, HTuple mult, HTuple add)
        {
            IntPtr proc = HalconAPI.PreCall(1609);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.Store(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            HalconAPI.UnpinTuple(add);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Multiply two images.
        ///   Instance represents: Image(s) 1.
        /// </summary>
        /// <param name="image2">Image(s) 2.</param>
        /// <param name="mult">Factor for gray range adaption. Default: 0.005</param>
        /// <param name="add">Value for gray range adaption. Default: 0</param>
        /// <returns>Result image(s) by the product.</returns>
        public HImage MultImage(HImage image2, double mult, double add)
        {
            IntPtr proc = HalconAPI.PreCall(1609);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.StoreD(proc, 0, mult);
            HalconAPI.StoreD(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Add two images.
        ///   Instance represents: Image(s) 1.
        /// </summary>
        /// <param name="image2">Image(s) 2.</param>
        /// <param name="mult">Factor for gray value adaption. Default: 0.5</param>
        /// <param name="add">Value for gray value range adaption. Default: 0</param>
        /// <returns>Result image(s) by the addition.</returns>
        public HImage AddImage(HImage image2, HTuple mult, HTuple add)
        {
            IntPtr proc = HalconAPI.PreCall(1610);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.Store(proc, 0, mult);
            HalconAPI.Store(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mult);
            HalconAPI.UnpinTuple(add);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Add two images.
        ///   Instance represents: Image(s) 1.
        /// </summary>
        /// <param name="image2">Image(s) 2.</param>
        /// <param name="mult">Factor for gray value adaption. Default: 0.5</param>
        /// <param name="add">Value for gray value range adaption. Default: 0</param>
        /// <returns>Result image(s) by the addition.</returns>
        public HImage AddImage(HImage image2, double mult, double add)
        {
            IntPtr proc = HalconAPI.PreCall(1610);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.StoreD(proc, 0, mult);
            HalconAPI.StoreD(proc, 1, add);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Calculate the absolute value (modulus) of an image.
        ///   Instance represents: Image(s) for which the absolute gray values are to be calculated.
        /// </summary>
        /// <returns>Result image(s).</returns>
        public HImage AbsImage()
        {
            IntPtr proc = HalconAPI.PreCall(1611);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Calculate the minimum of two images pixel by pixel.
        ///   Instance represents: Image(s) 1.
        /// </summary>
        /// <param name="image2">Image(s) 2.</param>
        /// <returns>Result image(s) by the minimization.</returns>
        public HImage MinImage(HImage image2)
        {
            IntPtr proc = HalconAPI.PreCall(1612);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Calculate the maximum of two images pixel by pixel.
        ///   Instance represents: Image(s) 1.
        /// </summary>
        /// <param name="image2">Image(s) 2.</param>
        /// <returns>Result image(s) by the maximization.</returns>
        public HImage MaxImage(HImage image2)
        {
            IntPtr proc = HalconAPI.PreCall(1613);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)image2);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)image2);
            return himage;
        }

        /// <summary>
        ///   Invert an image.
        ///   Instance represents: Input image(s).
        /// </summary>
        /// <returns>Image(s) with inverted gray values.</returns>
        public HImage InvertImage()
        {
            IntPtr proc = HalconAPI.PreCall(1614);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Apply an automatic color correction to panorama images.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="from">List of source images.</param>
        /// <param name="to">List of destination images.</param>
        /// <param name="referenceImage">Reference image.</param>
        /// <param name="homMatrices2D">Projective matrices.</param>
        /// <param name="estimationMethod">Estimation algorithm for the correction. Default: "standard"</param>
        /// <param name="estimateParameters">Parameters to be estimated. Default: ["mult_gray"]</param>
        /// <param name="OECFModel">Model of OECF to be used. Default: ["laguerre"]</param>
        /// <returns>Output images.</returns>
        public HImage AdjustMosaicImages(
          HTuple from,
          HTuple to,
          int referenceImage,
          HTuple homMatrices2D,
          string estimationMethod,
          HTuple estimateParameters,
          string OECFModel)
        {
            IntPtr proc = HalconAPI.PreCall(1615);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, from);
            HalconAPI.Store(proc, 1, to);
            HalconAPI.StoreI(proc, 2, referenceImage);
            HalconAPI.Store(proc, 3, homMatrices2D);
            HalconAPI.StoreS(proc, 4, estimationMethod);
            HalconAPI.Store(proc, 5, estimateParameters);
            HalconAPI.StoreS(proc, 6, OECFModel);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(from);
            HalconAPI.UnpinTuple(to);
            HalconAPI.UnpinTuple(homMatrices2D);
            HalconAPI.UnpinTuple(estimateParameters);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Apply an automatic color correction to panorama images.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="from">List of source images.</param>
        /// <param name="to">List of destination images.</param>
        /// <param name="referenceImage">Reference image.</param>
        /// <param name="homMatrices2D">Projective matrices.</param>
        /// <param name="estimationMethod">Estimation algorithm for the correction. Default: "standard"</param>
        /// <param name="estimateParameters">Parameters to be estimated. Default: ["mult_gray"]</param>
        /// <param name="OECFModel">Model of OECF to be used. Default: ["laguerre"]</param>
        /// <returns>Output images.</returns>
        public HImage AdjustMosaicImages(
          HTuple from,
          HTuple to,
          int referenceImage,
          HTuple homMatrices2D,
          string estimationMethod,
          string estimateParameters,
          string OECFModel)
        {
            IntPtr proc = HalconAPI.PreCall(1615);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, from);
            HalconAPI.Store(proc, 1, to);
            HalconAPI.StoreI(proc, 2, referenceImage);
            HalconAPI.Store(proc, 3, homMatrices2D);
            HalconAPI.StoreS(proc, 4, estimationMethod);
            HalconAPI.StoreS(proc, 5, estimateParameters);
            HalconAPI.StoreS(proc, 6, OECFModel);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(from);
            HalconAPI.UnpinTuple(to);
            HalconAPI.UnpinTuple(homMatrices2D);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Create 6 cube map images of a spherical mosaic.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="rear">Rear cube map.</param>
        /// <param name="left">Left cube map.</param>
        /// <param name="right">Right cube map.</param>
        /// <param name="top">Top cube map.</param>
        /// <param name="bottom">Bottom cube map.</param>
        /// <param name="cameraMatrices">(Array of) 3x3 projective camera matrices that determine the internal camera parameters.</param>
        /// <param name="rotationMatrices">Array of 3x3 transformation matrices that determine rotation of the camera in the respective image.</param>
        /// <param name="cubeMapDimension">Width and height of the resulting cube maps. Default: 1000</param>
        /// <param name="stackingOrder">Mode of adding the images to the mosaic image. Default: "voronoi"</param>
        /// <param name="interpolation">Mode of image interpolation. Default: "bilinear"</param>
        /// <returns>Front cube map.</returns>
        public HImage GenCubeMapMosaic(
          out HImage rear,
          out HImage left,
          out HImage right,
          out HImage top,
          out HImage bottom,
          HHomMat2D[] cameraMatrices,
          HHomMat2D[] rotationMatrices,
          int cubeMapDimension,
          HTuple stackingOrder,
          string interpolation)
        {
            HTuple htuple1 = HData.ConcatArray((HData[])cameraMatrices);
            HTuple htuple2 = HData.ConcatArray((HData[])rotationMatrices);
            IntPtr proc = HalconAPI.PreCall(1616);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, htuple1);
            HalconAPI.Store(proc, 1, htuple2);
            HalconAPI.StoreI(proc, 2, cubeMapDimension);
            HalconAPI.Store(proc, 3, stackingOrder);
            HalconAPI.StoreS(proc, 4, interpolation);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(htuple1);
            HalconAPI.UnpinTuple(htuple2);
            HalconAPI.UnpinTuple(stackingOrder);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out rear);
            int err4 = HImage.LoadNew(proc, 3, err3, out left);
            int err5 = HImage.LoadNew(proc, 4, err4, out right);
            int err6 = HImage.LoadNew(proc, 5, err5, out top);
            int procResult = HImage.LoadNew(proc, 6, err6, out bottom);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Create 6 cube map images of a spherical mosaic.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="rear">Rear cube map.</param>
        /// <param name="left">Left cube map.</param>
        /// <param name="right">Right cube map.</param>
        /// <param name="top">Top cube map.</param>
        /// <param name="bottom">Bottom cube map.</param>
        /// <param name="cameraMatrices">(Array of) 3x3 projective camera matrices that determine the internal camera parameters.</param>
        /// <param name="rotationMatrices">Array of 3x3 transformation matrices that determine rotation of the camera in the respective image.</param>
        /// <param name="cubeMapDimension">Width and height of the resulting cube maps. Default: 1000</param>
        /// <param name="stackingOrder">Mode of adding the images to the mosaic image. Default: "voronoi"</param>
        /// <param name="interpolation">Mode of image interpolation. Default: "bilinear"</param>
        /// <returns>Front cube map.</returns>
        public HImage GenCubeMapMosaic(
          out HImage rear,
          out HImage left,
          out HImage right,
          out HImage top,
          out HImage bottom,
          HHomMat2D[] cameraMatrices,
          HHomMat2D[] rotationMatrices,
          int cubeMapDimension,
          string stackingOrder,
          string interpolation)
        {
            HTuple htuple1 = HData.ConcatArray((HData[])cameraMatrices);
            HTuple htuple2 = HData.ConcatArray((HData[])rotationMatrices);
            IntPtr proc = HalconAPI.PreCall(1616);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, htuple1);
            HalconAPI.Store(proc, 1, htuple2);
            HalconAPI.StoreI(proc, 2, cubeMapDimension);
            HalconAPI.StoreS(proc, 3, stackingOrder);
            HalconAPI.StoreS(proc, 4, interpolation);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            HalconAPI.InitOCT(proc, 6);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(htuple1);
            HalconAPI.UnpinTuple(htuple2);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out rear);
            int err4 = HImage.LoadNew(proc, 3, err3, out left);
            int err5 = HImage.LoadNew(proc, 4, err4, out right);
            int err6 = HImage.LoadNew(proc, 5, err5, out top);
            int procResult = HImage.LoadNew(proc, 6, err6, out bottom);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Create a spherical mosaic image.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="cameraMatrices">(Array of) 3x3 projective camera matrices that determine the internal camera parameters.</param>
        /// <param name="rotationMatrices">Array of 3x3 transformation matrices that determine rotation of the camera in the respective image.</param>
        /// <param name="latMin">Minimum latitude of points in the spherical mosaic image. Default: -90</param>
        /// <param name="latMax">Maximum latitude of points in the spherical mosaic image. Default: 90</param>
        /// <param name="longMin">Minimum longitude of points in the spherical mosaic image. Default: -180</param>
        /// <param name="longMax">Maximum longitude of points in the spherical mosaic image. Default: 180</param>
        /// <param name="latLongStep">Latitude and longitude angle step width. Default: 0.1</param>
        /// <param name="stackingOrder">Mode of adding the images to the mosaic image. Default: "voronoi"</param>
        /// <param name="interpolation">Mode of interpolation when creating the mosaic image. Default: "bilinear"</param>
        /// <returns>Output image.</returns>
        public HImage GenSphericalMosaic(
          HHomMat2D[] cameraMatrices,
          HHomMat2D[] rotationMatrices,
          HTuple latMin,
          HTuple latMax,
          HTuple longMin,
          HTuple longMax,
          HTuple latLongStep,
          HTuple stackingOrder,
          HTuple interpolation)
        {
            HTuple htuple1 = HData.ConcatArray((HData[])cameraMatrices);
            HTuple htuple2 = HData.ConcatArray((HData[])rotationMatrices);
            IntPtr proc = HalconAPI.PreCall(1617);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, htuple1);
            HalconAPI.Store(proc, 1, htuple2);
            HalconAPI.Store(proc, 2, latMin);
            HalconAPI.Store(proc, 3, latMax);
            HalconAPI.Store(proc, 4, longMin);
            HalconAPI.Store(proc, 5, longMax);
            HalconAPI.Store(proc, 6, latLongStep);
            HalconAPI.Store(proc, 7, stackingOrder);
            HalconAPI.Store(proc, 8, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(htuple1);
            HalconAPI.UnpinTuple(htuple2);
            HalconAPI.UnpinTuple(latMin);
            HalconAPI.UnpinTuple(latMax);
            HalconAPI.UnpinTuple(longMin);
            HalconAPI.UnpinTuple(longMax);
            HalconAPI.UnpinTuple(latLongStep);
            HalconAPI.UnpinTuple(stackingOrder);
            HalconAPI.UnpinTuple(interpolation);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Create a spherical mosaic image.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="cameraMatrices">(Array of) 3x3 projective camera matrices that determine the internal camera parameters.</param>
        /// <param name="rotationMatrices">Array of 3x3 transformation matrices that determine rotation of the camera in the respective image.</param>
        /// <param name="latMin">Minimum latitude of points in the spherical mosaic image. Default: -90</param>
        /// <param name="latMax">Maximum latitude of points in the spherical mosaic image. Default: 90</param>
        /// <param name="longMin">Minimum longitude of points in the spherical mosaic image. Default: -180</param>
        /// <param name="longMax">Maximum longitude of points in the spherical mosaic image. Default: 180</param>
        /// <param name="latLongStep">Latitude and longitude angle step width. Default: 0.1</param>
        /// <param name="stackingOrder">Mode of adding the images to the mosaic image. Default: "voronoi"</param>
        /// <param name="interpolation">Mode of interpolation when creating the mosaic image. Default: "bilinear"</param>
        /// <returns>Output image.</returns>
        public HImage GenSphericalMosaic(
          HHomMat2D[] cameraMatrices,
          HHomMat2D[] rotationMatrices,
          double latMin,
          double latMax,
          double longMin,
          double longMax,
          double latLongStep,
          string stackingOrder,
          string interpolation)
        {
            HTuple htuple1 = HData.ConcatArray((HData[])cameraMatrices);
            HTuple htuple2 = HData.ConcatArray((HData[])rotationMatrices);
            IntPtr proc = HalconAPI.PreCall(1617);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, htuple1);
            HalconAPI.Store(proc, 1, htuple2);
            HalconAPI.StoreD(proc, 2, latMin);
            HalconAPI.StoreD(proc, 3, latMax);
            HalconAPI.StoreD(proc, 4, longMin);
            HalconAPI.StoreD(proc, 5, longMax);
            HalconAPI.StoreD(proc, 6, latLongStep);
            HalconAPI.StoreS(proc, 7, stackingOrder);
            HalconAPI.StoreS(proc, 8, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(htuple1);
            HalconAPI.UnpinTuple(htuple2);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Combine multiple images into a mosaic image.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="homMatrices2D">Array of 3x3 projective transformation matrices.</param>
        /// <param name="stackingOrder">Stacking order of the images in the mosaic. Default: "default"</param>
        /// <param name="transformDomain">Should the domains of the input images also be transformed? Default: "false"</param>
        /// <param name="transMat2D">3x3 projective transformation matrix that describes the translation that was necessary to transform all images completely into the output image.</param>
        /// <returns>Output image.</returns>
        public HImage GenBundleAdjustedMosaic(
          HHomMat2D[] homMatrices2D,
          HTuple stackingOrder,
          string transformDomain,
          out HHomMat2D transMat2D)
        {
            HTuple htuple = HData.ConcatArray((HData[])homMatrices2D);
            IntPtr proc = HalconAPI.PreCall(1618);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, htuple);
            HalconAPI.Store(proc, 1, stackingOrder);
            HalconAPI.StoreS(proc, 2, transformDomain);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(htuple);
            HalconAPI.UnpinTuple(stackingOrder);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HHomMat2D.LoadNew(proc, 0, err2, out transMat2D);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Combine multiple images into a mosaic image.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="homMatrices2D">Array of 3x3 projective transformation matrices.</param>
        /// <param name="stackingOrder">Stacking order of the images in the mosaic. Default: "default"</param>
        /// <param name="transformDomain">Should the domains of the input images also be transformed? Default: "false"</param>
        /// <param name="transMat2D">3x3 projective transformation matrix that describes the translation that was necessary to transform all images completely into the output image.</param>
        /// <returns>Output image.</returns>
        public HImage GenBundleAdjustedMosaic(
          HHomMat2D[] homMatrices2D,
          string stackingOrder,
          string transformDomain,
          out HHomMat2D transMat2D)
        {
            HTuple htuple = HData.ConcatArray((HData[])homMatrices2D);
            IntPtr proc = HalconAPI.PreCall(1618);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, htuple);
            HalconAPI.StoreS(proc, 1, stackingOrder);
            HalconAPI.StoreS(proc, 2, transformDomain);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(htuple);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int procResult = HHomMat2D.LoadNew(proc, 0, err2, out transMat2D);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Combine multiple images into a mosaic image.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="startImage">Index of the central input image.</param>
        /// <param name="mappingSource">Indices of the source images of the transformations.</param>
        /// <param name="mappingDest">Indices of the target images of the transformations.</param>
        /// <param name="homMatrices2D">Array of 3x3 projective transformation matrices.</param>
        /// <param name="stackingOrder">Stacking order of the images in the mosaic. Default: "default"</param>
        /// <param name="transformDomain">Should the domains of the input images also be transformed? Default: "false"</param>
        /// <param name="mosaicMatrices2D">Array of 3x3 projective transformation matrices that determine the position of the images in the mosaic.</param>
        /// <returns>Output image.</returns>
        public HImage GenProjectiveMosaic(
          int startImage,
          HTuple mappingSource,
          HTuple mappingDest,
          HHomMat2D[] homMatrices2D,
          HTuple stackingOrder,
          string transformDomain,
          out HHomMat2D[] mosaicMatrices2D)
        {
            HTuple htuple = HData.ConcatArray((HData[])homMatrices2D);
            IntPtr proc = HalconAPI.PreCall(1619);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, startImage);
            HalconAPI.Store(proc, 1, mappingSource);
            HalconAPI.Store(proc, 2, mappingDest);
            HalconAPI.Store(proc, 3, htuple);
            HalconAPI.Store(proc, 4, stackingOrder);
            HalconAPI.StoreS(proc, 5, transformDomain);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mappingSource);
            HalconAPI.UnpinTuple(mappingDest);
            HalconAPI.UnpinTuple(htuple);
            HalconAPI.UnpinTuple(stackingOrder);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err2, out tuple);
            HalconAPI.PostCall(proc, procResult);
            mosaicMatrices2D = HHomMat2D.SplitArray(tuple);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Combine multiple images into a mosaic image.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="startImage">Index of the central input image.</param>
        /// <param name="mappingSource">Indices of the source images of the transformations.</param>
        /// <param name="mappingDest">Indices of the target images of the transformations.</param>
        /// <param name="homMatrices2D">Array of 3x3 projective transformation matrices.</param>
        /// <param name="stackingOrder">Stacking order of the images in the mosaic. Default: "default"</param>
        /// <param name="transformDomain">Should the domains of the input images also be transformed? Default: "false"</param>
        /// <param name="mosaicMatrices2D">Array of 3x3 projective transformation matrices that determine the position of the images in the mosaic.</param>
        /// <returns>Output image.</returns>
        public HImage GenProjectiveMosaic(
          int startImage,
          HTuple mappingSource,
          HTuple mappingDest,
          HHomMat2D[] homMatrices2D,
          string stackingOrder,
          string transformDomain,
          out HHomMat2D[] mosaicMatrices2D)
        {
            HTuple htuple = HData.ConcatArray((HData[])homMatrices2D);
            IntPtr proc = HalconAPI.PreCall(1619);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, startImage);
            HalconAPI.Store(proc, 1, mappingSource);
            HalconAPI.Store(proc, 2, mappingDest);
            HalconAPI.Store(proc, 3, htuple);
            HalconAPI.StoreS(proc, 4, stackingOrder);
            HalconAPI.StoreS(proc, 5, transformDomain);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(mappingSource);
            HalconAPI.UnpinTuple(mappingDest);
            HalconAPI.UnpinTuple(htuple);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err2, out tuple);
            HalconAPI.PostCall(proc, procResult);
            mosaicMatrices2D = HHomMat2D.SplitArray(tuple);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Apply a projective transformation to an image and specify the output image size.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "bilinear"</param>
        /// <param name="width">Output image width.</param>
        /// <param name="height">Output image height.</param>
        /// <param name="transformDomain">Should the domain of the input image also be transformed? Default: "false"</param>
        /// <returns>Output image.</returns>
        public HImage ProjectiveTransImageSize(
          HHomMat2D homMat2D,
          string interpolation,
          int width,
          int height,
          string transformDomain)
        {
            IntPtr proc = HalconAPI.PreCall(1620);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HData)homMat2D);
            HalconAPI.StoreS(proc, 1, interpolation);
            HalconAPI.StoreI(proc, 2, width);
            HalconAPI.StoreI(proc, 3, height);
            HalconAPI.StoreS(proc, 4, transformDomain);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)homMat2D));
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Apply a projective transformation to an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="homMat2D">Homogeneous projective transformation matrix.</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "bilinear"</param>
        /// <param name="adaptImageSize">Adapt the size of the output image automatically? Default: "false"</param>
        /// <param name="transformDomain">Should the domain of the input image also be transformed? Default: "false"</param>
        /// <returns>Output image.</returns>
        public HImage ProjectiveTransImage(
          HHomMat2D homMat2D,
          string interpolation,
          string adaptImageSize,
          string transformDomain)
        {
            IntPtr proc = HalconAPI.PreCall(1621);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HData)homMat2D);
            HalconAPI.StoreS(proc, 1, interpolation);
            HalconAPI.StoreS(proc, 2, adaptImageSize);
            HalconAPI.StoreS(proc, 3, transformDomain);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)homMat2D));
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Apply an arbitrary affine 2D transformation to an image and specify the output image size.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="interpolation">Type of interpolation. Default: "constant"</param>
        /// <param name="width">Width of the output image. Default: 640</param>
        /// <param name="height">Height of the output image. Default: 480</param>
        /// <returns>Transformed image.</returns>
        public HImage AffineTransImageSize(
          HHomMat2D homMat2D,
          string interpolation,
          int width,
          int height)
        {
            IntPtr proc = HalconAPI.PreCall(1622);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HData)homMat2D);
            HalconAPI.StoreS(proc, 1, interpolation);
            HalconAPI.StoreI(proc, 2, width);
            HalconAPI.StoreI(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)homMat2D));
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Apply an arbitrary affine 2D transformation to images.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="homMat2D">Input transformation matrix.</param>
        /// <param name="interpolation">Type of interpolation. Default: "constant"</param>
        /// <param name="adaptImageSize">Adaption of size of result image. Default: "false"</param>
        /// <returns>Transformed image.</returns>
        public HImage AffineTransImage(
          HHomMat2D homMat2D,
          string interpolation,
          string adaptImageSize)
        {
            IntPtr proc = HalconAPI.PreCall(1623);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HData)homMat2D);
            HalconAPI.StoreS(proc, 1, interpolation);
            HalconAPI.StoreS(proc, 2, adaptImageSize);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)homMat2D));
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Zoom an image by a given factor.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="scaleWidth">Scale factor for the width of the image. Default: 0.5</param>
        /// <param name="scaleHeight">Scale factor for the height of the image. Default: 0.5</param>
        /// <param name="interpolation">Type of interpolation. Default: "constant"</param>
        /// <returns>Scaled image.</returns>
        public HImage ZoomImageFactor(
          double scaleWidth,
          double scaleHeight,
          string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1624);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, scaleWidth);
            HalconAPI.StoreD(proc, 1, scaleHeight);
            HalconAPI.StoreS(proc, 2, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Zoom an image to a given size.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="width">Width of the resulting image. Default: 512</param>
        /// <param name="height">Height of the resulting image. Default: 512</param>
        /// <param name="interpolation">Type of interpolation. Default: "constant"</param>
        /// <returns>Scaled image.</returns>
        public HImage ZoomImageSize(int width, int height, string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1625);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, width);
            HalconAPI.StoreI(proc, 1, height);
            HalconAPI.StoreS(proc, 2, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Mirror an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="mode">Axis of reflection. Default: "row"</param>
        /// <returns>Reflected image.</returns>
        public HImage MirrorImage(string mode)
        {
            IntPtr proc = HalconAPI.PreCall(1626);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Rotate an image about its center.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="phi">Rotation angle. Default: 90</param>
        /// <param name="interpolation">Type of interpolation. Default: "constant"</param>
        /// <returns>Rotated image.</returns>
        public HImage RotateImage(HTuple phi, string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1627);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, phi);
            HalconAPI.StoreS(proc, 1, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(phi);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Rotate an image about its center.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="phi">Rotation angle. Default: 90</param>
        /// <param name="interpolation">Type of interpolation. Default: "constant"</param>
        /// <returns>Rotated image.</returns>
        public HImage RotateImage(double phi, string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1627);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, phi);
            HalconAPI.StoreS(proc, 1, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Transform an image in polar coordinates back to cartesian coordinates
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row">Row coordinate of the center of the arc. Default: 256</param>
        /// <param name="column">Column coordinate of the center of the arc. Default: 256</param>
        /// <param name="angleStart">Angle of the ray to map the first column of the input image to. Default: 0.0</param>
        /// <param name="angleEnd">Angle of the ray to map the last column of the input image to. Default: 6.2831853</param>
        /// <param name="radiusStart">Radius of the circle to map the first row of the input image to. Default: 0</param>
        /// <param name="radiusEnd">Radius of the circle to map the last row of the input image to. Default: 100</param>
        /// <param name="width">Width of the output image. Default: 512</param>
        /// <param name="height">Height of the output image. Default: 512</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "nearest_neighbor"</param>
        /// <returns>Output image.</returns>
        public HImage PolarTransImageInv(
          HTuple row,
          HTuple column,
          double angleStart,
          double angleEnd,
          HTuple radiusStart,
          HTuple radiusEnd,
          int width,
          int height,
          string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1628);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.StoreD(proc, 2, angleStart);
            HalconAPI.StoreD(proc, 3, angleEnd);
            HalconAPI.Store(proc, 4, radiusStart);
            HalconAPI.Store(proc, 5, radiusEnd);
            HalconAPI.StoreI(proc, 6, width);
            HalconAPI.StoreI(proc, 7, height);
            HalconAPI.StoreS(proc, 8, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(radiusStart);
            HalconAPI.UnpinTuple(radiusEnd);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Transform an image in polar coordinates back to cartesian coordinates
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row">Row coordinate of the center of the arc. Default: 256</param>
        /// <param name="column">Column coordinate of the center of the arc. Default: 256</param>
        /// <param name="angleStart">Angle of the ray to map the first column of the input image to. Default: 0.0</param>
        /// <param name="angleEnd">Angle of the ray to map the last column of the input image to. Default: 6.2831853</param>
        /// <param name="radiusStart">Radius of the circle to map the first row of the input image to. Default: 0</param>
        /// <param name="radiusEnd">Radius of the circle to map the last row of the input image to. Default: 100</param>
        /// <param name="width">Width of the output image. Default: 512</param>
        /// <param name="height">Height of the output image. Default: 512</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "nearest_neighbor"</param>
        /// <returns>Output image.</returns>
        public HImage PolarTransImageInv(
          double row,
          double column,
          double angleStart,
          double angleEnd,
          double radiusStart,
          double radiusEnd,
          int width,
          int height,
          string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1628);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, row);
            HalconAPI.StoreD(proc, 1, column);
            HalconAPI.StoreD(proc, 2, angleStart);
            HalconAPI.StoreD(proc, 3, angleEnd);
            HalconAPI.StoreD(proc, 4, radiusStart);
            HalconAPI.StoreD(proc, 5, radiusEnd);
            HalconAPI.StoreI(proc, 6, width);
            HalconAPI.StoreI(proc, 7, height);
            HalconAPI.StoreS(proc, 8, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Transform an annular arc in an image to polar coordinates.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row">Row coordinate of the center of the arc. Default: 256</param>
        /// <param name="column">Column coordinate of the center of the arc. Default: 256</param>
        /// <param name="angleStart">Angle of the ray to be mapped to the first column of the output image. Default: 0.0</param>
        /// <param name="angleEnd">Angle of the ray to be mapped to the last column of the output image. Default: 6.2831853</param>
        /// <param name="radiusStart">Radius of the circle to be mapped to the first row of the output image. Default: 0</param>
        /// <param name="radiusEnd">Radius of the circle to be mapped to the last row of the output image. Default: 100</param>
        /// <param name="width">Width of the output image. Default: 512</param>
        /// <param name="height">Height of the output image. Default: 512</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "nearest_neighbor"</param>
        /// <returns>Output image.</returns>
        public HImage PolarTransImageExt(
          HTuple row,
          HTuple column,
          double angleStart,
          double angleEnd,
          HTuple radiusStart,
          HTuple radiusEnd,
          int width,
          int height,
          string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1629);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, row);
            HalconAPI.Store(proc, 1, column);
            HalconAPI.StoreD(proc, 2, angleStart);
            HalconAPI.StoreD(proc, 3, angleEnd);
            HalconAPI.Store(proc, 4, radiusStart);
            HalconAPI.Store(proc, 5, radiusEnd);
            HalconAPI.StoreI(proc, 6, width);
            HalconAPI.StoreI(proc, 7, height);
            HalconAPI.StoreS(proc, 8, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(radiusStart);
            HalconAPI.UnpinTuple(radiusEnd);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Transform an annular arc in an image to polar coordinates.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="row">Row coordinate of the center of the arc. Default: 256</param>
        /// <param name="column">Column coordinate of the center of the arc. Default: 256</param>
        /// <param name="angleStart">Angle of the ray to be mapped to the first column of the output image. Default: 0.0</param>
        /// <param name="angleEnd">Angle of the ray to be mapped to the last column of the output image. Default: 6.2831853</param>
        /// <param name="radiusStart">Radius of the circle to be mapped to the first row of the output image. Default: 0</param>
        /// <param name="radiusEnd">Radius of the circle to be mapped to the last row of the output image. Default: 100</param>
        /// <param name="width">Width of the output image. Default: 512</param>
        /// <param name="height">Height of the output image. Default: 512</param>
        /// <param name="interpolation">Interpolation method for the transformation. Default: "nearest_neighbor"</param>
        /// <returns>Output image.</returns>
        public HImage PolarTransImageExt(
          double row,
          double column,
          double angleStart,
          double angleEnd,
          double radiusStart,
          double radiusEnd,
          int width,
          int height,
          string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1629);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, row);
            HalconAPI.StoreD(proc, 1, column);
            HalconAPI.StoreD(proc, 2, angleStart);
            HalconAPI.StoreD(proc, 3, angleEnd);
            HalconAPI.StoreD(proc, 4, radiusStart);
            HalconAPI.StoreD(proc, 5, radiusEnd);
            HalconAPI.StoreI(proc, 6, width);
            HalconAPI.StoreI(proc, 7, height);
            HalconAPI.StoreS(proc, 8, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Transform an image to polar coordinates
        ///   Instance represents: Input image in cartesian coordinates.
        /// </summary>
        /// <param name="row">Row coordinate of the center of the coordinate system. Default: 100</param>
        /// <param name="column">Column coordinate of the center of the coordinate system. Default: 100</param>
        /// <param name="width">Width of the result image. Default: 314</param>
        /// <param name="height">Height of the result image. Default: 200</param>
        /// <returns>Result image in polar coordinates.</returns>
        public HImage PolarTransImage(int row, int column, int width, int height)
        {
            IntPtr proc = HalconAPI.PreCall(1630);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, row);
            HalconAPI.StoreI(proc, 1, column);
            HalconAPI.StoreI(proc, 2, width);
            HalconAPI.StoreI(proc, 3, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Approximate an affine map from a displacement vector field.
        ///   Instance represents: Input image.
        /// </summary>
        /// <returns>Output transformation matrix.</returns>
        public HHomMat2D VectorFieldToHomMat2d()
        {
            IntPtr proc = HalconAPI.PreCall(1631);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HHomMat2D hhomMat2D;
            int procResult = HHomMat2D.LoadNew(proc, 0, err, out hhomMat2D);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hhomMat2D;
        }

        /// <summary>
        ///   Deserialize a serialized image object.
        ///   Modified instance represents: Image object.
        /// </summary>
        /// <param name="serializedItemHandle">Handle of the serialized item.</param>
        public void DeserializeImage(HSerializedItem serializedItemHandle)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1650);
            HalconAPI.Store(proc, 0, (HTool)serializedItemHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)serializedItemHandle);
        }

        /// <summary>
        ///   Serialize an image object.
        ///   Instance represents: Image object.
        /// </summary>
        /// <returns>Handle of the serialized item.</returns>
        public HSerializedItem SerializeImage()
        {
            IntPtr proc = HalconAPI.PreCall(1651);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HSerializedItem hserializedItem;
            int procResult = HSerializedItem.LoadNew(proc, 0, err, out hserializedItem);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hserializedItem;
        }

        /// <summary>
        ///   Write images in graphic formats.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="format">Graphic format. Default: "tiff"</param>
        /// <param name="fillColor">Fill gray value for pixels not belonging to the image domain (region). Default: 0</param>
        /// <param name="fileName">Name of image file.</param>
        public void WriteImage(string format, HTuple fillColor, HTuple fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1655);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, format);
            HalconAPI.Store(proc, 1, fillColor);
            HalconAPI.Store(proc, 2, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fillColor);
            HalconAPI.UnpinTuple(fileName);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Write images in graphic formats.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="format">Graphic format. Default: "tiff"</param>
        /// <param name="fillColor">Fill gray value for pixels not belonging to the image domain (region). Default: 0</param>
        /// <param name="fileName">Name of image file.</param>
        public void WriteImage(string format, int fillColor, string fileName)
        {
            IntPtr proc = HalconAPI.PreCall(1655);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, format);
            HalconAPI.StoreI(proc, 1, fillColor);
            HalconAPI.StoreS(proc, 2, fileName);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Read images.
        ///   Modified instance represents: Image read.
        /// </summary>
        /// <param name="headerSize">Number of bytes for file header. Default: 0</param>
        /// <param name="sourceWidth">Number of image columns of the filed image. Default: 512</param>
        /// <param name="sourceHeight">Number of image lines of the filed image. Default: 512</param>
        /// <param name="startRow">Starting point of image area (line). Default: 0</param>
        /// <param name="startColumn">Starting point of image area (column). Default: 0</param>
        /// <param name="destWidth">Number of image columns of output image. Default: 512</param>
        /// <param name="destHeight">Number of image lines of output image. Default: 512</param>
        /// <param name="pixelType">Type of pixel values. Default: "byte"</param>
        /// <param name="bitOrder">Sequence of bits within one byte. Default: "MSBFirst"</param>
        /// <param name="byteOrder">Sequence of bytes within one 'short' unit. Default: "MSBFirst"</param>
        /// <param name="pad">Data units within one image line (alignment). Default: "byte"</param>
        /// <param name="index">Number of images in the file. Default: 1</param>
        /// <param name="fileName">Name of input file.</param>
        public void ReadSequence(
          int headerSize,
          int sourceWidth,
          int sourceHeight,
          int startRow,
          int startColumn,
          int destWidth,
          int destHeight,
          string pixelType,
          string bitOrder,
          string byteOrder,
          string pad,
          int index,
          string fileName)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1656);
            HalconAPI.StoreI(proc, 0, headerSize);
            HalconAPI.StoreI(proc, 1, sourceWidth);
            HalconAPI.StoreI(proc, 2, sourceHeight);
            HalconAPI.StoreI(proc, 3, startRow);
            HalconAPI.StoreI(proc, 4, startColumn);
            HalconAPI.StoreI(proc, 5, destWidth);
            HalconAPI.StoreI(proc, 6, destHeight);
            HalconAPI.StoreS(proc, 7, pixelType);
            HalconAPI.StoreS(proc, 8, bitOrder);
            HalconAPI.StoreS(proc, 9, byteOrder);
            HalconAPI.StoreS(proc, 10, pad);
            HalconAPI.StoreI(proc, 11, index);
            HalconAPI.StoreS(proc, 12, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Read an image with different file formats.
        ///   Modified instance represents: Read image.
        /// </summary>
        /// <param name="fileName">Name of the image to be read. Default: "printer_chip/printer_chip_01"</param>
        public void ReadImage(HTuple fileName)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1658);
            HalconAPI.Store(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(fileName);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Read an image with different file formats.
        ///   Modified instance represents: Read image.
        /// </summary>
        /// <param name="fileName">Name of the image to be read. Default: "printer_chip/printer_chip_01"</param>
        public void ReadImage(string fileName)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1658);
            HalconAPI.StoreS(proc, 0, fileName);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Return gray values of an image at the positions of an XLD contour.
        ///   Instance represents: Image whose gray values are to be accessed.
        /// </summary>
        /// <param name="contour">Input XLD contour with the coordinates of the positions.</param>
        /// <param name="interpolation">Interpolation method. Default: "nearest_neighbor"</param>
        /// <returns>Gray values of the selected image coordinates.</returns>
        public HTuple GetGrayvalContourXld(HXLDCont contour, string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1668);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)contour);
            HalconAPI.StoreS(proc, 0, interpolation);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)contour);
            return tuple;
        }

        /// <summary>
        ///   Calculate gray value moments and approximation by a first order surface (plane).
        ///   Instance represents: Corresponding gray values.
        /// </summary>
        /// <param name="regions">Regions to be checked.</param>
        /// <param name="algorithm">Algorithm for the fitting. Default: "regression"</param>
        /// <param name="iterations">Maximum number of iterations (unused for 'regression'). Default: 5</param>
        /// <param name="clippingFactor">Clipping factor for the elimination of outliers. Default: 2.0</param>
        /// <param name="beta">Parameter Beta of the approximating surface.</param>
        /// <param name="gamma">Parameter Gamma of the approximating surface.</param>
        /// <returns>Parameter Alpha of the approximating surface.</returns>
        public HTuple FitSurfaceFirstOrder(
          HRegion regions,
          string algorithm,
          int iterations,
          double clippingFactor,
          out HTuple beta,
          out HTuple gamma)
        {
            IntPtr proc = HalconAPI.PreCall(1743);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreS(proc, 0, algorithm);
            HalconAPI.StoreI(proc, 1, iterations);
            HalconAPI.StoreD(proc, 2, clippingFactor);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out beta);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out gamma);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Calculate gray value moments and approximation by a first order surface (plane).
        ///   Instance represents: Corresponding gray values.
        /// </summary>
        /// <param name="regions">Regions to be checked.</param>
        /// <param name="algorithm">Algorithm for the fitting. Default: "regression"</param>
        /// <param name="iterations">Maximum number of iterations (unused for 'regression'). Default: 5</param>
        /// <param name="clippingFactor">Clipping factor for the elimination of outliers. Default: 2.0</param>
        /// <param name="beta">Parameter Beta of the approximating surface.</param>
        /// <param name="gamma">Parameter Gamma of the approximating surface.</param>
        /// <returns>Parameter Alpha of the approximating surface.</returns>
        public double FitSurfaceFirstOrder(
          HRegion regions,
          string algorithm,
          int iterations,
          double clippingFactor,
          out double beta,
          out double gamma)
        {
            IntPtr proc = HalconAPI.PreCall(1743);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreS(proc, 0, algorithm);
            HalconAPI.StoreI(proc, 1, iterations);
            HalconAPI.StoreD(proc, 2, clippingFactor);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int err2 = HalconAPI.LoadD(proc, 0, err1, out doubleValue);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out beta);
            int procResult = HalconAPI.LoadD(proc, 2, err3, out gamma);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return doubleValue;
        }

        /// <summary>
        ///   Calculate gray value moments and approximation by a second order surface.
        ///   Instance represents: Corresponding gray values.
        /// </summary>
        /// <param name="regions">Regions to be checked.</param>
        /// <param name="algorithm">Algorithm for the fitting. Default: "regression"</param>
        /// <param name="iterations">Maximum number of iterations (unused for 'regression'). Default: 5</param>
        /// <param name="clippingFactor">Clipping factor for the elimination of outliers. Default: 2.0</param>
        /// <param name="beta">Parameter Beta of the approximating surface.</param>
        /// <param name="gamma">Parameter Gamma of the approximating surface.</param>
        /// <param name="delta">Parameter Delta of the approximating surface.</param>
        /// <param name="epsilon">Parameter Epsilon of the approximating surface.</param>
        /// <param name="zeta">Parameter Zeta of the approximating surface.</param>
        /// <returns>Parameter Alpha of the approximating surface.</returns>
        public HTuple FitSurfaceSecondOrder(
          HRegion regions,
          string algorithm,
          int iterations,
          double clippingFactor,
          out HTuple beta,
          out HTuple gamma,
          out HTuple delta,
          out HTuple epsilon,
          out HTuple zeta)
        {
            IntPtr proc = HalconAPI.PreCall(1744);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreS(proc, 0, algorithm);
            HalconAPI.StoreI(proc, 1, iterations);
            HalconAPI.StoreD(proc, 2, clippingFactor);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out beta);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out gamma);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out delta);
            int err6 = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out epsilon);
            int procResult = HTuple.LoadNew(proc, 5, HTupleType.DOUBLE, err6, out zeta);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Calculate gray value moments and approximation by a second order surface.
        ///   Instance represents: Corresponding gray values.
        /// </summary>
        /// <param name="regions">Regions to be checked.</param>
        /// <param name="algorithm">Algorithm for the fitting. Default: "regression"</param>
        /// <param name="iterations">Maximum number of iterations (unused for 'regression'). Default: 5</param>
        /// <param name="clippingFactor">Clipping factor for the elimination of outliers. Default: 2.0</param>
        /// <param name="beta">Parameter Beta of the approximating surface.</param>
        /// <param name="gamma">Parameter Gamma of the approximating surface.</param>
        /// <param name="delta">Parameter Delta of the approximating surface.</param>
        /// <param name="epsilon">Parameter Epsilon of the approximating surface.</param>
        /// <param name="zeta">Parameter Zeta of the approximating surface.</param>
        /// <returns>Parameter Alpha of the approximating surface.</returns>
        public double FitSurfaceSecondOrder(
          HRegion regions,
          string algorithm,
          int iterations,
          double clippingFactor,
          out double beta,
          out double gamma,
          out double delta,
          out double epsilon,
          out double zeta)
        {
            IntPtr proc = HalconAPI.PreCall(1744);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreS(proc, 0, algorithm);
            HalconAPI.StoreI(proc, 1, iterations);
            HalconAPI.StoreD(proc, 2, clippingFactor);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            HalconAPI.InitOCT(proc, 5);
            int err1 = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int err2 = HalconAPI.LoadD(proc, 0, err1, out doubleValue);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out beta);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out gamma);
            int err5 = HalconAPI.LoadD(proc, 3, err4, out delta);
            int err6 = HalconAPI.LoadD(proc, 4, err5, out epsilon);
            int procResult = HalconAPI.LoadD(proc, 5, err6, out zeta);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return doubleValue;
        }

        /// <summary>
        ///   Create a curved gray surface with second order polynomial.
        ///   Modified instance represents: Created image with new image matrix.
        /// </summary>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="alpha">Second order coefficient in vertical direction. Default: 1.0</param>
        /// <param name="beta">Second order coefficient in horizontal direction. Default: 1.0</param>
        /// <param name="gamma">Mixed second order coefficient. Default: 1.0</param>
        /// <param name="delta">First order coefficient in vertical direction. Default: 1.0</param>
        /// <param name="epsilon">First order coefficient in horizontal direction. Default: 1.0</param>
        /// <param name="zeta">Zero order coefficient. Default: 1.0</param>
        /// <param name="row">Row coordinate of the reference point of the surface. Default: 256.0</param>
        /// <param name="column">Column coordinate of the reference point of the surface. Default: 256.0</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        public void GenImageSurfaceSecondOrder(
          string type,
          double alpha,
          double beta,
          double gamma,
          double delta,
          double epsilon,
          double zeta,
          double row,
          double column,
          int width,
          int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1745);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.StoreD(proc, 1, alpha);
            HalconAPI.StoreD(proc, 2, beta);
            HalconAPI.StoreD(proc, 3, gamma);
            HalconAPI.StoreD(proc, 4, delta);
            HalconAPI.StoreD(proc, 5, epsilon);
            HalconAPI.StoreD(proc, 6, zeta);
            HalconAPI.StoreD(proc, 7, row);
            HalconAPI.StoreD(proc, 8, column);
            HalconAPI.StoreI(proc, 9, width);
            HalconAPI.StoreI(proc, 10, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Create a tilted gray surface with first order polynomial.
        ///   Modified instance represents: Created image with new image matrix.
        /// </summary>
        /// <param name="type">Pixel type. Default: "byte"</param>
        /// <param name="alpha">First order coefficient in vertical direction. Default: 1.0</param>
        /// <param name="beta">First order coefficient in horizontal direction. Default: 1.0</param>
        /// <param name="gamma">Zero order coefficient. Default: 1.0</param>
        /// <param name="row">Row coordinate of the reference point of the surface. Default: 256.0</param>
        /// <param name="column">Column coordinate of the reference point of the surface. Default: 256.0</param>
        /// <param name="width">Width of image. Default: 512</param>
        /// <param name="height">Height of image. Default: 512</param>
        public void GenImageSurfaceFirstOrder(
          string type,
          double alpha,
          double beta,
          double gamma,
          double row,
          double column,
          int width,
          int height)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1746);
            HalconAPI.StoreS(proc, 0, type);
            HalconAPI.StoreD(proc, 1, alpha);
            HalconAPI.StoreD(proc, 2, beta);
            HalconAPI.StoreD(proc, 3, gamma);
            HalconAPI.StoreD(proc, 4, row);
            HalconAPI.StoreD(proc, 5, column);
            HalconAPI.StoreI(proc, 6, width);
            HalconAPI.StoreI(proc, 7, height);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Determine the minimum and maximum gray values within regions.
        ///   Instance represents: Gray value image.
        /// </summary>
        /// <param name="regions">Regions, the features of which are to be calculated.</param>
        /// <param name="percent">Percentage below (above) the absolute maximum (minimum). Default: 0</param>
        /// <param name="min">"Minimum" gray value.</param>
        /// <param name="max">"Maximum" gray value.</param>
        /// <param name="range">Difference between Max and Min.</param>
        public void MinMaxGray(
          HRegion regions,
          HTuple percent,
          out HTuple min,
          out HTuple max,
          out HTuple range)
        {
            IntPtr proc = HalconAPI.PreCall(1751);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, percent);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(percent);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out min);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out max);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out range);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
        }

        /// <summary>
        ///   Determine the minimum and maximum gray values within regions.
        ///   Instance represents: Gray value image.
        /// </summary>
        /// <param name="regions">Regions, the features of which are to be calculated.</param>
        /// <param name="percent">Percentage below (above) the absolute maximum (minimum). Default: 0</param>
        /// <param name="min">"Minimum" gray value.</param>
        /// <param name="max">"Maximum" gray value.</param>
        /// <param name="range">Difference between Max and Min.</param>
        public void MinMaxGray(
          HRegion regions,
          double percent,
          out double min,
          out double max,
          out double range)
        {
            IntPtr proc = HalconAPI.PreCall(1751);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreD(proc, 0, percent);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HalconAPI.LoadD(proc, 0, err1, out min);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out max);
            int procResult = HalconAPI.LoadD(proc, 2, err3, out range);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
        }

        /// <summary>
        ///   Calculate the mean and deviation of gray values.
        ///   Instance represents: Gray value image.
        /// </summary>
        /// <param name="regions">Regions in which the features are calculated.</param>
        /// <param name="deviation">Deviation of gray values within a region.</param>
        /// <returns>Mean gray value of a region.</returns>
        public HTuple Intensity(HRegion regions, out HTuple deviation)
        {
            IntPtr proc = HalconAPI.PreCall(1752);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out deviation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Calculate the mean and deviation of gray values.
        ///   Instance represents: Gray value image.
        /// </summary>
        /// <param name="regions">Regions in which the features are calculated.</param>
        /// <param name="deviation">Deviation of gray values within a region.</param>
        /// <returns>Mean gray value of a region.</returns>
        public double Intensity(HRegion regions, out double deviation)
        {
            IntPtr proc = HalconAPI.PreCall(1752);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int err2 = HalconAPI.LoadD(proc, 0, err1, out doubleValue);
            int procResult = HalconAPI.LoadD(proc, 1, err2, out deviation);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return doubleValue;
        }

        /// <summary>
        ///   Calculate the gray value distribution of a single channel image within a certain gray value range.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="regions">Region in which the histogram is to be calculated.</param>
        /// <param name="min">Minimum gray value. Default: 0</param>
        /// <param name="max">Maximum gray value. Default: 255</param>
        /// <param name="numBins">Number of bins. Default: 256</param>
        /// <param name="binSize">Bin size.</param>
        /// <returns>Histogram to be calculated.</returns>
        public HTuple GrayHistoRange(
          HRegion regions,
          HTuple min,
          HTuple max,
          int numBins,
          out double binSize)
        {
            IntPtr proc = HalconAPI.PreCall(1753);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, min);
            HalconAPI.Store(proc, 1, max);
            HalconAPI.StoreI(proc, 2, numBins);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(min);
            HalconAPI.UnpinTuple(max);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out tuple);
            int procResult = HalconAPI.LoadD(proc, 1, err2, out binSize);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Calculate the gray value distribution of a single channel image within a certain gray value range.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="regions">Region in which the histogram is to be calculated.</param>
        /// <param name="min">Minimum gray value. Default: 0</param>
        /// <param name="max">Maximum gray value. Default: 255</param>
        /// <param name="numBins">Number of bins. Default: 256</param>
        /// <param name="binSize">Bin size.</param>
        /// <returns>Histogram to be calculated.</returns>
        public int GrayHistoRange(
          HRegion regions,
          double min,
          double max,
          int numBins,
          out double binSize)
        {
            IntPtr proc = HalconAPI.PreCall(1753);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreD(proc, 0, min);
            HalconAPI.StoreD(proc, 1, max);
            HalconAPI.StoreI(proc, 2, numBins);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            int intValue;
            int err2 = HalconAPI.LoadI(proc, 0, err1, out intValue);
            int procResult = HalconAPI.LoadD(proc, 1, err2, out binSize);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return intValue;
        }

        /// <summary>
        ///   Calculate the histogram of two-channel gray value images.
        ///   Instance represents: Channel 1.
        /// </summary>
        /// <param name="regions">Region in which the histogram is to be calculated.</param>
        /// <param name="imageRow">Channel 2.</param>
        /// <returns>Histogram to be calculated.</returns>
        public HImage Histo2dim(HRegion regions, HImage imageRow)
        {
            IntPtr proc = HalconAPI.PreCall(1754);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 3, (HObjectBase)imageRow);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            GC.KeepAlive((object)imageRow);
            return himage;
        }

        /// <summary>
        ///   Calculate the gray value distribution.
        ///   Instance represents: Image the gray value distribution of which is to be calculated.
        /// </summary>
        /// <param name="regions">Region in which the histogram is to be calculated.</param>
        /// <param name="quantization">Quantization of the gray values. Default: 1.0</param>
        /// <returns>Absolute frequencies of the gray values.</returns>
        public HTuple GrayHistoAbs(HRegion regions, HTuple quantization)
        {
            IntPtr proc = HalconAPI.PreCall(1755);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.Store(proc, 0, quantization);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(quantization);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Calculate the gray value distribution.
        ///   Instance represents: Image the gray value distribution of which is to be calculated.
        /// </summary>
        /// <param name="regions">Region in which the histogram is to be calculated.</param>
        /// <param name="quantization">Quantization of the gray values. Default: 1.0</param>
        /// <returns>Absolute frequencies of the gray values.</returns>
        public HTuple GrayHistoAbs(HRegion regions, double quantization)
        {
            IntPtr proc = HalconAPI.PreCall(1755);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreD(proc, 0, quantization);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Calculate the gray value distribution.
        ///   Instance represents: Image the gray value distribution of which is to be calculated.
        /// </summary>
        /// <param name="regions">Region in which the histogram is to be calculated.</param>
        /// <param name="relativeHisto">Frequencies, normalized to the area of the region.</param>
        /// <returns>Absolute frequencies of the gray values.</returns>
        public HTuple GrayHisto(HRegion regions, out HTuple relativeHisto)
        {
            IntPtr proc = HalconAPI.PreCall(1756);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out relativeHisto);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Determine the entropy and anisotropy of images.
        ///   Instance represents: Gray value image.
        /// </summary>
        /// <param name="regions">Regions where the features are to be determined.</param>
        /// <param name="anisotropy">Measure of the symmetry of gray value distribution.</param>
        /// <returns>Information content (entropy) of the gray values.</returns>
        public HTuple EntropyGray(HRegion regions, out HTuple anisotropy)
        {
            IntPtr proc = HalconAPI.PreCall(1757);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out anisotropy);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Determine the entropy and anisotropy of images.
        ///   Instance represents: Gray value image.
        /// </summary>
        /// <param name="regions">Regions where the features are to be determined.</param>
        /// <param name="anisotropy">Measure of the symmetry of gray value distribution.</param>
        /// <returns>Information content (entropy) of the gray values.</returns>
        public double EntropyGray(HRegion regions, out double anisotropy)
        {
            IntPtr proc = HalconAPI.PreCall(1757);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int err2 = HalconAPI.LoadD(proc, 0, err1, out doubleValue);
            int procResult = HalconAPI.LoadD(proc, 1, err2, out anisotropy);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return doubleValue;
        }

        /// <summary>
        ///   Calculate gray value features from a co-occurrence matrix.
        ///   Instance represents: Co-occurrence matrix.
        /// </summary>
        /// <param name="correlation">Correlation of gray values.</param>
        /// <param name="homogeneity">Local homogeneity of gray values.</param>
        /// <param name="contrast">Gray value contrast.</param>
        /// <returns>Homogeneity of the gray values.</returns>
        public double CoocFeatureMatrix(
          out double correlation,
          out double homogeneity,
          out double contrast)
        {
            IntPtr proc = HalconAPI.PreCall(1758);
            this.Store(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int err2 = HalconAPI.LoadD(proc, 0, err1, out doubleValue);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out correlation);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out homogeneity);
            int procResult = HalconAPI.LoadD(proc, 3, err4, out contrast);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return doubleValue;
        }

        /// <summary>
        ///   Calculate a co-occurrence matrix and derive gray value features thereof.
        ///   Instance represents: Corresponding gray values.
        /// </summary>
        /// <param name="regions">Region to be examined.</param>
        /// <param name="ldGray">Number of gray values to be distinguished (2^LdGray@f$2^{LdGray}$). Default: 6</param>
        /// <param name="direction">Direction in which the matrix is to be calculated. Default: 0</param>
        /// <param name="correlation">Correlation of gray values.</param>
        /// <param name="homogeneity">Local homogeneity of gray values.</param>
        /// <param name="contrast">Gray value contrast.</param>
        /// <returns>Gray value energy.</returns>
        public HTuple CoocFeatureImage(
          HRegion regions,
          int ldGray,
          HTuple direction,
          out HTuple correlation,
          out HTuple homogeneity,
          out HTuple contrast)
        {
            IntPtr proc = HalconAPI.PreCall(1759);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreI(proc, 0, ldGray);
            HalconAPI.Store(proc, 1, direction);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(direction);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out correlation);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out homogeneity);
            int procResult = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out contrast);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Calculate a co-occurrence matrix and derive gray value features thereof.
        ///   Instance represents: Corresponding gray values.
        /// </summary>
        /// <param name="regions">Region to be examined.</param>
        /// <param name="ldGray">Number of gray values to be distinguished (2^LdGray@f$2^{LdGray}$). Default: 6</param>
        /// <param name="direction">Direction in which the matrix is to be calculated. Default: 0</param>
        /// <param name="correlation">Correlation of gray values.</param>
        /// <param name="homogeneity">Local homogeneity of gray values.</param>
        /// <param name="contrast">Gray value contrast.</param>
        /// <returns>Gray value energy.</returns>
        public double CoocFeatureImage(
          HRegion regions,
          int ldGray,
          int direction,
          out double correlation,
          out double homogeneity,
          out double contrast)
        {
            IntPtr proc = HalconAPI.PreCall(1759);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreI(proc, 0, ldGray);
            HalconAPI.StoreI(proc, 1, direction);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int err2 = HalconAPI.LoadD(proc, 0, err1, out doubleValue);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out correlation);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out homogeneity);
            int procResult = HalconAPI.LoadD(proc, 3, err4, out contrast);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return doubleValue;
        }

        /// <summary>
        ///   Calculate the co-occurrence matrix of a region in an image.
        ///   Instance represents: Image providing the gray values.
        /// </summary>
        /// <param name="regions">Region to be checked.</param>
        /// <param name="ldGray">Number of gray values to be distinguished (2^LdGray@f$2^{LdGray}$). Default: 6</param>
        /// <param name="direction">Direction of neighbor relation. Default: 0</param>
        /// <returns>Co-occurrence matrix (matrices).</returns>
        public HImage GenCoocMatrix(HRegion regions, int ldGray, int direction)
        {
            IntPtr proc = HalconAPI.PreCall(1760);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.StoreI(proc, 0, ldGray);
            HalconAPI.StoreI(proc, 1, direction);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return himage;
        }

        /// <summary>
        ///   Calculate gray value moments and approximation by a plane.
        ///   Instance represents: Corresponding gray values.
        /// </summary>
        /// <param name="regions">Regions to be checked.</param>
        /// <param name="MRow">Mixed moments along a line.</param>
        /// <param name="MCol">Mixed moments along a column.</param>
        /// <param name="alpha">Parameter Alpha of the approximating plane.</param>
        /// <param name="beta">Parameter Beta of the approximating plane.</param>
        /// <param name="mean">Mean gray value.</param>
        public void MomentsGrayPlane(
          HRegion regions,
          out HTuple MRow,
          out HTuple MCol,
          out HTuple alpha,
          out HTuple beta,
          out HTuple mean)
        {
            IntPtr proc = HalconAPI.PreCall(1761);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out MRow);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out MCol);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out alpha);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out beta);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.DOUBLE, err5, out mean);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
        }

        /// <summary>
        ///   Calculate gray value moments and approximation by a plane.
        ///   Instance represents: Corresponding gray values.
        /// </summary>
        /// <param name="regions">Regions to be checked.</param>
        /// <param name="MRow">Mixed moments along a line.</param>
        /// <param name="MCol">Mixed moments along a column.</param>
        /// <param name="alpha">Parameter Alpha of the approximating plane.</param>
        /// <param name="beta">Parameter Beta of the approximating plane.</param>
        /// <param name="mean">Mean gray value.</param>
        public void MomentsGrayPlane(
          HRegion regions,
          out double MRow,
          out double MCol,
          out double alpha,
          out double beta,
          out double mean)
        {
            IntPtr proc = HalconAPI.PreCall(1761);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HalconAPI.LoadD(proc, 0, err1, out MRow);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out MCol);
            int err4 = HalconAPI.LoadD(proc, 2, err3, out alpha);
            int err5 = HalconAPI.LoadD(proc, 3, err4, out beta);
            int procResult = HalconAPI.LoadD(proc, 4, err5, out mean);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
        }

        /// <summary>
        ///   Calculate the deviation of the gray values from the approximating image plane.
        ///   Instance represents: Gray value image.
        /// </summary>
        /// <param name="regions">Regions, of which the plane deviation is to be calculated.</param>
        /// <returns>Deviation of the gray values within a region.</returns>
        public HTuple PlaneDeviation(HRegion regions)
        {
            IntPtr proc = HalconAPI.PreCall(1762);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Compute the orientation and major axes of a region in a gray value image.
        ///   Instance represents: Gray value image.
        /// </summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="rb">Minor axis of the region.</param>
        /// <param name="phi">Angle enclosed by the major axis and the x-axis.</param>
        /// <returns>Major axis of the region.</returns>
        public HTuple EllipticAxisGray(HRegion regions, out HTuple rb, out HTuple phi)
        {
            IntPtr proc = HalconAPI.PreCall(1763);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out rb);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out phi);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Compute the orientation and major axes of a region in a gray value image.
        ///   Instance represents: Gray value image.
        /// </summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="rb">Minor axis of the region.</param>
        /// <param name="phi">Angle enclosed by the major axis and the x-axis.</param>
        /// <returns>Major axis of the region.</returns>
        public double EllipticAxisGray(HRegion regions, out double rb, out double phi)
        {
            IntPtr proc = HalconAPI.PreCall(1763);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int err2 = HalconAPI.LoadD(proc, 0, err1, out doubleValue);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out rb);
            int procResult = HalconAPI.LoadD(proc, 2, err3, out phi);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return doubleValue;
        }

        /// <summary>
        ///   Compute the area and center of gravity of a region in a gray value image.
        ///   Instance represents: Gray value image.
        /// </summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="row">Row coordinate of the gray value center of gravity.</param>
        /// <param name="column">Column coordinate of the gray value center of gravity.</param>
        /// <returns>Gray value volume of the region.</returns>
        public HTuple AreaCenterGray(HRegion regions, out HTuple row, out HTuple column)
        {
            IntPtr proc = HalconAPI.PreCall(1764);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out row);
            int procResult = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return tuple;
        }

        /// <summary>
        ///   Compute the area and center of gravity of a region in a gray value image.
        ///   Instance represents: Gray value image.
        /// </summary>
        /// <param name="regions">Region(s) to be examined.</param>
        /// <param name="row">Row coordinate of the gray value center of gravity.</param>
        /// <param name="column">Column coordinate of the gray value center of gravity.</param>
        /// <returns>Gray value volume of the region.</returns>
        public double AreaCenterGray(HRegion regions, out double row, out double column)
        {
            IntPtr proc = HalconAPI.PreCall(1764);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)regions);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            double doubleValue;
            int err2 = HalconAPI.LoadD(proc, 0, err1, out doubleValue);
            int err3 = HalconAPI.LoadD(proc, 1, err2, out row);
            int procResult = HalconAPI.LoadD(proc, 2, err3, out column);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)regions);
            return doubleValue;
        }

        /// <summary>
        ///   Calculate horizontal and vertical gray-value projections.
        ///   Instance represents: Grayvalues for projections.
        /// </summary>
        /// <param name="region">Region to be processed.</param>
        /// <param name="mode">Method to compute the projections. Default: "simple"</param>
        /// <param name="vertProjection">Vertical projection.</param>
        /// <returns>Horizontal projection.</returns>
        public HTuple GrayProjections(HRegion region, string mode, out HTuple vertProjection)
        {
            IntPtr proc = HalconAPI.PreCall(1765);
            this.Store(proc, 2);
            HalconAPI.Store(proc, 1, (HObjectBase)region);
            HalconAPI.StoreS(proc, 0, mode);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int procResult = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out vertProjection);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return tuple;
        }

        /// <summary>
        ///   Detect and read 2D data code symbols in an image or train the 2D data code model.
        ///   Instance represents: Input image. If the image has a reduced domain, the data code search is reduced to that domain. This usually reduces the runtime of the operator. However, if the datacode is not fully inside the domain, the datacode might not be found correctly. In rare cases, data codes may be found outside the domain. If these results  are undesirable, they have to be subsequently eliminated.
        /// </summary>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        /// <param name="genParamName">Names of (optional) parameters for controlling the behavior of the operator. Default: []</param>
        /// <param name="genParamValue">Values of the optional generic parameters. Default: []</param>
        /// <param name="resultHandles">Handles of all successfully decoded 2D data code symbols.</param>
        /// <param name="decodedDataStrings">Decoded data strings of all detected 2D data code symbols in the image.</param>
        /// <returns>XLD contours that surround the successfully decoded data code symbols. The order of the contour points reflects the orientation of the detected symbols. The contours begin in the top left corner (see 'orientation' at get_data_code_2d_results) and continue clockwise.  Alignment{left} Figure[1][1][60]{get_data_code_2d_results-xld_qrcode} Order of points of SymbolXLDs Figure Alignment @f$ </returns>
        public HXLDCont FindDataCode2d(
          HDataCode2D dataCodeHandle,
          HTuple genParamName,
          HTuple genParamValue,
          out HTuple resultHandles,
          out HTuple decodedDataStrings)
        {
            IntPtr proc = HalconAPI.PreCall(1768);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)dataCodeHandle);
            HalconAPI.Store(proc, 1, genParamName);
            HalconAPI.Store(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HXLDCont hxldCont;
            int err2 = HXLDCont.LoadNew(proc, 1, err1, out hxldCont);
            int err3 = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err2, out resultHandles);
            int procResult = HTuple.LoadNew(proc, 1, err3, out decodedDataStrings);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)dataCodeHandle);
            return hxldCont;
        }

        /// <summary>
        ///   Detect and read 2D data code symbols in an image or train the 2D data code model.
        ///   Instance represents: Input image. If the image has a reduced domain, the data code search is reduced to that domain. This usually reduces the runtime of the operator. However, if the datacode is not fully inside the domain, the datacode might not be found correctly. In rare cases, data codes may be found outside the domain. If these results  are undesirable, they have to be subsequently eliminated.
        /// </summary>
        /// <param name="dataCodeHandle">Handle of the 2D data code model.</param>
        /// <param name="genParamName">Names of (optional) parameters for controlling the behavior of the operator. Default: []</param>
        /// <param name="genParamValue">Values of the optional generic parameters. Default: []</param>
        /// <param name="resultHandles">Handles of all successfully decoded 2D data code symbols.</param>
        /// <param name="decodedDataStrings">Decoded data strings of all detected 2D data code symbols in the image.</param>
        /// <returns>XLD contours that surround the successfully decoded data code symbols. The order of the contour points reflects the orientation of the detected symbols. The contours begin in the top left corner (see 'orientation' at get_data_code_2d_results) and continue clockwise.  Alignment{left} Figure[1][1][60]{get_data_code_2d_results-xld_qrcode} Order of points of SymbolXLDs Figure Alignment @f$ </returns>
        public HXLDCont FindDataCode2d(
          HDataCode2D dataCodeHandle,
          string genParamName,
          int genParamValue,
          out int resultHandles,
          out string decodedDataStrings)
        {
            IntPtr proc = HalconAPI.PreCall(1768);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)dataCodeHandle);
            HalconAPI.StoreS(proc, 1, genParamName);
            HalconAPI.StoreI(proc, 2, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HXLDCont hxldCont;
            int err2 = HXLDCont.LoadNew(proc, 1, err1, out hxldCont);
            int err3 = HalconAPI.LoadI(proc, 0, err2, out resultHandles);
            int procResult = HalconAPI.LoadS(proc, 1, err3, out decodedDataStrings);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)dataCodeHandle);
            return hxldCont;
        }

        /// <summary>
        ///   Convert image maps into other map types.
        ///   Instance represents: Input map.
        /// </summary>
        /// <param name="newType">Type of MapConverted. Default: "coord_map_sub_pix"</param>
        /// <param name="imageWidth">Width of images to be mapped. Default: "map_width"</param>
        /// <returns>Converted map.</returns>
        public HImage ConvertMapType(string newType, HTuple imageWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1901);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, newType);
            HalconAPI.Store(proc, 1, imageWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(imageWidth);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Convert image maps into other map types.
        ///   Instance represents: Input map.
        /// </summary>
        /// <param name="newType">Type of MapConverted. Default: "coord_map_sub_pix"</param>
        /// <param name="imageWidth">Width of images to be mapped. Default: "map_width"</param>
        /// <returns>Converted map.</returns>
        public HImage ConvertMapType(string newType, int imageWidth)
        {
            IntPtr proc = HalconAPI.PreCall(1901);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, newType);
            HalconAPI.StoreI(proc, 1, imageWidth);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>Compute an absolute pose out of point correspondences between world and image coordinates.</summary>
        /// <param name="worldX">X-Component of world coordinates.</param>
        /// <param name="worldY">Y-Component of world coordinates.</param>
        /// <param name="worldZ">Z-Component of world coordinates.</param>
        /// <param name="imageRow">Row-Component of image coordinates.</param>
        /// <param name="imageColumn">Column-Component of image coordinates.</param>
        /// <param name="cameraParam">The inner camera parameters from camera calibration.</param>
        /// <param name="method">Kind of algorithm Default: "iterative"</param>
        /// <param name="qualityType">Type of pose quality to be returned in Quality. Default: "error"</param>
        /// <param name="quality">Pose quality.</param>
        /// <returns>Pose.</returns>
        public static HPose VectorToPose(
          HTuple worldX,
          HTuple worldY,
          HTuple worldZ,
          HTuple imageRow,
          HTuple imageColumn,
          HCamPar cameraParam,
          string method,
          HTuple qualityType,
          out HTuple quality)
        {
            IntPtr proc = HalconAPI.PreCall(1902);
            HalconAPI.Store(proc, 0, worldX);
            HalconAPI.Store(proc, 1, worldY);
            HalconAPI.Store(proc, 2, worldZ);
            HalconAPI.Store(proc, 3, imageRow);
            HalconAPI.Store(proc, 4, imageColumn);
            HalconAPI.Store(proc, 5, (HData)cameraParam);
            HalconAPI.StoreS(proc, 6, method);
            HalconAPI.Store(proc, 7, qualityType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(worldX);
            HalconAPI.UnpinTuple(worldY);
            HalconAPI.UnpinTuple(worldZ);
            HalconAPI.UnpinTuple(imageRow);
            HalconAPI.UnpinTuple(imageColumn);
            HalconAPI.UnpinTuple((HTuple)((HData)cameraParam));
            HalconAPI.UnpinTuple(qualityType);
            HPose hpose;
            int err2 = HPose.LoadNew(proc, 0, err1, out hpose);
            int procResult = HTuple.LoadNew(proc, 1, err2, out quality);
            HalconAPI.PostCall(proc, procResult);
            return hpose;
        }

        /// <summary>Compute an absolute pose out of point correspondences between world and image coordinates.</summary>
        /// <param name="worldX">X-Component of world coordinates.</param>
        /// <param name="worldY">Y-Component of world coordinates.</param>
        /// <param name="worldZ">Z-Component of world coordinates.</param>
        /// <param name="imageRow">Row-Component of image coordinates.</param>
        /// <param name="imageColumn">Column-Component of image coordinates.</param>
        /// <param name="cameraParam">The inner camera parameters from camera calibration.</param>
        /// <param name="method">Kind of algorithm Default: "iterative"</param>
        /// <param name="qualityType">Type of pose quality to be returned in Quality. Default: "error"</param>
        /// <param name="quality">Pose quality.</param>
        /// <returns>Pose.</returns>
        public static HPose VectorToPose(
          HTuple worldX,
          HTuple worldY,
          HTuple worldZ,
          HTuple imageRow,
          HTuple imageColumn,
          HCamPar cameraParam,
          string method,
          string qualityType,
          out double quality)
        {
            IntPtr proc = HalconAPI.PreCall(1902);
            HalconAPI.Store(proc, 0, worldX);
            HalconAPI.Store(proc, 1, worldY);
            HalconAPI.Store(proc, 2, worldZ);
            HalconAPI.Store(proc, 3, imageRow);
            HalconAPI.Store(proc, 4, imageColumn);
            HalconAPI.Store(proc, 5, (HData)cameraParam);
            HalconAPI.StoreS(proc, 6, method);
            HalconAPI.StoreS(proc, 7, qualityType);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(worldX);
            HalconAPI.UnpinTuple(worldY);
            HalconAPI.UnpinTuple(worldZ);
            HalconAPI.UnpinTuple(imageRow);
            HalconAPI.UnpinTuple(imageColumn);
            HalconAPI.UnpinTuple((HTuple)((HData)cameraParam));
            HPose hpose;
            int err2 = HPose.LoadNew(proc, 0, err1, out hpose);
            int procResult = HalconAPI.LoadD(proc, 1, err2, out quality);
            HalconAPI.PostCall(proc, procResult);
            return hpose;
        }

        /// <summary>Compute a pose out of a homography describing the relation between world and image coordinates.</summary>
        /// <param name="homography">The homography from world- to image coordinates.</param>
        /// <param name="cameraMatrix">The camera calibration matrix K.</param>
        /// <param name="method">Type of pose computation. Default: "decomposition"</param>
        /// <returns>Pose of the 2D object.</returns>
        public static HPose ProjHomMat2dToPose(
          HHomMat2D homography,
          HHomMat2D cameraMatrix,
          string method)
        {
            IntPtr proc = HalconAPI.PreCall(1903);
            HalconAPI.Store(proc, 0, (HData)homography);
            HalconAPI.Store(proc, 1, (HData)cameraMatrix);
            HalconAPI.StoreS(proc, 2, method);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)homography));
            HalconAPI.UnpinTuple((HTuple)((HData)cameraMatrix));
            HPose hpose;
            int procResult = HPose.LoadNew(proc, 0, err, out hpose);
            HalconAPI.PostCall(proc, procResult);
            return hpose;
        }

        /// <summary>
        ///   Perform a radiometric self-calibration of a camera.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="exposureRatios">Ratio of the exposure energies of successive image pairs. Default: 0.5</param>
        /// <param name="features">Features that are used to compute the inverse response function of the camera. Default: "2d_histogram"</param>
        /// <param name="functionType">Type of the inverse response function of the camera. Default: "discrete"</param>
        /// <param name="smoothness">Smoothness of the inverse response function of the camera. Default: 1.0</param>
        /// <param name="polynomialDegree">Degree of the polynomial if FunctionType = 'polynomial'. Default: 5</param>
        /// <returns>Inverse response function of the camera.</returns>
        public HTuple RadiometricSelfCalibration(
          HTuple exposureRatios,
          string features,
          string functionType,
          double smoothness,
          int polynomialDegree)
        {
            IntPtr proc = HalconAPI.PreCall(1910);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, exposureRatios);
            HalconAPI.StoreS(proc, 1, features);
            HalconAPI.StoreS(proc, 2, functionType);
            HalconAPI.StoreD(proc, 3, smoothness);
            HalconAPI.StoreI(proc, 4, polynomialDegree);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(exposureRatios);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Perform a radiometric self-calibration of a camera.
        ///   Instance represents: Input images.
        /// </summary>
        /// <param name="exposureRatios">Ratio of the exposure energies of successive image pairs. Default: 0.5</param>
        /// <param name="features">Features that are used to compute the inverse response function of the camera. Default: "2d_histogram"</param>
        /// <param name="functionType">Type of the inverse response function of the camera. Default: "discrete"</param>
        /// <param name="smoothness">Smoothness of the inverse response function of the camera. Default: 1.0</param>
        /// <param name="polynomialDegree">Degree of the polynomial if FunctionType = 'polynomial'. Default: 5</param>
        /// <returns>Inverse response function of the camera.</returns>
        public HTuple RadiometricSelfCalibration(
          double exposureRatios,
          string features,
          string functionType,
          double smoothness,
          int polynomialDegree)
        {
            IntPtr proc = HalconAPI.PreCall(1910);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, exposureRatios);
            HalconAPI.StoreS(proc, 1, features);
            HalconAPI.StoreS(proc, 2, functionType);
            HalconAPI.StoreD(proc, 3, smoothness);
            HalconAPI.StoreI(proc, 4, polynomialDegree);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return tuple;
        }

        /// <summary>
        ///   Apply a general transformation to an image.
        ///   Instance represents: Image to be mapped.
        /// </summary>
        /// <param name="map">Image containing the mapping data.</param>
        /// <returns>Mapped image.</returns>
        public HImage MapImage(HImage map)
        {
            IntPtr proc = HalconAPI.PreCall(1911);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)map);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)map);
            return himage;
        }

        /// <summary>
        ///   Generate a projection map that describes the mapping of images corresponding to a changing radial distortion.
        ///   Modified instance represents: Image containing the mapping data.
        /// </summary>
        /// <param name="camParamIn">Old camera parameters.</param>
        /// <param name="camParamOut">New camera parameters.</param>
        /// <param name="mapType">Type of the mapping. Default: "bilinear"</param>
        public void GenRadialDistortionMap(HCamPar camParamIn, HCamPar camParamOut, string mapType)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1912);
            HalconAPI.Store(proc, 0, (HData)camParamIn);
            HalconAPI.Store(proc, 1, (HData)camParamOut);
            HalconAPI.StoreS(proc, 2, mapType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParamIn));
            HalconAPI.UnpinTuple((HTuple)((HData)camParamOut));
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate a projection map that describes the mapping between the image plane and a the plane z=0 of a world coordinate system.
        ///   Modified instance represents: Image containing the mapping data.
        /// </summary>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="worldPose">3D pose of the world coordinate system in camera coordinates.</param>
        /// <param name="widthIn">Width of the images to be transformed.</param>
        /// <param name="heightIn">Height of the images to be transformed.</param>
        /// <param name="widthMapped">Width of the resulting mapped images in pixels.</param>
        /// <param name="heightMapped">Height of the resulting mapped images in pixels.</param>
        /// <param name="scale">Scale or unit. Default: "m"</param>
        /// <param name="mapType">Type of the mapping. Default: "bilinear"</param>
        public void GenImageToWorldPlaneMap(
          HCamPar cameraParam,
          HPose worldPose,
          int widthIn,
          int heightIn,
          int widthMapped,
          int heightMapped,
          HTuple scale,
          string mapType)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1913);
            HalconAPI.Store(proc, 0, (HData)cameraParam);
            HalconAPI.Store(proc, 1, (HData)worldPose);
            HalconAPI.StoreI(proc, 2, widthIn);
            HalconAPI.StoreI(proc, 3, heightIn);
            HalconAPI.StoreI(proc, 4, widthMapped);
            HalconAPI.StoreI(proc, 5, heightMapped);
            HalconAPI.Store(proc, 6, scale);
            HalconAPI.StoreS(proc, 7, mapType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)cameraParam));
            HalconAPI.UnpinTuple((HTuple)((HData)worldPose));
            HalconAPI.UnpinTuple(scale);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Generate a projection map that describes the mapping between the image plane and a the plane z=0 of a world coordinate system.
        ///   Modified instance represents: Image containing the mapping data.
        /// </summary>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="worldPose">3D pose of the world coordinate system in camera coordinates.</param>
        /// <param name="widthIn">Width of the images to be transformed.</param>
        /// <param name="heightIn">Height of the images to be transformed.</param>
        /// <param name="widthMapped">Width of the resulting mapped images in pixels.</param>
        /// <param name="heightMapped">Height of the resulting mapped images in pixels.</param>
        /// <param name="scale">Scale or unit. Default: "m"</param>
        /// <param name="mapType">Type of the mapping. Default: "bilinear"</param>
        public void GenImageToWorldPlaneMap(
          HCamPar cameraParam,
          HPose worldPose,
          int widthIn,
          int heightIn,
          int widthMapped,
          int heightMapped,
          string scale,
          string mapType)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1913);
            HalconAPI.Store(proc, 0, (HData)cameraParam);
            HalconAPI.Store(proc, 1, (HData)worldPose);
            HalconAPI.StoreI(proc, 2, widthIn);
            HalconAPI.StoreI(proc, 3, heightIn);
            HalconAPI.StoreI(proc, 4, widthMapped);
            HalconAPI.StoreI(proc, 5, heightMapped);
            HalconAPI.StoreS(proc, 6, scale);
            HalconAPI.StoreS(proc, 7, mapType);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)cameraParam));
            HalconAPI.UnpinTuple((HTuple)((HData)worldPose));
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Rectify an image by transforming it into the plane z=0 of a world coordinate system.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="worldPose">3D pose of the world coordinate system in camera coordinates.</param>
        /// <param name="width">Width of the resulting image in pixels.</param>
        /// <param name="height">Height of the resulting image in pixels.</param>
        /// <param name="scale">Scale or unit Default: "m"</param>
        /// <param name="interpolation">Type of interpolation. Default: "bilinear"</param>
        /// <returns>Transformed image.</returns>
        public HImage ImageToWorldPlane(
          HCamPar cameraParam,
          HPose worldPose,
          int width,
          int height,
          HTuple scale,
          string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1914);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HData)cameraParam);
            HalconAPI.Store(proc, 1, (HData)worldPose);
            HalconAPI.StoreI(proc, 2, width);
            HalconAPI.StoreI(proc, 3, height);
            HalconAPI.Store(proc, 4, scale);
            HalconAPI.StoreS(proc, 5, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)cameraParam));
            HalconAPI.UnpinTuple((HTuple)((HData)worldPose));
            HalconAPI.UnpinTuple(scale);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Rectify an image by transforming it into the plane z=0 of a world coordinate system.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="worldPose">3D pose of the world coordinate system in camera coordinates.</param>
        /// <param name="width">Width of the resulting image in pixels.</param>
        /// <param name="height">Height of the resulting image in pixels.</param>
        /// <param name="scale">Scale or unit Default: "m"</param>
        /// <param name="interpolation">Type of interpolation. Default: "bilinear"</param>
        /// <returns>Transformed image.</returns>
        public HImage ImageToWorldPlane(
          HCamPar cameraParam,
          HPose worldPose,
          int width,
          int height,
          string scale,
          string interpolation)
        {
            IntPtr proc = HalconAPI.PreCall(1914);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HData)cameraParam);
            HalconAPI.Store(proc, 1, (HData)worldPose);
            HalconAPI.StoreI(proc, 2, width);
            HalconAPI.StoreI(proc, 3, height);
            HalconAPI.StoreS(proc, 4, scale);
            HalconAPI.StoreS(proc, 5, interpolation);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)cameraParam));
            HalconAPI.UnpinTuple((HTuple)((HData)worldPose));
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Change the radial distortion of an image.
        ///   Instance represents: Original image.
        /// </summary>
        /// <param name="region">Region of interest in ImageRectified.</param>
        /// <param name="camParamIn">Internal camera parameter for Image.</param>
        /// <param name="camParamOut">Internal camera parameter for Image.</param>
        /// <returns>Resulting image with modified radial distortion.</returns>
        public HImage ChangeRadialDistortionImage(
          HRegion region,
          HCamPar camParamIn,
          HCamPar camParamOut)
        {
            IntPtr proc = HalconAPI.PreCall(1924);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)region);
            HalconAPI.Store(proc, 0, (HData)camParamIn);
            HalconAPI.Store(proc, 1, (HData)camParamOut);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)camParamIn));
            HalconAPI.UnpinTuple((HTuple)((HData)camParamOut));
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)region);
            return himage;
        }

        /// <summary>
        ///   Simulate an image with calibration plate.
        ///   Modified instance represents: Simulated calibration image.
        /// </summary>
        /// <param name="calPlateDescr">File name of the calibration plate description. Default: "calplate.cpd"</param>
        /// <param name="cameraParam">Internal camera parameters.</param>
        /// <param name="calPlatePose">External camera parameters (3D pose of the calibration plate in camera coordinates).</param>
        /// <param name="grayBackground">Gray value of image background. Default: 128</param>
        /// <param name="grayPlate">Gray value of calibration plate. Default: 80</param>
        /// <param name="grayMarks">Gray value of calibration marks. Default: 224</param>
        /// <param name="scaleFac">Scaling factor to reduce oversampling. Default: 1.0</param>
        public void SimCaltab(
          string calPlateDescr,
          HCamPar cameraParam,
          HPose calPlatePose,
          int grayBackground,
          int grayPlate,
          int grayMarks,
          double scaleFac)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(1944);
            HalconAPI.StoreS(proc, 0, calPlateDescr);
            HalconAPI.Store(proc, 1, (HData)cameraParam);
            HalconAPI.Store(proc, 2, (HData)calPlatePose);
            HalconAPI.StoreI(proc, 3, grayBackground);
            HalconAPI.StoreI(proc, 4, grayPlate);
            HalconAPI.StoreI(proc, 5, grayMarks);
            HalconAPI.StoreD(proc, 6, scaleFac);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)cameraParam));
            HalconAPI.UnpinTuple((HTuple)((HData)calPlatePose));
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
        }

        /// <summary>
        ///   Extract rectangularly arranged 2D calibration marks from the image and calculate initial values for the external camera parameters.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="calPlateRegion">Region of the calibration plate.</param>
        /// <param name="calPlateDescr">File name of the calibration plate description. Default: "caltab.descr"</param>
        /// <param name="startCamParam">Initial values for the internal camera parameters.</param>
        /// <param name="startThresh">Initial threshold value for contour detection. Default: 128</param>
        /// <param name="deltaThresh">Loop value for successive reduction of StartThresh. Default: 10</param>
        /// <param name="minThresh">Minimum threshold for contour detection. Default: 18</param>
        /// <param name="alpha">Filter parameter for contour detection, see edges_image. Default: 0.9</param>
        /// <param name="minContLength">Minimum length of the contours of the marks. Default: 15.0</param>
        /// <param name="maxDiamMarks">Maximum expected diameter of the marks. Default: 100.0</param>
        /// <param name="CCoord">Tuple with column coordinates of the detected marks.</param>
        /// <param name="startPose">Estimation for the external camera parameters.</param>
        /// <returns>Tuple with row coordinates of the detected marks.</returns>
        public HTuple FindMarksAndPose(
          HRegion calPlateRegion,
          string calPlateDescr,
          HCamPar startCamParam,
          int startThresh,
          int deltaThresh,
          int minThresh,
          double alpha,
          double minContLength,
          double maxDiamMarks,
          out HTuple CCoord,
          out HPose startPose)
        {
            IntPtr proc = HalconAPI.PreCall(1947);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)calPlateRegion);
            HalconAPI.StoreS(proc, 0, calPlateDescr);
            HalconAPI.Store(proc, 1, (HData)startCamParam);
            HalconAPI.StoreI(proc, 2, startThresh);
            HalconAPI.StoreI(proc, 3, deltaThresh);
            HalconAPI.StoreI(proc, 4, minThresh);
            HalconAPI.StoreD(proc, 5, alpha);
            HalconAPI.StoreD(proc, 6, minContLength);
            HalconAPI.StoreD(proc, 7, maxDiamMarks);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple((HTuple)((HData)startCamParam));
            HTuple tuple;
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out tuple);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out CCoord);
            int procResult = HPose.LoadNew(proc, 2, err3, out startPose);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)calPlateRegion);
            return tuple;
        }

        /// <summary>
        ///   Segment the region of a standard calibration plate with rectangularly arranged marks in the image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="calPlateDescr">File name of the calibration plate description. Default: "caltab.descr"</param>
        /// <param name="sizeGauss">Filter size of the Gaussian. Default: 3</param>
        /// <param name="markThresh">Threshold value for mark extraction. Default: 112</param>
        /// <param name="minDiamMarks">Expected minimal diameter of the marks on the calibration plate. Default: 5</param>
        /// <returns>Output region.</returns>
        public HRegion FindCaltab(
          string calPlateDescr,
          HTuple sizeGauss,
          HTuple markThresh,
          int minDiamMarks)
        {
            IntPtr proc = HalconAPI.PreCall(1948);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, calPlateDescr);
            HalconAPI.Store(proc, 1, sizeGauss);
            HalconAPI.Store(proc, 2, markThresh);
            HalconAPI.StoreI(proc, 3, minDiamMarks);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(sizeGauss);
            HalconAPI.UnpinTuple(markThresh);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment the region of a standard calibration plate with rectangularly arranged marks in the image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="calPlateDescr">File name of the calibration plate description. Default: "caltab.descr"</param>
        /// <param name="sizeGauss">Filter size of the Gaussian. Default: 3</param>
        /// <param name="markThresh">Threshold value for mark extraction. Default: 112</param>
        /// <param name="minDiamMarks">Expected minimal diameter of the marks on the calibration plate. Default: 5</param>
        /// <returns>Output region.</returns>
        public HRegion FindCaltab(
          string calPlateDescr,
          int sizeGauss,
          int markThresh,
          int minDiamMarks)
        {
            IntPtr proc = HalconAPI.PreCall(1948);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, calPlateDescr);
            HalconAPI.StoreI(proc, 1, sizeGauss);
            HalconAPI.StoreI(proc, 2, markThresh);
            HalconAPI.StoreI(proc, 3, minDiamMarks);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Decode bar code symbols within a rectangle.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="codeType">Type of the searched bar code. Default: "EAN-13"</param>
        /// <param name="row">Row index of the center. Default: 50.0</param>
        /// <param name="column">Column index of the center. Default: 100.0</param>
        /// <param name="phi">Orientation of rectangle in radians. Default: 0.0</param>
        /// <param name="length1">Half of the length of the rectangle along the reading direction of the bar code. Default: 200.0</param>
        /// <param name="length2">Half of the length of the rectangle perpendicular to the reading direction of the bar code. Default: 100.0</param>
        /// <returns>Data strings of all successfully decoded bar codes.</returns>
        public HTuple DecodeBarCodeRectangle2(
          HBarCode barCodeHandle,
          HTuple codeType,
          HTuple row,
          HTuple column,
          HTuple phi,
          HTuple length1,
          HTuple length2)
        {
            IntPtr proc = HalconAPI.PreCall(1992);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)barCodeHandle);
            HalconAPI.Store(proc, 1, codeType);
            HalconAPI.Store(proc, 2, row);
            HalconAPI.Store(proc, 3, column);
            HalconAPI.Store(proc, 4, phi);
            HalconAPI.Store(proc, 5, length1);
            HalconAPI.Store(proc, 6, length2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(codeType);
            HalconAPI.UnpinTuple(row);
            HalconAPI.UnpinTuple(column);
            HalconAPI.UnpinTuple(phi);
            HalconAPI.UnpinTuple(length1);
            HalconAPI.UnpinTuple(length2);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)barCodeHandle);
            return tuple;
        }

        /// <summary>
        ///   Decode bar code symbols within a rectangle.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="codeType">Type of the searched bar code. Default: "EAN-13"</param>
        /// <param name="row">Row index of the center. Default: 50.0</param>
        /// <param name="column">Column index of the center. Default: 100.0</param>
        /// <param name="phi">Orientation of rectangle in radians. Default: 0.0</param>
        /// <param name="length1">Half of the length of the rectangle along the reading direction of the bar code. Default: 200.0</param>
        /// <param name="length2">Half of the length of the rectangle perpendicular to the reading direction of the bar code. Default: 100.0</param>
        /// <returns>Data strings of all successfully decoded bar codes.</returns>
        public string DecodeBarCodeRectangle2(
          HBarCode barCodeHandle,
          string codeType,
          double row,
          double column,
          double phi,
          double length1,
          double length2)
        {
            IntPtr proc = HalconAPI.PreCall(1992);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)barCodeHandle);
            HalconAPI.StoreS(proc, 1, codeType);
            HalconAPI.StoreD(proc, 2, row);
            HalconAPI.StoreD(proc, 3, column);
            HalconAPI.StoreD(proc, 4, phi);
            HalconAPI.StoreD(proc, 5, length1);
            HalconAPI.StoreD(proc, 6, length2);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            string stringValue;
            int procResult = HalconAPI.LoadS(proc, 0, err, out stringValue);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)barCodeHandle);
            return stringValue;
        }

        /// <summary>
        ///   Detect and read bar code symbols in an image.
        ///   Instance represents: Input image. If the image has a reduced domain, the barcode search is reduced to that domain. This usually reduces the runtime of the operator. However, if the barcode is not fully inside the domain, the barcode cannot be decoded correctly.
        /// </summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="codeType">Type of the searched bar code. Default: "auto"</param>
        /// <param name="decodedDataStrings">Data strings of all successfully decoded bar codes.</param>
        /// <returns>Regions of the successfully decoded bar code symbols.</returns>
        public HRegion FindBarCode(
          HBarCode barCodeHandle,
          HTuple codeType,
          out HTuple decodedDataStrings)
        {
            IntPtr proc = HalconAPI.PreCall(1993);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)barCodeHandle);
            HalconAPI.Store(proc, 1, codeType);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(codeType);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HTuple.LoadNew(proc, 0, err2, out decodedDataStrings);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)barCodeHandle);
            return hregion;
        }

        /// <summary>
        ///   Detect and read bar code symbols in an image.
        ///   Instance represents: Input image. If the image has a reduced domain, the barcode search is reduced to that domain. This usually reduces the runtime of the operator. However, if the barcode is not fully inside the domain, the barcode cannot be decoded correctly.
        /// </summary>
        /// <param name="barCodeHandle">Handle of the bar code model.</param>
        /// <param name="codeType">Type of the searched bar code. Default: "auto"</param>
        /// <param name="decodedDataStrings">Data strings of all successfully decoded bar codes.</param>
        /// <returns>Regions of the successfully decoded bar code symbols.</returns>
        public HRegion FindBarCode(
          HBarCode barCodeHandle,
          string codeType,
          out string decodedDataStrings)
        {
            IntPtr proc = HalconAPI.PreCall(1993);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)barCodeHandle);
            HalconAPI.StoreS(proc, 1, codeType);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HalconAPI.LoadS(proc, 0, err2, out decodedDataStrings);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)barCodeHandle);
            return hregion;
        }

        /// <summary>
        ///   Return the estimated background image.
        ///   Modified instance represents: Estimated background image of the current data set.
        /// </summary>
        /// <param name="bgEstiHandle">ID of the BgEsti data set.</param>
        public void GiveBgEsti(HBgEsti bgEstiHandle)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(2003);
            HalconAPI.Store(proc, 0, (HTool)bgEstiHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)bgEstiHandle);
        }

        /// <summary>
        ///   Change the estimated background image.
        ///   Instance represents: Current image.
        /// </summary>
        /// <param name="upDateRegion">Region describing areas to change.</param>
        /// <param name="bgEstiHandle">ID of the BgEsti data set.</param>
        public void UpdateBgEsti(HRegion upDateRegion, HBgEsti bgEstiHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2004);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)upDateRegion);
            HalconAPI.Store(proc, 0, (HTool)bgEstiHandle);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)upDateRegion);
            GC.KeepAlive((object)bgEstiHandle);
        }

        /// <summary>
        ///   Estimate the background and return the foreground region.
        ///   Instance represents: Current image.
        /// </summary>
        /// <param name="bgEstiHandle">ID of the BgEsti data set.</param>
        /// <returns>Region of the detected foreground.</returns>
        public HRegion RunBgEsti(HBgEsti bgEstiHandle)
        {
            IntPtr proc = HalconAPI.PreCall(2005);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)bgEstiHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int procResult = HRegion.LoadNew(proc, 1, err, out hregion);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)bgEstiHandle);
            return hregion;
        }

        /// <summary>
        ///   Generate and initialize a data set for the background estimation.
        ///   Instance represents: initialization image.
        /// </summary>
        /// <param name="syspar1">1. system matrix parameter. Default: 0.7</param>
        /// <param name="syspar2">2. system matrix parameter. Default: 0.7</param>
        /// <param name="gainMode">Gain type. Default: "fixed"</param>
        /// <param name="gain1">Kalman gain / foreground adaptation time. Default: 0.002</param>
        /// <param name="gain2">Kalman gain / background adaptation time. Default: 0.02</param>
        /// <param name="adaptMode">Threshold adaptation. Default: "on"</param>
        /// <param name="minDiff">Foreground/background threshold. Default: 7.0</param>
        /// <param name="statNum">Number of statistic data sets. Default: 10</param>
        /// <param name="confidenceC">Confidence constant. Default: 3.25</param>
        /// <param name="timeC">Constant for decay time. Default: 15.0</param>
        /// <returns>ID of the BgEsti data set.</returns>
        public HBgEsti CreateBgEsti(
          double syspar1,
          double syspar2,
          string gainMode,
          double gain1,
          double gain2,
          string adaptMode,
          double minDiff,
          int statNum,
          double confidenceC,
          double timeC)
        {
            IntPtr proc = HalconAPI.PreCall(2008);
            this.Store(proc, 1);
            HalconAPI.StoreD(proc, 0, syspar1);
            HalconAPI.StoreD(proc, 1, syspar2);
            HalconAPI.StoreS(proc, 2, gainMode);
            HalconAPI.StoreD(proc, 3, gain1);
            HalconAPI.StoreD(proc, 4, gain2);
            HalconAPI.StoreS(proc, 5, adaptMode);
            HalconAPI.StoreD(proc, 6, minDiff);
            HalconAPI.StoreI(proc, 7, statNum);
            HalconAPI.StoreD(proc, 8, confidenceC);
            HalconAPI.StoreD(proc, 9, timeC);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HBgEsti hbgEsti;
            int procResult = HBgEsti.LoadNew(proc, 0, err, out hbgEsti);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hbgEsti;
        }

        /// <summary>
        ///   Asynchronous grab of images and preprocessed image data from the specified image acquisition device.
        ///   Modified instance represents: Grabbed image data.
        /// </summary>
        /// <param name="contours">Pre-processed XLD contours.</param>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="maxDelay">Maximum tolerated delay between the start of the asynchronous grab and the delivery of the image [ms]. Default: -1.0</param>
        /// <param name="data">Pre-processed control data.</param>
        /// <returns>Pre-processed image regions.</returns>
        public HRegion GrabDataAsync(
          out HXLDCont contours,
          HFramegrabber acqHandle,
          double maxDelay,
          out HTuple data)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(2029);
            HalconAPI.Store(proc, 0, (HTool)acqHandle);
            HalconAPI.StoreD(proc, 1, maxDelay);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = this.Load(proc, 1, err1);
            HRegion hregion;
            int err3 = HRegion.LoadNew(proc, 2, err2, out hregion);
            int err4 = HXLDCont.LoadNew(proc, 3, err3, out contours);
            int procResult = HTuple.LoadNew(proc, 0, err4, out data);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)acqHandle);
            return hregion;
        }

        /// <summary>
        ///   Asynchronous grab of images and preprocessed image data from the specified image acquisition device.
        ///   Modified instance represents: Grabbed image data.
        /// </summary>
        /// <param name="contours">Pre-processed XLD contours.</param>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="maxDelay">Maximum tolerated delay between the start of the asynchronous grab and the delivery of the image [ms]. Default: -1.0</param>
        /// <param name="data">Pre-processed control data.</param>
        /// <returns>Pre-processed image regions.</returns>
        public HRegion GrabDataAsync(
          out HXLDCont contours,
          HFramegrabber acqHandle,
          double maxDelay,
          out string data)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(2029);
            HalconAPI.Store(proc, 0, (HTool)acqHandle);
            HalconAPI.StoreD(proc, 1, maxDelay);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = this.Load(proc, 1, err1);
            HRegion hregion;
            int err3 = HRegion.LoadNew(proc, 2, err2, out hregion);
            int err4 = HXLDCont.LoadNew(proc, 3, err3, out contours);
            int procResult = HalconAPI.LoadS(proc, 0, err4, out data);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)acqHandle);
            return hregion;
        }

        /// <summary>
        ///   Synchronous grab of images and preprocessed image data from the specified image acquisition device.
        ///   Modified instance represents: Grabbed image data.
        /// </summary>
        /// <param name="contours">Preprocessed XLD contours.</param>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="data">Preprocessed control data.</param>
        /// <returns>Preprocessed image regions.</returns>
        public HRegion GrabData(out HXLDCont contours, HFramegrabber acqHandle, out HTuple data)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(2030);
            HalconAPI.Store(proc, 0, (HTool)acqHandle);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = this.Load(proc, 1, err1);
            HRegion hregion;
            int err3 = HRegion.LoadNew(proc, 2, err2, out hregion);
            int err4 = HXLDCont.LoadNew(proc, 3, err3, out contours);
            int procResult = HTuple.LoadNew(proc, 0, err4, out data);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)acqHandle);
            return hregion;
        }

        /// <summary>
        ///   Synchronous grab of images and preprocessed image data from the specified image acquisition device.
        ///   Modified instance represents: Grabbed image data.
        /// </summary>
        /// <param name="contours">Preprocessed XLD contours.</param>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="data">Preprocessed control data.</param>
        /// <returns>Preprocessed image regions.</returns>
        public HRegion GrabData(out HXLDCont contours, HFramegrabber acqHandle, out string data)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(2030);
            HalconAPI.Store(proc, 0, (HTool)acqHandle);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = this.Load(proc, 1, err1);
            HRegion hregion;
            int err3 = HRegion.LoadNew(proc, 2, err2, out hregion);
            int err4 = HXLDCont.LoadNew(proc, 3, err3, out contours);
            int procResult = HalconAPI.LoadS(proc, 0, err4, out data);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)acqHandle);
            return hregion;
        }

        /// <summary>
        ///   Asynchronous grab of an image from the specified image acquisition device.
        ///   Modified instance represents: Grabbed image.
        /// </summary>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        /// <param name="maxDelay">Maximum tolerated delay between the start of the asynchronous grab and the delivery of the image [ms]. Default: -1.0</param>
        public void GrabImageAsync(HFramegrabber acqHandle, double maxDelay)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(2031);
            HalconAPI.Store(proc, 0, (HTool)acqHandle);
            HalconAPI.StoreD(proc, 1, maxDelay);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)acqHandle);
        }

        /// <summary>
        ///   Synchronous grab of an image from the specified image acquisition device.
        ///   Modified instance represents: Grabbed image.
        /// </summary>
        /// <param name="acqHandle">Handle of the acquisition device to be used.</param>
        public void GrabImage(HFramegrabber acqHandle)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(2033);
            HalconAPI.Store(proc, 0, (HTool)acqHandle);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)acqHandle);
        }

        /// <summary>
        ///   Add training images to the texture inspection model.
        ///   Instance represents: Image of flawless texture.
        /// </summary>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        /// <returns>Indices of the images that have been added to the texture inspection model.</returns>
        public HTuple AddTextureInspectionModelImage(
          HTextureInspectionModel textureInspectionModel)
        {
            IntPtr proc = HalconAPI.PreCall(2043);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)textureInspectionModel);
            HalconAPI.InitOCT(proc, 0);
            int err = HalconAPI.CallProcedure(proc);
            HTuple tuple;
            int procResult = HTuple.LoadNew(proc, 0, HTupleType.INTEGER, err, out tuple);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)textureInspectionModel);
            return tuple;
        }

        /// <summary>
        ///   Inspection of the texture within an image.
        ///   Instance represents: Image of the texture to be inspected.
        /// </summary>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        /// <param name="textureInspectionResultID">Handle of the inspection results.</param>
        /// <returns>Novelty regions.</returns>
        public HRegion ApplyTextureInspectionModel(
          HTextureInspectionModel textureInspectionModel,
          out HTextureInspectionResult textureInspectionResultID)
        {
            IntPtr proc = HalconAPI.PreCall(2044);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)textureInspectionModel);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 0);
            int err1 = HalconAPI.CallProcedure(proc);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HTextureInspectionResult.LoadNew(proc, 0, err2, out textureInspectionResultID);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)textureInspectionModel);
            return hregion;
        }

        /// <summary>
        ///   bilateral filtering of an image.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="imageJoint">Joint image.</param>
        /// <param name="sigmaSpatial">Size of the Gaussian of the closeness function. Default: 3.0</param>
        /// <param name="sigmaRange">Size of the Gaussian of the similarity function. Default: 20.0</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        /// <returns>Filtered output image.</returns>
        public HImage BilateralFilter(
          HImage imageJoint,
          double sigmaSpatial,
          double sigmaRange,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2045);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageJoint);
            HalconAPI.StoreD(proc, 0, sigmaSpatial);
            HalconAPI.StoreD(proc, 1, sigmaRange);
            HalconAPI.Store(proc, 2, genParamName);
            HalconAPI.Store(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageJoint);
            return himage;
        }

        /// <summary>
        ///   bilateral filtering of an image.
        ///   Instance represents: Image to be filtered.
        /// </summary>
        /// <param name="imageJoint">Joint image.</param>
        /// <param name="sigmaSpatial">Size of the Gaussian of the closeness function. Default: 3.0</param>
        /// <param name="sigmaRange">Size of the Gaussian of the similarity function. Default: 20.0</param>
        /// <param name="genParamName">Generic parameter name. Default: []</param>
        /// <param name="genParamValue">Generic parameter value. Default: []</param>
        /// <returns>Filtered output image.</returns>
        public HImage BilateralFilter(
          HImage imageJoint,
          double sigmaSpatial,
          double sigmaRange,
          string genParamName,
          double genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2045);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageJoint);
            HalconAPI.StoreD(proc, 0, sigmaSpatial);
            HalconAPI.StoreD(proc, 1, sigmaRange);
            HalconAPI.StoreS(proc, 2, genParamName);
            HalconAPI.StoreD(proc, 3, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageJoint);
            return himage;
        }

        /// <summary>
        ///   Find the best matches of multiple NCC models.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.8</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "true"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public void FindNccModels(
          HNCCModel[] modelIDs,
          HTuple angleStart,
          HTuple angleExtent,
          HTuple minScore,
          HTuple numMatches,
          HTuple maxOverlap,
          HTuple subPixel,
          HTuple numLevels,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score,
          out HTuple model)
        {
            HTuple htuple = HTool.ConcatArray((HTool[])modelIDs);
            IntPtr proc = HalconAPI.PreCall(2068);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, htuple);
            HalconAPI.Store(proc, 1, angleStart);
            HalconAPI.Store(proc, 2, angleExtent);
            HalconAPI.Store(proc, 3, minScore);
            HalconAPI.Store(proc, 4, numMatches);
            HalconAPI.Store(proc, 5, maxOverlap);
            HalconAPI.Store(proc, 6, subPixel);
            HalconAPI.Store(proc, 7, numLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(htuple);
            HalconAPI.UnpinTuple(angleStart);
            HalconAPI.UnpinTuple(angleExtent);
            HalconAPI.UnpinTuple(minScore);
            HalconAPI.UnpinTuple(numMatches);
            HalconAPI.UnpinTuple(maxOverlap);
            HalconAPI.UnpinTuple(subPixel);
            HalconAPI.UnpinTuple(numLevels);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelIDs);
        }

        /// <summary>
        ///   Find the best matches of multiple NCC models.
        ///   Instance represents: Input image in which the model should be found.
        /// </summary>
        /// <param name="modelIDs">Handle of the models.</param>
        /// <param name="angleStart">Smallest rotation of the models. Default: -0.39</param>
        /// <param name="angleExtent">Extent of the rotation angles. Default: 0.79</param>
        /// <param name="minScore">Minimum score of the instances of the models to be found. Default: 0.8</param>
        /// <param name="numMatches">Number of instances of the models to be found (or 0 for all matches). Default: 1</param>
        /// <param name="maxOverlap">Maximum overlap of the instances of the models to be found. Default: 0.5</param>
        /// <param name="subPixel">Subpixel accuracy if not equal to 'none'. Default: "true"</param>
        /// <param name="numLevels">Number of pyramid levels used in the matching (and lowest pyramid level to use if $|NumLevels| = 2$). Default: 0</param>
        /// <param name="row">Row coordinate of the found instances of the models.</param>
        /// <param name="column">Column coordinate of the found instances of the models.</param>
        /// <param name="angle">Rotation angle of the found instances of the models.</param>
        /// <param name="score">Score of the found instances of the models.</param>
        /// <param name="model">Index of the found instances of the models.</param>
        public void FindNccModels(
          HNCCModel modelIDs,
          double angleStart,
          double angleExtent,
          double minScore,
          int numMatches,
          double maxOverlap,
          string subPixel,
          int numLevels,
          out HTuple row,
          out HTuple column,
          out HTuple angle,
          out HTuple score,
          out HTuple model)
        {
            IntPtr proc = HalconAPI.PreCall(2068);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, (HTool)modelIDs);
            HalconAPI.StoreD(proc, 1, angleStart);
            HalconAPI.StoreD(proc, 2, angleExtent);
            HalconAPI.StoreD(proc, 3, minScore);
            HalconAPI.StoreI(proc, 4, numMatches);
            HalconAPI.StoreD(proc, 5, maxOverlap);
            HalconAPI.StoreS(proc, 6, subPixel);
            HalconAPI.StoreI(proc, 7, numLevels);
            HalconAPI.InitOCT(proc, 0);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            HalconAPI.InitOCT(proc, 4);
            int err1 = HalconAPI.CallProcedure(proc);
            int err2 = HTuple.LoadNew(proc, 0, HTupleType.DOUBLE, err1, out row);
            int err3 = HTuple.LoadNew(proc, 1, HTupleType.DOUBLE, err2, out column);
            int err4 = HTuple.LoadNew(proc, 2, HTupleType.DOUBLE, err3, out angle);
            int err5 = HTuple.LoadNew(proc, 3, HTupleType.DOUBLE, err4, out score);
            int procResult = HTuple.LoadNew(proc, 4, HTupleType.INTEGER, err5, out model);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)modelIDs);
        }

        /// <summary>
        ///   Get the training images contained in a texture inspection model.
        ///   Modified instance represents: Training images contained in the texture inspection model.
        /// </summary>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        public void GetTextureInspectionModelImage(HTextureInspectionModel textureInspectionModel)
        {
            this.Dispose();
            IntPtr proc = HalconAPI.PreCall(2075);
            HalconAPI.Store(proc, 0, (HTool)textureInspectionModel);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            int procResult = this.Load(proc, 1, err);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)textureInspectionModel);
        }

        /// <summary>
        ///   Guided filtering of an image.
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="imageGuide">Guidance image.</param>
        /// <param name="radius">Radius of the filtering operation. Default: 3</param>
        /// <param name="amplitude">Controls the influence of edges on the smoothing. Default: 20.0</param>
        /// <returns>Output image.</returns>
        public HImage GuidedFilter(HImage imageGuide, int radius, double amplitude)
        {
            IntPtr proc = HalconAPI.PreCall(2078);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)imageGuide);
            HalconAPI.StoreI(proc, 0, radius);
            HalconAPI.StoreD(proc, 1, amplitude);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)imageGuide);
            return himage;
        }

        /// <summary>
        ///   Create an interleaved image from a multichannel image.
        ///   Instance represents: Input multichannel image.
        /// </summary>
        /// <param name="pixelFormat">Target format for InterleavedImage. Default: "rgba"</param>
        /// <param name="rowBytes">Number of bytes in a row of the output image. Default: "match"</param>
        /// <param name="alpha">Alpha value for three channel input images. Default: 255</param>
        /// <returns>Output interleaved image.</returns>
        public HImage InterleaveChannels(string pixelFormat, HTuple rowBytes, int alpha)
        {
            IntPtr proc = HalconAPI.PreCall(2079);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, pixelFormat);
            HalconAPI.Store(proc, 1, rowBytes);
            HalconAPI.StoreI(proc, 2, alpha);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(rowBytes);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Create an interleaved image from a multichannel image.
        ///   Instance represents: Input multichannel image.
        /// </summary>
        /// <param name="pixelFormat">Target format for InterleavedImage. Default: "rgba"</param>
        /// <param name="rowBytes">Number of bytes in a row of the output image. Default: "match"</param>
        /// <param name="alpha">Alpha value for three channel input images. Default: 255</param>
        /// <returns>Output interleaved image.</returns>
        public HImage InterleaveChannels(string pixelFormat, string rowBytes, int alpha)
        {
            IntPtr proc = HalconAPI.PreCall(2079);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, pixelFormat);
            HalconAPI.StoreS(proc, 1, rowBytes);
            HalconAPI.StoreI(proc, 2, alpha);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Segment image using Maximally Stable Extremal Regions (MSER).
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="MSERLight">Segmented light MSERs.</param>
        /// <param name="polarity">The polarity of the returned MSERs. Default: "both"</param>
        /// <param name="minArea">Minimal size of an MSER. Default: 10</param>
        /// <param name="maxArea">Maximal size of an MSER. Default: []</param>
        /// <param name="delta">Amount of thresholds for which a region needs to be stable. Default: 15</param>
        /// <param name="genParamName">List of generic parameter names. Default: []</param>
        /// <param name="genParamValue">List of generic parameter values. Default: []</param>
        /// <returns>Segmented dark MSERs.</returns>
        public HRegion SegmentImageMser(
          out HRegion MSERLight,
          string polarity,
          HTuple minArea,
          HTuple maxArea,
          HTuple delta,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2087);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, polarity);
            HalconAPI.Store(proc, 1, minArea);
            HalconAPI.Store(proc, 2, maxArea);
            HalconAPI.Store(proc, 3, delta);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(minArea);
            HalconAPI.UnpinTuple(maxArea);
            HalconAPI.UnpinTuple(delta);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HRegion.LoadNew(proc, 2, err2, out MSERLight);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>
        ///   Segment image using Maximally Stable Extremal Regions (MSER).
        ///   Instance represents: Input image.
        /// </summary>
        /// <param name="MSERLight">Segmented light MSERs.</param>
        /// <param name="polarity">The polarity of the returned MSERs. Default: "both"</param>
        /// <param name="minArea">Minimal size of an MSER. Default: 10</param>
        /// <param name="maxArea">Maximal size of an MSER. Default: []</param>
        /// <param name="delta">Amount of thresholds for which a region needs to be stable. Default: 15</param>
        /// <param name="genParamName">List of generic parameter names. Default: []</param>
        /// <param name="genParamValue">List of generic parameter values. Default: []</param>
        /// <returns>Segmented dark MSERs.</returns>
        public HRegion SegmentImageMser(
          out HRegion MSERLight,
          string polarity,
          int minArea,
          int maxArea,
          int delta,
          HTuple genParamName,
          HTuple genParamValue)
        {
            IntPtr proc = HalconAPI.PreCall(2087);
            this.Store(proc, 1);
            HalconAPI.StoreS(proc, 0, polarity);
            HalconAPI.StoreI(proc, 1, minArea);
            HalconAPI.StoreI(proc, 2, maxArea);
            HalconAPI.StoreI(proc, 3, delta);
            HalconAPI.Store(proc, 4, genParamName);
            HalconAPI.Store(proc, 5, genParamValue);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(genParamName);
            HalconAPI.UnpinTuple(genParamValue);
            HRegion hregion;
            int err2 = HRegion.LoadNew(proc, 1, err1, out hregion);
            int procResult = HRegion.LoadNew(proc, 2, err2, out MSERLight);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return hregion;
        }

        /// <summary>Train a texture inspection model.</summary>
        /// <param name="textureInspectionModel">Handle of the texture inspection model.</param>
        public static void TrainTextureInspectionModel(HTextureInspectionModel textureInspectionModel)
        {
            IntPtr proc = HalconAPI.PreCall(2099);
            HalconAPI.Store(proc, 0, (HTool)textureInspectionModel);
            int procResult = HalconAPI.CallProcedure(proc);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)textureInspectionModel);
        }

        /// <summary>
        ///   Reconstruct a surface from several, differently illuminated images.
        ///   Instance represents: The Images.
        /// </summary>
        /// <param name="gradient">The Gradient.</param>
        /// <param name="albedo">The Albedo.</param>
        /// <param name="resultType">The Result type. Default: "all"</param>
        /// <returns>The NormalField.</returns>
        public HImage UncalibratedPhotometricStereo(
          out HImage gradient,
          out HImage albedo,
          HTuple resultType)
        {
            IntPtr proc = HalconAPI.PreCall(2101);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, resultType);
            HalconAPI.InitOCT(proc, 1);
            HalconAPI.InitOCT(proc, 2);
            HalconAPI.InitOCT(proc, 3);
            int err1 = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(resultType);
            HImage himage;
            int err2 = HImage.LoadNew(proc, 1, err1, out himage);
            int err3 = HImage.LoadNew(proc, 2, err2, out gradient);
            int procResult = HImage.LoadNew(proc, 3, err3, out albedo);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Insert objects into an iconic object tuple.
        ///   Instance represents: Input object tuple.
        /// </summary>
        /// <param name="objectsInsert">Object tuple to insert.</param>
        /// <param name="index">Index to insert objects.</param>
        /// <returns>Extended object tuple.</returns>
        public HImage InsertObj(HImage objectsInsert, int index)
        {
            IntPtr proc = HalconAPI.PreCall(2121);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)objectsInsert);
            HalconAPI.StoreI(proc, 0, index);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)objectsInsert);
            return himage;
        }

        /// <summary>
        ///   Remove objects from an iconic object tuple.
        ///   Instance represents: Input object tuple.
        /// </summary>
        /// <param name="index">Indices of the objects to be removed.</param>
        /// <returns>Remaining object tuple.</returns>
        public HImage RemoveObj(HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(2124);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 0, index);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(index);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Remove objects from an iconic object tuple.
        ///   Instance represents: Input object tuple.
        /// </summary>
        /// <param name="index">Indices of the objects to be removed.</param>
        /// <returns>Remaining object tuple.</returns>
        public HImage RemoveObj(int index)
        {
            IntPtr proc = HalconAPI.PreCall(2124);
            this.Store(proc, 1);
            HalconAPI.StoreI(proc, 0, index);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            return himage;
        }

        /// <summary>
        ///   Replaces one or more elements of an iconic object tuple.
        ///   Instance represents: Iconic Input Object.
        /// </summary>
        /// <param name="objectsReplace">Element(s) to replace.</param>
        /// <param name="index">Index/Indices of elements to be replaced.</param>
        /// <returns>Tuple with replaced elements.</returns>
        public HImage ReplaceObj(HImage objectsReplace, HTuple index)
        {
            IntPtr proc = HalconAPI.PreCall(2125);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)objectsReplace);
            HalconAPI.Store(proc, 0, index);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HalconAPI.UnpinTuple(index);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)objectsReplace);
            return himage;
        }

        /// <summary>
        ///   Replaces one or more elements of an iconic object tuple.
        ///   Instance represents: Iconic Input Object.
        /// </summary>
        /// <param name="objectsReplace">Element(s) to replace.</param>
        /// <param name="index">Index/Indices of elements to be replaced.</param>
        /// <returns>Tuple with replaced elements.</returns>
        public HImage ReplaceObj(HImage objectsReplace, int index)
        {
            IntPtr proc = HalconAPI.PreCall(2125);
            this.Store(proc, 1);
            HalconAPI.Store(proc, 2, (HObjectBase)objectsReplace);
            HalconAPI.StoreI(proc, 0, index);
            HalconAPI.InitOCT(proc, 1);
            int err = HalconAPI.CallProcedure(proc);
            HImage himage;
            int procResult = HImage.LoadNew(proc, 1, err, out himage);
            HalconAPI.PostCall(proc, procResult);
            GC.KeepAlive((object)this);
            GC.KeepAlive((object)objectsReplace);
            return himage;
        }
    }
}
